{"meta":{"title":"Luhao's Blog","subtitle":"luhao wiki","description":"Just for Learing","author":"Luhao","url":"http://luhao.wiki"},"pages":[{},{},{},{}],"posts":[{"title":"【C++11】lvalue & rvalue (references)","date":"2023-08-20T14:53:43.000Z","path":"posts/rvalue/","text":"C++ 左值、右值引用 导读 Understanding the meaning of lvalues and rvalues in C++ C++ rvalue references and move semantics for beginners Move semantics and rvalue references in C++11 前言 从接触、学习、运用 C++ 至今，左右值引用一直是自己困惑的点。伴随着现代C++的发展，它们开始扮演越来越重要的作用（如 std::move、std::remove_reference…）。 这篇争取彻底搞懂他们。 先看 gcc 一个编译报错，为什么 666 = x 的语法是错误的？ error: lvalue required as left operand of assignment 编译器是在说：赋值符号 = 的左操作数，必须是左值 lvalue ! 换句话说，这里的 666 不是一个左值。 int x; 666 = x; lvalue &amp; rvalue 如何区分 左值 和 右值？ lvalue：指向明确的内存地址，又称 variable rvalue：没有明确的内存地址，又称 literal constant 下面看几个示例： int x = 666：x 是 lvalue，666 是 rvalue int* y = &amp;x：x 是 lvalue，y 是 lvalue reference 编译规则，赋值= 和取地址&amp; 的左边必须是 lvalue，不然会报如下错误： error: lvalue required as left operand of assignment error: lvalue required as unary ‘&amp;’ operand` 区分 左值 和 左值引用 int x = 1：x是左值 int&amp; y = x：y是左值引用 function reference 函数的返回值可以是 左值，也可以是 右值。 右值 × int setValue() { return 6; }; setValue() = 3; // error: lvalue required as left operand of assignment 左值 √ int x = 100; int&amp; setValue() { return x; }; setValue() = 1; lvalue to rvalue 左值 经常会被转化为 右值，如下示例： x, y 都是 左值 x + y 被转化为 右值 int x = 1; int y = 3; int z = x + y; // ok 上面经历了一次 lvalue -&gt; rvalue 的隐式转换，很多操作符（+, -, /）都会提供。 rvalue to lvalue 右值 到 左值 的转换是被禁止的，如下代码是非法的： int&amp; x = 10; // error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int' rvalue reference 🔥 C++ 的一条重要编译规则是：你无法绑定一个 右值 的地址，除非绑定到一个 const 类型，例如： int&amp; x = 666; // error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int' const int&amp; x = 666; // OK std::string s1 = \"Hello \"; std::string s2 = \"world\"; const std::string&amp; s3 = s1 + s2; s3 += \" luhao\"; // error: no match for 'operator+=' (operand types are 'const std::string' 但是上面的写法有个弊端，即无法再修改 s3 的值。 为了能够修改右值（即临时变量），C++11 正式引入右值引用（rvalue reference），其符号是 &amp;&amp;： std::string s1 = \"Hello \"; std::string s2 = \"world\"; std::string&amp;&amp; s3 = s1 + s2; s3 += \" luhao\"; // OK 上面的示例看出来用处不大，因为 rvalue reference 真正大展拳脚的地方，是在 移动语义（move semantics）。 move semantics 🔥 阅读资料 Move semantics and rvalue references in C++11 移动语义 是一种利用右值引用的技术，来避免拷贝临时变量的优化手段。 为什么需要 move semantics? 💡 假设 class Holder 是一个(内存)非常繁重的类，考虑到如下的构造和拷贝构造函数。 当调用 Holder h1(h) 时，因为 std::copy 造成巨大的内存拷贝开销，如果后文中 h 也不再继续使用，为什么不尝试将 h 转交给 h1 呢? class Holder { public: Holder(int size) { m_data = new int[size]; m_size = size; } Holder(const Holder&amp; other) { m_data = new int[other.m_size]; std::copy(other.m_data, other.m_data + other.m_size, m_data); m_size = other.m_size; } ~Holder() { delete[] m_data; } private: int* m_data; size_t m_size; } int main() { Holder h(10000); Holder h1(h); // 调用 std::copy 带来非必要开销 return 1; } 借助移动语义，可以优化掉上面的拷贝。注意到下面使用了 std::move，它能将左值转化为右值，是C++标准库的成员函数，后面有介绍。 Holder(Holder&amp;&amp; other) { // 赋值 m_data = other.m_data; m_size = other.m_size; // 清空other的状态 other.m_data = nullptr; other.m_size = 0; } int main() { Holder h(10000); Holder h1(std::move(h)); return 1; } std::move 阅读材料： cppreference libstdc++: move.h 阅读 std::move 的源码，其实只是作了类型转化，将 任意形式的_Tp 转化成右值: std::remove_reference：去掉引用 static_cast：隐式转换 std::move move 右值：直接返回 move 左值：转成右值，并返回 /** * @brief Convert a value to an rvalue. * @param __t A thing of arbitrary type. * @return The parameter cast to an rvalue-reference to allow moving it. */ template&lt;typename _Tp&gt; constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; move(_Tp&amp;&amp; __t) noexcept { return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); } std::remove_reference remove_reference 顾名思义，就是去除任意类型的引用，借助模板实现。 核心是对于 _Tp&amp; 和 _Tp&amp;&amp; 这两种带引用的传参，需要去掉其引用的部分，只获取其类型（通过 ::type 获取） template&lt;typename _Tp&gt; struct remove_reference { typedef _Tp type; }; // 特化 template&lt;typename _Tp&gt; struct remove_reference&lt;_Tp&amp;&gt; { typedef _Tp type; }; // 特化 template&lt;typename _Tp&gt; struct remove_reference&lt;_Tp&amp;&amp;&gt; { typedef _Tp type; };"},{"title":"【C++17】refl-cpp","date":"2023-08-17T16:27:58.000Z","path":"posts/refl-cpp/","text":"品读C++经典反射库 导读 源码：veselink1/refl-cpp blog：refl-cpp — A deep dive into this compile-time reflection library for C++ 这篇博客大致是英文版的 直译 + 自己理解，旨在提高对 templates + reflections 的掌握 精读blog ➜ 理解源码 ➜ 上手仿造 目录 前言 compile-time反射 构建类的成员 使用 macros 组织代码 函数反射 遍历类的成员 前言 refl-cpp 的设计初衷是： 支持 在 C++17 及更高版本 提供编译期反射（Compile-time） 的方法。 支持 enumeration，introspection enumeration：类似 Python dir() 枚举对象所有的属性 introsection：类似 Python getattr 访问对象的指定属性 支持 类型模板、成员模板 支持 attributes TODO refl-cpp 的设计避免如下： 避免 使用宏魔法 避免 Private 私有成员的反射 避免 运行时 按名称查询类型信息 compile-time反射 首先 refl-cpp 是一个 compile-time 的反射库，这意味着它不会维护一个 runtime 的数据结构来实现反射目的，例如下面是不可取的： struct TypeInfo { std::string name; // 对象的类型名称 std::vector&lt;?&gt; members; // 对象的所有成员 std::vector&lt;?&gt; attributes; // 对象的所有成员取值 } // ↓ 维护一个全局的反射数据结构 std::unordered_map&lt;std::string, TypeInfo&gt; s_typeRegistry; 相反，refl-cpp 的做法是，通过 cpp模板特化 以一种类相关的方式（type-dependent）来存储 metadata，例如下面的做法： template &lt;typename&gt; struct TypeInfo {}; // ↓ Point类的编译期信息 template &lt;&gt; struct TypeInfo&lt;Point&gt; { static constexpr char name[] = \"Point\"; ??? members = {}; ??? attributes = {}; }; 构建类的成员 上一节提供了存储 类信息 的方法，但是如何存储 其成员变量（和方法）呢？ refl-cpp 使用一种新颖的方式来存储： template &lt;size_t N&gt; struct MemberInfo; /* 第0个成员的模板特化 */ template &lt;&gt; struct MemberInfo&lt;0&gt; { /* ... */ }; /* 第1个成员的模板特化 */ template &lt;&gt; struct MemberInfo&lt;1&gt; { /* ... */ }; static constexpr size_t MemberCount = 2; MemberInfo 是类成员的模板特化，因此将其添加到 TypeInfo 的作用域（如下）。 typename Dummy 是因为C++不允许成员完全模板特化，而部分成员的模板特化是允许的。TODO template &lt;&gt; struct TypeInfo&lt;Point&gt; { template &lt;size_t N, typename Dummy&gt; struct MemberInfo; /* 第0个成员的模板特化 */ template &lt;typename Dummy&gt; struct MemberInfo&lt;0&gt; { /* ... */ }; /* 第1个成员的模板特化 */ template &lt;typename Dummy&gt; struct MemberInfo&lt;1&gt; { /* ... */ }; static constexpr size_t MemberCount = 2; }; 使用 macros 组织代码 上一节提供了粗略的 类 + 类成员 的反射方案，那么如何声明它们呢？ 答案是借助 macros 实现（作者不是不建议使用宏么😂…） __COUNTER__ 是非标准库的宏，每次调用增加1，且从0开始 宏展开后的代码，可看示例：refl-cpp-deep-dive-5-generated.cpp 另外每个 TypeInfo 和 MemberInfo 还应该包含如下内容： static constexpr char name[] = … static constexpr std::tuple&lt;…&gt; attributes = {…} static constexpr auto* pointer = &amp;Type::MemberName template &lt;typename T&gt; struct TypeInfo {}; #define REFLECT_TYPE(TypeName) \\ template&lt;&gt; struct TypeInfo&lt;TypeName&gt; { \\ template &lt;size_t, typename&gt; struct MemberInfo; \\ static constexpr size_t MemberIndexOffset = __COUNTER__ + 1; #define REFLECT_FIELD(FieldName) \\ template &lt;typename Dummy&gt; struct MemberInfo&lt;__COUNTER__ - MemberIndexOffset&gt; \\ {}; \\ #define REFLECT_END \\ static constexpr size_t MemberCount = __COUNTER__ - MemberIndexOffset; \\ }; // Usage: REFLECT_TYPE(Point) REFLECT_FIELD(x) REFLECT_FIELD(y) REFLECT_END Tips: 借助 VisualStudio 查看宏展开 鼠标悬停在宏上，点击 Expand Inline 函数反射 refl-cpp 还提供反射函数的功能。 为了区分成员（是变量还是方法），每个 MemberInfo 有一个公共的 typedef，它等同于 refl::members::field 和 refl::members::function 两者之一。而考虑到 函数的重载和模板，这部分功能（相对于反射成员）会更加复杂。 refl-cpp 通过如下方法：TODO template &lt;typename R, typename... Args&gt; auto resolve(R(*fn)(Args...), Args&amp;&amp;... args) -&gt; decltype(fn); /* Imagine 12 more overloads of resolve for different pointer-to-member combinations (plain, &amp;, &amp;&amp;, const, volatile qualifiers) */ template &lt;typename... Args&gt; static constexpr decltype(detail::resolve(&amp;Type::MemberName, std::declval&lt;Args&gt;()...)) pointer { &amp;Type::MemberName }; ↑ 上面这段代码理解起来较为困难，我们可以将其功能拆解一下，它是为了解决什么问题？ 想象类型 A 具有两个函数重载： f(int) f(const std::string) 当拥有一个指向f的函数指针（&amp;f）时，编译器怎么知道调用哪个？ refl-cpp 实际会帮助编译器 推导出正确的重载函数（通过将 &amp;f 作为参数传递给另一个函数的方式，来直接触发函数）。 resolve 没有任何定义，它只是一个 prototype，作用是作为编译器的一个提示。 这种方法总结起来是：传递函数性质的参数（由 std::decalval 产生）。它的好处是：所有的参数类型转换都适用，即我们可以通过 MemberInfo&lt;?&gt;::pointer&lt;int&gt; 并得到一个 void(*)(long) 类型的指针作为结果。 遍历类的成员 前面讲了如何创建和存储类成员的 metadata，这节介绍如何遍历它们（compile-time）。 核心思想是 借助可变参数模板，创建一个 TypeList 的类型成员列表，并提供枚举的方法。 template &lt;typename... Ts&gt; struct TypeList { }; !!! NOTE 这块讲的不是很细，没搞懂…"},{"title":"【cpp】Templates","date":"2023-08-13T17:47:03.000Z","path":"posts/templates/","text":"C++模板、meta-programming Function Templates 模板基础 下面是一个最简单的函数模板示例： template &lt;typename T&gt; T max (T a, T b) { return b &lt; a ? a : b; } T 是定义类型的变量，它可以是 int、float、任何class… typename 是关键字，template&lt;class T&gt; 是兼容 C++98 的一种正确写法 上面有两个潜在约束：1. T必须支持&lt;操作符，2. T必须支持拷贝构造函数，为了return 下面是简单的模板使用实例： ::max(7, 8); // 8 ::max(1.2, 1.5); // 1.5 ::max(\"abc\", \"abcd\"); // abcd 当调用上者时，模板会自动实例化为： int max(int, int); double max(double, double); char const* max(char const*, char const*); 编译检查 模板的编译检查分为两个阶段（Two-Phase Translation） 定义阶段 实例化阶段 template &lt;typename T&gt; void foo(T t) { undeclared(); // 未定义函数，定义阶段报错 undeclared(t); // 引用了T，所以实例化阶段才报错 } 参数推导 编译器会根据传入参数的类型，自动推导 T 的取值 若引用传递：不允许类型转化 若值传递：只允许退化（decay），const和volatile会被忽略。引用会被转化成引用的类型。 int const c = 42; int i = 1; ::max(i, c); // OK: (int, int) ::max(c, c); // OK: (int, int) int&amp; ir = i; ::max(i, ir); // OK: (int, int) int arr[4]; ::max(&amp;i, arr); // OK: (int*, int*) 多参数 模板允许定义多组不同的参数，以如下函数示例，其返回值的类型是不确定的： template&lt;typename T1, typename T2&gt; T1 max (T1 a, T2 b) { return b &lt; a ? a : b; } 返回类型推断 从C++14开始，允许使用 auto 声明函数的返回值，即让编译器自己决定。 template&lt;typename T1, typename T2&gt; auto max (T1 a, T2 b) { return b &lt; a ? a : b; } 在C++11中，auto必须配合 trailing return type 使用，否则编译报错如下： error: 'xxx' function uses 'auto' type specifier without trailing return type template&lt;typename T1, typename T2&gt; auto max (T1 a, T2 b) -&gt; decltype(b&lt;a?a:b); 类型萃取 #include &lt;type_traits&gt; template&lt;typename T1, typename T2&gt; std::common_type_t&lt;T1,T2&gt; max (T1 a, T2 b) Trick: C++如何获取变量x的类型? #include &lt;typeinfo&gt; typeid(x).name() Class Templates 模板特化 这篇中文资料说得通俗易懂：深入理解特化与偏特化 源码 推荐阅读： type_traits 模板特化的作用是，针对模板的参数类型，从而定义不同的实现。 只要你教得好，它可以 “见人说人话，见鬼说鬼话” （有点类似 函数重载 和 虚函数继承 的思想） 模板特化实现思路是： 先定义基本模板（能说话） 再针对每种参数实现特例（能见人下菜碟） 下面仿照 Python 实现 C++ 的 type 函数: #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; template&lt;typename T&gt; class TypeId { public: static constexpr char const* type = \"NULL\"; TypeId(T t) {} }; template&lt;&gt; class TypeId&lt;int&gt; { public: static constexpr char const* type = \"INT\"; TypeId(int t) {} }; template&lt;&gt; class TypeId&lt;std::string&gt; { public: static constexpr char const* type = \"STRING\"; TypeId(std::string t) {} }; int main() { ::cout &lt;&lt; TypeId(1).type &lt;&lt; \"\\n\"; // INT ::cout &lt;&lt; TypeId(std::string(\"abc\")).type &lt;&lt; \"\\n\"; // STRING return 1; } 模板特化 规则 模板特化 符合 函数重载 的两个条件之一： 参数数量相同、类型不同 参数数量不同（特化只能少于等于） 否则出现报错： error: too many template arguments for class template xxx 示例如下： template &lt;typename T, typename U&gt; struct X ; // 0 // 原型有两个类型参数 // 所以下面的这些偏特化的实参列表 // 也需要两个类型参数对应 template &lt;typename T&gt; struct X&lt;T, T &gt; {}; // 1 template &lt;typename T&gt; struct X&lt;T*, T &gt; {}; // 2 template &lt;typename T&gt; struct X&lt;T, T* &gt; {}; // 3 template &lt;typename U&gt; struct X&lt;U, int&gt; {}; // 4 template &lt;typename U&gt; struct X&lt;U*, int&gt; {}; // 5 template &lt;typename U, typename T&gt; struct X&lt;U*, T* &gt; {}; // 6 template &lt;typename U, typename T&gt; struct X&lt;U, T* &gt; {}; // 7 template &lt;typename U, typename T&gt; struct X&lt;U, T, T &gt; {}; // Error 模板特化 代码示例 refl-sum.cpp refl-factorial.cpp std ⭐std::max _GLIBCXX14_CONSTEXPR 在 C++14 会被替换为 constexpr 实际可以展开为：constexpr inline const _Tp&amp; max(const _Tp&amp; __a, const _Tp&amp; __b) constexpr无实质作用，重点是参数使用 const &amp; template&lt;typename _Tp&gt; _GLIBCXX14_CONSTEXPR inline const _Tp&amp; max(const _Tp&amp; __a, const _Tp&amp; __b) { // concept requirements __glibcxx_function_requires(_LessThanComparableConcept&lt;_Tp&gt;) //return __a &lt; __b ? __b : __a; if (__a &lt; __b) return __b; return __a; } ⭐std::pair [cppreference] std::pair [stackoverflow] What is the purpose of std::make_pair vs the constructor of std::pair? c++14及之前，std::pair需要显式指定类型，std::make_pair不需要 template&lt;typename _T1, typename _T2&gt; struct pair : private __pair_base&lt;_T1, _T2&gt; { typedef _T1 first_type; ///&lt; The type of the `first` member typedef _T2 second_type; ///&lt; The type of the `second` member _T1 first; ///&lt; The first member _T2 second; ///&lt; The second member _GLIBCXX_CONSTEXPR pair() : first(), second() { } // ... } ⭐type_traits 以 is_integral 为例，判断是否为整型 template&lt;typename _Tp&gt; struct is_integral : public __is_integral_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type { }; __is_integral_helper 是一个标准的模板特化，非常简单！ template&lt;typename&gt; struct __is_integral_helper : public false_type { }; template&lt;&gt; struct __is_integral_helper&lt;int&gt; : public true_type { }; template&lt;&gt; struct __is_integral_helper&lt;char&gt; : public true_type { }; // ... true_type 相关定义如下，其value变量就是一个bool类型的 true /// integral_constant template&lt;typename _Tp, _Tp __v&gt; struct integral_constant { static constexpr _Tp value = __v; typedef _Tp value_type; typedef integral_constant&lt;_Tp, __v&gt; type; constexpr operator value_type() const noexcept { return value; } // ... }; template&lt;typename _Tp, _Tp __v&gt; constexpr _Tp integral_constant&lt;_Tp, __v&gt;::value; /// The type used as a compile-time boolean with true value. typedef integral_constant&lt;bool, true&gt; true_type; /// The type used as a compile-time boolean with false value. typedef integral_constant&lt;bool, false&gt; false_type; 反射 先看看什么是 reflection: reflection is the ability of a process to examine, introspect, and modify its own structure and behavior. 通俗解释，反射就是从一个对象(object)，能够反推其类型、成员和方法 以Python为例，getattr 就是经典的反射功能 为什么cpp没有反射? 反射会导致编译后文件过大 cpp很少用到元编程（相对于C#) cpp有模板，足够应付大部分需求... 阅读材料 CPP-Templates-2nd 英文 CPP-Templates-2nd 中文版翻译 cpp-templates-2nd 中文版翻译 C++ Template 进阶指南 refl-cpp What Does Haskell Have to Do with C++?"},{"title":"日志：2023年8月","date":"2023-07-31T16:35:13.000Z","path":"posts/2023/8/","text":"b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475debb79baf718116b8398ebb7a36965f5712db04a990a04196bf7d89b9188d2f59608c72ed5aa29e6fc56a5ff1b29fef766d4c0885ae8cf2dca8001db9ea7dd57171e66061d8a834aadac2d5261a378e855f619f74a4d6dbb2143558f830195ad778bbec3dcb3f658d755d1900562037e667a8aeb10ee60aaaef6c52df6297f9462edb95ad5b1ef626d83551b4a58dc951356f6585adb2fd17b3f8d279cf52c2f8d72cc91aa7ad9374c68556628b6eac552af647ab2fd1923a9447dbde9fef5d52838673d369ae6f0aa23c8646e56d8c1d605bcc8af83c4d4f0550714f459fca02e02cf177074372528193700ee905e8a3d1ef9cfad8fa347d783f698acfc1d6621587714cc62dfc4f05111dffb28ac0250c4e24194ffbdac8c2ae00f2e7137af9fc5294b8fe8aeb1597e6d14ab20765e4184da5b7c7da4721343486f481306d0243f5d4f3628438bc757805b7bdf36f18b2924cea837cc5fcadf62ace8f4dd7cfd5e6e5784be2002d15481b611ce627e96d25d779ccb29de2125b3b65d03f1d8156fbdcaaabc7d8171179b0394534542a538fe76093f53926518a112004a6cfebaef13534e2fe76c3a54902c984194a0a6de04954bf4cd205b88029a0f2728e5dc88197f6717058d85be6b54424c89c6526590408102ba7394d8e6ca056b0079e0af5b4091fd2e38d75b11a047a24b91d5432da942d300440e845b0760cbaebc2efdda0c0736c0ba020a756530e7423e0eaae34cfc379779c820675f8b34e6d3638676129235be434315c6abc0fb09a31b703d5ca2884910883ab97c5e1aa88a78b993d28d4b848510c48d42fb6ee1a1541de3cabd17a6f4ca15f048f3c51d2d6621c80a539cc9f9d8daa575a78fa492b87aff1829bba7ce0f994b5c8400d6831bc2c7f0ab9c46c6b506fe4ba4150ad6a8c59f41cdf9f729188eb76453c2e4fea23e1e363f83585acb94e73a12e6f48402b97076a6590aa617a06dded7a2a177a67281c1ef07a6428ea7f734387f214defd4e2ae3d69672cddcd753e5fc2da4c05091245e31d0fef7a5f964e46b56d5a69042ceec4f4e865a211fc80798c4f6fb561d89e2aea26a0e2c7ac84c5d2e6294a2d9248b255f455f7af4217d74cc0944c7c34673ff3d4ed1ff55db06d202282b9ffb5297de798d1e57d33b8c6e2dec74982ed0510fb2d3822cccaf7cdc2da790492c861cb2b131b5e0ae5d188414cc8ca3227cf00cfa1fc089f0fe21740d573150eebae9eb7a20c4b75daab35324d91674b333abebaebe360ba0d386821d95e5a0d71fd60f0973b97d4d5c8c1c243e1c5842045167e2f529b87e9a1689cd3316ba1572fb2474c7673ffd386e384b81dfae67a29ed38de34773eb1c59420dc68a8a0f4fe20c4817de33ca763598f919b8bbc035ea9a1f05379c8f1b32e3038799390534af9602ed02376fdb6c0760fd5f21b5cc6fe7554daf9366ec27ace455d8fdf94526c31713be61195127cc9034f6a5a06aca65ac32e8431a89be8fd8b102b3caec954bc15ff5cc4a31301a0607a287b1dd6ee3be0692c9ef69e3823ee16406428501b1b4daefaaf906adc274d7ba06b31653653661f767c15e724a42011e5af33f245b2a487601dcb59507d19d7c633767a635460fa30b7dca369db46707f1eb5af18d65eccf849e616d39fec44cf96368474b64982e85b4f8bb24a638593b9d81eace9f0aca1b2e79c55e61456a060c2ee04e1c170c966cb085fbac5dad84e5bd2ae2b11e95ca37b7fc47a66546b50d6615b0e9df25b3460b6bc4a1fb15856d0a809818defba5343286c66995c7666af6fb00b4e9d1e0fe19947f360421576003ae290774a40eb53e242cded63c09d9b235b03f632fa1b9ca0ae0c6faa3cfd84685f2590fd6ed1432233adf3a7e4853695786eea091edfeec31f9523b0546a684976797e89b389e9e765f02da544fadefd0b8ce59b181adccdce8a36f67054d917e52198878d32e614cd187e94a9dd42e876a9fda7f5ac64b158ec60ee23623f91ec282113ceed0e6d1fbdd07d7695a10238615db8d8f58d4d86436b594a5331711b1770e43faa7c7b50baed8200225de1e36d9dcec77578ca0d2ace231c6957f6fb55e6e45974ab30caf60b80fd95bb5cc86af4ddc8020fff5e686955c8eb9858277690c8c8c7547d4d3a843a37245aed86aa38d4f0a2d5f02195553b0ecffa956328afbaa809a83f0158f3bbe54f9ac9f617a3c3e3328fac7919d944a8759e4374f1d4cf3f2c5268a15f08b37e9e7cf11d9432c7f039a2a50bf3aa580d2ec4557b4f2c2d8db4176f537d28295a07df9bba37776510991b3b7033f7a7bba2e37f0a049f677fd112b1b2c8c0bed6e574f501a1c2f62553c5e257e4f03806a7a3294ff303ff7ace3cc9d640493f7ea63060aec5e7b10a1b85e5e33ecb1efb07ea6681dbcaf44a5bb5730c57cc02143fecd0a8f8d9409e205342f65895752abcafe4a9f74d5f5865c4b7bd3021d48aeee6d16d229b3984aa12fc9760ff60f525bfc83f1cf5fcbdf3087e2467276e931ec7ddfdd4897a7ebc0e7b9344703e6663675f1277aa016ffc152cb9c28c4eb0d0c8739958d2cf8a6c8e182986aa111aa729c58dfbd641773e571e35ced963489f7493f2a1116eff1c494c9ea794f20194b1a26e77f95daefa7893ecb220c337887046ac07e47fbd17d7a8673896ca16f8b91a0cac4cdaf0c7ab4b3303e3c1a098bce8c38d7e98d38ecebf11ed883f35936c21cfcb78222bc1677c2a90f3abd284169d48c7d9eb16a82ccc6178bc2802a2ccca7fc69d53de1902cd0f7bce9e3a7c67dd61934e6efa72ddd6e80c542595df0c241c2814fd1796c38d066d54cab2edc81a2acc7f57cf5a40253accd30cbceab90216522b6339b13b056e511ba96810264f9c9c6fcd165766dd9475b67594dc2cbe028815778abf2ac6bc43a1b45510c023e82596e2168f381485e0e578a0945166eb2af8d1fb832fef97bba4089f154e5cb70c301a317e23634e078c492d7196773d52bd674034916bce980ae691eefa63c622b2986a9d7e2db31c2c091dfea825d74d18c357303e1edd8fb38251d76eda6c8d2d80bd428f20f72b3c2223ae36fec911f78d66c8a0c62169a1cd5173adfd5496c55f26ad1ce9a28f55386d9fdec7392de8385b5441ab95aa5d29682c2aab5a76efb4e9aad422ec1f07ddb567a284fe9759e367669356999bdc0fad52c72c1fce2cba1927c82d5415c3ccf1b80be9fb07e57e85b1e88c337e1898d0 Hey, password is required here."},{"title":"【vscode】vim定制化插件","date":"2023-07-23T12:04:39.000Z","path":"posts/vscode-vim/","text":"导读 VSCodeVim 是仿照vim的vscode插件 本文在其基础上添加一些额外的个性化功能 VSCodeVim vscode vim主流插件有两款，分别是: VSCodeVim：仿vim的插件，功能不全 VSCode Neovim：基于Neovim，功能较全，但依赖nvim环境且配置复杂 笔者一直使用前者，因此本文全部围绕 VSCodeVim展开。 缺陷 😞 VSCodeVim Github 拥有 1.5k 未处理的 Issues，作者的维护迭代速度非常慢，因此有很多缺陷和功能不足之处： 不支持 vimscript function 不支持 vim bash 【bug】经常Esc失效，弹窗报错 vim.Escape is undefined… 需要重装插件 亮点 🎉 打开 \"vim.statusBarColorControl\": true，可以使底部 statusBar 跟随 vim模式 而改变颜色。 本文希望进而改变 Cursor 和 当前行 的颜色、高亮显示，并支持 config 配置，效果图如下： 改进 💡 支持配置 StatusBar, Highlight 等颜色配置 支持区分 Normal, Insert, Visual 三种模式的颜色 下载链接: https://github.com/593413198/Vim/releases/tag/vim-mode-1.0 配置文件: \"vim.statusBarColorControl\": true, \"vim.alpha\": \"80\", \"vim.statusBarColors.visual\": \"#005f5f\", \"vim.statusBarColors.insert\": \"#5f0000\","},{"title":"随手记","date":"2023-07-21T19:15:33.000Z","path":"posts/idea/","text":"b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475debb79baf718116b8398ebb7a36965f5712db04a990a04196bf7d89b9188d2f5969b089300c199c887ad4490953d1810357cd375ac06e732d356d4ec27b642aa2d46c8fdf198d48a4b9620936f8c18efa99cd53c0e6c5befbd6da9ebb0e8d473ba88daf9814bf097589053470cd244c49759b29258898ae147d3b92406541ecc1426781b7f965d69488f8227468d25ace43c6b69c8a19f97354453e8ff96435fa7c142eabaa7418866597b071d73575a4fa98f09916a3b6256959c82764411afd8c8baf90fb4965fdfacbf4695b2488acf5d7f161a49b796a0b1b992232c56c8393b9705588b441acf55138be81fe973cfb15be2e79a6f99afa38481729479c286ec6a02cc951fd7f863308221e3409f3e1974680d2f02c063980d44af8e06e16848b8bd660fed16d9b5d1445f1619d498731bec635a5437f3f2dd0b389fbb52905c7c24ebbf54885173e06c7c5b2e3915335e700578626ce7eac45b801a88360b8431a63f02f909f337c51c8aca522afdfb179a032059d1b0c60d82a39c9101894591c99a69d4788c0964ffdf8c8bd340d4f4d0c40c91f0d7b04f33253a142ee29a844e5b7eca56476ebd534d90b54953c9f26a98bfd690dc70f043a224f68814d251f07166ef0cdd195c05dc74eb39f54b5345f809b762a7889cd161f77be58e0d1a2d473e983209035a731b88905105060112483e9324a6df5104a9d6be63f87da391c0963d4f09a7cab737a5ca573d7cc00e96996d16164c26f39cad48b191074aafceccb1b3d53728962bd363fbc5627a401d1e619cec7e88b364d74eb44372b771b3298a63f2ee75e774d3e77dfbd897be6acdde70394ef7580df602e0a38bce10cad68512761784e406a8013db99dd0603f12f71922b4c0096b6300d7650275d8ecb2786e40c1187ee12fd4fb1775bda1356f771b8b5a57a0bed3378dfad7dc5baad11f5881526cb7ac9ab7611d612d3c29b056a9b9bf0de347f042f4450adfc4ea792893a9036ac653c750ef496314e75ab9bba2d0cc6fbb432a6d0f3660175d4b2ad9eeec969249f0bbbbda47a5f4f7dce869e349d36873f7467f4f5ec0aa44ad792b07401cc88a8dc033e02944369446cb5b05697fe8bf6bbf65a9d346bff04820224139dfd1a1cf85deca75e794f0b832b49512771efbf8f1a0eef19813c8e81a9c512407b82da2a92ce4ff5c7498c4616570b114c4726cf5e093b6db53b0caae6b68f5c41bafd3160eb97aa989ea35ceb03a147a590f98ce818c50346ca8f47237f31af4a0cfeb0791050d948fbca28ef55ded16209f8e41edb8a9842d0ef9827896b599286592e161b849811ca388e6bf80f06961d2ea9f358183636ff61f5eec59b8ac1545fe823aa00d11178e27670035ef3bd2b9d8f471ca1d586eec438333b06b5fc4108afbf9f7944b8e3d322f9080ca0b7257758b2afa40fc4d13c8d7f981ef5695731074e28a121caf34662a362ae542b924e7d4fd9ceae3b9fa8e2156b05a39f3097052cb253621faf9b116c4036437439ec93b0b62c96bf2919ef9ad9253db93e51b547212058a17ae92375a14a55c772414c4522f55a3ef5efdeb323b24c79caa9357d59432b46a8573d1493361c7c3590e11bb944e909a82ddc36bf88270aeae872ca68dfe902569a78f619b1adb34b97df39eeffb28a5014b262ec15a7ed4bebb1b7f2460ceda958ff9a7de6a055c36de7dbe157c0525ba2e49875514a08865a7a718a47c8a33a8eb7d47d7f3a4d64ebda713869f43b091edfa61119340049ca058007dd9905e1cc2965a213a563431740a7102aac4e0a994a8e9a940ff8dc13e0c45ff1a51a04224bac0b622b1dd70b405b4050db4461ffabbdcb3ea261b7a472e18505cfdb68b66bfa1e27083b8c3c13607300fd56b4a27f0cd5ef639af34fbfeb0efd525cc23fcdbec7c41d22200f013fc7ae0e12bb3b4f5097232b15478fdbe6123c2c57c5103580cb7f658f88c2fef06b6f95cd263e9b8efdff49ba91912030d3dcb27186e876b79c55a7d858c879ced8f072df33819cb630a99d257c12908716bf5641cee7f6194f99d50b48bf8f89a313966f1444bb912ece43df34b7d076ddadd04196cddb3a91e66e6087e8f45627d2a079cb965614c87013a5c72dc3eb9bb4ead78c8d1731c6a6ec05c3c3df91531183798efc466bb311e25c69c8eccdcbc01d9988bb464bf5fce429d571caaa21955f9edfe44ede26630953d2435425e61f24a70cf49102abd5bb9214225f69386c2c95b7979d5229a20d297de7c7868295ca0acbc0231fc8dac08bf5406b8ee577d2e149a87a97feda2e744bd178b37f08700dc7a3ad0f0ec4931472a967e48665fb734bfce821d359eb03fa8ce1a71fb3631b151e449073a58c9cdb11e8a00b7561fffa36adb40edaff25ed6f18b146238b350fea5bfe68c44b6d3371f8e4c86eabee6495898c28c6fc39559860856313745c4b39bc2a01e82f0cab968733f206a603d192013a8be40d62b477810bcda312ab9aa5776ed3473a97a8f3997855b4b79cec7279a5682d14884cc6248576e0a71e3da135c4ec8724f71d7b06577bf0cb7e966cfe4471d37fb036984a7b009a29aef0bcd3895fcd5f07525e7d491e25c9e780b7326483f7c21afe885f107131ee9ca7dc92d4d6b59d9fcf6abaa10585a6bf751c8bd689d490e9c8ff97835323c668d9ba245b927eae9a6b3177b043f607119550e419a2bbcdcf0a986701ca14dbad99d73fc81ee268eff8e72d99808084674afdb4fb85fb80fd97f22e133498a507accb9f4874a765e5ac5c2e0e47c20e79024456b8095e492fed0473bef96d448aaf792d3345ca87c7083d3f5403b4d3248e50e1d821c5457d81e7506e0cc1947d85cacbf5b8bf1cf05be2b6c146299b84f1a9353ad7c631265d788671b71d1566ebcace6f8ae3e7836fdb14b5733ebe7325d37eeca274c8e128b2d8afbc759dcf20ca02fbccbb4769edf7c0e557b145f1f9a5f9ff138fb39aff43683d7ed57fe10273069f4f3dc7154e4a30eb0fe46e65e0ac4e9ccc9e736a8a2af677db27adb58b60cf4c7248fc82c7224bc0bcd1a9cce4e5e53108c34664b647c0371796ab9d9a8aff79dc3a9260a090d5594cee5fba116b8f17702211ba61dba5569bd148e4f9f3bdf1d79be05cbc391e35cbe5efcd993d3598ddf98a7705049a7f33615e2058b2c817f5320170bcc9dceacaf5de7f1cd6d250c8ea202bd2e76f6d4398f8bb134683ff43f630f606abec6e9b0d1afcda6435bfc232f15fecf0e93ecb9ffb7beb00aa8809dc6f728a12d8d8e2a73c0721c090fe197a7d2c9a82f2b5bf1388c3389f16fc0484e1c6b6587aec6a0f901699ff4320531447fd91adeb30ec99f71241ec6b2a7992414a6f4725cd24f67b5215118c2908e7300bcd74447aaad4184bfe76fd8745d76024dc03e77dd13fee09d5206ab5d99bfaa1e2b9065a49f27ff9ad259b0e05699cc885f0814aae8783b91eebc04774db8867aa018e66f9689a65ad73c01b3edb3a2e924e83f397fd449a669b25593f11f4f6e7738208cdc40c4ee97aa10f01c59ca11428df34e92ebaab91f2fb688989b88400d894299b7f8edebb2ec04234bd3f419c66e01785905662e74d6139bc67d5472ad88900e7dffa19f6d7213f7e5e0ac959cea7d1a41effca6b1cd739fa84e4d8f7dfe2432bdaa83f225282787a92e873235e06510d44225a66fc723fdd8778d36d48bb42c9f02f74068881db80f7466f5901fbdd4ed0d3857e5f987425527f9269454f1495a11e5bcbf49ba88ed0ad22b4e15c72e7a5ab8c12e8bc245e1cc10a3c4d2c402ccabcf611b713078c234f3a4fafa9699b5d7d2e85e426515495a36e18872de9ee0e664ca807be324c24ce7b956ccc438e8ce250599959fcbcedb4e0b8ecf709c3ec098e3e57b43af40e96c20c77f7110e46b0b050aaa4bc42f5f71298440244cef61cab7acb5fe43615017b162543382f1663940e565f39821225f7786238a349dcc903bc3395a4c3241e6d696f6d8ed7339563e8ab261443eae67b7154b1238c93434b3e7d95fd1ecae1b06aebe78a52c7c40ebd81a50081c4e30d2abd5b563d0d789449f48f23c43e8bdc66f5d40a3a0d1cfa331025e7a444334538e2acc8ef62f62d0dee33894d26b895429da5e6d4963d58c59e836911f65116cc55dd10f543c3b37ea3e50f0575e278f35968f767388b896d0214f1e28cebb1ef02c7517629935a29f9248bafea8c8fc1868ab3aeeb3760c840b800f34f79d3d36eff7021599d842d814176e74cef86284c8d3e8ae631257650e20796c3b35b5e4dc6155ef75464f99510b73f43cec90eeb5cfd10af1a6c486b70a4d37fd0ee9c6dedb15ab418df602348ceff776af60e167dd68b5d1e7d36c008ef91bfa315ce60da8bc45ac62c7308e1f72ed434333bd24c9d7793dbdd0e867c96679ebe5f4fdbe87acc5dd9b552601cb2aeb09f9dd9c1bb3bde713640d04cf68a603ae05179c4aa3676497ed19d4fa4adfd809e13f899d022555b165775c2ff1c85ac805eae6fa3a3d09d047e3dd7c0e72aaad8c452d216e3bd0584c81d38e325116d2614e4cb6d6a4a97e214aa5e69101522377eedb66e104f3fde3c63f2af22912d15ac40c78e539138ef8173dd3cecc7c65eb9c412050965fe98a1c70bab93ffa41a83bdf2e4f7cc597f4165c7c4e6944d993846e5033510f5612e6926b0dabffcf6a08f027541740fc819712d85ffdde7a77ec18b1cf902b200c9ad604536b569811cc31158e4f4986f1a972d34736c5579c30417c04dfa4c4deb97d18ecef466e658512536e3dd36335b619966585773488c7ec3dc9eb2d73 Hey, password is required here."},{"title":"【表达技巧】跟罗永浩学演讲","date":"2023-07-09T16:52:35.000Z","path":"posts/talk/","text":"罗永浩15堂演讲私教课学习总结 导读 B站视频：【演讲】罗永浩15堂演讲私教课 知乎：【学习笔记】罗永浩演讲私教课 前言 开这篇是因为近期，有一个在公司内部分享的计划。 因为不是技术类型的讲座，技巧因素占比就会很低（而技术分享更注重将东西解释清楚）。所以萌生学习这类演讲 + 表达技巧的念头。 认识罗永浩，最初是 6个亿 的负债梗，更深入的是在 脱口秀大会 作为嘉宾时期的发言，对其有几个认识： 听感：表达清晰连贯，但嗓音条件恶劣（据本人调侃是老太监音色） 逻辑：知识涉猎广泛，且临场反应迅速（后者是幽默感 + 经验累积） 内核：善于制造一句核心话题，并反复洗脑callback（如脱口秀的“大局观”，如演讲课的“因为大脑就是被这样设计的”…） 关于这个教程 基于罗老师 “演讲都是有套路和技巧” 的观点，将其演讲课的套路总结如下三点： 为什么要这样?（赢得认同） 如何达到这样?（方法论） 举例、类比论证（深入人心） 十三个要素 这些技巧比较多，难以短时间记忆和掌握，因此先记录一下核心观念，剩下的在实践中掌握和理解。 精华摘要 开始一场演讲的最好方式，就是讲笑话或讲故事。（千万不能讲道理） 对于晦涩或陌生的事物，要巧用类比，如 谈判就是找交集。 开始主体内容前，用三段式介绍提纲。（思维导图） 讲故事的三要素：冲突（吸引注意力） + 行动（故事的发展） + 结局（表达的内涵） 其他技巧 1. 用坐标系描述事物 举例，如何看待 “量化交易”? 首先，一个交易策略的评判标准有两个维度，分别是： Interpret：（金融底层的）解释能力 Predict：（金融市场的）预测能力 因此，引入一个二维坐标系，甚至可以类比不同事物在其分布，例如： 进化论：能解释为什么猿猴进化到人类，但无法预测人类未来进化的趋势 地心说：能预测太阳东升西落，但底层科学原理是错的 最后，根据 量化交易 预测能力强，但无法自圆其说的特点，可以将它放在类似进化论的位置。 该方法论可以让听众直观清晰地了解事物的多维度特征。 2. 结尾升华主题 几天过后，观众未必会记得你讲了什么，但他们或许能从情感上认同你。 这很大程度上，来源于结尾的几句升华。"},{"title":"【cpp】Memory","date":"2023-07-04T17:01:35.000Z","path":"posts/memory/","text":"C++的内存分配与管理 导读 理论偏：【CSAPP】Virtual Memory 本篇结合 C/C++ 了解内存分配相关领域知识 ptmalloc，tcmalloc，jemalloc ... malloc/free 阅读文档：cppreference: Dynamic memory management 使用的时候多查阅文档，注意 malloc 使用时要判断 NULL 避免内存分配失败 #include &lt;unistd.h&gt; void *malloc(size_t size); void *calloc( size_t num, size_t size ); void *realloc( void *ptr, size_t new_size ); 分配过程：↓ 需要考虑字节对齐，注意被释放后的内存也可能重复利用，这也解释了为什么野指针的 undefined behavior new/delete malloc / free 前面有介绍过。 以 A* a = new A为例，通过 godbolt 查看汇编代码，发现其有两段逻辑组成： 调用 new operator 调用 class's constructor call operator new(unsigned long) mov rbx, rax mov rdi, rbx call A::A() [complete object constructor] 相应的 delete 方法，也对应如下的两段逻辑： 调用 class's destructor 调用 delete operator 下面重点展开对 new / delete 两个操作符的学习（推荐阅读 C++ Operators 和 cppreference operator overloading） 先看 libc 的 源码实现，可以看到是对 malloc 的一层封装。 如果类自定义了 new /delete，则优先调用它们。 void * operator new(std::size_t size) _THROW_BAD_ALLOC { if (size == 0) size = 1; void* p; while ((p = ::malloc(size)) == nullptr) { // If malloc fails and there is a new_handler, // call it to try free up memory. std::new_handler nh = std::get_new_handler(); if (nh) nh(); else #ifndef _LIBCPP_HAS_NO_EXCEPTIONS throw std::bad_alloc(); #else break; #endif } return p; } void operator delete(void* ptr) noexcept { ::free(ptr); } System Call 程序中的内存分配有三个层次，如下图。 最终调用的还是Linux/Windows中的操作系统API：如sbrk, mmap… 因此需要重点掌握这些系统调用。 brk, sbrk change data segment size 参考阅读 cnblog: brk 和 sbrk 区别 linux man 手册中描述两者的作用是改变 data segment 的结束地址。 通俗地理解就是，brk函数会重新设置 heap 的高位地址，而 sbrk函数会根据大小来调整 heap 的容量。 两个函数的定义如下： #include &lt;unistd.h&gt; int brk(void *addr); void *sbrk(intptr_t increment); mmap map (or unmap) files or devices into memory #include &lt;sys/mman.h&gt; void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); int munmap(void *addr, size_t length); ptmalloc"},{"title":"日志：2023年7月","date":"2023-06-30T16:23:22.000Z","path":"posts/2023/7/","text":"b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475debb79baf718116b8398ebb7a36965f5712db04a990a04196bf7d89b9188d2f59608c72ed5aa29e6fc56a5ff1b29fef766d5ea38b7aab101c2c288cc8d47a1ddb98f58e3ebed46e51710844af238f638a595dcac39d4bda5ded8547aa673d0beeca805102f4562a781f12cdc07d2da448e4ebf47133795728ca1d580628672d374c763017902d054d929efa4c3aee95334f067071686413aed6fbc1c0d418e93aa3bcb387a92a042cfa05b807fe267b5ba62c20a2f048c31c3b7091c6bfd48e1bbdf52156047e2f8b07cc4a7df940b8fef50a435e591511689fcf8d2d5faafbabd0527fcb5da530c6230f1fa703e6716f23890796df860502732d5f6a1cea25acc2e1bc11a51504d36fdd945bce963514e161abf4cec44c03159e11f9038e237289e9d8281c702e61576f2f90f375a12a819e4286e7c31c3bb74514a6925ee85eca1529d6abdd7538e15c4bd1fc3fd1f3ebff6ac9483c9dfce5b7b0eccabc593db99c4822ca51a2378436fcf09fdad42d29ff50482e9d0eb1b58dadea5fa9f50b79855fd26c4b19f49d191e8c2aab60a2e1a436859f97a44935946f841150d27050f2903a09341a4a8cf9ad0138efa26d1c815137b28364ad5ed2b4a1ff9fe16eb21147a6a004b01f2403a1a0085ba3db57dfe4654b751e00925b9d369286309ba339d22f2dddb796ead59f80055f73298232520397531f0b0bf705b21554ea101a48ae5198f596e98687394f595cb88f6dee6cf78552aa85c806a0a8159ad13cbaeabe70aae83809f31eade9f489579c6a060c007c51f55e25f3efe4c96a995ca0f4021d2c4e4440c6e09b16160c085b5b23dc7b78be18c8976f0be7ed1e97c28be99e78fcd804bd5506b100a863f874f936bc9ed0b78aac30391272c90e7d1d316b6e5c2cc5f1eed1893662cb50797b1d4b808eeeb26daadad35aabeceb2fdfdd8f3be439a15a66581b665403960b81732cbb50ddf30180c7375d28c085245e3a2cadd3b2d476254386ac8b145a5aaff957ffed6c48dba81df88bb3382b402af47ea8680eb1fe397d3bb86d8b229a9748bfd6a62751b933916745ab9b5a6a9e773e52a4d4071bbcc2e57efa8556864abb615fc4e253fc4ebf85f1caf87972a49b45ee2517d46b10098ccfe32a315a4e0b47488a4724c74e25a09f2f4ee2967d96b393e885bb43f3a82d36843b27a51d9656f20d41770672b81c2e7b3da43e172e55ff0979c9bdf1025f6ddd49ad4af161eea013373b3cf15a20468117c1193013fe3bf6db061118a23a0050afdc5fb085393904249490314b1628e1dfe03f37072e7ba62e793d34bd62fd6f64c799eb289e2208cc202709291d15df54bdfb21f389b168c0f3e02e373d8c751be8e61ec2f1a067a1ba484704dc9c9811dea65853c08781728678cabd4b6cbd900710b0efc505729f7c46b7e460e170f2fa94e9074029e9f6f6ef812557fbb56bcbebfec0e7b9b6634f2a18879de02211e08fa0399cd8774dfdd1fd1955ec71252e0d53df0acd78629e25f744aa6f60252d65d659c040506ce1575b77a5873e09d6a3c637493a04e75580aaf4ffe018fb783edbc83e439794e861ffab9b4d2c9d9b3cb35d58ff7325563ebb045ef75509072d74494e140e0a50f0c02487562fb6287259f07251e539cda2b3895bdad3cdbd023b8779fc0493dc3fe460563cff17d403f99d77a8828c301fb4a673bce167d4937ef27c9f9dcff8e350bc7c04c6abab0d9ae0c4b50a1280ecff99136e4630850a0a283668f6f7a163dbbc5d2bad3bdf260c0c830bdee9e5544c667b5841c9e61d439950b737215db4115bf937dbd188d8abe942c27bdb222dabad08c7d5411d1d33f64b48a2cacfcc74976f93c48c7be58619b24e03f73e0ae71ddd8d9aa3cba8bd5241c901ccbb12047c71df2f1e0f1d8c32b6fbb77079595043e084d71302e670c2c93d5c3dbfac2bb55fd167be16ec2a74adbdffb67689b15bce66a86311136613f7c99ecebd9e46c8b2089e9ce1af7985c3dada61c7f6465192afea33e9693b3b4f750f1c734b959ab9c4e9ee1b884fe587cf7a85870296dad165b34248e76a1aab7a6e29c81561757aef5d293dc52f6f280705c880fb6b86c9e3cb78e6eafab6b717b5670108af7ae4f54ef294e37a35fa85c3f222fd86c258f527908cf424ed2b4e0157871288f709a37900b01a328960d19a4f82637d1571e9bb0d8c7cedc536a6288b33d3a7a4c1914fbd4946cce2209cb735a3e86f82d100d3f3e0ada4de54f1a8b1a4503faea8645b502aee40fb7e0f4a972c5ecd020d00b3ef50deaed2d91418684b7c0c9cee51dbc616861db3992c8be405dd83981022b68b5ddabe3930545b07acea0bfa328def7212adfbdfdb3e2a29b30d8ecae02b08cf0a1e37053c3533fba1d8c214a3a4bf6f6bf768028d5e39af030d42a561e908b6a8adb0870dc59164c6b41eebd6f7cd339047ab3115eb107904d0e869330b8b2ffaa8b07b2a8729871cb589505754bb5d5a8fafbd49c1b210f5591c68f71f166fef3a030eb2d7f3c7b889d398953fdfa85c5a522dae6a699be1eba275739811d6185901a96d74796fd8e2169dc2763bf66683a1564afc2662bf0da774c0f3ad3040b6c9a3b71495e7f7fb2af8baec4432394cfaebae134cecf5903339f4082a7f719532e441fe971cc4f63e23420710a78970362d3ca4f95aac85b62976bb256b2dafe1a81cd4a905973d12b7d9fe80b55dffb5ec11a7f091a10c088fe7b24ca48f3a1adbc64eb5b238420f121b1acc6c4c8cee8625e9b26bfec714553d92b501633b893ee9497d6299c1cd0e1732e3cb3c81775326a622ce31bac61ade3a8d4c188dc5964cbc5187ded1de93a5050726e1d9431f4253ee3d6f8c589d304e66d5b6c275a8b9de7a66c717d98fa5491026ef813fb52417c68a30893b792900520f4533dbcdc5e92b4864957167918ad9781db9181bd90e1f30c58750d5c631c1870d8afe445da4f9e65494985cb2f61ec69a82edb3cf1527d7c07824a62649aac69d7c4fbc5a2fe03e4372a52cef7200d7d012d8e0be071467579d24a817ac5d9bd24b12473ce9d92297384e44ac719eb9c104bf356052de42f123899d850b46a8f3a790dbdaaf2d05560890e3a3d880669538307b7525ca3361609c356bcbd8316d113af68b238582799278bf2b05ff931df04fd8edf741a5d6aa1b6dd5bbeb2532b43c6299130fbe1e60cecbeff951a11f5cc8e3c5ceda6b972a52e5b99ddc0844c20fa96773c6c31a8180e4e2042a9331b440305c6053ce0ff5cb945b42b603ca3c44557288e0760a9d1e367b0ecfe47e9cb0be7a4f3821d1f9bf8ce0084d442c19a144417cf2641027647b9af5dbdfc0d246ffbdbbb1ccd272702035da0120809a713188f544ee7177ef356dd0f7f90664af7994ca49f7fcd53508380b5c074cb829271df0d9f2dc9694d59b08d60eb036c2fb125bdda82a353881a860134c734afea74432376e1e0e8050cc312cb8fc7b614f9e4a2cf2084cffb694045f6a80c687ffe4a05b9f729027117f24e96bbfac5bb1fcb70380fbd849e7db7f35da3b294070868c15e327c7f9b973b3b125a7da178eaca670c38ecc36cfa1bf30e09c9716f4013648129f30e5ba577bd2bd5d6b782fca8820d51ecb8b58fd0099325a5b6dd8f5e92159905ada98825a90c6f2f1435a68644fa3f2e12ce85cc4f95e7d7fbd157a6c60f2923ac5325e0dc99dd56267772016b7e8dcdd31b837899aa02999811f617c8938edf1770d7a282347aa0675aff22c16ce5aac49bce8ce09da67f600cc620d094b5c9001b8dcbad4316bdd5a7c5e7342a370c6272d554ab6483bd2b5ff3b50f170a8184937a41de33da575d35daba03896316323534f1d616c0f745d03405130da3ff4edaee6bc65a05da28795c69b941b5da634d4628113b85201779d48cafe9a7cf05d401ec4e2d95abb7ad7ffe2b5d739ab653f381c942af01cc93101749094673d1da7959ed6a3a4c058dcf7df7aeac52d2e51fec89e3e2f6821ad97073631943568425072bf7ddb1d6626570730a6ef615e987ef70001fcfe22fc75377390369ff8746e9fa689968518d1951b9ed544af5ac5642715fff081cc3192572d5409b00d32d39fb224f78cb39477fb711443a415aa98547b8d3508ccfda42e41f5a786a82e6a56eb6ff5f4317d2413a4a1f8f0d59a078cca5b99e97b9c7e824cc9547e6c90ca2febb33edb407e230ab0fdabad15d869d617ef2c36c90dcb4b1a322972ec87ed4e7fcefc8644ad5821d8aab57a94adef417a6ae5a7da91f04c589c16d51b4fdcce19f4573e5821cbd50cdae4e13c23b22628c81c2743e1aec6d94bbc8af4c65082463c0767fe9ee4aee334de605126c3fe04cdeac70768cb5312aaa81d873b7ab8e10917bfa321f677dbc7f61bec01ec32469c78d1afe8e085b86437439ed615e6fe2641a05cb41f69e917d90c775a2f9e39d506a6a6f540ef0ae2d4f954cfb1070445407592967dbdc4a15b84ecf8d61f9c675b844c49d8221600aa09140692777def80bbcd4d56fd18701e60ed67c8c044ebbcfe8f2279b3b74e8ecbc51cecfe8594d0945df93d68b17d2ec78f48e9870fef5eea32f6b50563a828f630ee83aa507109cb20457b6b42d5ce5f3357f179b90a939e36fd32be5c8c4f3a76235e8d89df99d4ac755afd14b14d102c2fba8aedb6743bc942e2468069e437a6c593dc0a147cd375dc68934ba3fcaf725ce186f69fff739e8f8a6c89c82559a2f1115f0b93028d37baa54a482a97d6f426edf678229042dcf806d747514b8d86b690adeef4eb178dc9b345035a030bb834821c1c064b69306f57765a39e022c9abcf19c2da3533bcdd30b77a97ad3ca44fe8388ea54f1b1ed6d46be660ebd51715f605644c9375fc50733aa7dae481691241e6dd54cca1c47f468289a8f0838377849d9189a1ae8a8350c823c720fe40e7ffc1ca2e2411c772a3509b76b5f85596b1454d4e3422f8918fd4383c7020fc791f03fd850c37209ad301f0b0fb536d3e0a6cbee4d19b03f5a03bf92cf64778b76cc60ea6918094261d5f5a60e455f0cf7b84655677918b4cc722387be25d786865ec2a1b9f75c25eff52b534dcea4dc8b09a63394432c939b7ac38f3276bfc220803eb2f3c9460d7c6412fdc04c748602749b25addb1a4c9f6709d2a2935fa2f74e56bffecbeedbc645a7c9b77c13d79ca23ed866c46875ccf1918386c6d83b20ed86b7dcb7e1b040b753c73e2ad3921f05a399ad67ec7a9df630e1a2ae8ff74ea5e00dff6f2dfce3b1c8646d5f947181843a69b82df3f15cebd7168c87976bc598e1058636f4af23c280092a735820403590a6c065854653e6e12772037e8f221d8e48fb1a30f9e909c6b2e3e6ce4bdc808616d232ce88acf8f9a837d100f618a8e3fa0c7227ccda3cf88e02d66b7d2c430b1252f78267132c8927bdae7bc84953b5c271b64d8e81aebb202c79b6cc526dafdee92da4af6356fb54071c26ec25aa2086e59cb1183172e093b84612f938997c9d5d1036718792e5f291b2b36c2dc832524c7db54745aca1a829845a80ed631989339607776965518f89465a89a4342e4465717af858212d79a933775907de7aac428d5efb78bf354117f2ab54cfad82d0b5a744babc0dd2b87f1a8e4cbf96bcfb665c335588c1d22cdfaa3852bef3c91a13286764c0ba44c72cc37345731cb1e642bba556b2bfba771b99661f954d22c5e437752930eb11490647a2b26afb7a23f1a07316a51c8def4b57c70cea01c1a69fb482e7700e488459cc1293442f6b26e1ca933cd30322c6aca178f8e9f88b06a75358aaa87a2037aa51ec94a5ca7fc5373bb1694c59febdd78c1dd1b1daec60e29712fd393ffe4e8f659568c9a4e6caf8c70a59a259c157052323e083c47c465bbf333cd393d18cbb3467c6ee8ec6acd0feb53b3923005f563d5e703b3555a8e8f415411a8e67d6f49697cf7f9e49012d4c4b8311ca9f429c74cce655d0703b4020787633705f860c7c6d47956d377e770df3f316956c8859e526b40e8d5f61c5782153916efe1f4fc646cce2a7ce0dcaf6d32ed9410029ee0622da4ca5981ec49d88f3bdc8f86801871a6d76cbcfd9ab85c033ad0aca4925bd885e2ea6026a6ef9f211bd18833296ae0e6a982cce2d16b5452594b419695fdb7ff8fe633540e67ce9ebe369fe6d45324069a404f7af2c0c787e15b214cc3fc628f74432b012328dd93ecf150c7770875f55b5f1d5cf871be9ebe1db7875dc3a5080684672e3ebafbc3ab37fa1901eb986400cb96f3b3817667cd626a6c46616969a15c1c78b6124c678a1dba521e16cba513521d12398013c70f76a3c887a20212a85ca34d54e0d1e8c63cf1e0345d0d1d45d2096e08d722214a6cef7b7bfd4671e6b1416f6694e795bc19e7dc827d861588ecda82710f38d7f3306ae56562591e08b701a803cda99fca9408b3395fbba9407d149aa59aa1ea53d1d1618a67c4cd59fed13e23f9365c4bbad1f009712aceeae566425987db32e59f1cb80bc1861977dbdda87476a0d328ecf830d431fc33b23a09c8f86e3c3467bc91cc8eddd60bc3c0309a961b02532a462f7966460c923b8baa236091b116023c927c501ae78473aae12555c55b39f97741dc32cb2ac11cd6e7547da7f95a3a34bb97767a6a90dd5337c2ce9951f4a43dad32a8864a1b2e24e7a18447ee3a026f4b161030dcb8ef514a725f38a0609cff84a704a72f7f1f5a5474a4f4d85ef87813a11ba86655bb421988e5e788e59c92feaeb8697603a3d67a218acfa20f4e11d0c8ff23868da856fb2ea2a58f431e195ad5db2a86cc4e11a72e0da34a37627d30e40c911c8003736eddd6ca566eee05916f2acc10fc6d55440962f78094777e4023b81b4f8eea9e782c94f4aed27423ea62b4c5b21274f447a1f63aebb9f118d4bcaf77cb82365c4537ea6fa84262d9683151ec86e101f0995d7131543eada2ae0e2e18157ac7c82f2253ff44986ef3abb2483e00e5662284f92296dfc479d6c9e6f070c7689c0118f4c5f1dc1a48542f00eb5eae67f91bdcc675b38fb13251a05421412001d2da0f3f25d99a8759683ee1e0dfc651ffc262df1fbcfcea3ae8c3379ee79cca7d91ef196cc047c8179619ad6cc4791371ef92b377e63b66be402458adb9da94684953e864e4ef44dca8bf82e699395d5cb15175806961b82dbd73ff37a78b739a700f59e41383cd1364dec38474525c7c51a52cabb7983042836af3f2534bf684ad106bde36aad56 Hey, password is required here."},{"title":"Google评分卡💯及自评","date":"2023-06-27T16:40:51.000Z","path":"posts/grade/","text":"导读 Google将技术能力划分为 0~11 的等级 自我评估技术，判断下一步需要作出的努力 ↓ Self-Evaluation ↓ 基础要求 grade 熟悉数据结构与算法 2 熟练使用 C++11 3 熟悉并掌握 C++高级特性 (14/17/20) 1 熟练使用 Python 等脚本语言 4 熟悉batch、Shell、Linux常见指令 1 熟悉MySQL等数据库的设计、优化 0 熟悉编译原理、编译优化 1 熟悉 vscode、sublime、vim 等IDE、Editor 5 熟悉 Jenkins、TeamCity 等 CI&amp;CD 平台 2 熟悉 ChatGPT、CodeMaker 等 AI工具 1 熟悉Linux内核，如进程管理、内存管理、文件系统等 1 熟悉网络协议和网络编程，熟悉websocket、HTTP、socket、TCP/IP等 1 ↓ C/C++领域 内存管理、内存分配、ASan原理、内存错误及排查 1 模板、SFINAE、type traits、metaprogramming 1 并发、memory order、同步、互斥、boost::asio 0 编译优化、SIMD、ISPC、CPU性能分析 0 C++编码规范 2 ↓ Python2/3领域 Todo ↓ 工具/pipline领域 Jenkins 日常工作使用，无阻碍 3 VSCode 日常开发使用、多个插件开发经验 5 Vim 熟练使用、vimrc配置 4 Git 基本的GUI、CMD操作 2 ~ 3 ↓ 加分项 具备内存优化经验、熟悉linux内存分配 1 熟悉GPU使用，或有底层基础库（CUDA，mkl、openblas等）优化经验 0 ~ 1 良好的系统设计能力，如 performance、reliability、availability 多维度考量程序 2 熟悉机器学习平台相关工具，比如k8s，kubeflow，mlflow，automl等 0 有视频解码和渲染开发经验者优先 2 有存储系统、分布式系统等底层开发经验 0 ## ↓ Google-Standards 等级 标准 0 You are unfamiliar with the subject area 一窍不通 1 You can read/understand the most fundamental aspects of the subject area 理解基本概念 2 Ability to implement small changes,understand basic principles and able to figure out additional details with minimal help 能够实现一些小改动，在别人帮助下钻研更多细节 3 Basic proficiency in a subject area without relying on help 基本掌握和熟练使用 4 You are comfortable with the subject area and all routine work on it 足够精通，足够应对所有日常工作 5 An even lower degree of reliance on reference materials. Deeper skills in a field or specific technology in the subject area. 深耕某个细分领域 6 Ability to develop large programs and systems from scratch 独立开发大型系统 7~10 脚踏实地慢慢来吧…"},{"title":"【网络】HTTP协议进阶","date":"2023-06-26T12:51:27.000Z","path":"posts/http/2/","text":"导读 专栏：透视HTTP协议 墙裂推荐 ⭐ HTTP协议入门 HTTP数据编码 todo MIME-type 使用svn更新的时候有一栏会标注 Mime type，可以观察到除了常见代码文件外，都是以 application/octet-stream 格式传输，它代表未知的二进制数据。 HTTP大文件 todo HTTP连接 前面说过，HTTP协议 是运行在 TCP/IP协议 之上，因此每一次新的HTTP连接，都需要经过TCP协议的 “3次握手 &amp; 4次挥手”，这无形中降低了HTTP协议连接的代价。 因为 TCP位于传输层，HTTP位于应用层，所以可以用如下的类比来理解连接的代价： 开关机：TCP连接 使用电脑办公：HTTP连接 每次使用电脑办公，都需要打开电脑，在使用完毕后又需要关闭电脑。这就好比 HTTP 短连接。而更常规地做法是，保持电脑的始终开启，这样利于随时使用，这就好比 HTTP 长连接。 Connection字段 当HTTP请求采取长连接时，在响应报文的 “Connection” 字段会标记为 keep-alive，此时服务器不会在短时间内断开连接，但是为了降低服务器的无效占用，Web-Server 往往会在一段时间内若没有任何数据收发，便会主动断开连接，断开后会收到 “Connection: close” 的字段。 队首阻塞 因为 HTTP协议 采取 “一问一答” 的模式，即典型的 FIFO 结构，当队首的请求因为处理太慢而耽误时间，那么队列后面的所有请求也会相应地被阻塞，这就是 Head-of-line blocking。 类比理解为：食堂排队打饭，每次刷卡是一次 Request，每次领到饭是一次 Response，每处理完一次成对的 Request-Response，队伍才能往前推进一步。只要前面打饭的慢了，后面所有人都会受影响。 解决方案是：并发连接，即增加打饭的窗口。这里不详细介绍。 Cookie 前面说过 HTTP连接 是无状态的，即没有任何记忆。即使某个请求会让服务器出现500的错误，下次请求时服务器依然会 “热情招待”。这迫切得需要一种缓存的机制，Cookie应运而生。 Cookie 是服务器委托浏览器存储的一些数据，让服务器有了“记忆能力” Cookie原理 Response报文中，利用 Set-Cookie字段发送多个 “key=value” 形式的 cookie值，这些会由浏览器负责记录下来。当浏览器下次访问同样的地址时，Request报文会自动利用 Cookie字段将本地缓存的 cookie 发送给服务器，这样服务器就知道自己的身份了。 因为 Cookie 是与浏览器绑定的，如果你换个浏览器或者换台电脑，就会丢失之前的 Cookie记录，此时服务器也会重走一遍新的 Set-Cookie 流程。 Cookie生命周期 Cookie拥有自己的生命周期，它通过 Expires 或 Max-Age 两个字段实现。当超过标记的有效期后，浏览器会自动在本地删除记录，不会再通过HTTP请求发送给服务器。 Expires：记录“过期时间”，如 Fri, 07-Jun-23 20:00:00 GMT Max-Age：记录“保质期”，单秒是秒。将浏览器收到相应的时间加上 Max-Age，即得到 Expires Cookie作用域 浏览器会存储大量的Cookies，因此需要标记其作用域，即发送给哪个服务器或者URL，常用字段是：（不清楚的推荐阅读 HTTP协议之URL） Domain：域名 Path：路径 Cookie应用：身份识别⭐ 登录taobao等电商网站时，浏览器会自动保存你的登录账户（或密码），就便是利用cookies实现的。它同时还会记录你的浏览记录和购物车。 大概格式为：name=xxxxx.... Cookie应用：广告追踪 当你浏览各种网站时，它们会根据你的访问喜好作行为分析，然后定向推荐一些图片广告给你，这就是利用cookies的原理。 这部分成为 “第三方Cookie”，属于搜集用户隐私的行为，浏览器经常会弹出确认框以请求权限。 HTTP代理 传统的HTTP请求是 Client-Server，现在常常有“第三者插足”，即在中间会引入一个 代理服务器（Proxy Server），它的角色是双面的： 面对上游：充当客户端，发送请求 面对下游：充当服务端，响应请求 类比：消费者（浏览器）—— 便利店（代理）—— 源服务器（批发市场） 定理：计算机领域的任何问题，都可以通过引入一个中间层来解决 代理字段 代理服务器 通过字段 Via 标明代理的身份，在HTTP请求的链路中，每当报文经过一个代理节点，代理服务器就会将自身的信息追加到 Via字段的末尾。 另通过如下字段标明其他信息： X-Forwarded-For：追加代理的域名 X-Real-IP：客户端真实IP 代理协议 针对代理的HTTP请求，HAProxy 公司推出了专门的代理请求协议，The Proxy Protocol。 其基本格式为：开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\\r\\n）结束。 PROXY TCP4 1.15.115.4 110.42.228.178 32200 80\\r\\n 负载均衡 当一个区域所有的消费者，都蜂拥而至一个批发市场购物，就会造成堵塞排场对的现象。 因此 “负载均衡” 的解决方案是，在每个居民集中地地区设置一个小商超，或者经销商，而自己只负责货物的批发和调配。消费者 择近择闲 选择小商超去购物即可。 通过中间的代理服务器，将请求均匀合理地分散到多台源服务器，能够有效提高系统的响应速度和利用率，这就是 负载均衡 的基本原理。 而如何挑选转发的服务器，有如下的思路： 哈希：如尾数单号的去A服，尾数双号的去B服 轮询：对于新请求，分配一个最空闲的Server去处理 Cache 两句话讲清楚Cache 浏览器Cache：消费者家里囤（上次买的）货 服务器Cache：小商超囤（上次卖的）货 Cache：浏览器 当浏览器频繁每秒请求同样的数据时，如果服务器不厌其烦的依次发送，会造成很大的性能和流量浪费。因此需要客户端（即浏览器）的缓存。 一个带Cache的HTTP请求流程是： 浏览器检查cache，若有则直接读取，若无则发送新的HTTP请求； 服务器响应请求，并返回资源，同时标记资源的有限期； 浏览器接受请求，并缓存资源； 而标记资源的有效期字段是 max-age，即cache的生存时间（秒），过期则被浏览器自动销毁。 其他常见字段有： no_store：不允许缓存，如一些高频的秒杀字段 no_cache：使用缓存前，检查是否有最新版本 muster-revalidate：不过期则直接使用缓存 Cache：服务器 Todo，与HTTP协议关系不大，可以了解 Redis、Varnish 等缓存技术。 Chrome调试 Chrome浏览器提供了丰富而强大的调试功能，按下 F12 或者右键点击“检查” 以进入调试页面。"},{"title":"Computer Networking","date":"2023-06-22T12:18:00.000Z","path":"posts/network/","text":"计算机网络大纲，HTTP/TCP/UDP…"},{"title":"【网络】HTTP协议入门","date":"2023-06-21T16:15:09.000Z","path":"posts/http/1/","text":"导读 专栏：透视HTTP协议 墙裂推荐 ⭐ HTTP协议 HTTP 协议是 HyperText Transfer Protocol 的缩写，它是一种用于超媒体信息传输的应用层协议，是互联网通信的基础。 如何通俗地理解 HTTP协议 呢？ 如何理解新概念? 任何技术思想，在现实生活中都能找到映射 巧用 “类比” 的手段 Hypertext 在互联网早期，传输的信息只有简单的字符文字，即 Text。随着信息爆炸式地增长，网络需要传输的信息被扩展为 图片、音频、视频等等，这些就是超文本。 超文本的核心是 超链接 Hyperlink，通过互相引用而形成复杂的网状信息结构。 Transfer HTTP 是一种 Request-Response协议，即将信息在 A、B 两个点之间双向传输，因此有两类参与方： client http请求的发起方，通常指浏览器（如Chrome、Edge） server http请求的接收方，又称为 Web Server，如 Nginx、Apache 都是常见的服务器框架 CDN client和server之间通常不会直连，而是经过 CDN(Content Delivery Network) 这个中间商。它能够实现安全防护、负载均衡等常见功能。 Protocol HTTP 是众多网络协议中的一个，先理解什么是协议? 以毕业生签署的“三方协议”为例，参与对象是多元的（自己、学校、企业），同时协议还会规定各方需履行的义务，以及该做什么和不该做什么。因此协议的核心要素是： 多方参与 client、server、中转者… 通信规范 如规定 Get、Post 的请求报文格式，如请求的错误处理等等 在 HTTP 的发展历程中，也经历过很多大版本的迭代，如 HTTP/0.9、HTTP/1.0、HTTP/2、HTTP/3等等。 TCP/IP TCP/IP协议 是整个互联网的标准通信协议，它实际上是一系列协议的统称，其中最核心的是 TCP 和 IP，这里篇幅有限只作简单介绍。 IP IP协议（Internet Protocol）主要解决寻址和路由问题，它提出 IP地址 的概念来定位互联网上的每一台计算机。因此可以将其类比为电话号码，而整个运营商的拨号系统就是一个 IP协议。 IP协议又分为 IPv4 和 IPv6，大部分仍在使用前者，即IP地址是4个用冒号分割的数字，例如 1.15.115.4。之所以出现 IPv6，是因为v4分配的地址已经捉襟见肘，不够整个互联网的使用。 TCP TCP协议（Transmission Control Protocol）是一种 传输控制协议，它基于 IP协议 之上，提供可靠的、字节流形式的通信，也是HTTP协议得以实现的基础。 之所以了解TCP/IP协议，是因为HTTP运行在前者上，因此又称为 HTTP over TCP/IP。 DNS 在TCP/IP协议中，通常使用纯数字的 IP地址 来标记计算机，这非常不利于用于的使用和记忆。 因此 DNS（Domain Name System）域名系统 应运而生，它使用具有实际含义的名称来替代IP地址（即英文+数字的组合，也可以是汉字），例如：95.211.80.227是IP地址，nginx.org是其域名，两者指向的是同一个web服务器。 域名解析 以 www.apple.com 这个域名为例，当用户尝试访问该域名时，会经过至少3次的DNS域名解析服务器： Root DNS Server：管理 com, cn, net等顶级域名的IP地址。 Top-level DNS Server：管理 apple.com 的IP地址。 Authoritative DNS Server：管理 www.apple.com的IP地址。 DNS缓存 目前全世界有 13组 Root-DNS-Server 提供顶级域名的解析服务，但因为全世界的网民都在请求，会造成系统的拥挤并降低访问速度，优化手段之一就是利用 DNS缓存。 当你已经访问过 www.apple.com，操作系统就会在某个文件（如下↓）缓存解析后的IP地址，这样下次访问时，就不再需要经过 DNF解析服务器了。 linux: /etc/hosts windows: C:\\WINDOWS\\system32\\drivers\\etc\\hosts URL 通过 TCP/IP协议 加上 DNS 的组合，我们实现了访问互联网中任意一台机器，但是每台机器上的资源仍然有很多，如何对他们加以区分呢？ URL（Uniform Resource Locator）含义是 统一资源定位符，即俗称的网址，如下是其组成格式： scheme：指定http、https、ftp等协议 file：本地文件 ftp：文件传输 ssh：加密登录 ://：约定俗成的分隔符 user:passwd@：明文身份信息，已被弃用 host:port：省略端口会用默认值，如 HTTP 80，HTTPS 443 path：资源的在主机的路径，也可能是服务路径 ?query：查询参数 #fragment：仅浏览器使用，用于锚点跳转 HTTP抓包 “纸上得来终觉浅”，我们通过在windows下快速搭建一个最小化的HTTP模拟环境，借助抓包工具 wireshark 来对 HTTP 的细节一探究竟。 搭建http本地实验环境 知乎: Wireshark抓包指南 在启动本地web服务器后，尝试在浏览器输入 127.0.0.1 访问该server，然后按下回车，wireshark抓包（限制http/tcp port 80）抓包的结果如下： 前三个包：TCP协议的 “三次握手” 中间四个包：HTTP协议发送了一个 GET /HTTP/1.1 的请求报文，Server回复OK 后四个包：HTTP协议发送了请求 /favicon.io 的请求报文，Server回复404 通过http抓包，基本清楚了http协议的工作流程，核心是 “Requst-Response”，即 “一问一答”的模式。 HTTP报文 通过wireshark也可以清楚看到http请求发送的报文内容，其全部由 ASCII文本 组成，非常容易肉眼阅读。 HTTP协议的 requet报文 和 response报文 的组成机构基本相同，由三个部分组成，每个部分由一个空行 “CRLF（0x0D0A）” 隔开: 请求报文 回复报文 报文示例 HTTP状态码 既然 HTTP协议 采用 “一问一答” 的模式，那么响应报文内应该包含请求的结果信息，即状态码（Status Code）。 目前 RFC标准 规定状态码是三位数，即取值范围是 000 到 999，其从设计之初也有具体的含义区分： 1xx：提示信息 2xx：成功 200 OK 3xx：重定向 4xx：客户端请求报文错误 400 Bad Request 403 Forbidden 404 Not Found 408 Request Timeout 5xx：服务端内部错误 500 Internal Server Error 502 Bad Gateway HTTP特点 作为本篇的收尾总结，HTTP协议可以概括为三大特点： 可靠传输 注意，“可靠”只是确保 Request方 的必定传输，由于一些网络原因未必能确保 Response方 的成功接收。 明文传输 HTTP报文的所有信息都回暴露在 “光天化日之下”，HTTPS协议实现了加密版本的HTTP传输。 无状态 区分于 TCP协议 的状态，HTTPS协议 是没有状态的，即 “没有记忆能力”。"},{"title":"【GAMES101】Shading","date":"2023-06-13T15:42:19.000Z","path":"posts/shading/","text":"Lambertian、Blinn-phong、shading-tech 导读 GAMES101 Shading CS130 Shading WebGL demo Shading Wikipedia: Shading 维基百科对于 shading 的定义非常清楚，即对3维场景中模型 着色 的过程，且着色的效果取决于如下几个因素： 1.光源 推荐阅读：LearnOpenGL，CS130-Lecture12 Ambient lighting 环境光照，即使在最黑暗的情况下，存在一些微弱的光亮使得物体呈现出一些颜色。 Directional lighting 平行光，也称作天光，在固定的光源方向上无任何衰减。 Point lighing 点光，向四周照射，随距离衰减。 Spotlighting 聚光灯，呈一个锥形范围照射，随距离衰减。 2.相对位置 距离关系 光照强度一般随 距离的平方 衰减，$ ~ I / r^{2}$ 角度关系 根据 Lambert’s cosine law，$\\vec {n} * \\vec {l}$ （结合后面的 Lambertian Reflection 理解） 3.材质 Roughness 粗糙度越高，镜面反射能力越强，典型代表如镜子。 Metallic 金属度越高，漫反射越弱。 Translucent 具有透光属性，如典型的 SSS。 Local Shading 现实中的光照，需要考虑各种直接光、间接光的反射、吸收效果，想要在图形引擎中模拟它们非常不现实。因此一些大佬提出局部的着色算法，以模拟 一个独立点的shading计算，这里统称为 local-shading。 我们需要了解 Lambertian Reflection 和 Blinn-Phong Reflection。 Lambertian Reflection ⭐ Lambertian模型 一般用来模拟 diffuse光，核心影响分别是：距离、角度。 距离基本的衰减关系，前面讲过了。角度根据 Lambert’s cosine law 计算得一个光照强度的系数，其中 $max(0, n \\cdot l)$ 表示任何大于90度的夹角，光照强度都为0。 Blinn-Phong Reflection ⭐ Blinn-Phong模型 在前者的基础上引入了 Ambient 环境光 和 Specular高光，它是一个叫Blinn的教授拓展了Phong的光照模型，其计算方式分别为： Specular $L_{s} = K_{s}(I/r^{2}) max(0, n \\cdot h)^{p}$ 引入一个 半程向量 $h (=\\frac{v+l}{|v+l|})$，实际含义为入射角和观察角的二分之一夹角。此时衡量 $h$ 和 $n$ 的接近程度，即点乘 $n \\cdot h$（Phong模型选取的是 $cos(\\alpha)$，$\\alpha$是夹角）， $n, h$ 越接近 则点乘值越大，则高光越强烈。 其中的 p 衡量 高光随夹角的衰减速度，p值越大，则呈现高光的范围越小（如下图）。 p = 5 … 10：塑料 p = 100 … 200：金属 Diffuse 同 Lambertian模型 Ambient $L_{a} = k_{a}I_{a}$ 环境光假设任何点来自环境的 光照强度是一致的，即 $I_{a}$，它与实际光照方向无关。 笔者粗暴地理解为自发光、固有色。 Shading Tech 推荐阅读：Wikipedia，CS130-Lecture14 前面讨论光照模型的计算，但是忽略了一个重点：以什么对象（或粒度）进行Shading? 基于前面的知识得到，任何 mesh 都是由顶点和三角形（或Poly）组成，因此自然想到如下几种方案： Tri（Poly）：基于三角面的 Flat Shading Vertex：基于顶点的 Gouraud Shading Pixel：基于像素的 Phong Shading 1. Flat Shading 对每个三角形（或Poly） 计算出一个法线，可以通过叉乘得到，并基于法线作光照计算。此时三角形内的Shading结果是一样的。可以理解为 Low-Poly 的渲染风格。 2. Gouraud Shading 对每个顶点作计算（假设顶点没有自己法线，可以根据周围几个三角面的法线求均值）。可以理解为 Vertex-Shader。 3. Phong Shading 对每个像素插值出单独的法线，基于此作光照计算。因为是全像素的，所以性能开销高。可以理解为 Pixel-Shader 三种方案对比 Flat Gouraud Phong 光照粒度 poly Vertex pixel 表现 劣 中 优 性能需求 低 中 高 需要顶点法线 × √ √ Normal Shading的着色计算非常依赖 法线，下面介绍两种常见的法线计算方式： 1. 顶点法线 模型自带，例如 obj 格式可以指定逐顶点的法线 计算顶点周围 Poly 的法线均值 2. 像素法线 通过两个顶点的法线插值，记得归一化！"},{"title":"【CSAPP】Virtual Memory","date":"2023-06-13T12:33:56.000Z","path":"posts/virtual-memory/","text":"虚拟内存、cache、内存分配、内存泄漏… 导读 CSAPP 第9章：Virtual Memory（已读完，通俗 &amp; 受益匪浅） 汇编（一）：计算机架构入门（站内文章，硬件基础知识） CSAPP重点解读：虚拟内存 What Every Programmer Should Know About Memory（114页pdf） cppreference: Dynamic memory management IC221 Lab 05: Memory Leaks virtual memory 物理内存有什么问题？1. 内存空间不够，2. 产生内存碎片，3. 没有内存保护。从这个角度看，虚拟内存是一个中间层，本质是到物理内存的一层映射关系。 并非所有系统都会使用虚拟内存，一些古老or简单的系统就会直接使用物理内存。 物理地址和虚拟地址的对比如下： Physical-Address：物理地址，从0开始每个byte递增1 物理地址可以直观反应内存大小，且是连续的，例如 0x0000 ~ 0xFFFF 表示 64KB 的内存。 Virtual-Address：虚拟地址，是一种到物理地址的映射（MMU） 使用虚拟地址，可以节省地址总线的位数，且利于cache实现。 cache 存储器 是计算机用来存储数据的器件，即通常所说的磁盘。其根据读写特性又可以分为两类： ROM（Read-Only-Memory） 只读，一般是显卡、网卡上的默认系统，如BIOS RAM（Random-Access-Memory） 可读可写，显卡上的RAM又成为显存 为了提高CPU读写数据的速度，现代计算机在 CPU和RAM之间又增加了 速度更快、内存更小、造价更高的 L1, L2, L3 Cache，这部分称为 SRAM（Static）。 作为对比，DRAM（Dynamic） 一般用作虚拟内存的cache。（???） 至于为什么 SRAM 速度要比 DRAM 快很多？这需要从硬件制造上理解，参考阅读：存储技术SRAM详解 page 计算机内存会被划分为固定大小的 页（page），划分页是为了实现缓存的功能。 对于虚拟内存而言，任何一个 虚拟页（virtual page, VP） 中的内存只能处于如下三种状态： unallocated：未分配内存（即不在物理内存中） cached：已缓存（但在物理内存中） uncached：未缓存（但在物理内存中） PTE 为了描述 虚拟页 和 DRAM 之间的缓存关系，操作系统引入 页表 PTE（Page Table Entry） 的概念。通常情况下，它有一个有效位和一个n位地址 组成： 有效位：对应的虚拟页是否 cached 地址位：若cached，则对应 DRAM 的物理地址 其他许可位：如可读、可写、可在内核运行等 配合下图理解，一段虚拟内存被分为 8个虚拟页，对应着左侧的 8个PTE，其中的虚拟页1、2、4、7已经在物理内存中被缓存，同时在PTE中存储了对应地址。 虚拟内存访问页的两种情形 已缓存，即 page hits 未缓存，即 page faults page hits ✔ 页命中，即虚拟页已经在DRAM中被缓存，读取时只需根据 PTE 找到对应的物理地址。 page faults ❌ 页缺失，即虚拟页 cache miss，这是它在 PTE 中的有效位是0，即代表其在 DRAM 中未缓存。 此时内核会选择一个已经被缓存的 “无辜儿” 去替换成该页，这个无辜儿又称为 牺牲页（victim page），同时进行如下两个操作： （物理内存中）用 查找页 替换 牺牲页 （页表PTE中）交换 查找页和牺牲页 的 cache有效位 注意这里的 替换策略 很重要，主要有如下两种（实际应用会更复杂）： write-through：直写，发生改变时更新cache和内存 write-back：回写，发生改变时只更新cache DRAM 为了性能考虑，采取的是 write-back 方案。 locality 虚拟内存、分页之所以能达到非常好的cache优化，是因为程序的局部性原理 Locality of reference 时间局部性：一个刚刚被访问的内存地址，在未来有更大概率被再次访问 空间局部性：被访问的内存地址，其周围的内存更容易被访问 memory allocator 实际开发中，当需要申请一段内存时，其大小往往不是固定的（与runtime有关），此时有如下两种内存分配到方式： int arr[10000]; 静态定义偏 hard-code，浪费较多内存 int* arr; 需要时动态分配内存⭐，本章重点介绍 C++ 提供一种在 堆(heap) 上动态分配内存的方法，一个 runtime 程序的内存划分如下： C++ 的动态内存分配器有两种类型，区别在于如何释放内存： Explicit allocator 显示分配器，要求程序自己去释放掉申请的内存，C-Style的方法是 malloc/free，Cpp-Style的方法是 new/delete； 当程序没有正确或及时地释放内存，就会造成 Memory Leaks。 Implicit allocator 隐式分配器，它会自动检测未被释放的内存块，并主动去释放掉，它有一个通俗的名称叫 Garbage Collector（垃圾回收）； 诸如 Java、Python 等拥有自己的垃圾回收（这部分不作讨论）。 mallco &amp; free 阅读文档：cppreference: Dynamic memory management 使用的时候多查阅文档，注意 malloc 使用时要判断 NULL 避免内存分配失败 #include &lt;unistd.h&gt; void *malloc(size_t size); void *calloc( size_t num, size_t size ); void *realloc( void *ptr, size_t new_size ); 分配过程：↓ 需要考虑字节对齐，注意被释放后的内存也可能重复利用，这也解释了为什么野指针的 undefined behavior 衡量标准 动态内存分配器的实现有很多种（malloc是非常普遍的一种），一个优秀的分配器应该兼顾如下两种性质： 分配&amp;释放的速率 即每秒可以进行多少次的内存分配 和 释放操作，又称为吞吐率。 内存利用率 即内存的实际利用率，受牵制与内存中的小碎片。 垃圾回收 垃圾回收（Garbage Collection）是现代高级语言的常见特性，它最早可追溯于 1960s Lisp语言，如今也已经发展为 Java、Python 等语言的重要部分。 What is Garbage? 正所谓知己知彼方能百战百胜，欲消灭“垃圾”，先搞清楚“垃圾”的定义。 阅读下段代码，其中的指针p在函数garbage内部没有被释放掉，因此函数调用返回后，这就是一段内存垃圾，也称为内存泄漏。 因此垃圾回收，就是自动释放 泄漏的内存 void garbage() { int *p = (int *)Malloc(15213); return; /* Array p is garbage at this point */ } 实际的垃圾做法比较复杂，这里简要提一下其实现原理。 垃圾回收器 会维护一个内存块的有向图，其中 Reachable节点就是有指针指向的，可以被手动释放；而 Unreachable节点就是无内存泄漏的节点，垃圾回收就是去释放它们。 memory leaks 关于内存泄漏的定义，上面有提到。这里重点介绍两种检测内存泄漏的工具。推荐阅读这篇材料: IC221 Lab 05: Memory Leaks Valgrind valgrind ./a.out：跟踪内存泄漏 valgrind --leak-check=full ./a.out：查看更详细的内存泄漏信息 LEAK SUMMARY：该标签，就是潜在的泄漏部分 ==2392771== HEAP SUMMARY: ==2392771== in use at exit: 0 bytes in 0 blocks ==2392771== total heap usage: 0 allocs, 0 frees, 0 bytes allocated ASan AddressSanitizer 已集成到 gcc、clang 等编译器，添加 -fsanitize=address 的编译选项 并运行即可。 g++ -fsanitize=address -g main.cp ================================================================= ==2392472==ERROR: LeakSanitizer: detected memory leaks Direct leak of 5 byte(s) in 1 object(s) allocated from: memory bugs 内存bug 相对于其他类型的bug，往往更难以定义和排查。这篇文章 调试理论与实践 指出：程序代码错（Bug）到 可观测错（Failure）之间的跨度距离，决定一个bug排查的难易程度，而内存bug的跨度尤长。 换言之，不论是时间还是空间上，内存的错误 往往距离错误源有较长一段距离。 引用坏指针❌ 错误表现是 segmentation fault，错误原因有： 访问非法内存地址，如读取 0x0000001 地址的值； 对 “只读内存” 进行写操作，如 scanf(\"%d\", val) WARNING scanf(\"%d\", val) 会将 val 的值解释为一个地址 如果该地址只读，会出现 segmentation fault 如果该地址可写，程序会覆盖这段内存，造成无法预测的后果... 未初始化的堆内存❌ 对于 .bss 的静态内存，加载器会将其初始化为0，但是堆内存的值是无法预测的。 如下 y 数组的值不一定都为0，请手动为其赋值。 int *y = (int *)malloc(5 * sizeof(int)) 缓冲区溢出 ❌ 这类bug使用中文有点别扭，实际是 Stack (Buffer) Overflows，即写内存时超出原本的大小限制。如下当输入超过 64 bits 就会出现 segmentation fault： char buf[64]; scanf(\"%s\", &amp;buf);"},{"title":"【CSAPP】CMU 15-213","date":"2023-06-11T18:00:54.000Z","path":"posts/csapp/","text":"CS网课中的 “圣经” blockquote{ line-height: 30px; padding: 4px 16px; } 课程主页 | B站视频（中字） | 课程ppt CSAPP pdf 英文版 Labs Github CSAPP重点解读 读薄/读厚 CSAPP CSAPP CSAPP 是 《Computer Systems: A Programmer’s Perspective》 这本书的缩写，它作为CMU大学的ICS课教材，被誉为计算机系列课程的圣经，其内容涉及：计算机组成原理、操作系统、编译优化、网络和并发等。 “万丈高楼平地起，勿以浮沙筑高台”，学习计算机的底层原理，是在修炼内功、在夯实基础，这比修一个bug或者读几段代码更加实在。 站内文章 2. Information Storage 9. Virtual Memory 关于 labs 首先 CSAPP 的整个学习过程：以 labs 为主，视频和ppt 为辅。在github上找到一份疑似官方一致的repo，自己fork了一份用于开发：🔥Github Repo 整个 labs 的设计非常精巧，还囊括了测试、评分的用例，后者是用 python2 脚本编写。以 lab-0 为例稍微介绍其整体的架构设计： RAEDME：实验说明 Makefile：通过 make 完成实验的编译、运行与测试 *.c, *.h：lab源码 ⭐ qtest：脚本驱动的测试框架，值得一读 ⭐ 其中 console.c 实现了一个精巧的可交互命令行，并集成一些用于 lab 的指令。qtest 集成了前者和一些测试用例，它将评判你的代码是否通过多少case、以及获得多少得分。 通过实验，读懂实验框架代码，这两件事都很重要！ Lab0 - c programing"},{"title":"【cpp】Constructors","date":"2023-06-10T18:42:16.000Z","path":"posts/17P7469/","text":"提要 hackingcpp: destructors 面向一些基础使用，因此所涉比较浅 基础 cpp 有 3 种特殊的成员函数，本文所有的内容都围绕它们展开： what when T::T() 默认构造函数 T创建时 T::~T() 默认析构函数 T销毁时 T::T(param…) 特殊构造函数 T带参数创建时 即使用户不去声明 构造 和 析构 函数，编译器也会自行创建者两者。 构造函数的调用时机很容易理解，但析构函数的调用时机很特殊。 显式地销毁对象 隐式地被销毁，如局部变量的作用域结束 if (...) { T x; // constructor } // destructor Constructor 构造函数根据构造的类型，又分为如下几类： class Test{ public: Test(int a); // 构造函数 Test(const Test&amp;); // 拷贝构造函数 Test&amp; operator=(const Test&amp;); // 拷贝赋值operator Test(); // 构造函数 ~Test(); // 析构函数 } 考虑如下两个初始化的用法，才能看出调用构造函数的区别： Test t1(88);：普通构造函数 Test t1 = t2;：拷贝构造函数 Test t1; t1 = t2;：拷贝赋值operator C++11 delete 申明为 Test(const Test&amp;) = delete; 可以禁止用户使用拷贝构造函数 此时如果调用，会有编译报错：error: use of deleted function ‘Test::Test(const Test&amp;)’ Destructor 析构函数的调用顺序是编译器严格限制的，即析构顺序与声明顺序相反。 对于如下的结构体 Test，当对象发生销毁时，执行析构的顺序依次是： Test -&gt; t3 -&gt; t2 -&gt; t1 class Test { T1 t1; T2 t2; T3 t3; public: Test(); ~Test(); } RAII Resource Acquisition Is Initialization 这条 stackoverflow 认为RAII应该称作Scope-Bound Resouce Managerment，这样更容易理解，笔者深表赞同，因此下面也围绕这个理解展开。 Resource 首先理解什么是 Resource? 可以理解为任何需要被合理控制的c++对象 file handles thread lock … 对于任何一个resouce，它的生命周期会经历 创建 -&gt; 使用 -&gt; 销毁 三个阶段。而销毁往往最容易被忽视，这会引起内存泄漏等问题。 Scope-Bound Scope是指一个resource的作用域，当其离开作用域时，应该自动调用其析构函数以使其销毁。 总结 RAII 是一种防止内存泄漏而进行自动析构的cpp特性 RAII应用 一些 C Library 总是会成对出现一些功能性的函数，例如： gpulib_init, gpulib_finalize 如果只调用了init函数，而忘记调用负责析构的后者，就会出现内存泄漏、资源hung-up等bug。 因此我们可以在cpp层通过 RAII 的理念将它们封装一层： #include &lt;gpulib.h&gt; class GPUContext { int gpuid_; public: explicit GPUContext (int gpuid = 0): gpuid_{gpuid} { gpulib_init(gpuid_); } ~GPUContext () { gpulib_finalize(gpuid_); } }"},{"title":"2023下半年规划","date":"2023-06-04T17:29:53.000Z","path":"posts/2023b/","text":"b3dc07a81f6459d120ce338ccca5504603780459e0306826441972681af56d62ee5e99a6b2a15c89d5fbc320a13f63ed9ba268edabaf6c1c008413d66883445c58b4a2e699e4db9148ef23f3cdb870ec629634ee078e07787bd698a1a7017441544b629e2ca45641055b5256dddc3850ef7b32f2b68d3790a725ce8ee1848b4e29139d82dc7e412ad454c07aa205233a72745362d1b46e637326d420e4ac5e28b017b61b1e296a78ef19174eaf108459d882e5566ca8f8f60623de7fad8d11de55ac7a485bf7431c027be922ed67691382f46e870981bfa2d5f44c37647e9f884f2c949ff8f74e5fa4d637bdc965636ed0230500af093bd31a7b09acf2445adb8794690deae28484535dfdb43f905e86ba26b4573159e9b5ecb96ed3829629fc66f5cd9dd7246343cc41183bccf94ac15a62d1cdbf37380cac522e2d5d377a19c3e8d6ed1822424bc017329448f1c8adcf142b7caada11d87e5439cf3bece0f10d5ed2a3c12d936e44cac29d668f90addc6b225dbb15f90676d8e9482786e7c16988627d4396666cfec1962e24df0b06041ddfdcbeef3871ac953c6069b3bbc30965b3c86333b814c934887a596d9f1c850f96950fca6cac75638adf45420b02aece8370b695f968867993f35f474d6d3350443f69b67227cc572e8275fd928e0db708844c9164b3ac272eb6ee5525aec55eaba807aade2812a344a3b18a140a06f265f8ff4552e655e58cbf71729a738ce2b625c865c1f2d96ab306c29a47a85150ff833aa72eeb506bbebb58a14587f30b9162ff8c719c0100dfff7d8799074e9169fe89408724d6bfeb4b785fe99281eba0e152cb531201c5e2a93a93b7e9a1964ff44627b98f462cc24a37405aaac7c672ce32db0f0ff5200680f115a6d732e20ef1c200b633873737b1f7bc55387cbf298de8eb399796fa5a2a6bbba975a6ea0726ea4ba7d007b5fc3f6564eb44e0f73b181b67af8cf7789bfab11fa5e73364897d22096d2a7a63e713ce43751daa86f5ef363d9da1bbbfec4a7750b92cb80a3d5a8d65ed62aaf2ce940e4ab4061a33ac704538d7971f3b5f121c50c7c60d7d16b54bfbda8e77db4922165e6027af4f2cc756b5338bc079d09be3dd538cafb98f01726bd78333f0ad555cb27948781268f10a51debc2db9d2d46cc81fbe157e0a9649508d1d77dc43c218b0859c07788786ae885b4344558467826a80ff289634e430191ad3bf66237642cd97774672200753e853688fb057aefda431b5604c81c8aef7fc340231e5702cd69ea9687d8e3c9d716f6d687576534a21afbe1f8f06266eeee2aaae3abce9b1240f2c44b616b1f84231bd6a69a2e8bf1c2fdad57edda8344adbf3694490d99396f0f18d41d94319b3e4f8fb926cd3122bb3a59fca9fe04c321689bf48058bf7070da842c4cf79989c5581c0a341a7098b037d388d144697b6466ff9c0373bbd26022ded2f404c7294006d3ca085122e5e188b4cff484495e84d2272150bb15e090382a19512819a5d8a231a55e692c9d5f717f0e11e1f6d72c7e9c2960e21f1a9462d391d40827ec601608464e6f34c96d642087b63dbecbe5be536cd6715bf4fdc27ae0a7d7dfd053c57626ff18d54725e754a83cc95008132a7877833eb6b36f05797c066c13883fe6e9c72296ff91970b79a3c40f7c877d309d10876c9d578e53a923653ea56ee0f58a107cf5c6f1695397879703fd41ec9a32b3d75d2268e18b40c48af5f8dbe63433f4e4d79f431fcb8a7e45bce5fc56229d38d13ff4f69afcd888d4d4a05192c4b06f5049b647f65669b29a6825979f07d1ccac51cf6fc2e2e60a9b08bda21a068a094319fab135f33904e769adfebf535cfd14d97d02e6f816880f5c97058b0b19599f7824eccdcd65b680f645ee5778f0bb773ed91a9f7c027c0a1659663f1b4ae02c92ecbbf2a5be0df6b5b5c3ddbca4cb3b187b40adf90aa2748ef5097da69c8ca38f5628c6be9370ca63e5aeef4469a554d02e9551b280a20967f577a1c7cabfb548b8048d77181f11510b6fd064dc814f10a1010d564c540c3f0aaaf21e2f7af89c8f3e19411efef527b74b19c6be7e5e67df18a58c13a296373cc007f85088f0dc01db18d6a8787cfef33aa61a702c7a2c82ec15e0fb60a8d59735c05134ab63c2630bacf95233a1231c3b2f9236f752101fcc7c836f4a930d823dba55efe9aa6945f6795c4b0b4a8665313c0066bec928b4b11804aa25962beca36f97cfa9c542a7453e9235111cdf2b05ba36beecec8b85db3598b84f0455bd2013b35b3de1bcf33fd88efc181066389163ad3425e587b45dabdb05de461bc0b058d2cd68a09b895d8e2dba1576b8406608f10282c02e35dde1fc36c86351d335093ca29a8594cd2a4fff0c71472870f09321924997e1640f4be4d45823083bfe33383d7cf074bf73354f238d1fe74f96cb5fc0fdf276d2317973945b15645fd0b7553b99538defaea41925a04790d055939a8abe0fbf2e350acab956962faa74a71dc2e790c0103d37961524858ef1945d40e0c3ca254640b45b1400ffab5526a1abf0307ffe41476955986200bdcbd85eb74d9e4b5d166353aae8fa42d2419f3582e46370e3b01b1ee75e57584cb5629d8546d59a9c89df7a3db1c508a56f6ef213c9b359f3cbe34d8538dfba4f2b5b755c1d9443038f2ae1e4865eff43550e8d705f612b5f43e54a2329e1b748531ee9882914d2c92e18063d5240272a367cd0217e14e997913c875f2f4d8d1bbd4142d33c998c7e21e6f515c9edd0905e41abfee1054f4f0fffd23b8644592b8d28d7fe4d8d8386ad8db911f7670a1fe862760d909d595d4c9db7b2c9721d6ca64a2d1f4b0a91b7ff959e89d99256033cb971c6714092568d27ff51e5a0165e8e82dec2f8a601b98b14e86fde36585555aa49c3038228d05849c53dbd13ce512f973735241970e9a490e2970743c1c96946a566f7e7d90f123876426df1c59225549ca025d9d52236e0f964655578a8ce0bce211144c69161bdb8b407c0a1986f82d58bf58b32aaa173cfdcb6e033c9bd7c415c6be2fe796d402a708d62f7428112482baa55d5a0f163216448bff6568a7368b789ed94e649d03d18c30271023bec0bdefea04179bde56af9f0098f3b37641c026451f640c1128f4c6279642a8297aa2f95dd082c825a33ebcd8e22622f6b29462e94f378cf5d1e35f8d21639d024ba1bad4eaf48cf557a73a8737cc9f9b7771da5a16a22e7ea1e7f9ba257ed69106a2c368b38c1d3d6d2c9663e37cd51c141671821ff833f048995f39d63916d97f09be3c1ff5425de7fabd7bdc7bc05c4335184743c372219b5411b076ffc6a6d3ccbc30edb116cf71af0f70e1b491ccc653d0abbb9ccac5e09f48a50eede41a98f0a5373b29aa9f859efdefe6f096e0acd0d86c621b38a39d1f2d63e88f0e0c123255dbcd61f2aa3a6df50680380d3e1ad43d6c4bb2ec36c6853c8f489cc0839eb333b21e0592b66be81589d7fab122dd5a013463e7f87605092ab895a27af4f28de052e27eeefc5dce97e9cbeb211b0d46c1cb81fe927a5deb649edc71290d84ec1a7068742a00b13ebb5f27bd0f169570277c17b86ec75e2c72703fe37e7ce5708d688b16fe9b38f281c967cecb4218c73edb53ee1d90cf7d759d79d2813ac6ff7c1be48478259a88c37695e4e507f1b8f227a8087acbd6c552381e294f8ea4fdc92594a3b0b77ca9c3303aaa80ddba33e5d21f5b5f3ef6aa2133eea52661aced93d28565714ce48c68fd8c3c4b7954dc36d55716e88245574f0dd48c07deb601eff7916ab456e0ccfe9949e075c5efc9715377ae2b5c570843b0a131d0f8b7153dac182004f85685b1bc49d848da9dad908efa47e02d9d84936e94503d59c4287068b8286daaa59bd41bd89d1c970e36e8b0323dd5ccc17b5dc890a2253e5b71966d509cea4d1080c882c79286f6564a5cf343d2f28a5d7074d2aec74698765b68c33c670b54cf460ef2c22f9d95450fd35fd22c472db5961032e0d07ea4d360f2de35a188fb2aceb8ec0fc7d395513581b112036b758193e12f77c8e8b08f3e2aec967e059b98cd341f958bd2c7ab31ca6af5de1d837ba0e544a13a56ef5148d44e5158cc66e8fd04eaa644655889cb6cdf78072c8d3f31d5d4b59fb8ec2f4f02baaf827e48ad8adc8c15a92ec255d2eb912b8f2c3de5cb92166ed297f3c8d942c6529f631ae07cb678f92b6ec1d0e223ab6d5c60c5a6eac3f432faed0e3d8b858e9ac2d45338ca93b65e3fb81dc0dee61c64a209dc9d6c00fae5fc446f374b48281fa20cc3c03306ff9d4f73d51afe76ad29ce0a025be6714fd2a82b562aa25e1b3877665d196ec7412e00f186ba778c775bb509f1126f39f0687bfb48d9899eb76615d4b2e9bbd9329f16c4cbaae105516d3b35032e6281721b18657a198406915736a1117955316500dd17edb2645e0ed32e46e9823aef75d0f6436c1e590f18080923202521b34679c2976add9a497fead5803ce283b30f31cb164e271614aef329b96dee09ea1cdc2a48636b089475453bf571e739ee5bd7ea69e2047d954ed266984bd50a2db23cc043da5d9c4fb4ca873a4fd8b6bbe6f18e6ca04014b694c581135bba41aa8ccc42f2780506354692133e37a75c69f80f901be879ac3d3c502ac113c702bce5c9153aad0b139cb8aaa5f1b5bbbc79dd91db811dd96ef5640eb89c66a0fa34767750a9bd470452788dec3ee0940c59409a3298feb7832d5f38adecbc84dd3b6717c7e835230b98a23e90b2ce85ae29fa8624eb4812233c3a1d46c70f9ee25d9ce72d370107d750ba6b0d0980c0275116ee29f2b8fabad16d3e021e7b316eac Hey, password is required here."},{"title":"【vscode】如何配置断点调试","date":"2023-06-03T16:50:52.000Z","path":"posts/1RVNF84/","text":"包含python、cpp、ts/js等调试 概要 vscode debug 官方文档 附一张日常开发调试用的 vscode调试面板 截图 环境配置 vscode 虽然是一款轻量级编辑器（相比于Visual Studio、pycharm），但只要搭配正确的插件使用，依然可以轻松拥有 IDE 的断点debug功能。 launch.json vscode 的调试配置都写在 launch.json 文件中，它的位置是在 .vscode 目录下。如下是一个最简单的 python debug 配置： { \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"python\", \"request\": \"launch\", \"name\": \"Python: debug\", } ] } 常见字段的含义和配置方法如下： 字段 作用 必选 type 调试语言，需要安装对应的debug extension ✔ request 支持 launch 和 attach 两种模式 ✔ name 调试选项中展示的名称 ✔ program 调试的目标文件，如 main.py args 参数，格式为 [\"1\", \"2\"] env 环境变量 cwd 设置工作目录 port attach模式指定端口 console 使用哪种终端: internalConsole, integratedTerminal, externalTerminal preLaunchTask debug之前运行指定Task postDebugTask debug之后运行指定Task 一些常用的环境变量： ${file}：表示正在打开的文件 ${workspaceFolder}：表示 workspace 的根目录 python python一般选择调试当前文件，要注意工作目录是否正确。 { \"name\": \"Python: 调试当前文件\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"${file}\", } python2调试 新版的 python extension 往往不支持 python2 断点调试，需要回退到2021年左右的版本 cpp 官方文档: Debug C++ in VSCode C/C++ 的断点调试略微复杂，需要分为两个步骤： 使用 gcc/g++ 将源码编译为 可执行文件（默认为a.out） 使用 gdb 调试 可执行文件 1. 编译 首先借助 vscode tasks 将cpp源码编译为可执行文件，配置如下： 详细可以阅读 官方文档：VSCode Tasks { \"tasks\": [ { \"type\": \"cppbuild\", \"label\": \"C/C++: gcc build\", \"command\": \"/usr/bin/g++\", \"args\": [ \"-g\", \"${file}\", // 编译的cpp文件 \"-o\", \"${workspaceFolder}/a.out\" // 生成的可执行文件 ], \"options\": { \"cwd\": \"${workspaceFolder}\" }, \"problemMatcher\": [ \"$gcc\" ], } ], } 配置 tasks.json 完毕后，可以通过 ctrl+p 输入 Run Task 并选中 C/C++: gcc build，可以将当前cpp源码编译为指定的 a.out 可执行文件。 后面的调试需要用到这个task。 2. 调试 接下来配置 launch.json 以实现对上一步生成的 a.out 调试，配置如下： { \"name\": \"gcc/g++ debug\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/a.out\", // 需要调试的二进制文件 \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ], \"preLaunchTask\": \"C/C++: gcc build\", \"miDebuggerPath\": \"/usr/bin/gdb\" } 其中的 preLaunchTask 会在按下 f5 调试按钮后，先行运行指定的Task，即编译指定的cpp源码文件，然后调用 linux下的 /usr/bin/gdb 对可执行文件进行调试。 Node.js vscode 对于 js/ts 的开发生态支持度非常高（毕竟vscode插件都是基于typescript所开发的） { \"type\": \"node\", \"request\": \"launch\", \"name\": \"JS/TS debug\", \"skipFiles\": [ \"&lt;node_internals&gt;/**\" ], \"program\": \"${file}\" } others 其他语言用到时再补充"},{"title":"【cpp】pointers","date":"2023-06-03T14:58:55.000Z","path":"posts/pointer/","text":"cpp指针、地址、引用相关 概要 指针是C++学习中绕不过去的难题，需要对计算机内存有深入的理解。 hacking C++ Pointers Learning C++ Pointers for REAL Dummies todo: unique_ptr, shared_ptr ... When 任何一门技术（或者概念），都是服务于具体的需求，或者在特定的需求场景下，才会诞生。 C++的指针也不例外，它的出现是为了满足如下三个常见的场景： 持有（任意的）对象 在避免 copy 的情况下持有对象，这是 cpp 最重要的语言特性之一，通过指针可以实现对象的引用。 访问动态内存 这块暂时没理解，todo… 创建某些动态的数据结构 如 vector，链表，树等结构。 What Pointer to Object of type T，which stores a memory address. 指针永远指向一个具体的对象（任意类型T），也可以是空对象（nullptr）。 指针的本质是一个内存地址，这个地址在 x64 的机器上占 64 Bits，即 usigned int64。 指针的生命周期，和它所指向对象的生命周期，两者是相互独立的。 TODO: 通常说的 “指针” 是指c++默认指针，不包括如下（有空补充） std::unique_pointer std::shared_pointer std::weak_pointer Operators C++有三个操作符与指针相关，分别是 &amp;、*、-&gt;，需要区分其不同的使用场景和含义。 &amp;: Address &amp; 的含义是取地址，&amp;a 会返回对象a的地址。 *: Dereference * 的含义是解引用，该操作符后面会跟随一个地址，*p会返回地址p上的值。 -&gt;: Member Access -&gt; 的作用是访问类成员，准确说是访问一段地址上的某个成员属性，经常会和 . 使用混淆。 对于指针类型，使用 -&gt; 对于具体的对象，使用 . &amp; 和 * 的区别 作为不同的操作数有不同用法，区别如下： * &amp; 声明符 定义指针: int *p = nullptr 定义引用: int &amp;a = b 一元操作符 解引用: char a = *p 取地址: auto p = &amp;a 二元操作符 乘法运算: a * b 与运算: a &amp; b 不要在单行申明多个指针 int *a, b：容易产生歧义，建议多行申明 **: pointer to pointer ⭐ int v = 5; int* p = &amp;v; // 指向int int** pp = &amp;p // 指向int* nullptr (C++11) nullptr is a special pointer value NULL 完全等同于0，nullptr 本质是一个空指针对象，注意两者的区别！ 作为规范，nullptr 通常代表 无法访问的变量（value not available） nullptr 编码规范 指针初始化时，赋值为nullptr：int *p = nullptr 解引用时，检查该指针是否为nullptr：if (p != nullptr) { *p = 8; } const pointer Read-only and preventing pointer redirection. const 搭配指针会产生奇妙的化学反应，一共有如下四种情形： 牢记口诀：const 左边的永远是不可变的。 指向的对象 可修改? 指针自身 可修改? int * ✔ ✔ int const * ❌ ✔ int * const ✔ ❌ int const * const ❌ ❌ 下面看一段代码示例： int i = 5; int j = 8; int const* cp = &amp;i; *cp = 8; // ❌ COMPILER ERROR: pointed-to value is const cp = &amp;j; // ✔ int *const pc = &amp;i; *pc = 8; // ✔ pc = &amp;j; // ❌ COMPILER ERROR: pointer itself is const int const*const cpc = &amp;i; *cpc = 8; // ❌ COMPILER ERROR: pointed-to value is const cpc = &amp;j; // ❌ COMPILER ERROR: pointer itself is const this pointer this 仅在类内部使用，本质是一个指针。 this 返回类对象的地址 *this 访问类自身 this-&gt; 用来访问内部的成员 Memory 接下来从 内存分配 的视角，理解指针在计算机内的存储，以及指针运算符做了什么。 根据内存对齐，char 和 short 在内存中都占据 4 bytes 指针的本质，就是第一个byte的16位地址（因此 sizeof(p) = 2） 下图演示指针的++，会根据指向对象的内存大小而进行偏移 pointer += 2 或者 pointer -- 也是同样道理 pointer[3] 等价于 pointer += 3 后的取值 ⚠️ Warning 指针使用经常会出现如下几种错误： 1. dangling pointer dangling： pointer points to an invalid/inaccessible memory address 永远确保 指针指向的对象是合理的，否则出现 悬空指针（迷途指针）。 error 1：访问 未初始化的对象 int *p; // p not initialized! *p = 7; // ❌ error 2：访问 nullptr int *p = nullptr; *p = 7; // ❌ error 3：指向 无法访问的内存 p = 0x0000001，这是运行程序无法访问的内存段，运行时会报错。 2. pointer argument passing 当函数的参数定义为指针时，注意传入的参数，不能是一个非法的指针。 void swap_values (int* a, int* b) { int t = *a; *a = *b; *b = t; } int x = 3, y = 4; swap_values(&amp;x, &amp;y) // ✔ swap_values(&amp;x, 0); // ❌ UNDEFINED BEHAVIOR swap_values(&amp;x, nullptr); // ❌ UNDEFINED BEHAVIOR 3. hard code 通过合理的编码，区分 * 的频繁使用，尤其是乘法和指针混合使用的场景。 *p = *p * *p + (2 * *p + 1); // SO MANY STARS! 指针习题 当你以为入门了cpp指针，尝试解答下面的题目，常看常新： 已知如下的地址和取值，问如下输出 cout &lt;&lt; v; cout &lt;&lt; p; cout &lt;&lt; pp; cout &lt;&lt; &amp;v; cout &lt;&lt; &amp;p; cout &lt;&lt; &amp;pp; cout &lt;&lt; *v; cout &lt;&lt; *p; cout &lt;&lt; **pp; 解析如下： cout &lt;&lt; v：5 cout &lt;&lt; p：0x44 cout &lt;&lt; pp：0x48 cout &lt;&lt; &amp;v：0x40 (=p) cout &lt;&lt; &amp;p：0x44 (=pp) cout &lt;&lt; &amp;pp：0x48 cout &lt;&lt; *p：5 cout &lt;&lt; *pp：0x40 (=p) cout &lt;&lt; **pp：5"},{"title":"hackingcpp.com","date":"2023-05-31T17:20:56.000Z","path":"posts/1GTNS16/","text":"hackingcpp 网站的学习记录 背景 hackingcpp 是一个偶然发现的优秀C++学习网站，开这篇记录学习过程。 pointers constructors &amp; destructors Environment ISO Standard C++ C++语言标准，前后经历如下几个大的版本。大学教程所传授的C++基本是围绕 98 展开，工作中使用的 “现代C++特性” 基本也不出 11。 时间 特性 C++98 1998 the original standard C++11 2011 almost a new language C++14 2014 some improvements C++17 2017 new features &amp; library extensions C++20 2020 game-changing new features &amp; libraries Compiler 主要有 gcc, clang, MSVC 三种主流的C编译器，其跨平台、兼容性、代码生成和优化都有所差异。不过 99% 的开发场景不需要考虑到 这三种编译器 之间的差异性。 看到一些资料，都会说 clang 的性能和内存都要优于 gcc，这里不了解所以不作为何描述。 gcc/g++ GNU C++ 编译器，使用最为广泛。 clang/clang++ 又称 LLVM，一般作为 Mac 默认的编译器，因为其同时支持 C、C++、Objective-C。 关于 gcc和clang的对比，推荐阅读该材料：Clang vs GCC MSVC Microsoft Visual C++ 是由微软开发的C++编译器及相关环境，只使用于 Windows。简单来说，这是 windows C++ 开发的 唯一 最好选择。 Running g++ hello.cpp -o sayhello &amp;&amp; ./sayhello C++是一门编译型的静态语言，（区别于 Python）其源代码是无法直接运行的，而是需要通过前面说的编译器 转换成二进制的机器代码。因此一个 .cpp 文件的执行需要经过如下几个步骤： Compiler Flags g++ -std=c++20 -Wall -Wextra -Wpedantic -Wshadow input.cpp -o output 需要掌握基本的 C++编译选项，如 Warnings、编译标准、优化等级 等。 编译选项 作用 -std=c++20 使用 C++20 标准编译 -Wall 打开一系列的编译警告 -O0 优化选项，代表关闭所有优化 当你在 windows MSVC 开发时，借助 Visual Studio 可以在 “属性页” 查看和编辑所有的优化选项。它实际上是提供了一个可配置的GUI框。 Variables 最基本的变量申明方式有两种： type var = value: 通用写法 type var {value}: C++11 标准 undefined behavior 时刻牢记初始化变量，这样能避免很多类似Bug 注意 a++ 和 ++a 的区别，在合适的场景使用两者： a++：返回旧值 ++a：返回新值 Type Narrowing 低精度 向 高精度 转换：OK 高精度 向 低精度 转换：NARROWING，有信息丢失 Control flows if (statement; condition) {...} C++17 允许这样的写法: if ( int x = 5; x &gt; 0) { ... } switch 同理 using 使用 using 代替 typedef，用来作类型的赋值，例如： using real = double usning int_vector = std::vector&lt;int&gt;"},{"title":"【日志】2023年6月","date":"2023-05-31T17:12:32.000Z","path":"posts/2023/6/","text":"b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475debb79baf718116b8398ebb7a36965f5712db04a990a04196bf7d89b9188d2f59635faf1832a2edb2ba0713490beba8e4ed5067ac4d858ee3822a7c4c25db9cd26e8b3c9a201fd6e58b57ae9a946dba5702341378479a2f9ad7c362de651204e6903a148d2afe42a1daa51f8f2dde7150da1bfe7a8d526857f2d2d7c2b45616a64470f2a1d28bf84f4b7118b56cc4bcbf7a116f60ad9592a242cb84d0e1ea80751501c8b053ac67e1693b30dcf3f1b1fac55f7bbb19cd852c0e2d7232106b97c72036b8fb567232aff7f14a8bce872b88b9fbab3721cde8a712f2c3fdbe03e58e1626d120fb26fc7bfa02a78f3909f925f6eecf57f948fc4e1b7d42288084a70ba495c968c953c8b1540f6f6526fe08828f218329646eab6f542a3d60e414818ffb098b85eac9b3d546aad091dae9353fbb92ec533525406b899542172b579c88eed48c41bb033222a6e6066fef3edd521031781c2614972661c53471862b7e02ee9d6f49c6aae9b216f5415eee564cc4797b294fb4e90ef4e30635cf2c4a0c8c2ae8d244c99d40d165f6d28d702545a2e5933145b9d147662dc49b858f4544921559be00443177a5f58f8173346b540bbaef473b841def1f7e21fe432073161b79910e92d19caf7e4fc453e0bd0607aae88a258e2884c78376b8b6b48a9dcec77179344af35387dc809a788e5a9dae77b8dd127168ea41a4da318043df81d182c535223f641f2192d2713504ab0aa6d7afe42fa367b0624fa323659436ec2b41c5371e28bc43fa4bb06affe43be18c64471ba5a8618efe561b4ade694937d7421ab373ccce99ff1549476d1c51c9bc5e024c4fe5812f3c19a45ae6fe292a860dc39b33ae27a46e39ea57d3ef07397a74ce6468060265a09a42a66ae7ff72447d2ef85e443b7a8d825a81190c7bd694ea36950bdf3e38c5f4ac18cf4753dceb8efc5cbbef874f70a0a7d33665bb2b2a21e916d11ab81ae898ceea74cf26c4d26af99e6f908c4a025ab84a9be2063c055cd78051e25eb5d8537605bfc156bb083a9c1211e420691dd1b743edaa5424c21350c05af54cc553823a23ef6a021f2ad27225c3b1d09185213fd2b767f402353bf914f1f711d9fb5ae3f344ab313faefa0f1451514f42d2ca5396b3053466321f07caecb259ea88aa1f5ce69444a4665270121e69cbbc7ca5caa4cfcc2b6f6db513e2df9dc0a5edbc1a37f9fe98bf46c73ebb610b5cf98d73b698be72b29893a7edaae73364a5bda206806c4df3ebad341a52fddf8b3b2db832397c0909c5d29b3e07aaf92878025a48287dcecee7e103d702b00526027f1154f5cb7fbc5ac92ac0a7a7d739b789c857de424f13601335a6ccf46cb10151d0f166bfac681d79546dc2dd6a339fe4925256f0e915091a920ec45b57f98ac55be3370891bfd44655f96d82f1d2e2856b8b015d13ac498de3722c6f9a1f7eafaa46efb0c56ccefceb04116bd87242d938afc5b26253688b5bc87814ea696474e5684e5dd243162f74863732abd39e9bbedb5bd83e17d3bb6dc0a77ab4f919e22c3d69b9eb7d5cabf5e73109d31e12a7b33fcc83d3913dde06c8ab133623c83fec08a514e3e87ba2e21a0fd7560812631663195a7a0a8b08287ce70a797ca26495e9f9a1efc804bf457a5922c9434fb05accb18aa371bcc1d94c569a4750e507abfec2aaaa340875c80e8617a323f352c5a1dd5575f990986c564a1862e1dd764624e93d295ec8f9f5b395775130337a0ccb8a1f502dbceecc750e7be9e8425a7f94e48a5508c12bc5fb1e7eec2e2fbc38b39ee1b6ed3311940fb3efa793e2a5be7ae313a02e42991ed369763b658627fcc2e9dbb772bbc9fa7f8b4970195e48001aa96f85b0d96c84fb19af5826e2ba8502d5a381989e27e45ba6098fa48c3d16abe766af10cb936f03a602af5d078a8ffb0d707dbb5b82750ebd927b034b774ebf2ee98b73ed04a30e8adb8f1f4efca43304b7f9db3f0142911244f07d9f14da3c32193d305ffe75c944c51b4cb34e4a0aef09f5972d441cd39d4e46ff046741bd8919c443a5b9aed366f34ceb32a96970ef8a0dc67a429970f8373818abadccc45dc2cf458cf9f2c3a427fad215b2e5e3ad65c9040e06e69ff91319c282f9494d145d185492aa5122bbd1f704cfabe3a1d48a7658adb847978b8c3ca92ed21980f2eb635e75e88acd373797fd0b0ecb213773c477ff030a39ae193cf26fca68815ef85e9ed70c0c0274bd2307c5763772a7058c9f8eab8e53b653075ddb2a66aaf9120dcb49da98ed0044b9bd9609f70126f320012f36feb631ea6da5a0719015beba9d64daafc8c304cfaaca3a256cb1eba3a299220bfb4c0ae57ccd535a1ff6138abcfb5295c20c846f55b38c03abd2a098c7fd0a92e96c335f76bb2883d93ba5a058683a4922f676612b0c0a40bc2beb6091ac604dbab7afc5578b81026e58b2feefdc8be9c5e0c725f1041a0b8edd3243a4d6639539a918951272e5650a9fdb910a7ef99af47ce52942bae173b5a487d2c24aace0a226aad291deb4f860d5226330be29a104a1ccc2b10282fb4d96bad09d84d7876fb2036125b8f75c7c9850d2bf96b384a155f375058850d5d43515145dc905267ed0ce5d12f01c22f0e9d4489a2032d1ab0270f2a27764d67252f3cad6b3a7860535f2a0647768a1eaea8feef186094bf5122cdea5737226066c8cb4b66cd8c79a556b8c33595484367c8a2d14ee4790e249914c88039e7488dddc3e32e8d62f6c72e4a9a2f33e59a9d31703da01eda6d86cb5fb7bf691dacc156c7e68770ff400d89137c1e94d36620798ab3e908d149bda68e91f4a24cf060540af5c83cee2a6fc400d48093e2a810445716511334371cf510420748356849bb7385f1d77be3f48e8ce8853a4310e05e2535f7a795ec68d94ed002d6d9bb0dcb147f6f8edc817232318457f93ca9874506f9879f45ff6c2921805c40ac0cea1733b243f3657f4218b1fc1f23aae271642f0e9cacf7fdbf6fa148ae70029df55573181755bd82521cf660a06a7644b7eafa3d2f49a296ab9b09739bd037f3531bd63f7b087dd86bcb8228116f9737c039fd4eaa3f48a3fa64138275e686d3dce1dff26e841104721cebbe0aea05339d74f4f6eac7d05f30b0f13c63f5a81474877ad26ccaf021df9dedd31fee39a5dfb8d83ab4a71d3992aac6a9a672fc7aaef7d6fa0533af2d8c18289088953cddd7cb33773b27e298a03f973a4634b889ea93593741d322ae919f294802f55dd58128bb255571981b40d379266a17ecba5de2c6234430450b27eb8c783045de04fee1be911df000d7192abb51696a3ff87aabdad0975291bce747bafbb236cc7d6072ef17e53bd393536e3cc805adb83299a0ece476bbf81eca717fb02a4d5a4cc07770ce25299e9e8171c4a9e2b2c781d99754ec57aa3d2bf7f47e4e396ba744a81a83fe24d1fa64b10b20105ee1ec7da31e290d45e7e6442821f92261f20cbceb948d20cf419c9c942cff4efd5d74f461901803345869a458d3fdcf6895fe892d93cfcc4fec0523fbc90ca38b31087f1784df594e05e68fc714ead72d26106c21b0d53c272200e4aded4ea4f03738a6637500093d3fc450128a6c486ccb9481b796be3aa675fca145f78b8b11c76839e6b9c83058a4f83e19b0a146bdbaf93d13d72ee34ce41aeb85be02cc556f51ed5449271008fbaee9c1cccc067e80ad8a0b15181dd30f6f830dd7879ba078088235a77d4ab13ba386b39b7b0dd2c68bef5bd690b81d68dcbb83400b0a202f13cc67ffbb885fe983dba5f8e514ceea9b02656220c6abe7c54ffe60793ee70c25fb3345053df4a02ef5bc9163bf5296c93d5e820218f84cb0947e85c5243729bb2a3becad2157cc802fb383613c6553b44a7c8babba6b57c5cf046bcfeda6be863745cd64b2b5facb223afa6393eae3ab66876374af8bad712cbb13b92f2bf584a0c3588d4acc5702c01b943c085f89dce5b3536eb551ef55ebcc8e6ee2a584163a2b1f0491d1b54804a2445aa3c55d47d4498bbcfbb79f3f6e4857e5a649999a610a33ac9a7d73f157c064ac2a952eb700a24cc322b91606f40ec9593ac78bf14b2efdac83916983ab704ddd9787638ff9071a06ea5485965e518f5d63d6edfc8e992ad931caa78efad985daa01c2178b3dfa7eb3a3bc8807c3b2b870d5a653511f4eda5b3adbb7b25195ad5112f46b836dff6a0d7a644e45f4d3b71cd56de6306cbf8b6fb32f47939ddc2d2460e1c2cd614cea2ee424f2d8c45cb5ccb843233410b328c4470e8e7eb2a7770fbc7cd0a981bd1e117edb683711000f9d484000323b2b850434ae095818642363ae967a72ddf9daf7243c0a70d951e2f80755bd1276522870560f378bbf6d0a61d9bd78c19807cab702f7d17d11e252452aa4322620ce9303c9e0f878fe52f693c4ff16ee499abf75d4f2d019310f0cebfb7ef627d30728fce24de77f1e7af816c229328c9ba88c584546f33632a82444c79942159d9b922ec5889f44c889566f26050f4aaaffee02760c64e30ad186147c5896beef0f2ea29dd28fd1db0d5af4f832324f010bcaa68c6b2a12314d2211a2d66c8e3f38c345d7c31f513b928f2f142b96561a17c1774d6e3b87cf5cfdcc373af02ab3b7fb0651f3a716c79695c719e1c48ce760980e5394672567d365a5688ede4d835ba11677f19d137b83c0771ec5390aeef591d1ce7280c94fee712b4255d3cb1548fc547053af75ffb3b029da769d1e1ca944a9fd87ba7ab804d50f19b5166b1e54952c1f2709edc16da0ec9d6b392d6e59d0a26a5265879bd82b9f7950f5c0be09c4582e50e6f9e35418deb0608d06b62717bf7606a5d30e5cff885eacd7c1e4bfc35b07209b0db43db677e59a78cca14a60dbc46f6340016f3ebe6a31be8c3ef3d278268ba1bfd369999ac331b2cfdb85ea35adac17cca19db47944d53b69c5e39754b7313231f312c233f54947f066ca982517ea7c30875436f8f7aaea45388e85013541fef4559cd59a00d43d6633c2684b3694534e23f19fa2892af2018638da9c034ab324237f4eb0dfb455b7138e1ef5cd3d5534a29bbb60cbf38fe39a7c6898b21bacbafed2b02e42a2fb60446e5529e67ec8d91df10f2042596123eeed3c68a320efc532fc78647dc5d97a44541e84c1b2639ca7cce4f865bead88747ed033144a3ddcd56b2d0ad8f45d8a4b83de693390eac2e71eb383f34e6e2eb17f57a95a56ae4e0e7628d8f21bb206ac2cc0b167619041a7ff03986eceb058a26ddd6f7562fd012592fb40eb007b52ceda4916cc6f340cf8da0d49e5246a7c73d3c0c057a7229c5f4bbb0fd066ee9f080def0d6b35d992bb8fec3624c31d0195930153570ee6d03a2b1d3ec26577186b91cdac54c3010496a615d6d0402b17b74e8a3532d0c0d91102f35769a6fcd3a881ed9e8a68747b881e961c64b669e0ed18201cac2fb77a028d782c3b67cd3e025919dfe54263ef9091de7b093baf9aef9b0013079b890f2ffdb9f80ae5e23852557b09cf9f01ca9e8d492a87303b196d3bbcb1dfa8e6d3a10e3eb3c0ec2e56b8ead3e0a21d025f3b08ff00c904eae74734546b0d57222e787ad9f12c7dc3e5dda519ed4ff6d51782edc25cf8ad9f44306077c04842d59dc51ec3696d5f64dbf578e4166e49b6fbf21575e56939bff9ad16a0042b13650f4d139eb206862737d84ab9863fe575aa38afdb2100dad0ee175defa90ad1b6b2e193b9c1703762503729b135b3671f5b48f2177cbfb68d6911cb04b92f7295ebb6e4afdb2f2d22791a2ac1d5924619ef92104186ad1fa539d09dff76a18c779950dfdd8c02c33fa85a8b48e17238aaab32b089fc9a97fd90fce5dd8d96f9bc6b91bceeb7de331278059157c54382f308088dd5c04a1362338868f25622ecfcc9be9a1b1761fd39dec45069020368ac5b9d51475d95ab1380fad11f2c106375fa83e2f6462cec0ae0e1b72710e671d47720787a690b3b389c16aa3e3cbfde01ecd196e70c0d85375668461709e5905996a5615625977f7063b97afceba02081fe9ade164e6c31fcfecc1d8611aa4103915dc50ddcca4b9ee5f7ba5f40471a7ceddf6cbbaa246c372c19c5ca483ea3e647b3c6379de13a335cc8d94e98d4d9d8bc3b4148c4639c7ae45664c0969f2dc50a535cf4eb9f31831eef4a5221709fa37b014a3661686a9268a949826674e696e34b3cfca54faa2db6749e24654889e405225d25714e4edef4d115cab4f0592f3c3506dccefe59716aa15e30a824f3ec6ead2330b44119a4cb1094723bbdc7b3bc89e870e1247f486ec5b8e2f202a87822c1e220ac0982822b6bd5956964c824289de3e3089c2018068d39f04ec15b9e5d391642f1df15125d894caaf5565a6276632113a004e69d02f3ee4327e0d364e5e5b9d22a1693cbe2de6b65b44eb57128466f83030ef843fd9492a5c193cffcd2e56eb1f90d9a452cbeaadc84a68bfa607e118754d9621834599269d641ae4f3afa7b95970bff3fb96a46971c174f3f8d31fa11d5a598f8f5bf759fbcdb21913da8d18d9f5d76daf06a68f925b91523f1b4e4a9614082ade495c2ee1138b843d15a93280428a5ffed1bb7453ef44c984c839087270d649553b6a24781666b03cf04474701b72185bb5d77c22b988d2a3ac024420b5e4455402c1d2ccb4873a03df61b133ab94646ddd1191ebbc38dd5ab0ec2f5b9f74efc5e9566fe3ae797954fd5987e90dc9ba85a93e7000a5808b326a24980d9454f7425278da609ccf5d7d0614a477167df549136684622993edc33e9f271f1a047c0cc45c5df99ef4bc4c6d620f14f428c27e716fd7965dfcf4b88b1981b370ae90be0a09973c90044464c9bea860c138fd148a1de09922dfcf03b722b18dfb77cfb1cf41e649e10c85b5231c44bf155a582bf101f2fb7bdf64f9d4f39ba5f9e635b15439c3a38107a06caf1d147b50628b71764902b678248fb2aebf39e864fd0efd7216c558415717dffb53dc9a31d83e441a922ffd6af4300b45643c8a617de86d30c726056e606bbe5d9e9d519a23f8481dcaa4671b57002f1e52dbc254a2efeb0b6ea8412340dd71fa4b4dea9e0c4241c81c0ab31b6ed31be0c9af6acdf7b6da5d248421667bff9919dbc27bbfbbc036a54af45f98df1b0ae9777d060b52ac02ba099e7f09f6446ec155773acc4ffa46d01cff917f9e8feb867375e7399984e0a01a0b9e4813f06087d0dcac6b6f8a52df86d9f0d9ba25d36c04a81ad9fce92e0b3f45c4e6c3c4bdd5c179445c2b6ffb7281a5ac12d2e4b5d29bf6e86453d51bad1b70f29aedfa429ed4d2308561d2e656d86c4a2de0374b5b9814eb7a4c4a0535ab2452be2b056d1c47fea00a6c867566cfc70fcf2bab5dd6ffb69110da63f0d6f25ac1b273070cfcfbafa76722534fe1c6b3ced65dfb1598d36e022835b1af1c267fcb433e114ec479dcfaad9c355d2af13ac016303ade3e5afd0dc3b2c5cc563f15088f2e3195aaef5764fb04e6a368309865bd68da81e9b7c75522022108906ab30e3ee2ef020baae26b1908b27ca5be84f19da7238fac611ae62601b73cc98b446f3b6ef81da6846f458bb0e2880ed02c5cf8ee0272fb991823da0e70173a8b8022a9e15208ff351e0742fc2942d103a3e19ac8c7f1a331f8374a067f1f12c8f80d287261d17f180e293e602dabdd4b8989eeb3d163d4aaa3c6c1023e037eac38833fe84fbab74eae52bb181104e4cf1aa2781ccdee8512963a53d3ac9271b7c8ce90e02582687c6d6bf70d53f924b66d0c76ec18b0bba9cee1ae7662b151b30a6f88b59638623cb0645d563a1e347dabdfeb9a8138397c9275e5bd22eb87598a23c400b2cd777b6426ec7e9b49a69f23600674b085ce6477bec5327888bd02c6dbd9faffd3d16c3be69806a5543808a60f77d35511704ee24c084a029798582da1c0ba211234b9f583f0bc9826a06344fceae70cc588651293484a7151aa61f85f0cacc9e290bc3cbd2a8f4171810d24c714b08205a8d9d0560413a5514c4cb41bdcf96a855d7c62c86ec12fea595b66f21784e17c0a58f33b0e78311f47f705c01bfd8f31ddb1201b5087d3f75a7eb9cc234befa540f2a167c0f3b1b80d96ba8893921dc3840116c60ceeda7eaf41cd100e9a581b1e7d8f190e61258b6c5021d743015424451d9910dbf83427a5114f8e4ddbca52aed262db211d9f83b3be43d47b511a9c97345c30064a636dbaba55ea032ae421037cac3878cc55e925993e084954fbbbf3b0d4710b9e58fc225941760567f689b9679b6f9022e63a841f4831ff212c707ac21dffd609f9aa834043e46198f5757d69927a8fd6c54ced1304b30ca96897cc92b804f59e90143698995a859eb004c20dda308045b9d23846adab99ebc2a57f6a98d6e62aac81409162ea29f249092064e18ec85a14bb0b8404d4940074be18a59c31ccaf3995a7deeb1164ef545209764f587d868dcbc2f698f02ca87927d2725bfa7edffc4975464efc2931fcf3585e24b81d4fff11f5c56f9b58e321852cca0f3b63450eceeade9d479ed9f32ba9911b07d4b1d0243e2ba86171f8839a64fc3e7197a4846c6a8bccdc1192acae8020ae78245ba3ec485c00b07d0dfc58089fd390545c53cf68f25bf4901d18e389d1d3f37e480ed649c6d8949fd49c24e5c42959aa3178b92d5e82baac3f7335915dbd24069c5b0ede93efbd1fecf8bb09bc496bf5c2cacb0529f8aa89cbd51e3a24f28f3c66d52c19edd55192464ad20058d2c53748f41895ec5471e8d6ef738128f3a124f01c18e56b4348acfa5491ce9529f9349d76dd7408c8efad6773af8b70c75e46a95eb96533e429fdaa9a2133e600c0985751f0e989d5c077f391692e2bcc4573075580610797f4f4debcaafe4533fe14d01c5b89d867affb77941c8e60c4758290b667cfda79148f73ba59433a324c1e2b811409c3d5453801c66c28b8c586e00892a54028ad9719c33045dd5f4e2ffc05c1ec1df3dd1de10f58590df161ca67a84884cf479cfe8ab940c97bf5b726e1b142e7aab5283e0eff3a8b7a6a0a6d2a683eb4197caa3252414c9618d7c611776d36fd9827a96406521941d741c52102b2b09f38a58aa3141f2d56ee7b0f1cf4e113ab64d81e6a4f9121d92c71e7de5891f74cb1f830b6c83de9848604d612701f28e0e7a1cd748f2267fd85c320666ce2869fef960664d6031abb56db9e75b25218182321fbd53099994add83b4b0cd765e7dff7dbda098306896e3e29fdf4f28d6eb81785a3e4e496e43ec7a76939240b013d4fb8a7a85f76fb628ec0c5b438ef944dc6db2bb00a8b3a49d73477b25e9ae3589c64adb3c9ab0e03f44322f5cef41108e7638e2dc9c8b60d90113c63d3070314a666736ecdd048624f3281022cc1437cbf8b7472ee5416795a7ce36b22a740bbaf497a475d7e996789be01e976288da81646d0ef2239de917ff32b5bf7ddd5b8d709802a36c8da4e2c909bbcb57340f3a2a4e5b18cc99540df195814151d637b433e401e45a4250b4049630677d550b54ec8776bbd90d3131c5b57b88a8982435c7438fca8925432180adb5e34a120785914727b0157374eda12965ee9c976a113bf2b4c22e5ef86121d6456845bb5ec3dc5d080caced3f95a3176462eac0e9cc12d83c97c82dd4cf12b1ba71f2f41354e2e6005bc80ed29d450fca5e232e007971eaa1e34e368c96b9c6e12eb3eeb6be9e3a2189f41320f0b732c248c7d734b25af3916d6a3b2a6c028d25ad2949503302963bd4952e3c5e2a0de3ff4e973370fda8ca418bd7bdb299783149b698030b1d92050876ca28fa17d5e63b9eb660b0856ce172e3b8b5148353687a80b8e1072346a78a7b870b3e0c5ffea052e476b38fd69142ac9467829d174529b107bada4d3782c6706c6d564ee0a85fe92898dd49638b0c7fd0fc428b3a6040b9fb0400692b1c0639125dc6a413e0ddd8059013acbf574e14f25a57e522c16f9c1045149b25cd1a912d821d803abac53867953616db9a71283e05266fb56b8fe9c42671d66aa78e73c054238ed403e88aa4785ac6acc3c717bc184ab32ff7c899d31e16043256354fca543e47f10dc0a9e0cb6703d6006ebd32f8bb09e42f2c35298a86cecc4343c87eb41237e53b06fc310168a8f5fbf009179e6d94 Hey, password is required here."},{"title":"【selenium】自动秒杀脚本","date":"2023-05-29T16:06:36.000Z","path":"posts/3R1HHH2/","text":"概要 借助 Python + Selenium 实现 taobao 购物车自动秒杀 TODO 增加定时秒杀的功能 time.sleep的时间把控（短则逻辑错误，长则秒杀失败...） 实测，实战 环境 下面以 windows 环境为例，因为高度依赖 chrome ui 界面操作，linux 暂且按下不表 pip3 install selenium，直接下载最新的 selenium 库 chrome://version/，在 chrome 浏览器输入 以查看当前版本 mirrors/chromedriver/，下载对应版本的 chromedriver.exe 访问网页 只需要掌握 webdriver 的几个核心接口：Chrome、ChromeOptions、find_element options = webdriver.ChromeOptions() 创建一个 chrome 的配置项，实际用途是避开反爬虫的js检测。 具体代码如下，复制粘贴即可： options.add_experimental_option('excludeSwitches', ['enable-automation']) options.add_argument(\"--disable-blink-features=AutomationControlled\") driver = webdriver.Chrome(executable_path='./chromedriver.exe', options=options) 创建一个 chrome 的自动化示例，它会唤起一个谷歌浏览器，但是又不同于正常打开的 chrome.exe。 注意，需要传入对应版本的 chromedriver.exe 的路径。 driver.get('https://cart.taobao.com/cart.htm') 利用 chrome 访问指定的网页 driver.find_element('id', 'xxx') 根据html、css规则，查找指定的对象。 可选的参数有 id、xpath、name… 注意，旧版的方法是 find_element_by_id… 自动登录 前面访问的网页是 cart.taobao.com/cart.htm，如果浏览器没有对应的缓存，则会自动跳转到登录界面。 这时候需要借助 find_element 实现自动登录与跳转。 find_element Arg1 Arg2 用户名 name fm-login-id 密码 name fm-login-password 代码示例为： # 用户名 input = driver.find_element('name', 'fm-login-id') input.clear() # 清空 # time.sleep(0.2) # 防止过快 input.send_keys('*******') # 输入您的用户名 # 密码 input = driver.find_element('name', 'fm-login-password') input.clear() # 清空 # time.sleep(0.2) # 防止过快 input.send_keys('*******') # 输入您的密码 # 跳转 driver.find_element(\"xpath\", \"//*[@id='login-form']/div[4]/button\").click() 自动下单 某宝下单成功有三个步骤 1.购物车中 “勾选商品” 2.点击 “结算” 按钮 （选中商品后，按钮才是可点击态） 3.点击 “提交订单” 按钮 （选择收货地址） 步骤 Arg1 Arg2 1. 勾选商品 id J_SelectAll1 2. 点击结算 id J_Go 3. 提交订单 link text 提交订单 勾选商品 下面简化为购物车内的商品全选。 while 1: try: select_all = driver.find_element(\"id\", 'J_SelectAll1') if select_all: select_all.click() break except: print ('Retry: 全选商品') 点击结算 while 1: try: buy = driver.find_element(\"id\", 'J_Go') if buy: buy.click() break except: print ('Retry: 点击结算') 提交订单 while 1: try: a = driver.find_element(\"link text\", \"提交订单\") if a: a.click() break except: print ('Retry: 提交订单') 代码示例 # coding: utf-8 import time from selenium import webdriver username = '' password = '' TB_LOGIN_URL = 'https://cart.taobao.com/cart.htm' options = webdriver.ChromeOptions() options.add_experimental_option('excludeSwitches', ['enable-automation']) options.add_argument(\"--disable-blink-features=AutomationControlled\") # exe path for chromedriver.exe exe_path = r'E:\\chromedriver.exe' driver = webdriver.Chrome(executable_path=exe_path, options=options) driver.get(TB_LOGIN_URL) input = driver.find_element('name', 'fm-login-id') input.clear() driver.implicitly_wait(0.5) print (\"Username:\", username) input.send_keys(username) input = driver.find_element('name', 'fm-login-password') input.clear() driver.implicitly_wait(0.5) print (\"password:\", password) input.send_keys(password) driver.find_element(\"xpath\", \"//*[@id='login-form']/div[4]/button\").click() time.sleep(0.2) # while 1: # try: # select_all = driver.find_element(\"id\", 'J_SelectAll1') # if select_all: # select_all.click() # break # except: # print ('Retry: 全选商品') # time.sleep(0.2) # while 1: # try: # buy = driver.find_element(\"id\", 'J_Go') # if buy: # buy.click() # break # except: # print ('Retry: 点击结算') # time.sleep(0.2) # while 1: # try: # a = driver.find_element(\"link text\", \"提交订单\") # if a: # a.click() # break # except: # print ('Retry: 提交订单') assert(0)"},{"title":"【GAMES101】Anti-Aliasing","date":"2023-05-28T13:13:49.000Z","path":"posts/3P0T9MZ/","text":"信号处理、抗锯齿 导读 LearnOpenGL: Anti Aliasing GAMES101: Rasterization and Anti Aliasing 知乎：如何理解傅里叶变换公式？ 知乎：如何理解图像经傅里叶变换后所得频谱图意义？ 信号处理 了解反走样与抗锯齿之前，需要学习一些基础的信号处理相关知识，其中最重要的就是 时域、频域 及两者的相互转化关系。 1. 时域 (Time-domain) 时域 是描述一个数学函数（或物理信号）对于时间的关系（函数） 电脑上的音频文件（例如mp3、wmv…）就是一个时域信号的典型例子，其本质是音频（波形图）在时间上的分布，如下所示： 横轴：时间 t 纵轴：声音的振幅 声音信号是由 高音、中音、低音 三个部分组成，如果我们想加强低音部分，仅仅通过时域信号是没法修改的。因为高中低音在时域中是混合在一起的，没法通过逆变换将他们抽离开来。 因此引申出 频域 的概念 ↓ 2. 频域 (Frequence-domain) 频域 是描述频率分布的关系 频域的理解有点困难，需要结合时域一起看（如下图）。时域上的信号可以看做不同频率的信号的叠加，因此频域就是展示这些不同频率信号的分布。 横轴：频率 纵轴：该频率的振幅（&gt;0） 空域 (Spatial-domain) 又称为空间域、图像空间（image space），可以理解为像素在屏幕空间（x，y）的分布。 时域与频域 时域与频域 表示的是同一个信息，只不过呈现的方式不同。 下面以标准正弦函数 $sin(x)$ 为例，展现时域和频域的不同表示： 函数 示意图 时域 $y = sin(t)$ 频域 $f = \\frac{1}{2π}$ 傅里叶变换（Fourier Transform） 关于傅里叶变换 这部分浅尝辄止，理解基本概念和用法即可 任何函数都可以表示为 $sin$、 $cos$ 函数的组合 将时域转化到频域（傅里叶变换） 将频域转化到时域（逆变换） 什么是走样（Aliasing）? 如下概括了三种常见的走样的导致的 Artifacts： Artifacts 原因 示例 Jaggies 空域采样频率不足 Moiré Patterns 空域采样频率不足 Wagon wheel effect 时域采样频率不足 demo 为什么产生走样? 从信号处理角度理解 Signals are changing too fast (high frequency), but sampled too slowly. —— GAMES101 将图像信息看做空域信号，根据傅里叶变换得出，可以表示为任何正弦信号的叠加，因此光栅化的过程可以理解为：以某个频率对原始信号进行采样的过程。 由于造物主的超然存在，自然界的所有采样频率可以当做无穷的（时间是连续的、世界是无穷多个像素点…），而妄图用有限的频率去描述、去采样现实世界，即用有穷描述无穷，必然会带来信号和信息的损失。 以下图为例，采样频率固定时，当原始信号的频率越低，采样产生的误差也就越小；当原始信号的频率越高，采样产生的误差越大。 上面3种常见的 采样导致的Artifacts，都是因为采样的频率较低（低于原图像的变化频率）。 原始图像的信号不是随着时间而变换（时域变换），而是随着空间中x、y的值而变化（空域变换）。信号的变化频率高是指：像素之间的RGB颜色是否发生骤变（如白色255变成黑色0）。 从这个角度理解走样的原因： 为什么锯齿都在图形的边缘? 因为内部的信号变化慢，低频采样没什么影响；而边缘的信号变换频率会骤增。 如何进行反走样（Anti-Aliasing）？ Anti-Aliasing，又称为反走样、抗锯齿，提高采样频率是最直接的反走样方案，如增加分辨率。 下面介绍一些常见的AA理论。 Blurring 模糊化是反走样的一个基本操作，即在光栅化之前对原始图像做一个模糊的操作。 High-Pass Filter 高通滤波，即高频的信号可以通过，过滤掉低频的信号 Low-Pass Filter 低通滤波，即低频的信号可以通过，过滤掉高频的信号 Convolution 前面的滤波技术，本质不是丢弃某些特定频率的信号，而是把它们变成一个新的信号。即$m*n$的信号通过滤波之后，得到的仍然是 $m*n$ 的信号。它的本质就是 将信号在时域上卷积，即求平均值。 滤波器：一个固定大小的信号，如 $1*3$，且每个信号都对应一个数值（系数），如下所示： 对于每个像素，根据滑动窗口计算 经滤波器后 的取值。 示例，对应为 $5$ 的像素，滤波后的结果是 $3*1/4 + 5*1/2 + 3*1/4 = 4$ 下图是一个 1/9 的滤波器，它起到了图像模糊化的作用，其本质也是一个低通滤波器（模糊的本质，是去掉高频变换的边缘区域） 理解困难 如何理解：时域（空域）的乘积，本质是频域上的卷积 MSAA MSAA（Multi-Sampling AA） 的本质是在更高倍分辨率下进行采样。 下图是一个 4 x MSAA 采样的示例，即对于每个像素，采样其中四个子像素，根据是否在三角形内的比例，得出其颜色的贡献值。 MSAA的额外开销 n-MSAA，意味着 N 倍的采样量 可以尽可能的复用之前的采样值 FXAA FXAA（Fast-Approximat AA） 是在屏幕空间的快速近似抗锯齿，它是在后处理阶段进行的。 在有锯齿的图像上，找到其边界，并替换为无边界的图像，与采样无关。 TAA TAA（Tempol AA） 将采样从单帧扩展到多帧，尽可能地复用之前帧的结果。需要额外处理动态物体的情况。 写在最后 MSAA，FXAA，TAA等抗锯齿方案需要更深入的学习和实践，这里只是浅尝辄止"},{"title":"【GAMES101】Rasterization","date":"2023-05-26T15:13:46.000Z","path":"posts/M5TXVE/","text":"光栅化与硬件基础 前集提要 GAMEASA101-Transformation描述了基础的线性变化，以及MVP变换的过程 本文讨论的是在MVP变换后，如何将一个正交的 $(0, 1)^{3}$ 坐标映射到屏幕坐标上 显示设备 CRT 阴极射线管 阴极射线管（英语：Cathode ray tube，缩写 CRT），是较早的显示仪器，曾广泛的应用于示波器、电视机和显示器上。 其原理是利用阴极电子枪发射电子，在阳极高压的作用下，射向荧光屏，使荧光屏上的荧光粉发光。 同时电子束能够在偏转磁场的作用下，作上下左右的移动来达到扫描显示的目的。（高中物理的磁场计算题…） 早期的CRT仅能显示光线的强弱，因此是黑白画面；直到1941年，CRT才支持红绿蓝三种颜色的电子束，这告别着彩色电视机技术的问世。 因为采用电子束的技术，CRT显示器具有亮度高、伤眼睛的特点。因此早期小朋友看彩电时，经常被家长督促离得远一些。 同时 CRT显示器 的分辨率做不高、屏幕做不到，导致2000年后逐渐被LCD、LED取代。 知乎：为什么 CRT 画质这么好也被淘汰，液晶反而发展的很好？ 隔行扫描技术 通常的显示器在成像时，会从上到下地扫描每帧图像。这个过程消耗的时间很长、占用带宽也很高。 因此CRT显示器采用一种 “隔行扫描” 的技术，即每次只传输和显示一半的图像，一场只包含奇数行或者偶数行。由于人眼具有视觉暂留效应，所以仍然会看到完整的一帧画面。 视觉暂留效应 光对视网膜所产生的视觉，在光消失后，仍然会保留一段时间（约1/16秒） 例如日常使用的日光灯每秒大约熄灭100次，但不会感觉到灯光的闪动 LCD &amp; LED LCD LED 功耗 ❌ 功耗高10倍 寿命 ✔ 寿命更长 视角 ❌ 视角较小 ✔ 视角宽达160° LCD液晶显示器 和 LED发光二极管 涉及较多的物理和光学专业知识，这里不详细展开，就对比两者的优劣和差异。 E Ink 电子墨水屏 电子墨水技术是由 E Ink Corporation 公司提出，常被用于制作电子显示器，例如大名鼎鼎的 Amazon Kindle 它的表面由大量包含正负电子的微胶囊组成，当设置电场为正时，白粒子向微胶囊的顶部移动，所以呈现白色；反之电场为负时，呈现黑色。 电子墨水的一大缺点时，即重置屏幕时具有延迟，因为要通过改变电场使粒子发生移动，例如Kindle阅读翻页时有明显等待。 光栅化 Pixels 首先如何从计算机的角度定义一个屏幕? 颜色：（R，G，B） 坐标：由分辨率决定的二维数组 左下角：$(0,0)$，右上角: $(width-1, height-1)$ 像素实际坐标：$(x+0.5, y+0.5)$ 要解决的实际问题： 将$[-1, 1]^{2}$ 映射到 $[0, width] \\times [0, height]$ 先经线性变化（先从屏幕左下角平移到屏幕中间，再经过缩放操作）： Triangles 为什么用 三角形 表示几何物体? 顶点数最多的平面几何（再少一个点就是线段了） 任何多边形都可以由三角形组成（三生万物） 利于做差值、判断内外… 一些常见的三维模型格式，例如obj、fbx，其内部都是用三角形（或者Poly）表示模型的。 可以看这篇文章：Model and Mesh 问题建模 光栅化实际要解决的问题如下: 对于每个三角形，逐个像素判断是否在三角形内，是则着色，不是则跳过。 判断三角形内 通过三次叉乘实现 参考这篇文章：【GAMES101】Transformation for tri in tris: # 所有三角形 for (x, y) in pixels: # 所有像素 output[tri, x, y] = inside(tri, x, y) 观察如上算法，是一个 $O(N^{3})$ 的遍历算法，是否有优化的方法呢？ 加速：AABB 利用三角形的包围盒来加速。 实际绘制中，不可能每个三角形都填充满整个屏幕，因此可以通过AABB剔除掉在包围盒外的像素点。 加速：Incremental Triangle Traversal 可以理解为更精细的AABB。 从三角形每排的最左侧到最右侧执行光栅化，基本不会多遍历一个像素点。"},{"title":"【CSAPP】Information Storage","date":"2023-05-22T14:13:19.000Z","path":"posts/24H1CZ3/","text":"原码、反码、补码、Integer、Float… 材料 CSAPP chapter 2 CSAPP 重点解读 IC S解读 0.30000000000000004.com Bit Hacks（位运算的奇技淫巧） 导读 CSAPP花费较多篇幅介绍计算机的二进制系统，以及“1字节=8比特”的设计。既然人类已经习惯使用十进制计数法，为什么计算机要改用二进制呢？ 二进制 对应电路中的高低电平，容易区分 二进制 利于物理存储，磁极、凹凸、光照等 推荐阅读如下前置知识： 计算机架构入门：CPU、存储器 Virtual Memory 大端小端 先看什么是大端、什么是小端，这些统称为字节序（Endianess） 假设 int a = 0x01234567，地址为 0x100，因为int类型占4个字节，所以写入 0x100 0x101 0x102 0x103 这四个字节的内存地址： 大端（Big-Endian） 将 数据的低字节 放在 内存的高位，符合人类的阅读习惯，又称为 network byte order 小端（Little-Endian） 将 数据的低字节 放在 内存的低位，与人类的阅读习惯相反，又称为 host byte order 大小端利弊 为什么没有厂商一统江湖，选择 “利于阅读” 的大端呢？ 原因是两种存储方式各有利弊，谁也无法说服谁… 知乎: 大小端字节序存在的意义，为什么不用一个标准 因为 “符号位” 存储在第一个字节（后文讲到），此时大端能快速判读大小、正负 执行加法运算时，高位往往需要添加额外的数据，此时小端效率更高，大端要额外移动 常见字节序 大端：IBM，JPEG … 小端：Intel，BMP … 观察字节序 // Demo_2:观察字节序的一个简单例子 typedef unsigned char *pointer; void show_bytes(pointer start, size_t len){ size_t i; for (i = 0; i &lt; len; i++) printf(\"%p\\t0x%.2x\\n\",start+i, start[i]); printf(\"\\n\"); } int main(){ int a = 0x01234567; show_bytes((pointer) &amp;a, sizeof(int)); } // 输出结果(Linux x86-64) Demo$ gcc -o chp2 chp2.c ; ./chp2 0x7ffc837a0b3c 0x67 0x7ffc837a0b3d 0x45 0x7ffc837a0b3e 0x23 0x7ffc837a0b3f 0x01 记录一个未区分大小端导致的Bug 如下定义了一个 struct 类型，大小是 32位，占 4字节。 假设 idx 存储的数据是 0x1234 当在shader中解析 idx 的取值时，因为存储在贴图的通道中，所以只能逐字节decode。 由于默认 0x12 在 低位，所以解码为 L + H &lt;&lt; 8，但是对于小端存储的机器（如Intel CPU），这个取值就是错的，因为实际算出来是 0x34 + 0x12 &lt;&lt; 8 struct DataDesc { uint16_t idx; uint8_t count1; uint8_t count2; } 修复方法 利用 htons 将小端统一转化为大端存储，htons(3) - Linux man page 注意头文件，Linux下是 #include &lt;arpa/inet.h&gt;，windows下是 #include &lt;winsock.h&gt; 原码 最高位表示符号位，其他位存放数值 数据的存储只能是 0 和 1 两种状态，如果想区分一个数值的正负，先人提出用 “最高位” 的 0 和 1 来表示： 1：负数 0：正数 思考一下为什么用1表示负数，而不是0呢？ 假设用 3 bits 表示一个整数，则 1个符号位 加上 2个数值位，可以表示的范围是 -3 ~ +3，如下表： 二进制 符号位 真值 000 + +0 001 + +1 010 + +2 011 + +3 100 - -0 101 - -1 110 - -2 111 - -3 原码的缺陷 原码中存在两个0，即正零和负零，意味着判断是否要0要两个时钟运算… 原码作运算时，如果符号位不同，会导致计算结果错误（需要硬件额外处理）： 001 + 101 = 110，表示 1 + (-1) = -2 反码 正数的反码是原码，负数的反码是符号位除外、其他按位取反 反码的出现是为了解决原码的弊端，即 “相反数之和不为0”。这里干脆从结果反推，为了使和为0，不如用一个整数的“按位取反” 来表示负数。 例如，001表示+1，则-1的反码是110，此时相加为 001 + 110 = 111 = 0 原码 反码 真值 000 000 +0 001 001 +1 010 010 +2 011 011 +3 100 111 -0 101 110 -1 110 101 -2 111 100 -3 反码的缺陷 仍然有两个0 表示有点反人类，不够直观 补码 正数和0的补码是原码，负数的补码是反码 +1 如何根据补码求真值? 牢记口诀，正数照求，负数将数值部分按位取反 +1 如下表，3 bit 补码的真值范围是 -4 ~ 3，比原码、反码多出一个值，是因为去掉了重复的正负零。 补码（正数略） 真值 - - 100 -4 101 -3 110 -2 111 -1 因为补码是现代计算机硬件应用最广泛的编码方式，顺便提一下补码的运算规则： 加法 不论正负数，直接对补码相加即可： 3 + (-2) = 011 + 110 = 001 = 1 减法 补码的减法，实际就是加一个负数，道理和加法是相同的： 3 - 2 = 3 + (-2) ... 浮点数 C++中计算浮点数加法时，经常会出现 0.1 + 0.2 = 0.30000000000000004 的类似现象，导致浮点数判相等很困难，这也是源于 IEEE 754 的存储方式。 首先，不论是0.1 还是0.2，在十进制这是一个有限的小数，但是在计算机二进制的表示中，他们是无限不循环的，这就造成了运算的精度误差。 小数的二进制 如何理解小数二进制 核心是科学计数法，十进制的 $0.525 = 5 * 10^{-1} + 2 * 10^{-2} + 5 * 10^{-3}$ 对应二进制为：$0.525 = 1 * 2^{-1} + 1 * 2^{-2}$ 口诀是：乘2取整，顺序排列 有限不循环的十进制，在二进制下 可能无限不循环，而数据存储的bits是有限的，这就是浮点数误差的根本原因。 以小数 0.2 转成二进制为例，按照上面的算法得出如下的计算过程： 依次乘2 取整数 二进制 0.2 * 2 = 0.4 0 0.0 0.4 * 2 = 0.8 0 0.00 0.8 * 2 = 1.6 1 0.001 0.6 * 2 = 1.2 1 0.0011 0.2 * 2 = 0.4 0 0.00110 …循环 0.00110011… IEEE 754 通用的浮点数标准是 IEEE 754，在1985年提出并沿用至今。 下面以浮点数 178.125 为例，描述二进制的计算过程： 整数部分：178，二进制为 10110010 小数部分：0.125，二进制为 001 合起来二进制为 10110010.001 转换成二进制的科学计数法，为 1.0110010001 * 2 ^ 7，7用二进制表示为111 接着对照下面的公式，代入三个部分的取值： 符号位 S = 0 尾数 M = 0110010001 指数 E = 111，结合偏移值得到 10000110 因此 178.125 的单精度浮点数是 0x43322000 32位浮点数 转换公式 $V = (-1)^{S} \\times M \\times R^{E}$ S：符号位，0为正、1为负 M：尾数（float），对于 $2.18 \\times 10^{-2}$ 中的 2.18 E：指数（int），对于 $2.18 \\times 10^{-2}$ 中的 -2 R：基数，十进制为10，二进制位2"},{"title":"【Python】UnitTest单元测试","date":"2023-05-21T15:16:02.000Z","path":"posts/A20MTJ/","text":"概要 工作中经常遇到一些阻碍开发流程的提交，希望通过 UnitTest 避免类似的commit todo: Python unittest，关于自动化测试的方法，测试理论等 plan: 预期这周内完成，伴随一些工作的脚本开发"},{"title":"PDCA 闭环思维","date":"2023-05-20T07:18:56.000Z","path":"posts/120QJ0A/","text":"提要 阅读材料来源：知乎：有什么行为习惯昭示着你是个编程**？ 本文都从工作的角度讨论，不涉及个人生活作息 为什么讲闭环 闭环思维，决定你是否能把一件事做到完美，决定你是否能成为一个靠谱的人。 通俗理解闭环思维，就是无论做什么事情，都要有始有终，能够形成一个完整的闭环。 五个核心 通俗地理解，闭环思维有五个核心，须牢记于心： 凡事有计划 约定必落实 问题早只会 及时报进程 事后须反馈 PDCA循环 ⭐ 闭环思维的理论依据是“PDCA循环”，由美国管理专家 休哈特博士 提出，将每件事分为四个阶段： Plan：计划 Do：落地 Check：检讨/检查 Action Improve：改善/改进 如下图所示，一个需求可能需要多个回合的改善才能完成，即代表多个“PDCA循环”： 这个模型完全可以应用于程序的日常开发，过去自己往往只关注 Do 的部分，而忽略了其他三个环节。 后面的改进： 需求提出初期，明确 Plan 环节 推动落地期间，逐步记录 Do 的过程 需求开发完毕，主动 Check 完成度、潜在的bug、回归范围 提出待改善项，即 Improve 针对目前的工作流程，如下是一个 PDCA 的示例： PDCA 示例 Plan ∘ 3月5日完成功能A ∘ 3月7日完成功能B Do ∘ 3月5日：完成A，同时优化了xxx ∘ 3月8日：完成B，同时修复了xxx Check ∘ A的性能存在问题 ∘ B的code review有两处comments Improve ∘ 计划4月通过xxx优化方案解决A的性能问题 ∘ code review问题已修复 ∘ B完成延期一天，原因是xxx 5W2H分析法 What：先阐述清楚要做的事情是什么，确保合作职能可以理解 Why：为什么要做这件事？ Who：参与协作的职能 When：交付时间 Where How：准备怎么做 How much：做到什么程度"},{"title":"【GAMES101】Transformation","date":"2023-05-12T17:55:34.000Z","path":"posts/30P8RVY/","text":"向量与线代、空间变换、投影 点乘 $\\vec {a} \\cdot \\vec {b} = |\\vec {a}| |\\vec {b}| cos \\theta$ 几何意义：$\\vec {a}$ 在 $\\vec {b}$ 方向上的投影与 $\\vec {b}$ 的乘积 图形学应用 衡量两个向量是否接近：值越大越相近 判定两个向量是否同向：正值同向、0为垂直、负值反向 叉乘 几何意义：$\\vec {a}$ 和 $\\vec {b}$ 围成平行四边形的面积 $\\vec {a} \\times \\vec {b}$ 垂直于两个向量所在的平面 方向：右手螺旋定理 四个手指顺着 $\\vec {a}$ 指向 $\\vec {b}$ 的方向，则大拇指表示 $\\vec {a} \\times \\vec {b}$ 的方向 图形学应用 判定左右：$\\vec {a} \\times \\vec {b}$ 叉乘为正，说明 $\\vec {a}$ 在 $\\vec {b}$ 的右侧 判定内外： 需要三次左右判定，如可以通过 $\\vec {AP} \\times \\vec {AB}$ 得到 $P$ 在 $\\vec {AB}$ 的左侧 正交左手（右手）系 可以通过 “叉乘” 定义一个正交坐标系 $|\\vec {x}| = |\\vec {y}| = |\\vec {z}| = 1$ $\\vec {x} \\cdot \\vec {y} = \\vec {x} \\cdot \\vec {z} = \\vec {y} \\cdot \\vec {z} = 0$ $\\vec {y} = \\vec {z} \\times \\vec {x}$ （左手系 or 右手系） 矩阵 $(M \\times N)$: 表示 $M$ 行 $N$ 列的矩阵 $(M \\times N) (N \\times P) = (M \\times P)$ 线性变换 缩放 以 $x$,$y$ 分别缩放 $a$,$b$ 为例： $x’ = ax$ $y’ = by$ $ \\left[\\begin{matrix} x’\\\\y’ \\end{matrix}\\right] = \\left[\\begin{matrix} a &amp; 0\\\\0 &amp; b \\end{matrix}\\right] \\left[\\begin{matrix} x\\\\y \\end{matrix}\\right] $ 反射 以绕y轴反射为例： $x’ = -x$ $y’ = y$ $ \\left[\\begin{matrix} x’\\\\y’ \\end{matrix}\\right] = \\left[\\begin{matrix} -1 &amp; 0\\\\0 &amp; 1 \\end{matrix}\\right] \\left[\\begin{matrix} x\\\\y \\end{matrix}\\right] $ 旋转 以绕坐标原点旋转 $\\theta$ 角为例： $ \\left[\\begin{matrix} x’\\\\y’ \\end{matrix}\\right] = \\left[\\begin{matrix} cos\\theta &amp; -sin\\theta\\\\sin\\theta &amp; cos\\theta \\end{matrix}\\right] \\left[\\begin{matrix} x\\\\y \\end{matrix}\\right] $ 平移 尝试了一波，发现没法用一个 $2\\times2$ 的矩阵表示二维的平移变换？ （后续为了解决此问题，引入了第三维度 $w$） 齐次坐标系 (Homogeneous coord.) 为什么引入 齐次坐标系? 考虑用 $M_{2 \\times 2}$ 叠加平移变换 $x' = x + p$ $y' = y + q$ 二维变换下，$x' = M_{2 \\times 2} \\quad x$ 无法作常量的平移变换 只能写成 ： $\\left[\\begin{matrix}x'\\\\y'\\end{matrix}\\right] =\\left[\\begin{matrix}a &amp; b\\\\c &amp; d\\end{matrix}\\right]\\left[\\begin{matrix}x\\\\y\\end{matrix}\\right] +\\left[\\begin{matrix}p\\\\q\\end{matrix}\\right]$ 平移变换 $ \\left[\\begin{matrix} x’\\\\ y’\\\\ w’ \\end{matrix}\\right] = \\left[\\begin{matrix} 1 &amp; 0 &amp; p\\\\ 0 &amp; 1 &amp; q\\\\ 0 &amp; 0 &amp; 1 \\end{matrix}\\right] \\left[\\begin{matrix} x\\\\ y\\\\ 1 \\end{matrix}\\right] = \\left[\\begin{matrix} x+p\\\\ y+q\\\\ 1 \\end{matrix}\\right] $ $w$ 维度 区分 点 和 向量 点：$(x, y, 1)^{T}$ 向量：$(x, y, 0)^{T}$ 区分 二维运算 向量 +/- 向量：$w$ 维度为0，得到向量 点 - 点：$w$ 维度为0，得到向量 点 + 向量：$w$ 维度为1，得到点 点 + 点：$w$ 维度为0，得到点 $(x, y, w)^{T}$几何意义 $w = 0$：表示向量 $w ≠ 0$：表示点 $(\\frac{x}{w}, \\frac{y}{w}, 1)$ 总结 此时可以表示 Scale、Rotation、Translation 三种线性变换： Matrix Scale $\\left[\\begin{matrix}s_{x} &amp; 0 &amp; 0\\\\0 &amp; s_{y} &amp; 0\\\\0 &amp; 0 &amp; 1\\end{matrix}\\right]$ Rotation $\\left[\\begin{matrix}cos\\theta &amp; -sin\\theta &amp; 0\\\\sin\\theta &amp; cos\\theta &amp; 0\\\\0 &amp; 0 &amp; 1\\end{matrix}\\right]$ Translation $\\left[\\begin{matrix}1 &amp; 0 &amp; t_{x}\\\\0 &amp; 1 &amp; t_{y}\\\\0 &amp; 0 &amp; 1\\end{matrix}\\right]$ 另外，可以用 $M^{-1}$ 表示逆变换（反向操作，逆函数） 欧拉角 知乎: 如何通俗地解释欧拉角？ Wikipedia: Eular angles 欧拉角使用三个角度来描述刚体在 $xyz$ 坐标系中的旋转，这三个角度分别表示绕 “三个轴” 旋转的角度，不同顺序会产生不同的结果 也可以用 roll, pitch, yaw 来表示欧拉角，如图所示 旋转所绕的轴有两种划分 世界坐标系（静止）：$xyz$ 局部坐标系（动态）：$XYZ$ TODO 万向节死锁这部分没完全弄懂 万向节死锁 MVP变换 首先前面提到过 $(x, y, z, w)^{T}$ 表示三维的信息 $w = 0$: 表示向量 $(x, y, z)$ $w ≠ 0$：表示点 $(\\frac{x}{w}, \\frac{y}{w}, \\frac{z}{w})$ 三维空间的点，最终展现到二维屏幕上，需要经过一些列的空间变换，可以概括为 “MVP” MVP 变换可以想象为一个拍照的过程： Model 变换 “将人群和景色放到一个合适的位置” 将所有模型移动到统一的世界坐标下（world space） 局部坐标 -&gt; 世界坐标 View 变换 “找一个合适的相机角度” 如何描述相机的信息? 坐标：$\\vec e = (x_{e}, y_{e}, z_{e})$ 相机朝向 Look-at：$g$ 相机上方向 Up：$t$ 通过一个 View矩阵 $M_{view}$ 将所有模型转换到 view空间，只需要 平移变换 + 旋转变换： 即 $M_{view} = R_{view} T_{view}$ 先平移 $T_{view}$ 平移变换是为了将相机移到中心原点，因此矩阵很好得到： $ \\left[\\begin{matrix} x’\\\\y’\\\\z’\\\\w’ \\end{matrix}\\right] = \\left[\\begin{matrix} 1 &amp; 0 &amp; 0 &amp; -x_{e}\\\\0 &amp; 1 &amp; 0 &amp; -y_{e}\\\\0 &amp; 0 &amp; 1 &amp; -z_{e}\\\\0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{matrix}\\right] \\left[\\begin{matrix} x\\\\y\\\\z\\\\w \\end{matrix}\\right] = \\left[\\begin{matrix} x - x_{e}w\\\\y - y_{e}w\\\\z - z_{e}w\\\\w \\end{matrix}\\right] = \\left[\\begin{matrix} x - x_{e}\\\\y - y_{e}\\\\z - z_{e}\\\\1 \\end{matrix}\\right] $ 后旋转 $R_{view}$ 拆解开来，需要作如下三个轴的旋转： $g$ 旋转到 $- \\vec Z$ $t$ 旋转到 $\\vec Y$ $g \\times t$ 旋转到 $\\vec X$ 将 “局部轴旋转到$XYZ$轴” 很困难，因此可以求逆变换：“将$XYZ$轴旋转到局部轴” 将 $\\vec X (1, 0, 0)$ 变换到 $(x_{g \\times t}, y_{g \\times t}, z_{g \\times t})$ 将 $\\vec Y (0, 1, 0)$ 变换到 $(x_{t}, y_{t}, z_{t})$ 将 $\\vec Z (0, 0, 1)$ 变换到 $(x_{-g}, y_{-g}, z_{-g})$ 将这三个特殊值代入，可以解出 $R_{view}^{-1}$ 矩阵为： $ R_{view}^{-1}= \\left[\\begin{matrix} x_{g \\times t} &amp; x_{t} &amp; x_{-g} &amp; 0\\\\ y_{g \\times t} &amp; y_{t} &amp; y_{-g} &amp; 0\\\\ z_{g \\times t} &amp; z_{t} &amp; z_{-g} &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{matrix}\\right] $ 根据转置矩阵得到 $R_{view}$： $ R_{view}= \\left[\\begin{matrix} x_{g \\times t} &amp; y_{g \\times t} &amp; z_{g \\times t} &amp; 0\\\\ x_{t} &amp; y_{t} &amp; z_{t} &amp; 0\\\\ x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{matrix}\\right] $ 逆向思维 “求逆” 是线性代数解决问题的常见思路 Projection 变换 “按下快门！拍照” 投影变换是最重要的部分，因为它塑造了 “立体感”，它分为两种： Perspective Projection: 近大远小，符合人眼 Orthographic Projection：远近一致 正交投影 疑问? 正交投影 为什么把任何立方体投影到一个(-1, 1)的正方体? 透视投影 TODO 这部分有点复杂，教程中利用 “相似三角形” 和 “特殊值法” 求出了矩阵，有空补一下"},{"title":"【C99】setjmp.h","date":"2023-05-10T03:40:54.000Z","path":"posts/3CKYSDZ/","text":"学习setjmpC标准库, 实现轻量级协程 写在最前面 setjmp 是C99的一个标准库, 其实现了 non-local jumps, 本次学习路线是: 阅读手册、文档 ✔: man(3), wikipedia 阅读代码示例 ✔: wikipedia: Example usage coding: M2: 协程库 (libco) 可选: 阅读 setjmp.h 的源码 man setjmp what 准确说是 man 3 setjmp, 3 的含义是 Linux Programmer's Manual. 先看其基本的定义: setjmp, sigsetjmp, longjmp, siglongjmp - performing a nonlocal goto 也就是说, setjmp的作用是执行一个 nonlocal goto; 为什么说 nonlocal? 举个例子, 看下面的 C 代码, main函数 中尝试借助goto跳转到 func函数内部, 编译会报错 因为 goto 只能实现函数堆栈内部的跳转，即 local jump! void func() { outer: printf(\"into func...\"); } int main() { inner: // ... goto outer; // error: label \"outer\" used but not defined goto inner; // ok // ... } how 继续阅读 Description 部分: The setjmp() function dynamically establishes the target to which control will later be transferred, and longjmp() performs the transfer of execution 直译过来就是说，setjmp() 扮演的是定义 label 作用，longjmp 扮演的是goto跳转作用 继续看这两个函数体的定义: int setjmp(jmp_buf env); void longjmp(jmp_buf env, int val); setjmp 接收一个 jmp_buf env 的参数, 看看手册是如何解释 env 的: The setjmp() function saves various information about the calling environment (typically, the stack pointer, the instruction pointer, possibly the values of other registers and the signal mask) in the buffer env for later use by longjmp() 写的很直白了， env 保存了调用处的局部环境，例如 栈指针、pc指针… （这块如果看不懂，需要恶补汇编知识，建议阅读：汇编（三）：基础AT&amp;T汇编） setjmp 负责写入env，longjmp 会读取env并恢复调用时的环境，这样就达到了 nonlocal goto 的作用 ok基本看明白了，但是还有一个 int val 的参数，作用是什么？ 这里我觉得 man手册 没说清楚，自己总结下吧 如果是 setjmp 的直接调用：返回 0 如果是 longjmp 的跳转调用：返回 一个非0 的 参数 setjmp的两次返回值 这里很抽象，需要结合代码理解 StackOverflow: What is the use of setjmp() returning 0? 注意点 阅读 man手册 的 Caveats 部分，有两点注意事项: 如果 调用 setjmp 的函数 在 longjmp 调用之前返回，那么行为不确定. 如果 在多线程 中使用 nonlocal env，那么行为不确定. 这两点在实际开发中暂时不会遇到，先列在这里吧 code example talk is cheap, show me the code：这部分开始讨论代码 下面的代码展示了 setjmp / longjmp 的基本使用: 核心：记住 setjmp 处会被call两次 第一次是用户自己调用的 第二次是 longjmp call 回来的 // https://en.wikipedia.org/wiki/Setjmp.h #include &lt;stdio.h&gt; #include &lt;setjmp.h&gt; jmp_buf env; int longjmp_ret = 8; // paramater pass to longjmp void second() { printf(\"second 1\\n\"); // √ longjmp(env, longjmp_ret); printf(\"second 2\\n\"); // × } void first() { printf(\"first 1\\n\"); // √ second(); printf(\"first 2\\n\"); // × } int main() { int val = setjmp(env); if (!val) { printf(\"setjmp return: %d\\n\", val); first(); // when setjmp executed, setjmp returns 0 } else { // when longjmp returns, setjmp returns 1 printf(\"setjmp return: %d\\n\", val); printf(\"main :: else\\n\"); } return 0; } // setjmp return: 0 // first 1 // second 1 // setjmp return: 8 // main :: else setjmp 实现协程 实验要求 看到这里觉得自己很牛逼了，觉得都会了，是骡子是马，上实验遛遛： 这里 NJU 操作系统的实验，利用 setjmp 实现一个轻量级的协程: M2: 协程库 (libco) 首先你要理解什么是 协程 （Python Generator 就是一种协程） 其次实现实验里给出的 api: co_start: 创建一个新的协程，并返回一个指向struct co的指针（类似于 pthread_create） co_wait(co): 表示当前协程需要等待，直到co协程的返回才能继续执行（类似于 pthread_join） co_yield(): 将当前协程“切换”出去，随机选择下一个线程执行 // co.h struct co* co_start(const char *name, void (*func)(void *), void *arg); void co_yield(); void co_wait(struct co *co); 如下是一个使用的例子： #include &lt;stdio.h&gt; #include \"co.h\" int count = 1; // 协程之间共享 void entry(void *arg) { for (int i = 0; i &lt; 5; i++) { printf(\"%s[%d] \", (const char *)arg, count++); co_yield(); } } int main() { struct co *co1 = co_start(\"co1\", entry, \"a\"); struct co *co2 = co_start(\"co2\", entry, \"b\"); co_wait(co1); co_wait(co2); printf(\"Done\\n\"); } TODO 为什么这里 count++ 不会有线程安全问题? 其中co1和co2这两个协程共享 count 变量，因此输出是： b[1] a[2] b[3] b[4] a[5] b[6] b[7] a[8] a[9] a[10] Done 一个小小的调试技巧: 当你不希望某些调试用的输出，出现在正式环境，可以借助宏重写 printf: （其中 __VA_ARGS__ 用来表示不定数量的参数） #ifdef DEBUG_MODE #define debug(...) printf(__VA_ARGS__) #else #define debug(...) #endif 编译时增加 -DDEBUG_MODE 的编译选项，即可打开 DEBUG_MODE 宏，即实现了输出控制 VSCode 调试 C++: 因为一直 VSCode Remote-SSH 在服务器上写代码，不适合用 VS、Clion 等现代IDE调试，gdb这种又贼难用，所以配了一下VSCode调试的环境，看 这篇博客； 限制还是有的：1. 只适合小型的 c/c++ 项目，2. 依赖太多三方库等文件时，launch.json不太好写 实现 首先将协程的状态分为几类: enum co_status { CO_NEW = 1, // 新创建 CO_RUNNING = 2, // 已经执行 CO_WAITING = 3, // 在 co_wait 上等待 CO_DEAD = 4, // 已经结束 }; 状态的划分很重要，因为 co_yield 会选取下一个幸运儿进行调度执行，选择标准就是协程的状态； 理想情况下，选取一个 CO_WAITING 状态的协程继续执行，正在执行的协程状态是 CO_RUNNING，且同时有且只能有一个 CO_RUNNING… 那么选取下一个协程时，有两种情形要处理： 有 CO_WAITING：直接切换 无 CO_WAITING：怎么办? 继续执行？显然违背了 yield 的原理 正确做法是切回到 main（可以将 main 理解为一个主协程）"},{"title":"【OS】多线程之互斥算法","date":"2023-05-07T16:58:38.000Z","path":"posts/14ZY2JK/","text":"导读 Mutex (Mutal Exclusion): 即相互排斥, 即多个线程不能执行同一段代码（指令） PPT: 理解并发程序执行 | B站: 理解并发程序执行 (Peterson算法、模型检验与软件自动化工具) 之前的多线程用C++实现, 这篇改用Python实现, 因为重点是算法思想而非语言 Todo 互斥算法的正确性证明: 画状态机, 暴力穷举, Model checking Todo C++, Python: 多线程, 锁等相关 问题背景 StackOverflow: Why using multiple threading to get the sum is incorrect? 先看一个经典的 Python多线程求和, 经典面试题目, 经典并发Bug: import threading N = 1000000 x = 0 def add(): global x for _ in range(N): x += 1 t1 = threading.Thread(target=add) t2 = threading.Thread(target=add) t1.start(); t2.start() t1.join(); t2.join() print(x) 什么N取值较小（如1000）, 结果却是正确的? todo 输出结果分布在 &lt; 200w 之间, 通过前面的学习已经知道, x ++ 这个操作是 非线程安全的 查看 Python汇编得到 foo 函数的汇编, 看到 x ++ 被拆分为 3条汇编指令 LOAD_GLOBAL: 读取x取值 INPLACE_ADD: 执行加1 STORE_GLOBAL: 写入x取值 12 LOAD_GLOBAL 1 (x) 14 LOAD_CONST 2 (1) 16 INPLACE_ADD 18 STORE_GLOBAL 1 (x) 20 JUMP_ABSOLUTE 8 -&gt; 22 LOAD_CONST 0 (None) 24 RETURN_VALUE 下面证明为什么被拆成3条cpu指令, 就会导致非线程安全: 如下表, 线程A和B分别有三条指令, 汇合在一起就是实现 x ++ 的功能 No. Thread-A Thread-B 作用 1 load(A) load(B) 读 x 2 add(A) add(B) x ++ 3 store(A) store(B) 写 x 首先明确执行的顺序规则, 同一线程内的指令一定是有序的, 但不同线程间的指令无法确保顺序 一种正确的情形 ✔: load(A) -&gt; add(A) -&gt; store(A) -&gt; load(B) -&gt; add(B) -&gt; store(B) 输入 x=0, 输出 x=2, 这是最理想的情况 一种错误的情形 ❌: load(A) -&gt; add(A) -&gt; load(B) -&gt; add(B) -&gt; store(A) -&gt; store(B) 输入 x=0, 输出 x=1, 显然出错了 问题在于线程A、B依次load的时候, x取值为0, 相当于都对0做了 +1 的操作, 所以结果少加了一次 如何避免这样的问题? 只要保证 x ++ 同时只有一个线程在执行, 这样的代码段称为 Critical Section 我们只需要确保 Critical Section 部分的代码, 不被多个线程同时执行, 即为它加上一把互斥锁 Critical Section Critical Section is the part of a program which tries to access shared resources. 即尝试访问共享内存（或资源）的程序段, 一次失败的尝试 现在实现一个多线程互斥算法: 脑袋里最直观的想法是, 维护一个全局变量（即锁）, 每当有线程访问 Critical Section 时, 就上锁, 以达到防止别的线程同时访问的目的, 退出访问后不要忘记解锁; lock = '' x = 0 def add(): global x, lock for _ in range(N): while lock == '🔒': pass lock = '🔒' # add lock x += 1 # critical section lock = '' # release lock 这段代码很简单很low, 但是你秉承着大道至简的信念, 略有自信的运行了它… Wrong Answer! … 继续看出错的原因在哪里? 第6行 while lock == '🔒' 和 第8行 lock = '🔒', 这里分别代表 load/store 操作, 其实已经违背了线程安全的原理 举个粒子, 线程A/B依次进入while的判断, 都以为现在是无锁的状态, 而实际的加锁都没走到… 互斥问题的类比 当你无法理解一个抽象问题, 尝试将其类比为熟悉或者具体 的概念 💡《直击本质》书摘 先假设一些前提： 每个人是独立的线程 大脑内的思想是局部的（private） 自然界的信息是所有线程共享的 （public, shared memory） 通过 抢厕所 解释 非线程安全: 早上10:05（带薪蹲坑的好时候）, A 和 B 同时看到 仅剩的一个厕所（Load） 他们激动难耐, 都同时冲了过去… （try to store） 此时产生两个人抢夺一个厕所的情况… （2 threads -&gt; critical section） 解决思路一: 叫号 由一个全局的公告牌决定 轮到谁上, 但是如果叫到A, 但是A不在或者临时有事了… 缺点: 违背 “空闲必进” 的原则 解决思路二: 协商 让A/B自己讨论放谁进去, 如果碰到两位仇家, 是不是谁也不让最后僵持不下? 缺点: 陷入死锁 通过这些 牵强 的类比, 大概对互斥算法设计的好坏、标准有了一些认识： 互斥算法的三条标准 Mutex: 互斥的正确性 Progress: 有线程进入critical section Bounded Waiting: 有限等待, 无死锁 LockOne算法 顾名思义, 引入一个bit的 turn, 即允许执行的线程id 假设 turn==0, 此时线程1想要执行, 只能干等… 违背了 “空闲必进” 的原则 LockTwo算法 顾名思义, 引入 2 bits的 flag, 标记第n个线程是否要执行（因为是双线程互斥，2个bit就足够） 假线程0、1同时标记了自身的flag, 它们就可以分别卡在等待中, 即死锁. 违背了 “有限等待” 的原则 WARNING 纠错: 下图的 flag[i]=true 应该在 while (flag[i]) 判断的上方 Peterson算法 既然 1bit的turn 与 2bit的flag都无法完美解决互斥, Peterson算法干脆说：“我全都要！” 它的优点是, 保证了双线程互斥正确性的同时， 既确保了 LockOne 的 空闲必进 原则 又防止了 LockTwo 的 陷入死锁 问题 尝试阅读如下材料, 以对Peterson算法又更直观的理解: Wikipedia: Peterson’s algorithm A Proof of Peterson’s Algorithm 写在最后 本文讨论的, 全部基于 双线程互斥, 不适用于 n &gt;= 3 的情形; 正确的互斥算法, 其内部的状态转移一定存在环 直观理解就是, 一个线程进入 critical section 后, 另一个线程不断的轮询等待 (陷入while)"},{"title":"【硬件】GPU架构","date":"2023-05-05T18:06:42.000Z","path":"posts/3Z9MX8B/","text":"GPU 与 显卡 的关系 GPU 是 显卡最核心的部件, 除了GPU, 显卡还有散热器、通讯元件等电子设备 目前的 GPU 厂家主要有两个： NVIDIA: 英伟达, 主要是GTX, RTX系列, 俗称N卡 AMD: 主要是Radeon系列, 俗称A卡 摩尔定律 Moore’s Law 是由 Intel 的创始人摩尔提出: CPU的性能每隔 18个月 就会提升一倍（同时成本也会相应地降低一倍） 但是 GPU 的性能发展历史打破了这一定律, 下图是 CPU/GPU 的性能提升对比图: CPU 和 GPU 的主要区别 参考阅读: GPU vs CPU: What Are The Key Differences? CPU 和 GPU 的设计区别 深入GPU硬件架构及运行机制 一个通俗的比喻: CPU是几个大学教授, 单打独斗能力强 GPU是成千个小学生, 擅长大规模并发计算 CPU GPU Short for Central Processing Unit Graphics Processing Unit Cores 6大核 (i5 10600kf) 4864小核 (RTX 3060Ti) Memory Performance, Capacity Bandwidth Arch. SIMD SIMT Application Operation System Graphcis, AI GPU 架构发展历史 0. Tesla 架构 Tesla 虽然是 GPU最简单的架构, 但是写这文章时, 大概只理解了不到两成（很多概念太抽象了）, 希望伴随职业生涯的学习能不断加深对硬件的理解 Tesla 是第一个面市的 GPU 架构, 但是经典永不过时 这篇知乎写的很好, 作者把GPU比作一个外包公司: 【GPU】Tesla架构（一）：初识GPU架构 通过几个核心器件来分析: Host interface GPU 所有工作的包工头, 负责派发任务 Input assembler 将 CPU 传递的顶点数据组装后, 传给 Vertex work distribution Vertex、Pixel、Compute work distribution 分别负责 顶点、片元、shader的三大任务 TPC （Texture Processing Clusters） 包含一个纹理单元 和 两个负责计算的SM（Streaming Multiprocessor） 理解核心的 TPC ⭐（架构如下图） 将 GPU 看作一家大的外包企业, 那么 TPC 就是其一个个小的子公司, 它的核心部门如下: SMC （SM Controller） SMC 是负责将总部的各种任务拆分打包成 Warp, 并交给下面的小部门（SM）处理。可以看做该部门的负责人, 既要对接外界资源, 又要管理内部的任务分配, 需要实现负载均衡 Texture Unit todo SM（Streaming Multiprocessor） SM 是真正负责干活的小部门, 内部划分如下: I cache: 指令cache, 将 SMC 传递来的指令缓存下来再分批执行 C cache: 常量cache与共享内存 MT Issue: 多线程主管, 负责内部进程的调度, 是GPU高并行的关键 SP（Streaming Processor）:负责执行基本的浮点、整型计算 SFU（Special Function Unit）: 执行更复杂的计算, 如超越函数、插值Lerp等. 接下来尝试理解GPU的高度并行 ⭐ 当 SMC 拿到 多条二进制GPU指令后, 会以 32个线程为单位 分发给手下的 SM, 它们就称为一个 Warp, 这就是 **SIMT（Single-Instruction, MultipleThread）**架构 真正的并行单位是 Warp. 理想情况下, 每个线程执行相同的指令（想象所有 pixel走的分支L逻辑一致）, 这时候几乎是 100% 并行的（取决于指令数 和 core数量） 但是实际 shader 运算中, 会出现 if 等分支语句, 导致不同线程的执行分支也不同, 如图展示了一个 Warp 中不同线程进入不同分支情况: 1. Fermi 架构 Fermi架构 相对于 Tesla架构 的优化主要在如下几点: 晶体管硬件的发展, 可以堆更对的 SM 和运算单元 固定管线的一些列操作（视口、裁减、光栅化、剔除等）逐步在硬件上细化 推荐阅读 知乎: 【GPU】Fermi架构（二）: 三角形的异世界之旅, 它以三角形的视角描述了 cpu -&gt; gpu -&gt; 各种着色器经历的计算过程 2. Kepler 架构 Kepler架构的核心是低功耗, 因为物理器件温度过高时, 会导致降频促使性能下降（尤其是移动端） 其他架构 Maxwell, Pascal, Turing这三个架构先不介绍了, 超出理解能力了… 移动端架构 区别于桌面端的架构, 移动端GPU受限于电池的短板, 需要避免高带宽导致的高电耗 当前主流的移动端 GPU架构（如PowerVR, Adreno, Mali…）, 都是基于块的渲染 （Tile Based Rendering, TBR）; 作为对比, 桌面端的GPU架构都是 （Immediate Mode Renderers, IMR） 什么是一个 Tile? 假设一个屏幕分辨率是 2k（2560 x 1440）, 它将每 16x16 划分为一个 Tile, 每个Tile内有自己的缓存, 绘制时也是逐 Tile绘制 写在最后 开这篇文章是为了普及一些GPU硬件的知识, 因为学习软件汇编时必然也会接触 CPU硬件架构. 但是GPU硬件很多概念根本看不懂, 很抽象, 权当科普吧… 过一段时间再回来头, 希望会好点"},{"title":"【引擎】渲染系统","date":"2023-05-04T17:02:53.000Z","path":"posts/36E2965/","text":"b3dc07a81f6459d120ce338ccca55046d81ca386354419b6b77d6b55182b8ed33140f2401a25c01a514a43101d339e09a1b2e92127965f9324a394488623f13567a42631fecb5042eb8052206cc0ab8768157a03a512d041b85e73b5ad01100c1fa62983540997e855ef137f75a3520d73b6e836afc1e03b244e0efd0b1f6659d84c1feb5f526eef882a052f38bc4d4f54c3b21f7ac35d22a6c7416b81d076e287d11d62c3b5acbc6ae09295d3d7b1272ba11d47a0078530d26b6167f5812214e6a06520ea990373c5131a13525c023f10aa6883f875e56eab9ee5b3a126d6bd289ba09c5d42273d5591d7e3600e926b52797fcd4634ea7e293dbeeecbc31e56415dbedc1c3e3509782ae8969064bf59e44532faef8d76fe16ff8a0cbf01fef3f37b65d5c97e98bb26cfc366a93c4b7d3320906ec8fcb19ecc09dab2ac6085682a4fd0f9b505cdac92091626de5a1e3f9f85ab4ab30ee4d8e8708c785c323ac26a29373c25ea6d70c2a175e5b34fc4100eabe70c375a9e735e462459fe8b5f28e3ecad7aa96d7b86db29953efac9973b0f8aa580bde40c9dbb368e2a691100aff1d77a886ce30df1e4d8de59456f31893bdf557bb11235120d8b98742991d76fb4862b973603cdbb4796bfa472f462456582b6488b101043431424649698a0f3c0c7b6661acd69df55a6a7028da6f6341f418f581b12bc922a4db384e85a031bdc3c716291dcd159730e3d708c102a5785b58186e6aafecf69b09ad841d82a17a53cc71c89dc518535bb8b25623715d35d9b3dc55777ec39572bc6aa1f7f243442686982b172cf41870dd48af9ce70d706731d8d9cf2884c75cb38e3a31cfb3f33906f66e57ccc29f7326116c69782b13bf6d04a91c7524f2081610f88588101c4c3c96020d0fa69749e328a8a5ac71d1c676a843a7ac125a3b561b17955fa3c2b774010aeec09c6f7e991381ef507d028a263c5f6809c70ed8f63f969fe439d1788b676f0168f0638fe2f7f9135b81b878eb1bf73cb732112c5dc64284bfdf7e764db90ce741a2a24cc5e41a9bbd5b9dd4a72f997e492b642f8f489d6f607dfd5be929710cf457350d7068d72584b9075bf45f3149f2a23e2e548360189bc8cb1965e7127041b5ec244a4286c1ac59878609b0facf2bb043eeb9814af93c75f8301a82d4ccd53930a62a888019fff22648897dc0df05c31580ed10f4e6c6a3993f462afc77165ce5afab45472b218d3347a5f20be6991cdcfba1a92a4c51eb3bd8f2cb5a1b44de5c5852baf98fbbe0bbeb7dbe5385a0ac07fd66a70a0d4070fc0f2a5bb25f431a9dc978bbebdcf9fd679ca147d788939bd6d009ddac8ddde3b5cb6b8f9cb0ab7996ceec5557b0a5e0e1f795f8ca4f10a626b2dbe9eece30b029b463de848b1906b5521811692fb082b5769737763807ee0325a7e7747cf46d711323621a47133107ed8d2f47421494d82d0886eaf307199f0f90cfb0a1ada6a09b8fde3a4dbc801e3cb492a129dde62ea2da11600831caedac3f4cd34aa499be6372068718da25e56cfe3df8452a599eeead7dee0464707548eebf99bb889efc716d1df4570c75e6091c3ce6184f0d86d6daa9ca3acc3a68f117003db2608193a5d934e3a69b9dbb0fb25eae3035d46227e2d99a1065dfe791ee901ccf13a3877a090a88e3a2852bb2f6748caa9d61d431759cd56ca123cef02ce434192873d9e24d36b90a926ffe58d699dc40d56d657a4ed210e12a9ef2c111a2b2a280ec20ba73a0e67fec2638962b3a2b5979f0baa47e700aaa171e064bc3ec8429d8ba52a8fded50c0acf30bda1a254249a6b44e86824c183d5df35b7197d3c1661fe6b0bd0ba7f9619b6bff75134d1b7db818ee222ed7e0be33ecf0d922e3e126ff9e15e660f1b0f279bc5736d6e4c630f64ed0ea65e38ad400081a50478cbfe606954db147ccae56a8b8da4ae954598953573137cdc779531faf9720ee47cc72e79a30c015b567da9ddd1b3b6f5047e5f2ffca7df6415867d9c6a87bdcceeb973263c6e382e88909817745b80cc2fd7972ecb826f953da3451fb67e34c1dbcc02df32852b7b85fa11de6dea20f6cb88d687bc5637585025bd23190698758239c8a81d210ad3965e49599e885575e72f6a5bf9f21f9d5cb466199144a00c057f2331d888ae729dc46e6163f4e5060b9e6a7fe6895680be21050b87f502e07014fe0349cad9130be7f6e4519def1a50571e6545d9fdf742f9344ae0715d700252c7da089b2cfd5f49b9010021c26ab1db6d7de4274128ad4d82a58ad776828e720e300f29056c8090b6f8e8fb6c20a103264f7020673648457d1666f16a7ac8690f4f36238e9ac81dc0c27625170dd8e25edeb82ebe881771e564c09cf2a603d50980975affc43e2db38398f05d034a3d83755447445833c61cf97701c5ef95770271a7b5ac8e6f9f4cb66b7548c9a583489f62641f0e3f3913b2003f62bcfe39eabb36d8987946a84ddf81f11460f28a8f5a9ed9733c635bf5c1b4b50a19727583cd826fc2e1aa15f7d5d194c8c83e6ee05a1a33c90f482cfc64712f29b6ac37b288969a25ffa414854c2b55fea1927eb6e5ffff6a8809a65cffa905f5060e3c70e79b8171b5ebb27cd96ab3585f37969256978caca4924fe49d13a39d3842e857e67f3df0f1ffbfaf88596bfb5197f607ee985f8cc96de53d60638281d150c39e6b0b557605c012f36cf9807943252326481bed87124b332502b189c01d99e19d358d9345e812a02dc571ca78bb904ef80f06800510bb529add3cd74638772daa7e747e7299519b6a29ba265d90b03b66c880de0f03415e34c9237b57d299808601a389801e81402f56286a8486c1e8176692f8f06e5b536d75fe14276bf2322ca3671cb9d8446f667ef615ed039cca31a4a76d690aae7fb357260d4b23ea1dd47e32b3f12bb529184c67b67e46c99dbdd742325afb3c0b123837e4a7f1c4ef67d68d5fd523ff3c1c5da4c102a7fea874b7431bde61a94d6fbd9ade44604b09a857f709fb0303e0096a110c0d2a5924971c1eeca291f692d2ea1b0ee1908acb76d32c639e7a926d30dd0dd4d36715a59ce078958f695f3ae356d2c8f9469abaa78380b588c7ddb9fb5dd02f86acbff35faeee0ce736110d5d034150c4afb47562a693b2abbc0d20ecb83e90e1c256c2ae2efdd44c777cc598c8c937eaf32e6773db326ac0afbc31e08b1105760e9ac24181841f900ea1468c9f2ea11f51d0e24d337dae2966a0ca697f9c43f2ab0e696f43c807f89922a70fb6684a2926dd729918eee6f27334507194e8dab192ed99fcd1feccc54816b9f4abca4cdd0ee8b31748800738425cd7b388bcdd5cd42b41391bdfcf17c4eb89ec3f1aa3a8c0f3fb27d220662680c387e8b2a0ea2424d0b21055f10631cd17a1e2e88810d0c381401637cae045600a93e12f11530627052eeb0525e1a3afe416766c37f8094cda3d806f9b6f6728af6a67058df6a1085cb70c614fcf2eb7bffca49e0146dd9f727c7c2671acd47814f33f343e983eaaa3f83bd377527d1bf8e42faa0f22ff205e4c79d20058386e8e870a343505fa026edd5bd9c54a5326ebce24186b452c04595b9576e440f228e991b8a5becc7fa9469d70c030f8476f983112c26198bbafbf65a06a2726eb990dc3a97b4ce4ed678ff39eb00ca821cc5e15af83e2be80fe18145007aaf2d2ef49ddfba7bf571972bab57c13d5bedfdb409207a77d91f79c24cccabbba779cbf781b143349f7284e0ab6e7e0e7e6457b1ad0a5ee86e3eba2dccc311fb1416c7e4d0457b7e0e04b11aaf453422ffd026b30c02100f6baee40dbfb4b55a1af00bf9051881b7888e11ae1fac464e6ba51901b4aeb1fdd7ca05cb1ab1b06052a518c52f63777e592a3f03b81ff507bb5a2e6ed828e1b705ab9c54af9bddac51ce97499871dd417e531c7ef12f2e00f514fca3306731fbce16afd2e95c9f9f216eb9a939909199a9a90b997b63228c25249379e4a0a67efbce19ae986a32b50592e1613c591d24fe0b529208055bbe962f221ce6c6fb36a043385b74508d40c28e592c6a87cd5c293cb9bbf7981f27a8cca06ba6486f9c962ca02fb505d52826da150ade739e31f88bc551f94f688603fe9459d20a4db401f7191e945deea96f95c0fb32b1137ca9827b77d00b4d5eda52bac4396a13999f4641eee8b8097f2cd883fb7923f2430d81e348f9a1455c02982a02dee67263bb5a6c9b20b198ed0d2a02a8dc4512e41324522b98c7e2fb38bd333df7c7ed77ed30baa491c12b643843e3e635178c9d5a383f4f69479e6d40d5923fe7a4b5ee6944d1a71236b7d007b1ac0d1d003894d91a1973bb24baf1819a5c86ac8bbfe1c6e02bc5fed57af474e893ced79276ac856f2a18ae88b067fe8e5c2a5464bdbb86c3f573fc9e53e9f233bd8b5e50e787c9bd54c1feb761f076dcff8fd23e08da9ee727c7af0ef4bc584f357e7853c35e7cd893c3fd6d0f72e338492620d6542bcb6435a3abfdf471e592b29bc06808b7d36b4f8dcd02f65dcf5b2213e1597629f4e7db48e563abd6edc9f5915dbbd8bd7fd637e97da895ee179aa94953f8dd7355cd0df6e17a98b9fc61a8b0d0dc997b15abce092e95f70d5f1cde992694b1fe46e939cf689129c2f1e2b24da5d20ac4cf3276f2eb442a44f333c0e5c11cf0c0329c904a2fa9524578fdac112cf273a856aef7de162df177e6e0ebae1c2e0bac5b2241f37a6034d1382258870b41599290830ded264a6a6f913f76332bf412a3a905b7cd4c4a13160158ba065035ddd368591f201be66d44e0853d81c2f33225debe5bf2979cb27914ffeeac385433a29401b7a4b0749d3ee258608bc5609318f853d89027621c857cb2c38a9f3a07c03996e317f078400b4 Hey, password is required here."},{"title":"【Python】编码之encoding","date":"2023-05-03T16:05:10.000Z","path":"posts/3RHEW9J/","text":"ASCII, gb2312, unicode, utf-8 Human use text. Computer speak bytes 不论什么字符, 在计算机中都是按照bytes存储. 区别仅在于 encoding 和 decoding 的规则. encoding: text -&gt; bytes decoding: bytes -&gt; text ASCII American Standard Code for Information Interchange （since 1963） /ˈæski/ ASCII 使用 7 bits 来表示计算机键盘上的所有字符. 一共定义了 128 个字符, 描述范围是 0 ~ 127. 95 x printable ch. : a-z, A-Z, 0-9… 33 x control ch. : EOF, LF 为什么 ascii 是 7bit 而不是 8bit? 第8个bit 要么用于校验位: Parity bit 奇偶检验位 要么用于扩展 ascii 到 256个: Extended ASCII ANSI: 泛指最早每种国家语言各自实现的 ascii 扩展编码方式，各个编码互相之间不兼容 GB2312 Guo Biao 2312 号标准 （since 1981） 由于 1个byte 的ascii不能表示中文, GB2312将编码拓展到 2个byte. 但是 GB2312 只收录了 7000多个 中文汉字, 不包含 生僻字、繁体字和日韩文字, 后来推广到 GBK（Guo Biao Kuozhan） 得以收录完毕. Unicode GB2312 是显示中文的编码, 不同国际不同语言都维护了这样的编码, 管理起来就很混乱 （如 \\ux8\\ue2在中文和俄文编码中的含义就不同）. Unicode 通过构建一个全世界通用的字符集解决了此问题. 具体的Unicode编码需要查表: Unicode, UTF-8, ASCII 在线转码的网站 UTF-8 ⭐ Unicode Transformation Format-8. UTF-8 是 Unicode 的一种编码方案, 它是不定长的（1~4字节）, 可以显示 ascii、中文、繁体及其他文字. encoding 规则如下: 单字节符号 (ascii): 第一个bit 为0, 后7位即 ascii码, 这与 Unicode/GB2312 都是兼容的. n字节符号 (如 汉字): 第一个byte 的 前n个bit 为1, 第 n+1个bit 为0, 后面byte的前两位一律为10, 剩下的都是Unicode编码. decoding 规则如下: 若第一个bit是0, 则为单字节的ascii. 若第一个bit是1, 则连续多少个1, 就表示占用多少个字节. 根据Unicode范围决定字节数: 1 byte: 0000 ~ 007F: 0******* 2 byte: 0080 ~ 07FF: 110***** 10****** 3 byte: 0800 ~ FFFF: 1110**** 10****** 10****** 4 byte: 0001 0000 ~ 0010 FFFF: 11110*** 10****** 10****** 10****** 以汉字 “鲁” 为例, 解释 UTF-7的编码规则: “鲁”的unicode编码是 0x9C81, 二进制为 1001 1100 1000 0001. 首先查上表得知占用 3字节, 因此选择 1110**** 10****** 10******. 从后往前依次填入 Unicode, 不足的补0: 得到: 11101001 10110010 10000001，十进制为 0xE9B281 Python编码问题 为什么首行添加 # -*- coding: utf-8 -*-? 因为Python默认编码是 ascii, 如果文件中包含如中文, 会报错: SyntaxError: Non-ASCII character '\\xa3' in file ..., 即 超过 127的ascii范围导致解码失败 BOM头 Byte-Order Mark 文本文件如何确定自己的编码方式? 通过开头几个字节即BOM来辨别, 同时包含大小端信息 FE FF: 大端 FF FE: 小端 EF BB BF: UTF-8 … 下面这段 python2 程序: a = u'El Niño' a.encoding('utf-16') # '\\xff\\xfeE\\x00l\\x00 \\x00N\\x00i\\x00\\xf1\\x00o\\x00' # fffe 即代表 小端存储 Escape Escape通常用来打印彩色输出等. wikipedia: Escape Character 站内博客: Python之优雅输出 Python与编码 传送门: json Python3.11 与编码打交道最多的是 json库 Python2 中允许传一个参数为 encoding Python3 干掉了这个参数, 需要手动编码 有一个 ensure_ascii参数, 默认是True, 它允许对 ascii 不进行额外的编码. 工作中遇到过一个小bug, request请求得到的unicode编码为: \\\\u6789..., 问题出在多了一个斜杠, 原因是重复的json.dumps, 需要避免 资料 Unicode, UTF-8, ASCII 在线转码的网站 Stackoverflow: What’s the difference between ASCII and Unicode? 阮一峰: 字符编码笔记 ASCII，Unicode 和 UTF-8"},{"title":"【日志】2023年5月","date":"2023-05-01T14:26:12.000Z","path":"posts/2023/5/","text":"b3dc07a81f6459d120ce338ccca55046116de9af7135eccfa9c61a82756948fc387d14cd325776592b49d3f1481915c7af940bfd801627f44561689b79cae0dc10d51e8b38f6abff19d282ea8f2ce4a1a7b21476ff60f0802fae4d4cf990cfa67f839215902bc1fd50e5aac32fc2f2c2501b22d895d776f73872ff39db9d4f0336d04723fffacce349547dbbfbc9bb3aea7a10e6685fc3aec57a4155b3009c0e109261f3ea9bd9ab466dd4c12bc32b47e77c0dc457085e5a6efaa6c9b8c236e377017b6c2b20bce3aeb1f710c5761130afbf733859958cfcf1bde5fbf0c13fb8cb206af3a3d0dd204f780e217c1fedd66c4227b6aac9b918474e0e3a0ac3df383d6a7f727c8a22b4c1f66c9298a02b34b44eb90c7473dc9243ca8cd8fe6f2abe429eed206e886a403067d8815ccd0a3a52dd5c2013b00b33453658ab181c7f90f99246d3311605b748704be75865fe09706269709e8fde2bcc3eae83d48869bc8fa8d6155ca00b8efdbeb22fff1bcbcaa5acdc5c34b1dc3fa4db78fdb663d62811aac50072a07ed19c8d785b9b7c560e83ca857443e4634b445dc999e6608b6ed048516050ab25255dd2f932d6695fdeb5b0fe0ef588553ca601bd4ca13037039f55b14cf80b2f53a9cdc8a945e045148acf1c14116299553df9b1d2c70e7339ffc0bc53a3d0c89bef9c77b897d7073812a94d21d434c4e4508a3b5bb5250a99ecc194614da541edfdb5d35e6c7a0150a4183e3595ec62f2a86d26e3906bd2226b9e12d240d7161dd8e86ba8a4c90688873b6526ea74cad40c2eb81bc2a7ec319f9d1f7d1ecff15e01a2edddcee4eaad12012058d55c68d75520057847766e5439a92b5ca5e0e9df4ffd8ac091735a9c75ebcd755849ed32c5a3e537dd6ccc69a74cb9e57971ff1b0bf326b171cf1b73c75e8681a47a38be4932dda31c80240e7fa5a1dbb68093f40741d794ea9b171df98b34945c567230f76070836e025a0a00334fc61ce3bf194d9dda4ef9d494e9c73bda899050ec5901e4c62a33b85e6461be8548ccd0ab0fe9f19662f936f5bb725a5fb1ed973fbcbb7d4dabf09f5ec0533979bf203ca9606581a3ed38a6989f176cde8a9a16f4b5173fd1e221e3e69861d221c307d021c1f3f78fe6ff05ce248c31dbdddd33d2d5619525d521abe18109ec7a1e5930329efc36e6267574bde629b0a080c9cb3a45a0f83f36b7b599c36c3bae734f2b711c29c16fa95bfe62936c2d3d5039655e9077b351b039a8e33527b6ed48d074450bdd1a9609d2a07bd87332ed66899c294ac44d22d946f71a2c148f4b5096ad8a37b8203b6a11b1a430f4932ee7c4362118ba3456aa5a670f62331ff2c755c8dc5932712d73fd45bf89d4a9e97420b04c55c55f5384fe13dde1f9f5fecc73a9dfedbbbf7dc1406b66747fd43a52d0b7efcb717d8d39890f3bfe809b75c90edd83bd81529fc1e62d1bb96ba287bacab0a91775df61ca59f5077ac81eb642796507855a6a47a26a205c60250630ceef5986ed3b27e14fbd8fbbf6298c049e7d2680adcc2c1cbf9d580c2948ca7a57ceb9c16d4e3a5ab063bcbefc7f2bd0911ffcd854dbcc17b32a21d382821ad48d8795c20b7abd62a52e545f216f48d1e0bff63da7aa2fa813617a1416d4fe5d1f0d6d3245518633ac00ea2c61722f085af79adbdeca87675200a505816b2825ed07a2d4d42a7f9966f6e569bac85eb16d6ae483459a179b558288067008e899a9c7ac02f6ca3a0fbadf3c52f1857dde68186a26120e510b813e8af4daea3b6b0e16c4f4d2c3196580cca97cf30e872fb8fd1a664033c1676c0bbf63a0aa02b0ab16e5522aa314a3b08496f6e5c3c2ec617eaa0763f9f8f850d0c6490f3f64612545a5400dad40797b4962c8bc2fd3c0a821f56c37dcd940caf323ea42c4c75fea51e83b9336d3932a3fb895e5e2f12d78ad910bdff50d233c187768cf0827eabf7a7f7eb551ca293ee788fec75eb37f60cc3d8829662fed9d03cd93a1f5cde87bb78333ca1182c60e17ac6c98f0c6888aaaaee952be6cf1027160e0626a2e027531dac6d3cabebb688cca80cb425186679305f211ed6e93403d466e9905d31b08f27c09e44df25405402c279bfabc28ee3a2d6ffa28023c7fb20a24fdcf74e24652002d487eebb237b8602d77a4d42fd85a05eca18b22482c12939f09743c4a0d9d83d0d1796e6ab6ca85c9d705073c24d197d63743d1f5cb5211e8dfb4a91345b62a5b2e5349f9759b534a757e2a00c11f8188f4a385ba18c74f79c2982c9c658c722037591ea9c606f9eed0d60fd6ca21073a53c4dba47d211093d43cb3cb024e4566c8e56c0f71d7c6066cf95855c5d36f5fe3c5407391fbdf9c5f166e2e80c9c6341eabcd498d31fe1349380b09f46acfe2908e5d602f1a0f3aab9176d2d256050417647e7def66ba0bd0e52873ebe838bea753d136c14fc952088fd2725db7d42db185d735876df2f099516b469f3e3dab80a4383aa91e5fc1d33bd4ebb2d19fcf6e01b45216e4d9e7d7fa2736a7bc3607882675117aa6b3309d69fbb8c90d5861b1044fffc516d150618523121322d51715a85a23ed606732fa5504afda287e0001ff8196be950cc7ec0fc63fa67d1690b443d0e241cce8dab60ac74b81418bdad07a0f776a27fc2679837b3676ee517b1fb53f49f35ab0c2db40c2ce3541db1c782830663a4d95fc16a7d49e7fb55a2d1bfd4b663efbedddc0923cab5a2da56fd3f158ca683744563ce8063c221eee1f47e597b20e55d150f28ea06d21d40cb0a4d08c4dec7d14eca9aa83931b5bfcbacf08b44bd108e24130a45b9ac1430fb3eb1415d2b35886ed66085b0919253d9a23cbca8067444ae6cf8f1125143fb589eede24d40e33a1bf685fb1cd90285d9a95e01e0edb5653abca4d63a31a78138481ae7788011885fea28073e164c79e9ff5d2c800ed4c5cb383cbf7204805ace01717f8c2372f72e75b18536d0fa84c99f8021be13b526518f189e17ae376e3b041b92797e428bba8ccd261168c5d42a98f04f81c237ed7b11ddbf3b47bcddf6cd4a573a877d38271dc0d24491df738912b40f3d0f23346f7fbdd271558b3429381c20c6c542c84b484c86acab5675f7ee7f78fa549f3a3adc1c0be44bcc07c8837731c50c5986517690821c509f6658f642e405366ec245b9308cd08a9218163a0297fda672c2846a49fa31446f87d806b457a360c9b3956dde2086f04003e5a62fa81901fb96ac85d4abdac89e4b761b54520238457966a6fa5852683ce182b79718d3ee9d7e77e435dd5b8b9bf8673a488e1846ee473c9a6aece281a95aebe74d77f04d0ad5f05780734e7293d09aacbae2c5a99a49316d88b67d0501aeb4f79064764f20b32c5a001bca3fc0f2d583b139cc1dbf9ffbe0acfeedd55f85f79cc03c31b351ec92f54cd9e5e2878087bac0521e00d19e4d14b37b5386a03188b690a5a1ce759ee417ebdbdd482d611efdfbd102782c487b1738f9aeccfde623c0bd511b138704a5986c5d914a402703e9e9604e4cf767a5e2c99d6b204d4d0ce2d6c9b4686a065893885f6f3657307863f57b0aad1cf7e3dedd8370dc13f2616aa46bd4050f1c5070b619d56ed75bc3f14faea904ebe399b00ca923c53795c36cedcadd5b4eaa0888beeb89da5fc9209e7bf716f79eb8615d5353feff27b35be050bc97ad666e70e991b16308f5143afffc39a5d878f771d9c7e4f0124cfb9a5b68479531d783827e91720d08f427c7a13178b0d32caf20fe6a0f17f9a59b04cbbfb937c1ac0d059b6bb013de86972fcbf4cbe85b82ff97dbce3692bc4b8ff6f66176332282d47eaef10db48c14e5d04ec3c6577a209868d4b2deea139ba312c40dc8fba8eb5bba9250e529d158dfc61c66004ae0a11a8ca6df5ddf98ae4e90570b755c9044420863f1f69607905dd917a6b20310c6a42ef87035e1dd453413ab40d183034afed3fce92f46d5d1e1af7136e2a2730125cb238daca79b36b36d7e28412a17e2607bea153955cf4ddebb58a6684d454f392141be1633da15410bf9c8117a0619befa13eb21447d51a60ecedbd6fc15b7ef2623afe8e3661024e9b25af88263c77475f338a412a0ff608aab216d51d79a2aecf40c3c25f273e09d7f6a405393d0c67608a75e40895b2657a2c02681d842c8888ee09ca3edcb74ce0f474f55aca7325b043ae4144a5bd5ddcd3473035be6df26d21ea7ec23a451155a622a841fa47bb136f951f06983024d46120fbcb0a121a7341fdd7298f2b223c6b4e4b15b14d6c499f01ed0892424ff097d564fecef94edfecb6d0559443139dea475209125b1e4ae0554cad8c47c6c97dc8cd7ec629ccb14d10a47b7aac1f784a338f18ad4d132d80b796e7d023953a579c8c8c1014d3b6fa35c89af7aa86f87f2a928d5b965fbcecc6aaa9468db1751ece62fcfb938ab049564fa7cdae2540c41ebf930025a9a342dd8731b01b5c431cd50ed130f5def04d18b7ce6e4ac58530c22a5a356c7bd87295103a4175028cae3da360b9fc8599e7cc85c96ee63ed4f8e9458212432bce8f0caf6973ecea91e130e889acc30ec2b77d0f34a6fa56ff236b85fbefe98ab6baa36a1408fcae4e443ead45d8308a3855c876cc08954dc8f7f579aa429b057d35ed1846626b98675accd106b76dcc865c95cc58d8e40b8ee1df1bde165c068c19da8ffae4b8ed6d73d83d3c839739e48e95014ff4bb05af38c2e4b67428a067dc29242d488594a5996ec1bb284f7e6708242f86fe3cf13eed62d01e109bda51c8c429377ea54e4515f0e56719ae0395b520fa9f49c3f66b44dfe24d016177df73d1378e7f778e70e658b0112de762cd1fb01c8fe07cea37ea13057dc75ec8a453535cd00dea731db058243e65edc325d7d70af364d24ee9dba5b32a35c0128ed406b4e4798755ee242e45480dd51f2d64f5532c2cbda90f431b852c7af54a56d63ab43bce0c11bcd363974e5228307430c28db64a9aa2d6eca73f0608e9c9f6b1102256e3ffba4f6febb0c803a3b386dd8a64b5b896dcf53e411b9ef61d363a7586a68e82936fee9b76410b8582e792e897dea12ac5469e4f284a7c0f9605ed4ecea756344a4a199f935904368c219e4a581c0a2a7ba6304eb5c2b43485d03c0bc2102c263d57dad0011f9a4a41db42297bdaa0bf0dd4c0cbca41f134657d27feb8df1dd7f7d3ed54d8509949e619367291e16bb4761aa8bb82003b61416004bbe8257840cb94c82edcbaf09bda9035a94396cf012f1e778cf12a5325b8d3e7f9628a732e070c10c5a075564f82bc7665167f9a7d0f87d0402779771f272ef3de3c647a7bac08626e91f7046efe6b3fbe89218e4b74362b3434f37129c513889234773cf22efba855251f270259247c6995e2a509861b462521a91eb2256c8b0a06895171d6c0cbedc34c76740e9e09031c90106cb97360fcb42f4ae4f3cab5fcf7d723f0b1011720986ff1e5105d139ccac0207c12a84d4783c871a8602835edfdd6bb97d9c66fe0cc001154aecd14ebb4f603f613f277425a43509806b91c48336ce15dbee4cc0286d3871250e0c0f65d52e2119b5a7ee9d77a7f9458361e933b30ef553ede51b5cb2e13a594b8700d4dae0d38282c5c88fdc7d9249e41c6c4c3605b2fa7b5f82006ac1436c9204138d4ab3c91f97e2e4b6c4c5b13b71e1a4742511742c9ebac165abd9cd13d7b7c03a713c79afc70a884f3470d0a39e4b4c771caf212f71e00b23044940a0b7c7a42932944b74abe80e088d53fb4ef24ab591f0eee9f80d300f09a6c515b9f7606602c42f90b2922347762427230d0ae7c2271b24346d15a5b3b7594edfb40104f0849eeda0b6563cdedb05f0e6dcae3b90cf0fb242e8c922ee03449966fefe3d63abd8c2b358d570ef579a22ab410aca029c3c04655a204458bf44d1528b8873e676a56ba65fc18d1dfe02bb523bc854deac1cf5aa32f4a92e92ce980599ded7336d42912d321fbf0dd381f64b1f952eca7992db3980df0d3aa31fad8833840b61d52ffff4cbe5d7dcbfcef4f4a40125e7be753476cdc690875f418d0de5fd1f50ff847c0c2650fbdab39aea9ffc731c31e9db61101d22641d2378c532d9201e31c33675cce5cbbcf5902b438c70492c30c4adff9c634ecbd8da97c836b273285eee757b785611817374ab42cfd691f8d9575e33339c1fb4519779be16d38a039bbc049061bf2470de0923f2bd0b9170313f1890ed5c81ab74d8802c4f28d9bd3ffe6d6f7a5f4b835ddd6556edf967a6e4a724366271697cb79bddc0a9df380ac304d91f11ab489f6c866bb017275b718f3d9e9bb98e30c22a0489b002ee55d2f062078e361ce1ed51b3bea2985c1f7a9b006e647705d970b08bbed3c730c3f39c94281868d3c9795575694c5dd05fdc7493947d73fd5331d6d3cc11ab4c7b9adc6d14f54817b9fd7dea83dfb2aaf2f69241c1a6edb591ac718b262acd5122806ee11c9a619d25a1e8cbafdd75d9953f88dc5a193c00509f58185adb7166d514e9abe0e2bcc87c15fa0d1b2864ae6e320d154ee17d50df4291b271e1cb42869e5c1d396091af829eff8ae349ddf4c49648d767a4286bb51f9aeaad5c5c47085b35406ff4d45b1d646f1b8f1e4641f44ffcdcb8f79267e94e145522acd730c59d9a6eef459e456a1377e4f3292ab586d047d28a51370f38cd2dcb57c5ef15cf9241b0b7d1c50f9f9e2a827b49bd084525dd530a440ab53810d8794e1bfcac4830f2fa9d28b45ce50b4d471a650ec5ced240bdca5ff17fb23a0011cade29b4749135788f39f2f90cc41ecf24ac39a9e57f91fb9709cb9139b266fecf8846f3342f3491859ab0542a5748f09b73cef07c31f88f8353ce7da017f7dd40508b9dbb1b26245d9ab461f78ee5542974ecd4a369a847620654588e6b3c9e60a05632f2a7e63bff05aad09465300abc60d4b378542db9c195359f93c727c8fadd71ff254dec98b9f257055900b8439d4b20345bf0474588efad9d2a8796e4349985fd1e1791f0fc75a25d47185dd9063b594975c725ec67c497a7efb036e1f17c0a42a194742e1fb6d062b42ca6bae088f756325fe2caf12b2101bf1b4d58e05d52d8b3592893a054c24d63a0322e20141a231dc3581419347ca6f1c97b7efd197c11bbeace06c3620d8a1e72216fb6c19ecac5dd4ec6c3527ad72360c9dc2c3b3bfcb1d702a0643e1fe90fda934037735d832ee36a404f21977630daf23ede143eae5cca722c5f01273a246e59d1bdf92749d0ee182e68ee0426e8489bfd5adfa1e2820bddc10c9d4cc4dfcc0db397ac01ed820063ddcf53c25a28fff37a548b7e61627ba0f6208c26eb6814d707b0b30b2e86f442dcc77ae0b4c03c742feba4191c0f6fe3b94538ee6b0db09e325eaad9ec378ac45c57d12117284c19fd8f3263e55db49deb5a1766d369034c618e4a4c6f58c1685e08f418c33f03375967ed2a7f34d5ac2f26b209d9fbe657c8c400c2a7834a0771a36bcaa66a06fb9632e94147b71f0746090685aae17bd149f5e3ce229216c923a757673c03e6bd11d572fa3f6d72ed49cfe111e1226910ad1694c7e6ab7905ac050d42917613f97a1876a88d7034ce49d384202d41bb22d42490ef8e4fb16a4ff8cecb27578028c114e53da70653bbad7eafa48a3c6fa68f3f7087345b5777e9c1f6986e646c0f701ff570c01d7115d12b8181b72783fd8b92cf460cc2b0faa6d92626f40047a23b737b4c0c8fd6b3b2d0eeb2038ba51bc5ff0ed27a6e85fc2f4f84faaa166be0f5a6e50feebea542eeb4937e25a4400cc3c796aeabbddb9bbac1730e5e6e5ae70a75233196f5ba7fce2fa1fe485d4d93fc09cdc2f560637aba9a7bda0c1b46231cb46392d2c02f745b1fcd09cd011e5c9c02a064b8f584ab7e09bdff439589ffea0e1b9c1fd35cf828819c485ac6d9c24e7377358bfc368b0a7b6e787a6b96db52756dd8a03dd8499d17d55d4e571d6764adf56e46d7dcc142e8581191e089b35810a5fc21938787605b9125e5feafd0702e48cb669e8176aa66c0b4cc587f3cdb51ecae939026b16c4c1ce1686eb75d141f51e08a9bd1a7d8328215f47105aab8fe16d315ee0433807a2911bb1b5c20085cc2cad0267830519f06fe73a1265c7a04c9a75d9e3a9b44cc0239a81ca81edebbf987df1628d238097ce5b289f4c64a7f1ce84d4abb554132d66d8a8425dd7c8011a8239563505d08601c100dda54d36860e38ec9a7163bf6ada16fbefaf3474940d0f78d8bc695e57aba37c34a8b68740234067ea135de11f7af41db7b9f773fabf3ff9c64be10e78ee9588d83fb376048c43f3778bd1adbcb5e63bd18dacb523e3dbd275d397a04a8dfa6b876bbabb94351164f43a36a73d086f247ff5b7e7a40f4557bc562149a6e9d8a15f673e1cd3c2b7e096c95b24be38ce89aa32948eb6ecc69d51fc7dab4750795343d6e4ebd8d3b89f153b3282122986a55573f54ca5559a6a4a3893d980e23ad1acc372eae6601b91396df91f96fe04a8bbd5f48d7b6afc5089ebb637fa5789da351c1bffdaa89bbbe4299c774be2a64c411d37fb98b3b987834e7bdef9827f768afed83375f4303d6abdffcc18170aa4840f140e8ac61fe524b26e8fa9383c9c10d77a93ba1249581cb380a9d263b6f10df5e88a773ec7dbb3c0c9a251b3f2d2d54cb0776833bac28ad2f1db95526f61aea66a576be06268ab241d25bdef338629897dc96c9e770d85d3d83d25b7e2f9c542ab8b86480efc7d017612f4e4c7ac6389046e9df86a97733c5bf96a0efdc8c9489663d6c4e6ff4fc8be0b96d8d0f71841a06541731b13da94bb1fa3272ff43a386d2f41e1a489362fd264b88588145abad341c7b8972a72bab5daad65148e916839c658e1b7092afde6897d50682a0ce7b5c30f7c19c170d21f7d7e2eb15f41c71a806db5a43343c35ef124bb17b1fb0de3e74e209b54e4bef72c89e5aab9e5a71904aaa793e9ba315faaee6d4e652fc4cd2f5a8db703fbc598b87b59968c8705719f97df552636e5dcfc96470ebd39f1b79b7b02fead29373f93ffa544f117dbc3568d57c91c2f0fd6afe5829ecc49e505f39507b8b0062b9bec28844a5b8566caee9ad8589445eba20e238ffb2cf5ed488638f2e69b330fd1fa32cea40b6eb85364b75fae13f04b4c098269011f173a987883affa3c44c4b366e45ae04fe3890e82bcd88559a7f396341ab631722f8980e587904029785c8449219d63b6e45b2d01c4f2c8346976c0adbaef3f21be46273c6bd496ce64952c5f429c900275e30d3b89defc342bf1ab9472bf05223dab95901b6ebe84e57118a826bb28b2edf7d1abd3ffe691b0619d25a3a41816bcc7e840f954de65572c5a64b40525f92a78da0cd6755a7fb3be25be7cb4a08ca626698314e37bc1e47eb86165e3011dce51dc6272172616b40c87862e511dc79f9ead6257af568398f9e8535276299eaaccdd7c4036858c3f8f68508d8ef843a8c2cc691ff567828bf5c3492ab80f4cc86a8e7f9253b0faf4d6ea68f6b6f5ca519055c9849d7a4ee2318ebc74ea81facb5baa1f902863ba0fd7feb0e77807604c798ac1dca05b9a7900d5f989329882020ee701056613755b724223df5f7351bf193bcd5a2efe0db994c51689ba3c1da6a11ac8b60ccf2a86666f942a228dcc62483da3b93666685c24d436f97a386365d3f699da11459af0c9050a0372b5acafbed04dfe4695b6a9d597dedbc03044fed4c1ae4848822c2c3ffb5cd31abe1da62cfa1764cdf065118d386617664eb97484e7a70c252af3c85345629229428b38f3bc511ea177169d46519451536e14a2dbc9ddc0d1c7497f9174 Hey, password is required here."},{"title":"2023上半年总结（写在五一）","date":"2023-04-30T19:16:24.000Z","path":"posts/2023a/","text":"b3dc07a81f6459d120ce338ccca55046116de9af7135eccfa9c61a82756948fc17f3721d690036660e1ca319b1de7ea5abee2b21d3b2ea15225dc942382fb2c6a01d15f403303ea35415a8b95d29bb66ef379a601361db61ad440174f24415743f6c6f9156bfeeaf0e6657aec44167f87bf27d9768494353a067b87b00a8c76676a1351ebacf5d195df6fa9b57ce808c501fa2aa03b645d2393067c862c33671b06654a4787ea1d45a0123005205bec8cea6476970d45126eb65e8e41c2204755ee61b772cfc80df1938c72d56dd1171efe1683b3a3e8225dfdcf8e999ab2bc72d9c078c46414a2a1ec88978f9207b13046bbb4152fa7c5c912771ac4081deffca6235bfed3cfcccd86776aeb2e247975da6d8d8c5f97217c495d5f55645b82fda52bc29b6114c3c612e47d09f6f7bd6df69366238caddb4f2e0f75a06adfda300037feef6a9e6426651f58b448bea63e6c19e5de7941243ebbf477fd0fdff187250aea12f29fb37bed75737c26615effd83715a69856556d0d7caa8ace3af0b697e5756c306654f2f3c2fa5569ffb2857ad59ff567047f989d51bbfbcf7ec6873fefb563576bb875354666c54ff7dc85524e5fbb3d0f89ceecb3cdb74abfcd2388266307d1caa091555781377025fe5b22396aa85d41793338e3db1fe30eb6a993e70ef79933ca100cee264aabdb13a7170a4565c364d12d0599160d5b4899fd4be011688b95398d2400b6330dc25b4e33d754a9ca8c27ad29a0fb8637129b6a8c85cf3d64aae7a79da926e99f7850a9b3d601f7c8cb0da06a14560e17c19eb45ed171f9e8ee924f4e1e49e06b9355e9233faf5aff88c09da9542b9b90d86c95e29fd0e9f85444a4b1ca681504d28dd142e7cff06cd226adcb6ccf12bd3d3ebb38acfc9059ba34ff82478f4e21a148982f2ffbb0b1d02674b850fb02cc1c92e1ef9d05347f15f4f64033f0dded2725d0d44a668e508a7c774eed0bfa85f8583a3a4a5e838db20c7ab8f2853ed080d789cc9d4f85be2b5b69552fc104069cf4f2e1ccbbb81cde2a09dd18dfca376ca1bb0794c9fb2ec71c11a1fcaaa8176255d9077fb86e66e08ae8bab5ff4fa1dd3bf874298c6e18887bad76d2649968d114ce2c3cd5a3c7be7b4abf5273e1085a1bccc567d8a37370c9afeb0a64bbbf9022a48db59365068675bce2de12b96100c4e11adb4071ff9a102dce16f2fbd48eba54c64298ae4ddf256c9e3b62a8392a8ae4b74df9a463ccf0bf5a2fe005ba508a520f5c6ab641800e34482eec8f13abc390d39e715dff34268e04a8dbf484816f755a578d502cabd819b27f40a4c59fd3ccdef61d045ef3059653482fa47318d385d0500904d924f175c1977dc337a854ef864eb24ed831ecd2678a99245de31475720585c390e5a7ed145b33c36d69027c7f7e1ae9ed74d1c4a0776d9e7d5aaa7339734835ec2d1b45692308a7e91f03170a586d86a8d68f785cb7f862e7345b121042a8fdfa42c32c999e7b14cc4f78cf433f818331d14b9edefd8ee81467e20972c5feeb7655100861d9e75bfacc02c24800bce75e824071f6ba480696afdc9be8a95a9d37344f74c9d2f20683ee1dfedb0ccbe2c871e7f35ecef96de4c674fdfb7dbe2af9678e45177c20f6fb3eec48d11ff50998a251978e816dae9307d28beeb9718ba6c11f94b1891613324224d36a5a0c4bdf0d8248ec2c6425a4c32712d6f34966800b283b127ff4f3c65414bfff3a187ad7a4cd6156d599992a0cd24041d258777b2a1db4660171a8137c071ae53025d28c8c2892250876516418433431dcd099cd87c339b90e7b4beb8db8385be58f49403820c3dc07110e581a7db180c174fa35020afc38a66b8f16c1aa7ede367eb98c619d831fba5bf94ddd6ff9941f90abbcb969aaad58622c9d2cd179c2dbaee78ea0f9f642f41c3a137f5f8ce59714c66acac56ca80948194ffe566d4c2d612cd2c7b9ec3ee2f1231e3620459b2eb79dd7b543cecb1f9d67673b4abdd22242e02f79451dd60f057b125fe420618ef3338a82c42b9196043be45ef43369da4887b0ddab80edcef2242b94ad9b0bccb50a745841b07175cde913ca4de6df1e31e2763e172a14e2c88fb29bef3398ce153a851f475706209307f0786e45562128f58ed2fee5b4a78330442ceeeecc51d78736696a3a2e00faf613eb3dac0bee0a5b7f256de770db74d3fabc06a9a7ba2417820df126eb0fa17ef4eaf1335ebd53686246b8c5255d5bc35c5b5beeeed19a840bf962abb10e74175b7c49d7a169ef72c2ff405f22ed09d518e78adb90f709be4c5914c0dd9df2f8cfdf03d132401308c41df6c85671f19f76720ef328bc5b1e1402b293898d2c1f46dc958433abfd2441ec9f5208e62643a6d5a4228b70973e81506fbc1f213c66703983a3fd7a35e72df84f010bedef9f95b54970c6122477c1c905300f290f0317515434350f9d749f60b55c06215d0b6f8a53f11579d3503990fab5eb95f779153ef32906d745ad6d5ad6fb498a9048bd33bf3292f0cc53b6537c7985cd72e071960d7c572561bdfcbf2b95011351a237dd9ca4d65771e5ff8bd91ee4ba1b71951d6ab211b6f5b10c15ab9e2970c87e5b0b852343d29fca6c0e3d54732bc9f2c7a971e7cd6586fcc719b104a206748dd2b2ff4ad6163ca121a1e62ba80aa91acc29763f4b164bfa9b52a392ee175435283bdced0b2210235074ebfa0a52b2b2389c8d90f3fe13fbd1b44e6534a2de358efae5eeb51d935325026c964209fa5e918c6f2c158ab412ff0342d1d7319b230c5ac880fc6bc53328d42f0fde9057180c7f3aa55990dc19a25a057f1afe05d31396e2d60dd72baa7044b758732f5b466bd7243d51e71cb3801c3fc6a4084be623cc36329ef25b4be7f2374423beb3fb48a7c35fd2d0961546dc605f25a260c50e791c25291c8191ce55b16965b7caf2b43ea2cd69fff7d71a17e713d1fc7df0f5ab55b503085cb30b0edb5c7d14bc48cdc31772706357ec2648b374790333497f7f2798cbf951c8e2f42c497d472c85b141f859800d210d655f2acf1a6fd8d259f0662be33000f22fcb8d6300cd41400ebbabbf0d42ea457213f548e6a71312d62f5aeb5ca2bc1b6fc11690f17be8ee0f872cbcc7323c8b7765134ab70ca8a72ebad4d9e5db12e207aee53e43d9a42e5fb21461e221f7986435e1f0f2b75edd6c89488dffd055fa8f7e2bf86e5906dc7b5f19e1ba6bbc22ba3983504d03e1c0889649b3bfbde88d8eb148eeb783a4cbb8b199ef58965f1f3a31f0559507640211d8c62de1020142456500e0aaa4f3da82f36daae0288597fca7b48dca12c2b2f6d54e654c70c83fb5bf999e27da7af4a98f80911652854b1fde14a7390761d4a873ab53396b0d34ef21a36035954664465e8c52c7172edc0ea305fa7344d57d3a51ff801a8c7afd86952a108982101aeb737a29111534a31c5989be365ccf5d8f9f1de8a7c106d582572241db3e8eed380c2e2819660f651d9fe082d5a4eb79a59a60cf62b15f435d241050cbaec0f0ba1c029ca5565a98a48a19de1db963a46101747e3919978ccf6f945f9c7fb383a0398643e3cbe88e34db77407a1c008534b2e5f14f4579bc22bb082d5786695d81e67b2ce9f6aa9cb445812a3b2a0e01ca47ac385640b88e18fa9cfe760ba6328253c781cb963a8cd8434fbd51abb8798a9299966941d31c08445b23ad9e8dff95c54e6c8791cb3e85b2733cefa62e41bf17e22fb7148811b196088f7f00e9aa404a539386809df25ebefca1eb52d0de4d48da335e2625bd6456034a384a454b32e07db056557e4b4bbbcf55efc0802e65fbd86fc70281d3fcd03cbbd14c93e3f8f77cba91668235ed98c5a141ccad4d0b5aad84f18f12f07aaafdc65f5d70f8c8be3021eb60c2c82d23ca3aff1a2ffb0bf86a75e698063776c7bd848ad9e819aa61a25813a214e7bda5aadf182ab983732af3af07597ec92c48ebc5e72c84bd8b0115228d1db868e5adb209371943bd41d1cf5caa839db2ab5273ea558a924a4c185539a0df2f8e900f526145934dd794c0ea31a476ba74b7bdb4b457bd2fc1a3501c6267fd9070640ce635848fa9c0848f3c006eba0d6e54af1c9da67bfe494bb33fb726f379d5396ebf68d826e609e15f56807adb72c170c993ee8f336a9453e7b8c622ea7e64b351f7494cf1bb1f68751e05ef9bfb6a7eff9ddf96e253626e030ed56aed15e15886be150af573f833efaf3b41fe281f8e8f599e2dec7df8dcfbb6d408e3358415d46ce7420ca658a1dcb7361e289043e27f05839af88ce810cea8ee19989da86a10584b70eb46330cd5292d89eeb8fc11ff5aa32a0f98a481aec10f580b8f0a972bd6e5e1f71d9a199feb23fab9aed6f9da39150cc77098d7a38344f286de76db18ba11bf0c3d467640a870a8f4477b1c177aecfa812a92fb020f6e969be9638033bc4e054234abab4211dd063a9d53c7b12a009880338ea6cacf4068ce4021e63123bb469239f1178255e8e195d97f241a9dbd9243a25690b817a02e0edd7e4512a235332850b836e64fa92e2aadd51296231bd7f9b10510952acefa6e27fa411da0466add8fb92c5ec48a1f436e1e3b8effbaf6b5efcc038e419c2300fd9d07013d804a869029001dfa50513a1e1dd2d57fdca2213f3ff92740ddd5bd37422a7eb64a75700c37c9e1176 Hey, password is required here."},{"title":"【引擎】基础架构","date":"2023-04-30T01:23:57.000Z","path":"posts/2TKCV1V/","text":"提要 很多技术点只是埋了个坑, 等以后学到了再回头补充 游戏引擎 Engine Types Games UE ⭐ 商业引擎 PUBG Unity3D ⭐ 商业引擎 原神 CryEngine 商业引擎 孤岛危机 RAGE 自研引擎（R星） GTA5荒野大镖客 NeoXMessiah 自研引擎（网易） 阴阳师明日之后 Orge 开源引擎 天龙八部 Godot 开源引擎 … Cocos2D 2D开源引擎 … … 核心难题 1. Complexity 游戏引擎设计的计算机技术非常广泛, 涉及模块不限于如下: 渲染 物理、动画 Gameplay 网络 … 图形与物理依赖于数学, 跨平台依赖操作系统的兼容性, 在线游戏又依赖于网络同步, 实时运算要求高效的cpu/gpu优化… 游戏引擎的开发, 可以说是计算机技术中的地域级难度 2. Realtime 区别于电影行业的离线渲染（off-time rendering）, 游戏要求在30ms内完成多个模块的运算； 对于某些要求高的FPS/动作类游戏，甚至要求16ms（即60帧） 3. Collaborate 一个3A游戏至少上百人的工作团队, 难题在于多职能间的协同合作. 涉及的职能不限于如下： 程序 美术 （模型，动作，特效，场编…） 策划 （数值，关卡，运营，战斗…） … 引擎架构 ⭐ 1. Tool Layer 工具层； 接触任何引擎的第一印象, 都来源于 编辑器 2. Function Layer 功能层 让整个游戏的功能丰富起来, 如角色控制、如物理碰撞、如特效渲染等 tickLogic(); // 逻辑tick tickRender(); // 渲染tick 单线程 -&gt; 多线程 ⭐ Fixed Thread: MainThread, RenderThread, LogicThread… MainStream: fork, join Job System: …? 2. Resource Layer 资源层； Assets: 将外部的资源导入为 游戏中的场景，模型，动画，声音… Composite Assets: 索引其他资源（xml）, 如场景索引模型、模型索引贴图… (Assets) Manager: 运行时资源管理很重要！ 频繁的加载与释放 垃圾回收 延迟加载 3. Core Layer 核心层 Math Library: Quake’s Fast Inverse Square Root Data Structure: 如八叉树管理场景 Memory Managerment: 内存管理, 减少cache miss, 处理垃圾回收 4. Platform Layer 平台层 需要兼容PC, Xbox, IOS, Android等多个操作系统 游戏对象 Everything is a Game Object 游戏中一切对象都是一个 GO, 根据是否改变/运动可分为: Dynamic GO Static GO 如何描述一个 GameObject? Property: 位置, 大小, 其他属性… Behaviors: 移动, 攻击… class Character: public GameObjectBase { public: // Property Vector3 position; float health; // Behavior void move(); void die(); } Component ⭐ Every GameObject could be described in a Component 将游戏对象的所有功能拆分为 Component, 例如: transform_comp: 移动的组件 ai_comp: AI的组件 … UE, Unity等主流商业引擎基本采用如下的设计： class ComponentBase { virtual void tick() = 0; } class TransformComp: public ComponentBase { Vector3 position; ... void tick(); } class GameObjectbase { vector&lt;ComponentBase*&gt; comps; virtual void tick(); //... } Tick ⭐ 游戏世界将所有 GameObject 的 Component 全部 tick一遍, 即模拟整个游戏世界的运行 Object-Based tick: 按照对象tick ❌ Simple and easy to debug. Component-Based Tick: 按照系统tick ✔ Parallelized processing. Reduce cache miss. Events GameObject interact with each other via events todo Scene Management GameObject are managed in a scene with efficient ways 多个GameObject如何管理? Uid Position 当地图上的一个角色开枪, 是否要遍历所有的GameObject以查询伤害情况? 二维 xz 划分: Quadtree 四叉树 三维 xyz 划分: Octree 八叉树 TODO Bounding Volume Hierarchies? 搞懂 BVH 的原理 知乎: BVH相比八叉树有什么优劣？ Wiki: Bounding volume hierarchy 学习参考 GAMES104-现代游戏引擎 Wikipedia: List of game engines CSDN 2016: 游戏行业内部主要几款游戏引擎的技术对比"},{"title":"初读 周易八卦","date":"2023-04-29T04:58:03.000Z","path":"posts/3GXTS7K/","text":"先说为什么叫 周易? 据传 \"周的易经\", 系周文王所创 昭示 周期性的规律, 世间万物的推演和变化 理解周易, 核心是理解下面这段话: 道生一，一生二，二生三，三生万物 道生一 “一” 是世界上划分物质、时间的基本单位. 一壶酒、一竿纶… 物质的划分是简单而具体的，但如何划分时间呢? 古人通过观察时间的变化规律： 根据日出日落划分为 “一日” 根据月亮阴晴圆缺划分为 “一月” 根据太阳位置变化的周期 划分为 “一年”. 这就是 “道生一” 中的 ，一，而它是根据自然界的运转规律得来的，因此称为 “道生一”. 一生二 古人观察到一年中总有两天很特别: 一天白天最长 （夏至）——&gt; 阳 一天白天最短 （冬至）——&gt; 阴 这就是阴阳两极的由来，即 “一生二” 中二的含义 古人继续观察发现，世间的任何东西都可以通过阴阳来划分: 日为阳、月为阴 男阳女阴 上为阳为阴，外为阳内为阴… 为了方便记录，古人创建 爻（yao二声）来代表阴阳： 即 —— 表示 阳爻，- - 表示 阴爻 阴阳爻与二进制 阴阳即二进制中的 0 和 1 古人认为阴阳是组成所有物质世界的基础，这与计算机的组成原理是一致的 阴阳转换 古人观察发现，夏至和冬至间，白天长度一直在发生变化 这代表阴阳两极之间也会相互转变 它在当时对农业生产起到极大的推动意义 这就是八卦的由来： 阴阳拓展 由于阴阳，夏至冬至的划分不足以满足 农耕农时的要求（理解为计算机中的精度不足）； 古人提出了 春分秋分 的概念 那么怎么表示呢? 聪明的古人将 “一爻” 推广到了 “二爻” （即计算机中1bit到2bit） 这样就能表示4种组合：春分、夏至、秋分、冬至 二进制的理解 对于上图用二进制表示，阳为1，阴为0 即 春（10），夏（11），秋（01），冬（00） 二生三 古人将 阴阳爻 扩展到 三爻，即创造了8种的排列组合，这就是 八卦 的由来! 三生万物 古人的 两仪（阴阳）、 四象（春夏秋冬）、 八卦（天地水火山雷风泽），就是自然世界的基本组成，它的确可以表示任何物质. 用现代计算机的解释就是，3 bit的组合可以推演出任何可能. 六十四卦 古人将 3bit 的八卦，衍生到 6bit，再拿去占卜算命，就是所谓的 “64卦” 解64卦 以下图的 “否卦”（乾上坤下）为例： 俗话说 “否极泰来”，显然否卦是不好的卦象，但是 “乾上坤下” 又很符合自然界的规律，这如何解释呢？ 为什么 “否卦” 是不好的？ 易经的核心是 “易”，即万事万物是寻求变化的 因此 “乾上坤下” 这种与自然界一致的卦象，属于 “不易”，毫无变化内部无限熵增，最终会乱作一团 卦象赏析 64卦 吉凶 释 象 乾，乾为天 乾上乾下 大吉 诸事顺利，名利双收 坤，坤为地 坤上坤下 吉 精守安顺，妄动招损 屯，水雷屯 坎上震下 吉 宜守不宜进，蛰伏 蒙，山水蒙 艮上坎下 凶 蒙昧忧愁，缺乏果断 需，水天需 坎上乾下 大吉 等待时机，收成在后 云团等待下雨 讼，天水讼 乾上坎下 凶 诸事不顺，避免树敌 天水相隔，事物相背 师，地水师 坤上坎下 中 包容别人 容纳江河的大地 比，水地比 坎上坤下 吉 求助聚力，方能谋事 水依附大地 小畜，风天小畜 巽上乾下 中 受人牵制，蓄养实力 风云积蓄但雨不曾落下 履，天泽履 乾上兑下 中 谦虚自重，不可攀缘 上天下泽尊卑先别 泰，地天泰 坤上乾下 大吉 万事诸顺 否，天地否 乾上坤下 大凶 诸事不顺，凡事忍耐 同人，天火同人 乾上离下 吉 与人共事，谋事有成 大有，火天大有 离上乾下 大吉 事事亨通，大有收获 火在天上明烛四方 谦，地山谦 坤上艮下 吉 谦虚忍让，步步高升 豫，雷地豫 震上坤下 吉 诸事吉祥，可得长辈助 雷鸣催发大地万物 随，泽雷随 兑上震下 吉 – 20. 观，风地观 巽上坤下 中 处于变化中，观机行事 34. 大壮，雷天大壮 震上乾下 吉 强盛壮大，切忌骄傲 55. 丰，雷火丰 震上离下 中 如日中天，谨防盛衰无常 63. 既济，水火既济 坎上离下 事情已成，谨防变故 水浇火熄 参考 B站: 一个视频就能讲明白的《周易》底层原理 B站: 如何解读周易64卦"},{"title":"【C++11】lambda","date":"2023-04-27T17:04:43.000Z","path":"posts/87V2YJ/","text":"Lambda lambda 表达式是C++11最重要的特性. 中文可以翻译为 匿名函数, 在此之前 C# 和 Python 都已经引入了 类似lambda 的概念: C# Func&lt;int, int&gt; square = x =&gt; x * x; Python square = lambda x: x * x 经常使用Python的同学应该能体会到lambda的好处, 避免了繁琐的函数定义, 提高可读性（避免跳转阅读）… 参考Python的语法, C++的 lambda语法基本一致, 只是多了其特有的 值传递 和 引用传递: auto func = [captures] (parameters) { /* func body */ }; 一个计算求和的简单Lambda函数: auto sum = [](int a, int b) { return a + b; } Parameters 这部分就是普通的参数定义, 不赘述; 重点提一下 auto lambda（C++14）, 即模板传参, 写起来非常方便 auto lambda = [](auto node) {}; Captures 与局部函数不同, lambda函数无法使用外部的变量, 因此需要通过 捕获（Caputres） 来获取外部变量. 同时捕获也分为 值捕获 和 引用捕获 两种: Value capture 等同于参数中的值传递, 会伴随一次拷贝, 无法修改原变量的值 Reference capture 等同于参数中的引用传递, 避免拷贝, 能够修改元变量的值 Implicit capture 隐式捕获, 主要如下几种写法: []: 无捕获 [&amp;]: 都引用捕获 [=]: 都拷贝捕获 [=v1, &amp;v2]: v1拷贝, v2引用 关于捕获 [=] [&amp;] 不是捕获所有 local 里的变量, 而是 \"对lambda内所有使用的变量, 采用 值/引用捕获\" 避免对 很大的结构体 使用拷贝捕获, 例如 vector&lt;int&gt; m_huge(10000) Examples 看了一圈发现微软的文档示例（Examples of Lambda Expressions）, 写的最好, 以后多读读微软的文档… 这是微软对 lamda 的介绍: Lambda expressions in C++ related: Modern C++ Tutorial Ch.3: Lambda Expression 中文 lambda代码示例"},{"title":"Fluent Python","date":"2023-04-24T16:06:47.000Z","path":"posts/3K47Y0N/","text":"《fluent python》前部分阅读摘录 NOTE 英文原版pdf链接: Fluent Python (2nd Edition) 上书随时可以拿来翻一翻，很多地方一目十行带过了 前景 精通Python? Python作为一门脚本语言, 上手门槛很低, 但是自以为 “精通Python后”, 往往导致自己再难跳出舒适区, 不会花费时间去学习跟高效、更科学的特性；4月25日晚, 花了半小时初读第一章 Data Structure 的部分内容, 收货非常多! 阅读计划 个人以为该书充当两个重要的作用: 随时查阅的手册 （Manual） 编程习惯的养成 （如何Pythonic） 章节划分 很多小节应该过得很快, 实际不需要1天的开销, 暂时先排到五一结束吧. 阅读这本书的收益还是很高的, 尽快读完~ 大节 小节 排期 进度 Data Structure 1. The Python Data Model ⭐ 4.26 ✔ 2. An Array of Sequences ⭐ 4.28 ✔ 3. Dictionaries and Sets 4.29 - 4. Unicode Text Versus Bytes 4.30 ✔ 5. Data Class Builders 5.1 - 6. Object References, Mutability, and Recycling ⭐ 5.7 ✔ 1. The Python Data Model 书中以实现52张的扑克牌为例（不包括大小王），讲述了若干Python的特性. 这段代码推荐反复阅读… import collections Card = collections.namedtuple('Card', ['rank', 'suit']) class FrenchDeck(object): ranks = [str(n) for n in range(2, 11)] + list('JQKA') suits = 'spades diamonds clubs hearts'.split() def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position] 涉及Python特性如下: namedtuple collections.namedtuple('Card', ['rank', 'suit']) 它创建了一个 Card 对象, 拥有 rank, suit 两个属性. namedtuple 可以替代 dict 和 class 的繁琐创建, 大幅提高代码的简洁度. meta programming 重写各种 内置函数( __len__ , __getitem__ ), 合理搭配 len, [] 等特性使用. list comprehension 列表推导式, 看第二节. TODO 找时间过一遍所有Python的内置函数 例如 __getitem__, __dir__... 2. An Array of Sequences Sequence 先看Python内置的容器 根据存储的数据类型可分为: Container sequences 允许不同种类型的对象： list, tuple, collections.deque Flat sequences 仅允许同一种对象：str, bytes, array.array 作为对比, Flat-seq 在内存上更为紧凑和节省, 因为 Container-seq 会存储 ob_refcnt、ob_type、ob_val等 C 对象, 这导致其内存占用也更大. 根据是否可修改可分为: Mutable sequences 可修改类型：list, bytearray, array.array Immutable sequences 不可修改类型: tuple, str, bytes Tuple 尽可能的使用tuple类型（在某些不可变对象的场景下）, 因为它有两个优点: 防止数据被错误修改 （如误传引用） 比list节省内存 tuple 不可变, 是意味着被tuple直接引用的对象不可变. 以下图为例, tuple中嵌套一个list, 该list仍是可变的. List comprehension [str(i) for i in range(10)] 这是一个最简单的 Python List Comprehension, 即列表推导式, 它可以替代简单的 for 循环. 性能上, 推导式 往往优于 for循环, 主要有两个原因: for循环中的 append 等操作很废. 推导式的 for 是C层面的 for, 它要快于Python写的for循环. runtime 优化 当不需要一次性产生所有数据时, 使用(str(i) for i in range(10)) 它是一个generator, 每次迭代时才会从中取出数据 filter 函数就是一个generator, 使用list(filter(...)) 以将其转化为列表 Unpack and * 使用unpack来赋值 a, b = \"1 2\".split() 使用*来存储溢出的数据 a, *b = \"1 2 3 4\".split(), 其中b是一个list 3. Dictionaries and Sets 略 4. Unicode Text Versus Bytes 写在这篇文章: 【Python】编码之encoding"},{"title":"【问题求解】Hash Map","date":"2023-04-23T14:59:09.000Z","path":"posts/7BBSYB/","text":"概要 《Introduction to Algorithms (4th)》: Hash Tables Python dict的算法原理 Hashing A hash table, also known as hash map, is a data structure that maps keys to values. 哈希表, 就是一种将 key 映射到 value 的数据结构 哈希表实则为列表的进阶应用, 那么为什么需要哈希表? 先看列表的增删查改开销: 增删改: O(1) 查: O(n) 因此遇到需要密集查询的场景 (如通讯录, 如飞机航班…), 列表就会遭遇查询的性能瓶颈 (数据量很大)… 此时 Hash Map 就是应对高效查询而提出的数据结构 Hashing 主要由三个部分组成: Key : 可以是任意的输入类型 Hash Function : 将input 转化为Hash index的函数 ⭐ Hash Table : 存储所有Key, Value的数据结构, 类似Python Dict Hashing的性能几乎完全由 Hash Function 的好坏决定, 因此本文将围绕 Hash Function 的选择展开论述. Hash Collisions 最朴素的Hash结构, 即用一个大的数组表示 （即直接地址法）, Key即Value. 缺点很明显, 随着数据量的上升, 该数据结构的内存开销很大, 且存在空隙的浪费 这在实际应用中显然是不可能的, 任何一个Hash Table, 其大小肯定是小于数据量的大小. 因此根据抽屉原理, 总会存在两个Key 哈希到同一个Index的情况, 这就叫哈希冲突 (Hash Collisions). 如下图所示: 如何理解 哈希冲突? 班上出现两个同名学生, 老师第一次点名时, 根本无法识别到哪一位. 因此需要额外的特征（身高、衣服、别的外号等）才能识别 如何处理 Hash Collisions? 🏅 Stackoverflow: How do HashTables deal with collisions? 1. Chaining 算法导论书中的方法是, 在哈希冲突的槽位中, 引入一个链表（如下面所示）. 这也是 Java Hash-Map 中解决冲突的方式（jdk1.7）. 0 -&gt; 40 -&gt; 27 -&gt; 53 // Hash Collision 1 -&gt; 88 // OK! 2 -&gt; 16 -&gt; 42 // Hash Collision ... 2. Double hashing 第一次哈希冲突时, 使用另一个备用的哈希函数, 循环下去直到冲突不再产生. 缺点是哈希的计算时间复杂度变高. 什么是 Load Factor (负载因子) 负载因子 = 总样本数 / 哈希表容量 对于列表来说, 负载因子为1, 永远不会出现 哈希冲突的情况. 负载因子越大, 说明发生哈希冲突的概率越高. Hash Function 此时我们得到 衡量一个哈希函数好坏的标准: 运算 快 内存 小 (产生的index少) 哈希冲突 少 ⭐ 负载因子 小 常用的哈希函数有如下几种: 1. Division Method $h(K) = k \\space mod \\space M$ 最朴素的哈希函数, 取模. 其中k是Key, M是哈希表的大小. 示例如下: k = 1278 M = 11 h(1276) = 1276 mod 11 = 2 这里的关键是 M 的取值, 显然它不能是 2 的任何次幂. 如何选 M 的取值? 2. Multiplication Method $h(K) = floor(M \\times (kA \\space mod \\space 1))$ 乘法哈希, 其中k是Key, M是哈希表的大小, A是一个 $(0, 1)$之间的常数. 示例如下: k = 12345 A = 0.357840 M = 100 h(12345) = floor[ 100 (12345*0.357840 mod 1)] = floor[ 100 (4417.5348 mod 1) ] = floor[ 100 (0.5348) ] = floor[ 53.48 ] = 53 Application 哈希如何用作加密? 以SHA举例, 用户输入自己的密码后（比如长度为5~12的字符串），系统会利用SHA Hash将其映射为 一个256bit的 字符串，并存储在计算机本地. 当用户再次输入密码, 只需要对比生成的SHA Hash值是否前后一致即可. 同时, 由于Hash的不可逆, 还能有效起到防盗的作用. SHA SHA-256（Secure Hash Algorithm）是最广泛的加密哈希算法之一, 任何长度的信息都会被映射到一个256位（32字节）的字符串. 详细可以看这篇: 知乎: SHA256算法详解及python实现 hash(\"hello\") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824 hash(\"hbllo\") = 58756879c05c68dfac9866712fad6a93f8146f337a69afe7dd238f3364946366 MD5 MD5（Message Digest 5) 是一种消息摘要算法, 同时也利用了哈希函数. 本质上, MD5就是把任意长度的数据生成一个128位的字符串. 详细可以看这篇: 稀土掘金: MD5算法的应用及原理 游戏Patch经常会使用MD5哈希算法, 来做文件下载校验. SVN检查本地哪些文件作了修改, 也使用了MD5. SHA-256, MD5等哈希算法是否可逆? 显然是不可逆的, 因为这些是摘要算法, 本质是 无穷信息 到 有穷信息 的一种映射 知乎: 为什么说 MD5 是不可逆的？ 王小云: 破解出一个高效的MD5哈希碰撞算法 Paper Wiki: Hash table Geeksforgeeks: What is Hashing Hashing"},{"title":"【Linux】如何阅读man手册","date":"2023-04-22T03:34:01.000Z","path":"posts/man/","text":"NOTE man-pages for web 程序员工作生涯三年, 至今恍然醒悟, 发现自己特喵的甚至不会读文档... 搜索能力、阅读能力、表达能力, 是容易忽视却重要的技能 TODO: man如何在多个标题之间快速跳转? man如何显示行号? man man man, 利用man查看man指令的手册. 基本使用: man 是完全按照 vim 的操作方式, 推荐阅读站内博客: 【VIM】Vi Improved 比如: q键退出, hjkl翻动等 下面总结几个重要的概念: sections 为了处理 linux 不同模块手册中重名问题, 利用section将其区分. 通过 man -f [cmd] 可以查看对应的section. 以 passwd 指令为例: man (1) passwd: changed user password (可执行指令) man (5) passwd: the password file (文件格式) 通常情况, 使用 man [cmd] 已经足够满足需求. 下面列出常用的section: 可执行程序或 Shell 命令 ⭐ 系统调用（内核提供的函数） ⭐ 库调用 ⭐ 特殊文件（通常位于 /dev 目录） 文件格式和约定（比如 /etc/passwd） 游戏 杂项（包和一些约定) ⭐ 系统管理命令（通常是 root 用户执行的命令） 内核相关的文件 headings man手册的输出, 一般有如下几个标题组成: Name: 指令名 Synopsis: 指令的格式概要 Configuration: Configuration details for a device. Description: 指令的详细描述 ⭐ Options: 指令接收的参数 ⭐ Examples: 指令的使用样例 Commands: 指令内置的操作键, 如htop有一个简单的UI界面. Defaults: The default functions of the command and how they can be overridden. Exit Status: 指令的返回值. Environment: 指令相关的环境变量. Files: 指令使用到的文件. Authors: 开发者和维护者. History: 发布历史. man -k 但你不确定要搜索的指令/模块名称, 使用 man -k 可搜索所有的手册全文. colored-man-pages 原生的man输出, 没有彩色的样式区分, 可以利用 colored-man-pages 实现. 阅读站内博客: 【Shell】oh-my-zsh k Quote How to Use man in Linux What do the numbers in a man page mean?"},{"title":"【OS】多线程之pthread","date":"2023-04-20T14:02:05.000Z","path":"posts/XT9Q9N/","text":"大学时期写了一篇 CSDN: 进程和线程的深入理解 阅读量接近4w, 回头看很多概念理解比较肤浅… 这篇文章会更注重代码层面的理解 pthread man pthreads Linux c 提供 pthread 库用于实现多线程, 可通过 man pthreads 查阅手册. 阅读一遍筛选部分有用信息: Description pthreads 是 POSIX threads 的简写, 它维护了线程相关的若干接口. These threads share the same global memory (data and heap segments), but each thread has its own stack (automatic variables). 这句很关键, 线程之间共享内存(堆), 但不共享栈. 看到没有, linux man 已经给了详细的答案和描述. Threads share a range of other attributess: 线程间还共享如下属性: - process ID - parent process ID - controlling terminal - open file descriptors - signal dispositions - ... Thread IDs Each of the threads in a process has a unique thread identifier (stored in the type pthread_t). This identifier is returned to the caller of pthread_create(3). 这就是俗称的pid (可以通过top指令看到), 它的类型是 pthread_t. pid是由 pthread_create 第一个参数给出的. Thread-safe functions A thread-safe function is one that can be safely (i.e., it will deliver the same results regardless of whether it is) called from multiple threads at the same time. 重点+1, 这句直接解释了何为线程安全, 这不比CSDN上的一堆废话来的清晰直接吗? 线程安全, 即多线程下随便怎么调用, 结果都是唯一和确定的 后面接着列出了非线程安全的C函数… Compiling on Linux On Linux, programs that use the Pthreads API should be compiled using cc -pthread. 在linux下使用该API, 需要加上 cc -pthread 的编译选项！ 直接 include &lt;pthread.h&gt; 以为就万事大吉了? 所以还是得看文档呀~ LinuxThreads 这里逐渐将如何使用 linux 多线程, 总结几点如下: 1.使用 pthread_create(3) 创建额外的线程, 这里自觉 man 3 pthread_create 查阅手册. 2.剩下的实践中再补充吧 pthread API 下面尝试利用pthreads实现 c 的多线程 pthread_create 这是创建线程的接口, 查看man文档可知: #include &lt;pthread.h&gt; int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); args: thread: 即pid attr: 创建线程的相关参数, 传NULL即使用默认 void*: 线程调用的函数 void&amp; arg: 函数的参数 return values: On success, pthread_create() returns 0; on error, it returns an error number, and the contents of *thread are undefined. 即创建成功会返回一个0, 有点像http请求的返回值规则. 下面给出一个示例: #include &lt;stdio.h&gt; #include &lt;pthread.h&gt; void *entry(void *arg) { char *ret; printf(\"thread() entered with argument '%s'\\n\", arg); } void main() { pthread_t pid; if (pthread_create(&amp;pid, NULL, entry, \"thread 1\") != 0) { printf(\"pthread_create() error\"); } } 通过 gcc main.c -lpthread &amp;&amp; ./a.out 编译运行, 发现没有任何输出… 这里得出猜测, pthread_create 创建的线程不会直接运行 查阅文档得知, pthread线程的运行时不确定的, 进一步查阅 pthread_join 相关手册. pthread_join int pthread_join(pthread_t thread, void **retval); 作用是等到一个线程运行结束, join函数才会返回. 对于上面的 C代码示例, 只需要加一行: if (pthread_join(pid, NULL) != 0) { } 然后编译运行, 就可以看到 entry 函数中的正常输出. 另外, pthread_join 的另一个参数 retval, 可以获取线程的返回值. pthread封装 Linux pthreads接口不是很好用, 且缺少一个全局的thread管理器. 我们可以尝试封装一层: thread.h 此时我们只需关注 create join这两个函数. 后面的所有代码示例都将使用 thread.h 展开. #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdatomic.h&gt; #include &lt;assert.h&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt; #define NTHREAD 64 enum { T_FREE = 0, T_LIVE, T_DEAD, }; struct thread { int id, status; pthread_t thread; void (*entry)(int); }; struct thread tpool[NTHREAD], *tptr = tpool; void *wrapper(void *arg) { struct thread *thread = (struct thread *)arg; thread-&gt;entry(thread-&gt;id); return NULL; } void create(void *fn) { assert(tptr - tpool &lt; NTHREAD); *tptr = (struct thread) { .id = tptr - tpool + 1, .status = T_LIVE, .entry = fn, }; pthread_create(&amp;(tptr-&gt;thread), NULL, wrapper, tptr); ++tptr; } void join() { for (int i = 0; i &lt; NTHREAD; i++) { struct thread *t = &amp;tpool[i]; if (t-&gt;status == T_LIVE) { pthread_join(t-&gt;thread, NULL); t-&gt;status = T_DEAD; } } } __attribute__((destructor)) void cleanup() { join(); } Shared Memory What is Shared Memory? 进程间存在共享内存 这个很容易解释, 想象一下windows的任务管理器, 或者Linux的top指令等. 他们一定可以读取其他进程的若干内存信息 (?). 线程间不共享内存(local), 但共享进程间内存(global) 线程的局部变量, 是存在栈中的, 之前看pthread man手册, 明确指出线程之间的栈是相互独立的空间. TODO 关于共享内存先埋个坑, 看到相关的再补充. Atomic 从一个经典的问题入手: sum.c 两个线程分别对一个全局变量++, 最后的结果是多少? long sum = 0; void Tsum() { for (int i = 0; i &lt; 1000000; i++) { sum++; } } int main() { create(Tsum); create(Tsum); join(); printf(\"sum = %ld\\n\", sum); } WHY? 基本介于100w~200w之间, 偶尔会出现小于100w的情况. 先给出结论: sum++ 不是一个原子操作, 即非线程安全. 为什么++非线程安全? stackoverflow: Can num++ be atomic for ‘int num’? 看汇编代码, num++ 实际会拆分为3句汇编指令: 这三条指令在多线程中其执行顺序是不确定的. 即线程1在read时, 线程2可能在write… mov eax, [num] // read inc eax // add mov [num], eax // write 什么是原子操作? Atomic operation 即原子操作在执行期间, 没有其他指令同时能够读或写. 正因为num++ 不是一个原子操作, 才会出现上面的多线程bug. 多线程引发的支付问题 下面是一段模拟支付宝 扣除100元 的多线程代码: 当时尝试运行它, 会发现账户中瞬间多出用不尽的money… 这里的问题有两个: blance -= amt: 它不是一个原子操作 unsigned long: 非整形导致的溢出 #include \"thread.h\" unsigned long balance = 100; void Alipay_withdraw(int amt) { if (balance &gt;= amt) { usleep(1); // unexpected delays balance -= amt; } } void Talipay(int id) { Alipay_withdraw(100); } int main() { create(Talipay); create(Talipay); join(); printf(\"balance = %lu\\n\", balance); } Paper 如何阅读man手册? pthreads(7) — Linux manual page Microsoft: About Processes and Threads MIT: Concurrency Three Easy Pieces: Concurrency and Threads Stackoverflow: What is the difference between a process and a thread?"},{"title":"Node.js","date":"2023-04-12T17:13:53.000Z","path":"posts/1T7TWH8/","text":"涵盖Node.js, NPM, html, TS/JS… NOTE WHAT is Node.js? Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine. WHAT is NPM? NPM is the standard package manager for Node.js. WHAT is TypeScript? TypeScript is Typed JavaScript at Any Scale. Node.js linux 默认安装比较老旧的 Node.js 版本，需要如下操作以升级： sudo npm install -g n sudo n stable TypeScript TS默认使用非常严格的静态语法检查，通过如下途径屏蔽它（不推荐）： 单行忽略 // @ts-ignore 忽略全文 // @ts-nocheck 取消忽略全文 // @ts-check nvm https://github.com/coreybutler/nvm-windows/ nvm 是一个管理多 Node.js 版本的工具, 就像python conda. 使用: nvm -h nvm list: 查看所有Node.js版本 nvm install xxx: 安装指定版本 (win10需要管理员权限) nvm use xxx: 切换到指定版本 install 遇到报错, 是因为无管理员权限 Error extracting from Node archive: open ...\\node-v18.15.0-win-x64\\corepack.cmd: Access is denied. Problems 1. npm如何打包发布到html? 借助 browserify: 如何在浏览器使用npm包? 2. html调用js方法总结 CSDN: HTML如何调用JavaScript 3. html中js的相对路径问题 使用 \" {{ assets/extra.css | url }} \", html会自动生成相对路径"},{"title":"【VSCode插件】function decoration","date":"2023-04-09T06:55:34.000Z","path":"posts/AEKS3P/","text":"🏠 vscode-function-decorations 原始需求 某个项目需要通过全局的Env属性来控制函数的可见性, 如下： Env.py # Env.py Feature_A = True Feature_B = False Feature_C = True # ... xxx.py if Env.Feature_A: def f1(): pass if Env.Feature_B: def f2(): pass 痛点 当python文件很大, 函数定义很多的时候, 你得往上翻文件并通过对齐来确定函数是属于哪个if的作用域, 这是非常痛苦的. 因此希望通过vscode插件解析其作用, 在不同的函数后面显示样式来区分, 如下: python语法解析 先借助 python ast 解析整个语法树 只需关注ast.If节点, 将它的body中是ast.FunctionDef的子节点都拿到即可 注意, 为了匹配else 还需要拿到其orelse对象 整体实现思路很简单, 见 pyast.py VScode添加标注 DecorationInstanceRenderOptions 的 after属性, 可以改变尾部的值和样式 代码示例: // 新建一个样式实例 const myRenderOptions: DecorationInstanceRenderOptions = { after: { contentText: ` # Feature_A`, fontWeight: 'bold', color: '#FF00FF', }, } // 控制样式位置和范围 dividerRanges.push({ range: ..., renderOptions: myRenderOptions, }) // setDecorations, 切换文件会失效 editor?.setDecorations( dividerDecoration, dividerRanges, ) 效果展示"},{"title":"【OS】实现指令pstree","date":"2023-04-08T12:28:46.000Z","path":"posts/3AGXVNM/","text":"提要 pstree 是os-2022的一个mini lab: M1: 打印进程树 (pstree) 主要内容是模拟linux下的pstree的输出 $ pstree systemd─┬─YDLive─┬─YDService─┬─sh───13*[{sh}] │ │ └─23*[{YDService}] │ └─14*[{YDLive}] ├─acpid ├─2*[agetty] ├─barad_agent─┬─barad_agent │ └─barad_agent───2*[{barad_agent}] | ... 思路 先通过 strace pstree 查看其系统调用, 发现其通过读取linux下 /proc/xxx 的文件实现 (这源自linux everthing is file的思想) $ strace pstree # 这句调用pstree的脚本 execve(\"/usr/bin/pstree\", [\"pstree\"], 0x7ffe85396ce0 /* 40 vars */) = 0 ... # 这句读取了/proc下的文件 openat(AT_FDCWD, \"/proc\", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3 fstat(3, {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0 ... # 这句读取/proc/1/stat的文件 openat(AT_FDCWD, \"/proc/1/stat\", O_RDONLY) = 4 ... 所以该实验考察的核心内容是: strace 系统调用 c 读文件 树 数据结构 代码 无脑写完的, 没有什么技巧, 等过完os-2022的课程再回头review一遍此代码, 看是否有提高吧 缩进不一, 应该是因为混用tab和space导致, 这个有空处理下Hexo的编码 #include &lt;stdio.h&gt; #include &lt;assert.h&gt; #include &lt;dirent.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; struct Proc { char name[255]; unsigned int pid; unsigned int ppid; }; struct Proc proc_list[255]; int proc_count = 0; int isNumber(char *str) { return strlen(str) == strspn(str, \"0123456789\"); } void walkTree(int ppid, int tabs) { // printf(\"%d:%d\", ppid, tabs); for (int i=0; i&lt;proc_count; i++) { struct Proc tmp = proc_list[i]; if (ppid == tmp.ppid) { for (int i=0; i&lt;tabs; i++) printf(\"---------\"); printf(\"%s(%d) [%d]\\n\", tmp.name, tmp.pid, tmp.ppid); walkTree(tmp.pid, tabs+1); } } } void walkDir() { DIR *d = opendir(\"/proc/\"); struct dirent *dir; FILE *fp; while ((dir = readdir(d)) != NULL) { if (isNumber(dir-&gt;d_name) == 0) continue; char path[256] = \"/proc/\"; strcat(path, dir-&gt;d_name); strcat(path, \"/status\"); fp = fopen(path, \"r\"); if (fp == NULL) continue; char buff[256]; struct Proc proc; while (fgets(buff, 128, fp) != NULL) { char *ptr = strtok(buff, \":\"); if (ptr) { char *val = strtok(NULL, \":\"); if (strcmp(ptr, \"Name\") == 0) { strncpy(proc.name, val, strlen(val)-1); } else if (strcmp(ptr, \"Pid\") == 0) { proc.pid = atoi(val); } else if (strcmp(ptr, \"PPid\") == 0) { proc.ppid = atoi(val); } } } proc_list[proc_count++] = proc; fclose(fp); } closedir(d); } int main(int argc, char *argv[]) { for (int i = 0; i &lt; argc; i++) { assert(argv[i]); printf(\"argv[%d] = %s\\n\", i, argv[i]); } assert(!argv[argc]); walkDir(); walkTree(0, 1); //printf(\"%s: %d\\n\", \"12.3\", isNumber(\"12.3\")); //printf(\"%s: %d\\n\", \"123\", isNumber(\"123\")); return 0; }"},{"title":"【问题求解】Recursion","date":"2023-04-04T14:29:58.000Z","path":"posts/20ER2MC/","text":"TODO 理论: 英文教材 《Chapter 2 Recursion: The Mirrors》 Leetcode: 递归专题 | 递归blog Recursion | Devide-and-Conquer | DP Recursion = Mirrors Recursion breaks a problem into smaller identical problems. 想象两面镜子正对着放在一起, 其中会无限产生倒映, 并且越来越小以至于肉眼看不见. 递归的本质, 就是将问题逐渐拆分成更小规模的问题, 以至于能被简单解决. How to search a word 书中以 “在英文字典查词 vademecum” 为例, 阐述了两种方法: Sequential search 从字典第一个单词开始, 按顺序逐个查询… Binary search 翻到字典一半位置, 根据首字母确定在前半部还是后半部, 然后接着翻到一半位置, 循环下去… 直到翻到只剩一页, 就停止循环, 在此页查找 这就是一个经典的递归思想. 2 x Features ⭐ 递归思想解决问题, 符合如下2个特征: base-CASE: 递归会终止于一个简单的问题 降维: 每次递归都会调用自身, 并解决一个规模更小的问题 Recursion Problems Factorial N 先以阶乘为例, 阐述上面的特征: $factorial(n) = n \\times (n-1) \\times (n-2) \\times … \\times 1$ $f(1) = 1$ 这是一个base case, 因为它是最小的正整数, 是终止条件 $f(n) = f(n-1) \\times n$ 每次通过调用自身缩小了问题规模 python程序如下: def fact(n): if n == 1: return 1 return n * fact(n - 1) String Backward 字符串倒置问题, 这是递归中稍难的问题, 因为没有返回值, 它不再像 Factorial那样直观 以此为例, 阐述解决递归问题的思路： 找到base-CASE: 长度为1的字符串, 倒置即是本身 找到降维方式: 已知n-1字符的倒置, 如何求n字符的倒置? 即S[n] + S[1…N-1] python程序如下: def write_backward(s): if len(s) == 1: print s else: print s[-1] write_backward(s[:-1]) Binary Search 二分查找, 这是计算机最经典的问题, 生活中也经常用到这个类思想. 任何情境下的二分问题,只需要想清楚如下2点: 什么是base-CASE? 它确保二分能停止 选左半边? 还是选右半边? 例如对一个有序数组作二分查找: base-CASE: array[i] == target 或者 left &gt;= right 选择: 根据大小关系很容易选 python程序如下: int binarySearch(const int&amp; Array[], int left, int right, int target) { if (left &gt; right) return -1; // not found int mid = (left + right) / 2; if (Array[mid] == target) return mid; // find it else if (Array[mid] &lt; target) // find right return binarySearch(Arrary, mid, right, target) else // find left return binarySearch(Arrary, left, mid, target) } Find Largest 二分查找每一半的最大值 def findLargest(arr): if len(arr) == 1: return arr[0] mid = len(arr) / 2 return max(arr[:mid], arr[mid:]) Find $k_{th}$ Largest Combination of $C^{k}_{n}$ Hanoi Tower ⭐ 这有个 网站演示demo WARNING这些算法待实现, 存在一定难度, 尤其是汉诺塔 Recursion Complexity ⏳ 递归算法的效率往往不高, 因为任何编程语言的函数调用开销都较大. 可以通过使用迭代避免, 以Faborial为例: def fact(n): ans = 1 for i in range(1, n+1): ans * = i return ans Leetcode 递归专题 这里选取了几个最经典的算法题: 斐波那契 反转链表 509. Fibonacci Number F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n &gt; 1. 计算F(n), 0&lt;=n&lt;=30 递归 int fib(int n) { return n &lt; 2 ? n : fib(n - 1) + fib(n - 2); } 尝试用主定理分析一波复杂度: $T(n) = 2 T(n)$ 等比数列求和得到复杂度: $O(2^n)$, 空间复杂度: $O(1)$ 尝试优化一下: fib(n-1)和fib(n-2)中间有很多是重复的运算, 可以作一个存储 递归 -&gt; 缓存 int fib(int n) { // n &lt;= 30 int cache[31] = {0, 1}; for (int i=2; i&lt;=n; i++) cache[i] = cache[i-1] + cache[i-2]; return cache[n]; } 通过数组存储, 避免了重复计算, 这里复杂度很容易分析: 时间$O(n)$, 空间也是$O(n)$ 进一步优化 那么是否有办法优化掉$O(n)$的空间呢? 尝试使用多个局部变量即可 即a, b, c, 三者分别代表$fib(n)$, $fib(n-1)$, $fib(n-2)$: int fib(int n) { if (n &lt; 2) return n; int a = 1, b = 0; int c = a + b; for (int i=3; i&lt;=n; i++) { b = a; a = c; c = a + b; } return c; } 他是复杂度为: 时间$O(n)$, 空间$O(1)$ 206. Reverse Linked List 反转链表, 并返回链表head 递归 先尝试递归的解法, 按照递归的两个特性尝试理解: base-CASE: 链表长度为1, 此时反转即本身 降维: 长度为n的链表, 反转为 $R_{n}$ + $R^{'}_{1 - (n-1)}$ 实现的技术细节不是很直观, 因为利用了递归中函数调用的栈特性 如下 next_node 其实会一直调用下去, 直到最后一个尾节点, 然后才会执行head-&gt;next-&gt;next=head那两行代码. 即真实执行的顺序, 是从尾部到头部 ! 这个leetcode题解有动画演示, 跳转链接 ListNode* reverseList(ListNode* head) { if (head == nullptr || head-&gt;next == nullptr){ return head; } ListNode* next_node = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return next_node; } 照例分析复杂度: 时间$O(n)$, 空间$O(1)$ 双指针 其实是单指针的方法, 利用head-&gt;next来更新节点, cur当做指针移动: 这个leetcode题解有动画演示, 跳转链接 ListNode* reverseList(ListNode* head) { ListNode* cur = head; while (head &amp;&amp; head-&gt;next) { ListNode* next_next = head-&gt;next-&gt;next; head-&gt;next-&gt;next = cur; cur = head-&gt;next; head-&gt;next = next_next; } return cur; } 复杂度和递归的方案一致"},{"title":"问题求解与算法","date":"2023-04-04T13:02:53.000Z","path":"posts/3HZHSCW/","text":"理论书籍 《Data Abstraction &amp; Problem Solving with C++》 目录 专题 Blog 备注 Sorting 【Algorithm】Sorting Recursion 【问题求解】Recursion Hash 【问题求解】Hash Map String-matching 【Algorithm】String matching Binary-tree 【Algorithm】BinaryTree Graphs 【Algorithm】Graphs 时间复杂度分析 递归和分治法, 可以通过主定理计算: 假设每次递归, 拆分为 $a$ 个规模是 $\\frac{n}{b}$ 的子问题, 额外计算量是$f(n)$ $$T(n) = aT(\\frac{n}{b}) + f(n)$$ 则时间复杂度为: 参考链接: wikipedia: Master theorem 主定理的证明及应用举例 附录 算法随想录 leetcode刷题攻略 Data-Structures"},{"title":"【日志】2023年4月","date":"2023-04-03T13:08:58.000Z","path":"posts/2023/4/","text":"b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475de0b1305a637ea913974dff7410a14ed4dbbb40a5278eb14bbac34e59e12a284c7643238e28174e788020e96a39239fbb7a1c76b116f6e38dc468b0c7cac9c50048e68c3dccb238a37e6d426c67296e44e624d0263ecbb1ee2ce6233952e63f68c54518300883aa91a56cb1ceea99ee02984fbd13056cf47fe0fd747697d84c93d835cf6f85ae3fef03ffe45ee23440aa039585c6ec0cbf30f39b3a857ce58c38f217729c7ec0c60e9bf63b162f3949f75b4548da5a65844a0bc0ed6329c52beceed7c96d178b24d5f7e92f673c17dd2f65c345f37961af7dee00bd990c7fc8ca4d5c0e4652d6d0313ddddf539200625354abbc375769ce7c5b3cce5aea73d281f4550dec5fdaf522abd2ca7b8deb0d9ea6c597736e09c84d18612210d09dafc7bfa4c134291a742e7627455b4b9883f85834fc8b42aa8bd86a5267a5595e235f3a2d43d079ff3e2554eb2e5d45370b7d46bfee4b35b6a89bb4161cd3e682ab74d091edf5a91939934ea6828deb895afc4bfdf0af86b435a2880bd8135110dc0f005a511f6b287e132c5031c05e8914e9d26f844cb26829a7d5c3c9cc64db2c2297fc35a8276e6f707ea808e5d83188fe0b9b31217c5c40f96f2bc55ed958db73b80aa28bd914c9aabda4ae50bbd92b45fc282114327b82c2d63a8a091bb0e0c1355e167457ce0638af83ec60396f3b1e714bfbcfd5fbb0ea9d25177b9876fd43403bb03db84052ea8e3fe9d998d819e6acf7433e431fd011e6a16d73ea835affc3dfe57c325036b3a905daa71ae851ba00ff7d2ed45f0ff999d368748f4ab57b8c9cb42bdaadef682c49de8c76f08613583208effcd82af9e5bb3b8843d46d348c4eea23cf50e4cc77bcb213da0dbbf3c964f2b00c70b9a51bd6e379ce65052185f6ddf25e40ad78df75342d8d529c9e2a4dee16e76d5b6e767452792eea3a78eced48fa7aebe768469f554bb29d3a26b45e676b7f1802179126ba0b5eeaebf314bb15cb18ee3a38a5f22d7b830c3b6cd5bf6c7b88fc0ab34d0cde0bc8fd13ab0a30219268c64488a44cb6fc24a8c6da1e5a5258bea003cf27452fce7c8a278cdbcccafab0874f9fe1dd35df6a9c5c5c9791557a59597466ac3fdb206ac43967ed09f6e9d03cec82142acaefe9397284812d51eee079393a92379cca42da4d044a189fbbe79fdc8a71d20c4566da54434eaeb6b7b947ddeea09e4c6c3813121795978ac2e2a6ac37e6923cf523881f8107cb5c1f74b60ef1c64502b8ffa625334760436e0fb541c55603f0c8703001790ca62c21ad1ff78c3d9078857492f6208aeb9956c02e277693987d84dacfb12c1889fb210da092b7a625051b2145de42cf1f3ecabe516402eff729b97479c39d0b3863a181ee41504fdca415abbd13659cb26535b16f0f1a53ac9805fe942ee5bcfabc61bf26b9175d10d56a104bed007bfebea691fd232481f2c7924679923b705334b6022f17ea6c5ff72571cf89eeb095a6dbaf77c190989d2804d8a1f7204a83d4d5a15777e3f7ea699029b6f5dfc31762b1751a52a738929435689823408d077906b5732028cd7ccd55f835ced93a1e95505e0e8518c53f26230da7226290f1bfc4094bd0ca2e31f6fa8300bacc4cf782b7fb3c6b7b64d23ba610c2b7d41c0c4e62d4c25f0aa96d616c09e371480c732b511f565ae06541634ca2170ce0eac117fa286a38f4db2f82c5379dfd273ef048fbb6019a8feb7437072263cc7bffa397e2a9d487a861f9d47f84aa0c7a5c1c9b7ed48e99485914a41feb32c57256fd04541511c9744c95c10f8ff74e2107f8ee6050594743c7ddd8c4e637ac67e1d515c2588de0fb08eb09f627080cd6cc1a308bc0ba5eac653b412b9eecb81751abec1d8ff98ae9803876457f586b4237285c3722363ac856a4118c53fe2725109627b02e0cc5d9326b40cb329c6ab74a8b9e1e616a389a8b9aa26bab69af4e4c9b688ec03f27474c283c2720b157a5081d8db41c5e5e5688b1a210a23d2577d48634e0e30ce3ab3e6f72fd8572fcdec59a6ca7e7631c11b3bc71ee23ded0881338671f60d8bd96bee283d3daccb34c5243b04795ec06b52dba190c85df0b0a8b8f26f9cffd4bc6bbf9fac76d313a5dee8c692a440ce26064d098b9a61f9a9c083a79dbd94baf0b6349f3f189677001ffc117520362ffd7962689d95d09720cf749bfd684cc708819053d68b0c0e2bd086ce4fcb962ccbce8a4fe87c9b23f885006f50c81d78ee05eecf1827b499caac7c6c4716f166ff2d24f6cdb4f505491ac74ff57455419b28ed82cfd484466fd1e34664cf015599aadabaafac3f3ca60399c3e5201aa84f81404b60cee265125e49e2965c90131eaa9c516556de738c73c834e9416bc33f1817e89c5691cd16094ae32a4c8484b57bef9ec2dfcfa4958a80a3da810faae1f1e9e893d4939b5d50f15bc4467d225ebc4578e2130e6e80708f4c909731851fbc62f690ddb403798e067cd8fc75a4ffdbefcb440a97872c0a8b0003d2076cff5ed39349590c5df318e6303454dd82ac3651a618a8729c5f848f2aedfe2e033d11aa4dc1d77a720be95609b8ae17f269eafce6fcd2133fb95789638aa3ff296f49a89de7c90174dd362abbca8d77a428b8352f389bd8fea81346093117ce89150ee938ec353a34dc587f96e5a1282af23b52030f616d237ce4472739b43e09effa8f468a76ce91b9ba04f479ef8f5215e8241e20df89b4c4257899ae013571b6eac5c7580f09cc075881f3eb59666834df5c3fcfc5dfae926e8e0a6bcab8eb187f5583a1cbcbe61efe8e0df7cd0d21d5df22602951840faf054ccf71cc069479dcbc5e3655f686ae62f84283075ed674c73fd372b7ec33a8da0a7f8094dfdedfe3149e6f9e197080f67d67e19fa1bfad62693cdaf6f527b6af9a7f01d9d0a4a62cd4d4788f8d36c1e80427328beb621504c18df5f672ff82842deae4e0c55758fce30fcfc2a752f69e06f179d97089237a7e1e1bd8da7b92acd39118092f6084a1b9956047c4c861a8f5b31825316f644772fbf5d690485974a4beacdcad5fa942cf5e1663ec241091b2eab691e7917647c9b7a66488caa4ae535a008a1424cb7a78bba3940d97a4ca29cd6ef7f256ca904c02df6f1199e85827b2f27f8f304fd60891666758a60b58291f35642051df38b6667fb6b3ae7ff21c1a3c4c8fa7013523818706aaf56497bb5989b0a51e410db312c22fe7ed84abdc3becc750e0e66d117120b467ccd65ea98f724430ccaee0c934c03aa6c830aae34f95c8c7eab5b74eb6fe903df3a7b088dea8714c5a20206261b3a4d1c7d9bfe01b373eefec634d80a6fbc826a9932d54fe1097a273083a29bfa6214ca40d6247342c6efda5d1bedb62125fff1ab5ec69c6ab62af161f05114b8b918dcc7d4bd2071d3cd1f380fc950b2a01975d81ccf708ed207452bf714b720b60f2061bb8c0f1c2d9076d2e2da3949b2296ffe23fb247b1ec05113372d7633c9a31210281abd97826aee4a159bfb83ed34b6ae3fef5032c27390248b861a22ff8b83471a6783162a359568c20d55b5e131153690bdfc4b23b4f776d0f71f87b4d3bc21ff03f6c2e7bf1179056993ea2a237a1f3a5eba2c8c2548c1dbb53377cc050918af21398be6fc0fecfdebb351a1e5d4789cde897cc9cd53a430f745bfc3c698203868d8a6fbc6f9ca6bb2a28991093d3dec6be898668c76b6b711f54c96a7b04e0589b436baab99b889791115fbfe6a9a95a859e9f921b516eb604911fc927b05e8c8701bd4414418b11694bba30aa2557ae860d42257dcba5642e6fa54ba7eb06a1a44dced955a2dc742f45cdf82a0b76ff1d0ec855aaea0dd33234c6ce00b223224a5287c059b7c159a0de028ba0cd8eb181936f42b8fbc2061ee5597fb4d993b0f307f392d22a411ced9e5511480fb56fbb92bad0d3ffd5c71fe7aa49a51ccf1968b84de2928c150f8a0aec8d2f11540ffbcdd5e74ea0b3eb6b73635d2f207ac5cba0bcac647c76f2e0cd49502ebdb7fc13785515cad8e8c90f0ff38f156eed1ec0dddf0f7082c5154620a2c377cf518d66e411dd742fb764808bdce9d5586c2d397033a90461cc3fc3163024f4f2a1be40f908e87dbafa28903fdc34f93be04aa36baac7163d1bada1be7f369ddab76852c03c0b6a59dbd10333b0459f450c68a63c86f6de68d724e5fdc05db3638335e99c4ca39093412b6a4e8ae587fc202e2324ccdadc93057f295da94204ff515b1de712dddec26b330cd8c08b4494b3509cf9df7872ace352ad66892e4c3814a6d3648284f43a91984d9acd95f99c8a5e930c64e480a5236657e8fff59dc0bb3af779dcce1722116c5f7e7fce65d8b87f7f240b122a353626fb67e5904baa6fef53ab8a4494fea1ff0bd0a0c2523472f5a987e7d5d8232bd3c4f605d29f2705931d4c19b4e7baa7b3b3d3b583a517559c5dac895d2ffbcd29dc5f9c6767ffce08dfb047ad03cdd504dcfaf8d8f5befc27b5eb0d93b53a039e7edb950310f379d3d074a87444dea4960e08bf5c28de126d4c87d8ac04048013673a5c006c755af4da7a33d18ebb40d5aec6cb3f6362ad96abe340f233d6c7dccc2ae0ee0c2b7dff380fc340ccfd085d9cf78b701f3a6b45410911f3dc9e6e3fee195ad76fcc084b698a42528fb460998d51bd70b037f50d53ce86d49d9b5198bfe6ff49c442fef2ace9def4beb230fb5664214e08ff7e239e9805a691b06550cd4211331399fcc53669f642c16fe6f3ceae673ae0e60ba980db05edc42ab19d2f0198858969ebc6046d52c03a2cb041c2a6ee1f513336d08ca54ee8a1877cc40d98c406219f42a8f9142ba4ac9fca5adea13bfd23bd53f0742c74082c00bd66ffb4eb8b0acdda9ee02172d790d7129d86175ba8cf332d239e7a9e7314d53c0c290a753e39f76f6fd87442c7ca656acb4c5736e1d244d45ae30617bed99775e3ec4b2e054813f09a52d6f1c35bba138b9d9e2308096901e715696f9dd9e480cfe38b9a16f24c810a70a507863712d1bd94d2bbf348dc222c80517532f9e649dd263edf76bb8bbffeb863025de7e9dcacb61131d25d8c15b8a1fff13c3e89dbeb5881ab629a3df14a8ba1323ca672b6d3a2e7b6c2ac619ab122a7fc921a0cf1334fd8529ed74adbe491d0db65b2fecdbc5b1f04b54577f51593028da29ac61197b6635c24b217339346e723589c70c35d5ed24b7265f041908c60d2325d47efbc9b3f90272bd321a2b042c39898ac5e0b85a59d137dc7a376dbee5672884227252fda1dbdb4d7c3ec1d776905eccd13fe4ec251579fb4caacccf414078a9966b3414ded41c1e3b03b0e21573540641aff48a2399b0a0427ee25e5da11091bd90f9b86547eb32ebe3b3d6104ecdff9ee25bd9d7c27c9938cadfe75b0d02274f518a50bb68149df05b8877d1e8de43d915063a3d75018d40e6c7be894ef445b2eff9e3f771e962070898b821a089d317f3c1e4e1c2f65858bc7948b5ed9403ae5e5c08c3521b67f561bfbf433a4ab02a8ea2bba3d10f8b3639c15e6137adf2ec05c2ab4e6c5772f614c052e8f646f8533f3d2ea6ac3fc6797cb36e803bbc21eb1a946a3b08e9e22ac8b3a54ba463578bd4585f14308848d8880fc00337a42bfbe05def1cc95b1bdfaed29ac60a88f5220cb5b9edcaa1295573e99eec3e09ab794342f749967222f992cb7c75593adf43fb37696d807aa2befdead293cbff99dad2a719fd7d6229c3b50ad88be6f4d01349e9a79784748c7fefd4666fbf6792b4824761a9a9b8a1a23fdb1112c98890e60b8fdbc96e0e20c1ec29336194839837f0b403167c6e112e55f84d5a3ea819c77f3c0c3068dc8938064cc6ae43ffc7d51a8eb5cfa023a0e1ef6e6c663bfea7635c2c1814a9aff3b25cec087ebb647008f4f3a1bf04431a226aef836e410e4ef6ecd90ecf6d16e72e19511e708963cfb24acddd81cd3fd2524ba05b1bca042f24ddb2739cc06a5e10b96ee41f62a55196eb23a79b93675d903187ce23e59708a6390101ab3f27e900cbe296958e90abebdb9049c64ce83c32fd755e11aeed53b332cbddf91375475e83f874aec215c25d7669bfae30644fb91923e70f6be060df7722e4a4e36fa0e329c11b443d78114a03b9231a0b9864b2ff0937d3ab3e9360befe8c1dfd503dbe946353f101e00769d518ef37a03d7c834e4753cd41e457cd5fc8a3b4c5e125472660f18e6200f6a7913fd48b35097e04500a2196109f8f27f3d1b3820c12ef16a3136d745e97e984fa56ae74d7ab85cb737bc9670a907f9101c591a31b4b804af14736be2959a356a7a23bc103e4606e9bddb0bb95767821a7f64af230c0739963768ebb4b4eee750b37d92e5d4aad00114ca491a88e13d79ea834e45c06e7061fbd4bffb8ab7a575f418ea75762f7b22b88ad8e8b4acde203319629a22e8adfacb2449b19a2fa26978e3f9457939c06e7cddabc79b7d0c0717748a5aff007980f4ddedd0b1dc44442d4afef1f2e070f92f340b0a488fdd50f2df1be00e8ef792679fdc2c7171fdae57f36a012badc922e70972dae00dfd0044fb3a9fd41b55eae9e44c672c72a5ae3c0c6723385175b2b0efd71f712e7ffe4420bfd8bdc953cf61f7a351cf43e5a962247854a1e3790f1cc9fcb281a460e6c2e074dfa23d6f16d1d05cd6d077bfa869aaf9701063c4f2dd0a0d90b56b05893ce653f8953d05eed96d2036bbc802278757b9c0f2da7d38a934afb7c9221a716c30b849d5d352d408ea450e2199feae9158d4a0672181a05a60c210e079b9fb941b5017637587bacffb99a0ea69584f64084943b6f1c21cee89cc06070ca947c3f3312adc6cb5d264398def825ebfe65112a7c1b401a4fc69e20eb35c58ff8e7704452f5b96a7d72a92679d116847429fa3941b9f5bc5e9033ba551505728e308e9c91f042ed4d3e904332015e6f4ccb837455670f42ea5ac535b0c279bfdf34ab8ba8c660a3dbc4b723b14291e1872fbd444a1cdb4e69030712fa60187bb0b635ef8ae0b00b52e4b00e09653a0239847a11fd9bb93befcc68d466b4c92533d83d9e987bc24fd3a3ecc294e194c23c329bda099934ea695e316da492fdcf329979324405ba709080ed628e6b88aa9933e4d948c9d911b525d63d96db55c839df78368c07288e2653fe5a44f00b33069bdae3514c993488ffae7207147a833366bf1f1befa4804ffa7dc29b62d3732575af990809438d7109f8b3a4440f48399bba568fb24ef942aa8aa00bbbf15a1e6a850f85ad96ec9ea836bcc09298ce6c2106aec488c35724ddd18b4ac57dd1d16e7703e005dc03b2e8bb65afa483877b53b7680b0b0ed459d3fa80cd6532cfaffb4c3a6d61f6678077d4b1d258630c9ae183629494f08456c63975d2508f72546f071311f29d373e2d0856dfea4d7dc44bfec38ca6891cedee6145e23c46f42c218c34d83b0a4f8b295a8a9e01ab248720407d669dea3393025e71b4e52dff37d7ad3e03895e5662fa5cb074c6f0d8d4ab5f01dc40bb01252707fe7c86446ef0af605ef07cbd9394e62cbb0bb0ef4d8a9c81e0250d6940e2133c5e6ed57462384073938a9b4b210295c1c8e3fe8451280c01284ae8ded609e9f194c8d262f6a2bd3a057684418cc11e33508bcebb5b554eca0ffecf29f66be7203ddb5a524513f9cf6ee91117555b3e0b709e58a8d8171e5a02c064fea90a91a83742051e19c7c0ae361e5d976bed60cbc8866a07c2cfb19d5eafd9bb78bbdf9415174cfc1033b19aeb26a54960246860556e4e83a1d30a18308b8fe6a5b0d5c487dea481afc21a938f1f1269173cff27cfdf9a4836dedb4b66a3366c524cb5bedfdf98df797903623707a00f8ba7358294b2dda6ba48db91246d427d4e6f49c0c45750f3da027699d026100c02b76275d743f147d30dc978364c42d725837595c32dc95b7b44311bd58517c31f6ff78e66ebf475f574a304363b82a57640de9f233f9700634beafcc2c6628ece15126f779fc993a3b7c6ab21dd8adcd2e830e5214ce9cf5357eb6b4fb55f60ff0f3c7f02c64ca1ea8ee60a338c4f9610e304080e8fc763549f35071ce6cede3da0739d3a4f8001232c397d231e805a8c1dd1b111e9079209d21e5617942768616fee6a640b8d4d9f7bc3c52663e5ecfbfc97cb649e0cd075efae20ea8a7eb9a8ee1570bf788fc713785da5adf625092a813e7027ec9332d813017d2d5d6bd3fe8ea2786297e0082595fb3625419a38c221e2599ba3735d57730ca43c96fba84d0ed297b13fc7c7efe2daba31b1e78007085edff1aa3ddb107b3d867535e52bad508a636c932972972fa8fef45061cce581e967ec08b5d75de36784f92bfa99cfb5853898b530e60e44b2e29076bf85e6fd9d5ae78d4978f21a1e551264aadf2c59a8c71493e33757c667c3b9a1f8b5d8e8d9a1b96eaed61e3ed1872d6a1d9a52674c96863b095447983ee8fd0bf7031b155738def2ddb694de86b8f80323031639d72ffd954e3f42144d71641bbb50e3a22b6e1ca321d5ba095ccd397b9a2ad01d510c14ea2e64134e6b3c8073c585015397dcf17bf51407fbec2b68a2cca8676f470ba80153d32d7c3816bc922e4731e434eed4314c759df2fc7dcbc0ca88b61b426c032b19017cf663022042e5adbf8072652461381b82b9f47052df41aea42e29b2f7bb6d2cb3d09588904249768bbf3d7979ba265659cddee29a6841641a453032a2e29e1e44bd226c542488b9f5bfd513e213b72fbb3294ea8617c857810e4b0a938373139b6d580b28364dec3af722e09506ad70f75d80fe8600d8b6b33fd94aa57990f990d3e25e97a94a624fe1d541bcfd26a33ae2f9086d2f1522f173a51fa541b36c5c19f3c0a1edfb4682947a8f3de8cdc14438736dbef0a3f6f208b012afa01ed1d7990bcc40693b13fd8d4be5add25ecd38b9e262c335be3362db170c2912978b309632d7f706f035fa74167f2f2d6d7290b0eb6069dd803209789026a432d48d4675dbe2f9801c294d140bcac1d60fd4e6bfd79ba1fc5a970c874e0675aae884754d52c63a16ac5d5ef3baf96934090584541cf7afff2797e3e9225aee8f3612ac81c690a55248dba8f13c2a53d2b647bf405e5e24e627a4e527adbc1fb3d6c38a8d9eddefc196be0070b1f9955752a21af691434099ece2a5ebca0f50615b5b8a33e83214f32c9dc9f2a0f8e86aa91cfb138dff8dc77071463126178b9829b77cfe3c0e143f87701c45cb4c37386024ed34f717575f4577998491e3e3d0e6864085295378277b009f8f23a4a06d16ca179c4b7aa0d391fd2b71066a915a1e46ceedb6a4121abbffe2c622d06e96223d744ba3375c2892ddbbbc3e5110e1162ec20147a2533542f0cf40609a58c668c2a458b3b03abad45ae408e029dea44f74cabc4184c7d3b1fe91b3822be30987996480eb75e5d09632d6a158d78648b2a00e14ea4b655f581cec7660f6f42bf730e9e7af691ab79d8698e067b36fb0b5255034a4ee3339860a82080f60d4db4ece88fff29fc9f090e654329adfbc42ea1db64f72069a4f3b4f53b1bdf69e729357bf9d1fd14d92ac4ae408b92b1bdc047a7241e9c6c7036bd73665083d0dba830f9ab1156d906ba96eb35658db3f726ff15b611e078dfb0cd1b3d94250f4c8c6ff4192afc95316f196955bd492f2cc319499099ed32a92ebbaf786073d457e04f55a9994eb13be9e4d07125374e57aa22b73fe9149912e1f95278b32e9e2e3b2308ce3e79a20d762d27ec02fe0e243b7a5a34bd985d2fe459f9ac140efdd4c79d51fa19523854c210770bedb676dc3728eba8e8d952abaf327ec172991c601fcde6b724203d115c1824ad41138240b1b9ac3957b0a72290e6de97604cc03eb523798f22fc64d4b00b2d19a942e2839edd97a90f4ab7b6d7538e0d528d7d5a897131a3c5e9d84756276ebf4eae39f5145d433e0297fe9b046e54f7ee11679506300cc76f332095adb1f105a57c2bebf1c7e08afa504a5994a3e225ced61fbd7950860d668dba5045c41d4a6f12b2bad61b7fd5cbc397b991d4dd135fbef3b378e4a9e3ced7d3705fb8345afa708c79e24d4af77b5623202fd6b3d46ffc2ffb1d74d92fe45a47b29f70d25d62820bf8f44d47aa692b92c58e8e09e94a5db1d444ac540cc565c33e0513c5cb75bcf4ec3851f12142f87109f656cac8187ebb4b4427f5ca1ea79925f7717586c0087f76ffca6ff2eaa57c0f4ea319700ce2377f4ab5181718b03a59055dbe00a012a2a2c58d492b97ef0eea7149d25f346368c5152d6b0c3c77639a99ca1d6a17208f564f1650953d01a043b252d3ea8930b8e012175ea9e734e9e932bb803fc35bdde65180c1d7c1d9ace27e090934977d3031b51fe187e790d51306e20107c30a4b27bc98991a81192669371b4da9afe9fc06b6651421252fd914003ef76bb2cb8c98a49ae090461c5bb3d04fe7009abf1acb2b51b9f4762500c2da26ca95e002d9c06a80853c7c2ee241fb993693d2b51451d17aa8fb3f76cc69eedc5d426fff5e24252c1a39a7079379d007a63f17bf781352d3ae04d510d97ac3a22799f0c3bd7710b366fefe1473a61ee18836060bece1bb2da87536bdadb2f71cb795001d071ba27349f9eed726b0dc217d7992659128686b62332da0991f198f44c6540f1eb11f47088cbe44a2cd6da4747415edc8db2c39b2a55ced7c6dc33b0a267b03c535813b8d98f7928b5838d995cec9db82405fff68f2fdc603a1d8e4d428f57d79fa442beb82490c859ee86d108c4d7a091c8c945d92b655069e4908930db4e14d61a013f8b7614dfff39276c4f65fe826d1e2a62305e1fbbc8ae1d80493e3dca4a114fca6efac773aa311d1b6f7159cad0f8e49cca6f78139c8604fd371d373f98bc56dd9088f22d9deb0faa17ab9ac1cd4b7b6dd6757aaaf31aceaad55d38ef27d190be76775b6eac81ed8290facf367da39532cca453201e288bcd72fed12a863ec1b5fabe7abfa66504f9d42530a811a3bb66b36142b0b502fdcc87171330deba44cb179aee041fd95b19c0e2e93e248d5b7eb741efe4e25812382c26fe577ff813bed23869261d3f985141156fb1a2605f847af853d0c8dfc432c1c25c5 Hey, password is required here."},{"title":"静态网页搜索引擎","date":"2023-03-29T17:00:55.000Z","path":"posts/2F3J6A9/","text":"背景提要 在使用 python-mkdocs 生成内部文档时, 其内嵌的搜索非常难用, 奇卡无比且不支持中文 因此萌生了写一个简易静态搜索引擎的想法 搜索方案 常见的搜索有两种实现: 接入 Baidu, Google 等搜索引擎的爬取, 然后利用他们的搜索接口去搜 适用于ip公开的网页, 好处是搜索快且功能全 坏处是, 不太好做输入的实时预览? 静态搜索网页内容, 适用于个人博客、内部站点 本文讨论的就是这种方案 实现步骤 解析markdown语法树 按照一定规则将解析结果写入Json 实时搜索时调用fast-fuzzy搜索 html前端展示搜索结果 markdown语法树解析 借助 python-commonmark 实现 import commonmark \"\"\" MdParser: 解析一个md, 返回所有正文 \"\"\" parser = commonmark.Parser() class MdParser(object): def __init__(self): self.visited = set() self.content = defaultdict(list) self.all_content = [] self.head = '' def entry(self, path): with open(path, encoding='utf-8') as f: string = f.read() root = parser.parse(string) self._walk(root) def _parse_children(self, node): if node in self.visited: return child = node.first_child while child: if child.literal and child.t != 'code_block': self.content[self.head].append(child.literal) self.all_content.append(child.literal) child = child.nxt self.visited.add(node) def _walk(self, root): for node in root.walker(): if node[1]: node = node[0] if node.t == 'heading': self.head = node self._parse_children(node) def dump(self): content = '.'.join(self.all_content) # fix special character content = content.replace(' ', '').\\ replace('，', ',').\\ replace('!.!.!.', '').\\ replace('\\t', ' ').\\ replace('img.', ' ') return content 生成数据search.json Key Value title h1标题 text 正文 link 跳转链接 如下遍历一个目录下的所有md, 并将结果写入一个json, 供搜索用 import os import json \"\"\" MdWalker: 解析路径下所有md \"\"\" index_output_path = '' output_path = './search.json' class MdWalker(object): def __init__(self): self.output = {'all': []} def entry(self, folder): # read index f = open(index_output_path, 'r', encoding='utf-8') index_json = json.load(f) f.close() # walk *.md for root, _, files in os.walk(folder): for _file in files: if not _file.endswith('.md'): continue path = os.path.join(root, _file) md = MdParser() md.entry(path) file_name = _file.split('.')[0] index_info = index_json.get(file_name, {}) self.output['all'].append({ 'title': index_info.get('title', file_name), 'text': md.dump(), 'link': index_info.get('link', '.'), }) # dump to output_path self.dump() def dump(self): with open(output_path, 'w', encoding='utf-8') as f: json.dump(self.output, f, ensure_ascii=False, indent=4) fast-fuzzy模糊搜索 借助 Node.js: fast-fuzzy 实现 使用方法直接看文档 html展示搜索结果 考虑复用mkdocs原有的前端框架, 或者找一个带滚动条的容器 采用这个html样式: swipeout-overswipe 其他问题 参考这篇: Node.js (站内文章)"},{"title":"【OS】调试理论与实践","date":"2023-03-20T14:50:57.000Z","path":"posts/2F2QH5R/","text":"牢记两条定律 机器永远是对的 未测代码永远是错的 Bug产生原理 代码错 Bug -&gt; 程序状态错 Error -&gt; 可观测错 Failure 代码错，通过阅读代码发现是比较困难的 程序状态错，是可以通过状态机（断点调试）一步一步定位出来的 可观测错，如Segmentation Fault、如Wrong Answer，是发掘Bug最主要的途径 因此debug最佳的方式，是 让Bug尽早暴露出来 二分 使用assert 使用print (注意是debug环境下…) gdb 汇编（四）：gdb调试 为什么gdb可以暂停程序的运行? 一般的debug都是利用 软中断，即将系统调用INT 3 注入汇编代码 明白此原理，可以自己实现一个gdb调试程序! vscode断点调试原理 现代编辑器（&amp;IDE）为每款语言都实现了一套自己的debug工具 如 ptvsd 就是vscode对python的debug工具 如下main.py: import time while 1: time.sleep(1) 运行时需要加入ptvsd选项，默认端口是5678 python -m ptvsd --host localhost .\\main.py 对vscode的launch.json加入如下配置: { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Client: Python Attach\", \"type\": \"python\", \"request\": \"attach\", \"port\": 5678, \"host\": \"127.0.0.1\", }, ] } 此时启动vscode 的f5，就可以愉快的断点调试了!"},{"title":"【Shell】oh-my-zsh","date":"2023-03-20T13:01:52.000Z","path":"posts/2N8EPP4/","text":"NOTEoh-my-zsh 是一款具有高亮和丰富插件的跨平台终端 已亲测在Linux、Win10、MacOs上使用 安装 需要先安装 zsh：sudo apt-get install zsh 官方文档给的是: sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 但是这个链接可能会被墙，因此使用国内代理: sh -c \"$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)\" 接着执行install.sh，如果速度仍然很慢，修改其中内容: # 这是旧的配置 REPO=${REPO:-ohmyzsh/ohmyzsh} REMOTE=${REMOTE:-https://github.com/${REPO}.git} 更改为: # 这是新的配置 REPO=${REPO:-mirrors/oh-my-zsh} REMOTE=${REMOTE:-https://gitee.com/${REPO}.git} Linux的默认shell一般是/bin/bash 可以通过echo $SHELL查看环境变量 设置zsh为默认shell, 重新打开shell后生效 sudo chsh -s /bin/zsh zsh插件 zsh插件基本是通过.sh实现的, 通过编辑~/.zshrc修改: 通过source ~/.zshrc使其生效 plugins=( git zsh-autosuggestions colored-man-pages # ... ) zsh-git 这个是默认配在plugins的, 会显示当前的git branch, 如图： zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions source ~/.zshrc 会自动根据历史、剪切板、推荐等补全shell输入，如图： 注意，右键是补全 colored-man-pages 彩色显示man，查手册非常有效"},{"title":"VSCode","date":"2023-03-16T04:52:31.000Z","path":"posts/3HCBFZ8/","text":"涵盖vscode源码、插件、使用技巧… 其他站内文章 vscode 多种语言断点调试 源码 github: microsoft/vscode Windows build 限制node.js版本最好使用: v16.19.0 安装yarn: npm install -g yarn git clone git@github.com:microsoft/vscode.git .\\scripts\\code.bat yarn watch: 任何源码修改会自动reload Linux build 还没成功, Linux谁用vscode… vscode 插件 推荐插件只有如下几个: Remote-SSH 远程连接服务器开发必备, 太爽了! 建议在其config中配置所有常用服务器的ip, 别名, 然后直接在Remote-Explore中快速连接 Bookmarks 快速在代码指定行添加标签, 方便跳转 推荐快捷键改为: ctrl + →: 添加mark ctrl + ←: 取消mark ctrl + ↑↓: 跳转 Live Server 网页开发必备, 快速其一个本地的server 自研插件: vscode-function-decoration 博客 | Github 为Python函数增加标识, 以区分是哪个if包围. vscode-markdown-snippet 博客 | Github 提供markdown的常用样式插入 使用技巧 0. Tasks 自定义vscode执行任务 相当于快速执行某个bat/shell脚本 1. 区分顶部窗口颜色 当work-space项目较多, 可以在setting.json下作颜色区分. active代表选中, inactive代表未选中的颜色 \"titleBar.activeBackground\": \"#583e63\", \"titleBar.inactiveBackground\": \"#583e6399\", 2. editor和terminal切换 作为VSCode terminal的重度使用者, 经常需要在其与编辑器界面切换 推荐绑定ctrl+, 在Keybord Shortcuts配置如下快捷键即可: { \"key\": \"ctrl+j\", \"command\": \"workbench.action.focusPanel\" }, { \"key\": \"ctrl+j\", \"command\": \"workbench.action.focusActiveEditorGroup\", \"when\": \"panelFocus\" }"},{"title":"【OS】程序与状态机","date":"2023-03-14T13:27:35.000Z","path":"posts/22MGG22/","text":"先理解两个概念: 程序是 状态机 程序 = 计算 + SYS_call 如何模拟一个数字电路? 假设有两个寄存器，X和Y，取值分别为0和1 每次执行下面的动作: X′= ¬X ∧ Y Y′= ¬X ∧ ¬Y 则对应下面三种状态的转移，每个转移对应cpu一个时钟周期： X=0 Y=0 X=0 Y=1 X=1 Y=0 循环... 这就是一个简单程序的数字电路视角，下面是C代码的实现: gcc -E main.c 可以展开宏 #define REGS_FOREACH(_) _(X) _(Y) #define RUN_LOGIC X1 = !X &amp;&amp; Y; \\ Y1 = !X &amp;&amp; !Y; #define DEFINE(X) static int X, X##1; #define UPDATE(X) X = X##1; #define PRINT(X) printf(#X \" = %d; \", X); int main() { REGS_FOREACH(DEFINE); // 展开: static int X, X1; while (1) { // clock RUN_LOGIC; // 展开: X1 = !X &amp;&amp; Y; REGS_FOREACH(PRINT); // 展开: printf(\"X\" \"=%d;\" X) REGS_FOREACH(UPDATE); // 展开: X = X1; putchar('\\n'); sleep(1); } return 1; } 示例代码: logisim.c seven-seg.py C程序的状态机 状态 = stack frame + 全局变量 初始状态 = main(argv, argv) 转移 = 执行pc处指令，pc++ 就是这么简单！结合上面的代码更容易理解。 模拟一个C程序的函数调用 hanoi-r.c hanoi-nr.c 二进制程序的状态机 状态 = M(内存) + R(寄存器), 所有能存储数据的东西 初始状态 = ？ 转移 = 执行pc处指令 程序 = 计算 + syscall 最基础的main函数都是通过syscall系统调用实现的 假设没有syscall，你甚至都不能让程序返回or停止！ 如下是一个最简单的没有syscall的C程序 // main.c void _start() {} 可以通过gcc -c main.c &amp;&amp; objdump -d main.o &amp;&amp; ld main.o的方式编译链接它 但当执行a.out时，得到Segmentation fault 尝试用gdb去调试这个程序，得到汇编如下： 0x401000 &lt;_start&gt; push %rbp 0x401001 &lt;_start+1&gt; mov %rsp,%rbp 0x401004 &lt;_start+4&gt; nop 0x401005 &lt;_start+5&gt; pop %rbp 0x401006 &lt;_start+6&gt; ret 下面将打印每步执行后的寄存器和堆栈的值： 汇编 rsp rip 栈顶 初始 0x0001, 0x0000 push %rbp - 8 0x0000, 0x0001 mov %rsp,%rbp pop %rbp + 8 0x0 0x0001, 0x0000 ret + 8 0x1 0x0000, 0x0000 最后执行ret时，rip的值是0x1，这意味着要取0x1地址上的指令去执行 但是0x1的内存是无法访问的！ 因此报错 segmentation fault 课程资料: NJU-OS2022 jyy ppt: 操作系统上的程序 b站: 南京大学2022操作系统-P2"},{"title":"【Slidev】基于Markdown的Web-PPT","date":"2023-03-13T05:08:37.000Z","path":"posts/2CQGWAY/","text":"NOTE slidev官网 slidev在线编辑器 slidev demo slidev是一款基于markdown语法，基于vite/vue3搭建的开源powerpoint工具，它的最大优势是可以部署在任何网站上，以实现快速、轻便访问目的 使用 WARNING下面这部分看官网文档... npm install @slidev/cli @slidev/theme-default npm init slidev: 初始化一个slidev工程 slidev build: 项目默认发布到./dist目录 slidev: 默认以localhost:3030的域名进行预览 演讲者模式 使用http://localhost:3030/presenter 可以查看注释，并且能同步操作另一处ppt的显示 todo：此功能无法用于发布场景 VSCode快速开发 插件：antfu.slidev 如何编写自己的theme? 所有主题开发遵循npm包规范，且存放在./node-modules 通过md中theme: default来指定选择的主题 为了适应公司内分享的ppt需求，特维护了一个slidev theme: 🔥 slidev-theme-beautiful 如何部署到服务器? slidev build会在当前./dist下生成所有的依赖资源，./dist/index即为访问的ppt主页 需要将./dist拷贝到对应服务器下，就能通过浏览器在线访问 slidev build --base './' 防止以下的路径使用绝对路径 &lt;script type=\"module\" crossorigin src=\"/root/hexo-workspace/source/assets/index-aaad8f94.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"/root/hexo-workspace/source/assets/index-43f0699a.css\"&gt; 编写规范 全局配置 相关配置可以阅读源码：💡 config.ts 官方推荐的主题：themes 合集 theme: seriph # ppt主题 background: https://source.unsplash.com/collection/94734566/1920x1080 # ppt背景图 class: text-center # 字体对齐方式 highlighter: shiki # 代码高亮格式 lineNumbers: false # 是否显示行号 drawings: persist: false transition: slide-left # ppt跳转方式 矢量Icons 借助 pictogrammers 实现ICONS自由: 先在官网查到icon名称, 如unity, 然后在md中插入: &lt;mdi-unity/&gt; transition 跳转 fade, fade-out - 淡出 slide-left, slide-right - 左右移出 slide-up, slide-down - 上下移出 class 对齐方式 text-center: 居中对齐, 一般用于首页 代码 // ```ts {2-3} // 表示从2-3行高亮 // ```ts {2-3|4-5|all} // 每次显示不同的高亮, 2-3 -&gt; 4-5 -&gt; 全部 // ```ts {monaco} // 可以运行编辑器 主题示例 一个具备图片轮播的主题 github: https://github.com/godkun/ppt-template 示例: https://ppt.godkun.top/#/4"},{"title":"【Apache】搭建文件服务器","date":"2023-03-09T16:17:12.000Z","path":"posts/5S5T02/","text":"概要 文件服务器: http://110.42.228.178/ 旧服务器地址即将到期（2023.6.24），已经迁移完毕 apache2 介绍 Apache2 又称为 httpd，它是一款开源的网页文件服务器，由于其安全性和可靠的跨平台性，被广泛使用。 安装：apt-get install apache2 启动服务：systemctl start apache2 停止服务：systemctl stop apache2 重启服务：systemctl restart apache2 Apache2 配置: 配置文件：/etc/apache2/apache2.conf 字体配置：/etc/apache2/conf-enabled/charset.conf 文件服务器的根目录（默认）：/var/www/html 默认显示 Apache默认展示的网页是 index.html，需要将其删除。 之后添加文件就能在服务器上看到 内容规划 该文件服务器主要用于存储一些文件，以方便在不同机器随时访问、以及起到备份的作用。 大概分为如下几类： pdf：一些书籍、资料、ppt等 tools：一些工具的安装包（支持正版） … 疑难 软链目录 /var/www/html 目录藏得太深，我们希望软链一个外层的目录，这样更容易修改和获取它： 先删除 html 目录：rm -rf /var/www/html 新建一个软链 到 ~/apache：ln -s ~/apache . 改回默认的 html 名称：mv /var/www/apache /var/www/html 如果此时文件服务器仍无法访问，这是因为需要为root加权限： chmod +x ~/apache 加密 为用户 luhao 创建一个密码，写在passwd中，后续会提示你输入密码的 htpasswd -c /etc/httpd/passwd luhao 接着在/etc/apache2/apache2.conf中维护你要加密码的路径： &lt;Directory \"/var/www/html/to_lock\"&gt; AllowOverride all authuserfile \"/etc/httpd/passwd\" authname \"luhao\" authtype basic require user luhao &lt;/Directory&gt; 中文乱码 todo，这个还没解决，文件名显示正常，文件内是乱码 美化 默认的apache网页风格实在太丑，推荐如下一个GUI框架： Github: simple-apache-directory-listing-theme"},{"title":"【日志】2023年3月","date":"2023-03-07T14:54:46.000Z","path":"posts/2023/3/","text":"b3dc07a81f6459d120ce338ccca55046116de9af7135eccfa9c61a82756948fc2a685033db839f342fbe3644f374a32778c751268c2722fcafa2a8f38511b56b78650e2cce932aa4eec25b1ef8bafcbfabf65bccd0fd450c8916126348c073c8da6394e16dabb4b5f1d7d49bcb675c654780966c4fc5f7ccbab6211ca668430e1ce67aee0ad4ef92fccefd194f2db6a6c81f7f130b9319631be3985720bf86b43a699748bf0896a9723e84f1f705e194b36b64e5a798155d83cb93a3433d15b33d9b3110bb38a7ad6c993db506d0a32ca10552f04fbadcce3fc8d2741850632243eaab632965c432e22f7c1a4916290b50a01b46b61cafac5873b9130a52daa3356fa546e113bc5f4a89970b1534b3bf425a14a9015e051ade2835d72d57a3c10c4031ee129fe4b3489fb22cadf33f65f40c8deb3db456ca911940431d3176302c5043f2c0c1c3c70902bdf9748e24df71fcd9accee6accfe9fc323ac423a4bf290452d768408e68dc140a28665e7b7b74bb5f6c1c5d9a94bfb53e01810866d8e7d27640b9e5bc86bd4308d7eae057e70df0faea1bfb25113f2f78404e67dc1ff1c8e44e2d757951b0e3382f7bc9307bcce71e3ea6fa2bad92ce1f239c3d2d5d355972490e0ce67f5fe4f548369ee756a347196266e8d56dc5e128e05b59fd1d843bcd1e045a2fa4e6abbccfa88f586e305b6690f9315dd4f74ad3f6ff7ae4bcf3a2a03d18700a396d40b38a513cce6afffc5ccd4c38bbd4428780fa06ac7397d0650450abf305ed91b8acc6a111c881148cb17adc2772b9dadfb3f4e791afcf88ee948f0d55c5b91056fb5e9ef19837518e97ddf8981c2c3c37eede0446a40875d509bdb1ed0f26b051903129e874d14514d8e18d64421a20e786db32e205ce9338fa88869960ba2512b515fd395b2cfc1f72ccfe768f532307de62863f496d6190b19815699cfaacf0a9d3eee9e28c396a9e5bd7991cb5a71e3d5efc250cf32aa19c82e6ae5c850a4d94c6570301a8b9e2186c620a808912da319f8496b2d6acc6418c9d79d8d008a2209c901fd19f3fb927d7e07c6696c9bd55d1196de36ad8a4db4cfee2acc33b85c3b53ca20725db7b0c358f3927dac7e75d5f48e82e6116eb3425b3bf284ea9fb60ffc43b171995ff8139551d93cc1cf2d1b3c98f166219644c699cc22662e766a0ecdaa42ec956e1f48debc0b48526dcf6db5ddc025931f1317a8c522f6d45017e36bfdadc5183e3467c960f3db80dc70f10b6dc3667c6c7ed0b2a3e03f0c4d3300edb5c2024cf66c90391338c0d7321fe73d17386583e31bca4a838aca381358604062e5fb26f8123550a1125a61a979c253a3a317efa22726b43142073eeae5126432f1dc4b3f5193415e691beb32b071305a7dc5d93562dd908997364813849976d8e7ca46801a870d90b9711cb065109b00f6c6d6fe4379f735f8d0904a786a187c247249b72e367d822fcfc97e17c0e3fb853fd8478bb404ab1a6a62414fa644ff1a661298473cfcc51ee729e1a5fc989c0f4a354442efc89cfc492643c6e5cbbc234404a7d5673bd0a7cda0617ceb9772189ed5658f025b7a781d3504d2aba758a5c29e7d5f473f0588e46c6a903bb068a384e6fc153e3d2163ac443f4066a913a8dd8c32daa088d0668abfec75b242d90dde0b97bb2a3a6683ed25c8aa695b551957baf638c5f7c682e1e2d2e51a48312789d7fbc64ae2e42323bc6899cd8bbbe0dca54dd4244e37797133a90836284e1e2ae547e316c0c0b333eee20d837f8d5abf3f7440e96ebde8219f2b34322284f9593dd2e5b22f1db74a103ae4f9e70f08b1ad1f64a1a448df8c768bc9867ba06e6dee4db18282ff447d08f4a38867145645beda234be1b4edcf6af90f5226d67ef8eb9b53eb197334634f3e0ae02ef4c97bd0965c173c1d6dfcd5955e9a027f279b86c5e36485620537877c5b33c1c917c13045c903943243034aa3bd744ecd9a726726e90b1c776fc0e5f2a4e412ceff0eed662ae057f02d584641d4ec931b4f28bbf2b809e0902259665cfe71258ba80f77a4d54907f5aa1723b07c3bbb9e5c5b968f587da18c9eb0ff58fe448165776bb1747c0ce1750f09ba3a355a1c54acec5ab3f70a351ffdafbc816b50a23596bc6a9fe8bd3b928c055d2c7e0d49cf8336deb86a35586345f68b0fd0c2cc71c85c57f64d5f11bca6db134fd68891977e79f8131d707d2bc210493bce0a5ef30818d388cae4953616b06bd2aeb06c8c4770588582eb488d9a6e51c7e85291f969f7fc45ba87bb73d7d0b0797453d4ba718efab30f408e7081f37c8f26f28e3feb4addabd050aa26922f7f747b0ef5a2a188c3cf5e16c9a7b725157e98e2e74d552924f8dfe6226f1d2f9b38ce9c4e7acf86a160a29f326be89b36f8c082dc517b0e0a5bf9202481b5d2ce14ec14da4b48a2b12681eafd363491bbc06e3ff9e25f01c828446ccc6633afa6f89fe2e474cc53777a0a9a65ead9217169824923b8b5e2bf73fa7da63516b542f84a996524c9f213399dc3254001c01df1d1729c7f451c1ad8558d1913f2c035e6a28a2870a502e09b6fa92181cce3f8b437bc993fb9998d35a4d1142282552c1f215a60e74ea9833be1ab34e4736ed6e6d9af67e2021890500e32dcefc4610b33cf8f2ede76bca09ca8a3b3779b78082da4f384b80b149a018bc11f3ccacb2de14a366d4e9bced5054d534f2fd774eb9df5ca2380af77f545b67d64fd8afc1e7db4b4a2130784cc1958c4f5795943f1fa21c3c0c555f1f17fdcbf71a185fa1bddb229dca738900661cf9df76842e428b74f45f47c707c4a3935f67f017f13deea1c8125da3e5b6692a6e9dc4dd72697c572f471e983e0e0d911bba75fdab2aa00e86286b3852798bb7f1ed9021531488913da4c4eb633e08722fe7a8c5cd3bdab3c7e38e21156453ed0d41452d2bfc10964e62c39e7defdd50598d7c77c53a3560710c6061440cf38d301cd89d5dcf21cdf441b59d68f75cbd3c30277b4dc2b91043d5c776599cb07f7eb1f379215ce40326a0173b2b59935d7e9bbae5e97232f255e4a280ae367995e76e91b9f0aac2cfe31f190844d13c745229a66d3073da7143ce33c0f3019c8bb0e3af209a817e0d619aa679cd358d16f39a2e4eaeb66ab66062b0ac1691cd275da2bfa11abb471c28d984f581c02c156dae243fa4aa6b09d53e7b13c4521fa7d0a9f914ad3995147b0ae239535dbe4e94caf2dc9cf2bd4a9aac6db36caaece65d695b3f55cae60505865de06be7cf43984e3eae0855afced8a1eba18fecc206e0589ffb3f8e25d43f9fb67f3336bfc39ce9b686b800d18299c0506c4aa414a3b89312f0b30d2539b698053e00ccedb7b4923836a7afcb87b7efb88f80e5362c8fbd75f4e0a6cbaf6e8840ed27d002be7ab3fc06084efaed7cb430ecfae1b2079d20c6432d21efb2d2d208c8317f66ae0f9c3d0f08bfd4680eb1b2135272d633dbf61873f0f84f2577ebdfbb5242dae268776174e570ce541bb8815fdca426085849cffe76d8c33357c3ecf47ad5079fbc7b125f8e6da5cf4eea0677a4f6369d7cd9d9d9b799401746751a55f72cd3d507f56e5520e8e1136df016c94faaca7c8b6e469a183aa2807818701dca2654deeb39f9363a6066abc89f06f075fce3fb3d25df744af1000edd5c02ed3f3516043b1afb71422b086fdc9a7de284270c9e28d525dfbc455b318bb6f2f4525573bf1e30d05cfb313d1886e5614bed6ca0139906900e0014553d3ab215b5bf13c089a0840354752ba3b963f5cbb8c95cb7aadb49e399b4f816aeb3a55d292f077046671c683bab21a0235bfc242a33acc5bad603ce94895d6e31d61f99fcad5143fd469d20b4bb30b8a7dea62bb64b9bb6bb51bb15c54989e60cf8f3b96a27111d08b24cd47f9e0f4068d46c506393001144c6e7487cc36d990e380c1e5de790b45a3d1bbcddf3d61be5fcece5dfea14765e4eac5d796d4fa376ab448337f909f7f7c3061a83a885d2dc11d5308f5ac2f5bd0cdd8f2cf2d92814d53c2ee8324969e60399dd6d39b79a9cc93f4b1cc1131bebc9302d83010b850e3da81a9e43e9dd13e22e944eb033c7abed65778b2634945078cdbc8137aa43b3049cbc3945f2521d750451982b1e22bc4f9990ce90541e22625b2cc8e7e647c6cc84ea9699f81a6d208f8b64d4d6ac2a6b68ead48706711a4cf40ea6fc0061a9eb58ed092fe703aee6e83df638138e02fe06d1e0b2cf4167aa65a5fc96dfb585a885bae094098dc7b92d7509290c46f27c75f7d7f2f75a819e312627e1ff38839ddc1d1fb97e308eedc335719dc55fa2f340d5ceed0e48f42d3cde44ed38e347063aa79d789817a59eb768bbd75abc9ed721bc8e2c7c3987582078da920cd82fee57f8cff1ed250aceba336a413aeefe0e3c9b71294b2346bdfd0932f69a95923364e9dcdbbe26633132736936364c72b30a229810ef6483a3b8621768b6e2d138452945fb57227772d10a6e7f363de532a25f01bd8b4eab5bc963a8ebd2816aadf83bd8f33e662183292bc9bead5b0a8bf42feac4df957defba50380c957243ee48598e7d13f7c2d4ef71a2cd4e223808493857a7ebcc5eb10a26baf09c306d0e3697e02048bf76330ad34adb464f5956ccd2bcf562a6c09664b467394b2066e4910e3e2fbcb4f1ab7b1c50223ef90acac5a881c6a7b76605b5724af032503cb4ed3e56ad28072afd7495ae9983e2c97bca6127cb767bf7f86d1944445cbc0074051811570c8cd386a68d154a1eed49ab8b1705677964bfc5c0d9ab10e0f27cf484a7cde722febda3f0b0e38d003e26311c294313ad5cccd64babfaf6184d43c19e75ac9c72ce9d49b3c47a199347e73cea06f0e639eac0a6e09f98b7686d07424883572561be7908960ac01593e8a59f3fb5916b343e9d76467c628fd0f6f3895a78e7b8ab9581a8a1c92b61a466f83d18442f91fc07f7ea2294b0be16cbc527ea4f90120cc50d791f28be374babf1e7729884a22f18690fe92509ad8aaf944a8eca19aa674892906dc1cb8ae41e4cbf1055e94840e71eb2f5992298d45bd32d78aefcb678221f1f5542176f8d76949bed21c8b2ebb2e0139128155dc96e5bb99b828416d8470cf8ab79b87ef5c162640c9e0b1c971b4b4d4383a46dbdfe3838b9d719480c37f696c1eb9c08c586dad326190c2708a3686503762ee5ca613006efc6a33eb57482f8339ce3ffd0596634943d8e3269243a806b48ec3eac7d3ef2f11c97a968c3feb9e634021edbff6a09d55748af4845fec96618e3fd4bc2c1ba4ce14399c14796addd1c9d820e714ad16d5d32597de20838d3b354d19269fb6ea586ea1bdb43e8f727867e87b5d7cf60d7dc74221721420d3c65931d292514b5157c2e63a570133ae2ba1b6cb6677c709c6be3650998fb49be85adadd0ef5fa5e1dfffbbb82ef83c316f576553c28b4322f30469dd41fd811354da276ca78715fe414ad38eda1cd86cc300338f014e6dcfb164bd1754e17e12c507466041af96384c770c77dc7b6d46a22e42b9f06df9a10c4e9459fe0533cd7d5dddf1bf2614e448a5d23139c74461fe72f14a98bb487dd57f73f29eb0c5e521a1ea44c09dfc5c23f12c871b2fc04b6da9b80e8ed13e3901539fc891fafa1eab0f5746dd69f6313bb288ea4eec3fdb95a5db7f9fef7247508c2fd8d7ae5abd80a6b3731abc4b05e3d9d19525eb9339c1c33336b640030caf8c28722814c67b104c6a6a0b05067e2fb6fd1976e1eb68c08caba75f9a24cf1d5c84e3cb82656e6a84ce09a0542605558b765bdf54e6a4aaae4414118ded3718b61ea492f0fbb664ad96af9563dd6a8abac5611a069f6beda5a27ef31545844adbd66b1f493c30dba3ce9f4e1175bc41a2828e9fd27277be5a3d37014bd41bdbd6fc7ade9be91e02f6b4e2680880301a03537cd7c74e0f6123c03131a2eb8de0ca0bf457f9c1ecf737b66af42998cd9d4f9f587bae317638057ef1870315be2f298a99837ccf9285e5597d69cf52e904143cb16bbb0630892f0e84ffda1a8a39dbd7abedd72d562df3085b6c5161371dd3244faae7df584fb9bf7147de739c8b96e47e939c414b5fda9cbcaf3692f4eae861d9c89747eca88fa46fb99acd4e1319c6e62f393fc680137b76fb436813ccea42ba185cb4bcbe5f99cf270bc99bff20ab5ccf4b3c6b709e78f2f04be946a798c54a8ab8b9d475c85e2ed4c1afdcbce2374ddc9e155f853fffe0bd1e1fdd01f6ec5e2925e12f3278dafd4550e4f179c5551278fc66d84682b2720f1aa26f01f012360e384068978df7a64fc96f3e4f8b1b81d59f1e4e63aae604b5069055d66cd2c9ad5fa8185f2587a2a4a38784c5fd161f25a12dc58fec2600d5d3342c2b6fe308c99672705c9e4281af62df2b4a4281bc87503a561835fd8fdf20b80ad2bbe9204da3f6faffdd4f3dff95cc113ff3bad3eb1e86f88f817770823c8b632ab918f5952f4300f10117d34808213c8238fb6edf0ae93eeefae112006d990c1bf9d2eccc81054b5c8694729bb3ca3d3bcc5e52cd6edae35efa9a177be42657b637d0d3bc3de23fd983a60f05e5e41ba212112cb7ca484ac1c54c58d915348c691c81c40290bd6c881ba8ed438a5375b0510361cb5a2ba8ba4ec1233873a669a89fb8b67daffb4ec2fa2e053afeca94bd2017f76c8ea5728e6158ee1db25bbbd7d317a20ee8fe87e635cb53783bd82f5bbec4465f002017688ed9a9b5fd051b366fdef1eebcd2eeedd5820d8339adff87bc1c5ad4b29e2d90bc9f4907dcdcb653e4b60d9737d560a76962f1fad2b834fb0dd90663e49ddafa0b1e7a495429aac7597f72bdef2c1d30b15f0325df918c1779cdb370dd62cd4b8a15b2a2394a28fd9b2d8efa79b6905e7ec2896d02a56d4e502657be8ac434d84f01cc336dcdb2ba3a2776738a16f48feba21a39cc17c84dd5ddc533874a9fa2fb510e18c6468a055b2593967d89dc13da1a20acabb6f31cd62f68aa1a2271b7f082ff23e93bf2cd217d6d14a6b80694055c06808c1556355c615339d5a67d5068e042adfaef0395869fa3ed245447fc0a31205bea8026a53317490227a2a8ed5036b5931171832de1c52e65157ddffbb4d5df57de2afebb453f9606f97845544c7de33807812afcf1395ec510665a70a8075d8ddd75e21b37816bb4478a3c3270c7d73448efac43a599f6178a64fe3265673aff3a380c6102c0620ab4a43957d8041064bb67ed7303b28fbf8d24c1970666be1adca34d11f1660444f881053d037a9019b9f476da48186ba02f2bcbcf770256245a85bdb1e048d4a3aa4c7fbf284b315a2add757ca00e5e60dff1d530e3edcdacacb9ef9c36910d87640417723fcfba8c1138c7713291a22348646ed2dfce33365f8385dcfc812607857e74ba833d5bfdebb91108dcb686be47ae038a5fd6f294f8f895c8f9e41f21edf91af6ad189d9d0a26e82e71ea88e0ade2d42803e27fe43ce1e39183f7b585b11428b7a5604512bb394be9f63ca91189c902d33cac5f06c8853ae61381d9cb05f00dfd78944e12f8d09195ff9061970c6f4e445a5b00ec6984ab7c6e62b497ff4cfb1bbd465f0998b8d24368ae00c06fa9ec60f6e0f6e3477222642fd7f78c1774cae7cad8df11069503d36ec2499bce4a0e6578cece39f176c39056701c21fb8b57107a234ac5e092096ed789fdd4cd65f6ce4a54e9fb31fad6862120f5fd6535c48404c25650105ec77f26eb1b9e21463c33181dfde995eb031aa3e229922f14d8c3637f78fda88db3640b50a5348aaf049489193067c53980bdcdf9cb88422f38c30532a8a2f3c5a0ed89fe7a0ed564623fbd0029452eae39e026aa6822214e93bebb90da7d18b497f8b89088a19a6235d86518a21b0a778b42581da018cf50eeb938d826c0bb65f5a147e64074611d5abbdac03f1221ddc6dbb2221ece9634a710224dbdaad01abee03db0797414b9de51f2240a293587fb01062e117a47b37fdfca68eb31ae778cc581b6554b8add2e43d20be9276a8cde78a6d81259952d5e9b03ef46f10f9f771fc2fe398af8f3b207fa0d1dfa0219de21db908af468becf9f2eb5c191669f51c547f6025f7c5d0a94b121bfa39cdba02aec49a6624d3dc40a00b374d713f654fdc1ff9f48784b077872459445fc89770c98bf070a8bf824e35875f672f5e75e83df8246bc0461136644f10e25c6c472187e1ef2e915231fe72f1b0668b09f8a585c2531328e1dcffc2dd5617b579b7e3622b1f36966589a9f5e6367eaa46425d8ddd050 Hey, password is required here."},{"title":"汇编（四）：gdb调试","date":"2023-03-06T04:42:48.000Z","path":"posts/3DJGDAE/","text":"GDB: The GNU Project Debugger gdb cheat sheet godbolt (C/C++, python等在线转汇编) online gdb (在线gdb调试) godbolt 推荐这个网站 https://gcc.godbolt.org，在线写 C/C++/Python 等代码，并查看整理后的汇编码，非常清晰。 Todo"},{"title":"汇编（三）：基础AT&T汇编","date":"2023-03-05T07:10:01.000Z","path":"posts/1QNHHCN/","text":"Read the Fucking Manul x86 Assembly Guide Linux System Call Table godbolt (C/C++, python等在线转汇编) AT&amp;T与intel汇编风格 汇编的编写，离不开寄存器和基础指令，前置知识需要阅读 👉汇编（二）：基础寄存器 汇编分为AT&amp;T与Intel风格：Intel vs. AT&amp;T syntax Intel AT&amp;T 注释 ; // # 指令 mov movb是byte, movw是word, movl是long 寄存器 eax %eax 立即数 0x12 $0x12 汇编 mov eax, 0x12 mov $0x12, %eax 移动0x12到eax寄存器 编译器 windows masm unix as AT&amp;T汇编示例 各个字段的含义，请继续阅读后文 .data # 定义数据段 t1: .int 0x1230 # 定义int型的t1, t2变量 t2: .int 0x4 .text # 定义代码段 .globl _start # 定义_start函数入口 _start: mov t1, %eax # eax: 0x1230 mov t2, %ebx # ebx: 0x4 add %eax, %ebx # ebx: 0x1234 # 0x80系统调用sys_exit, 退出程序 mov $0x1, %eax int $0x80 编译与链接 利用汇编器将.s转化为目标文件.o as hello.s -o hello.o 利用链接器将.o链接为可执行文件hello ld hello.o -o hello 为什么需要一个链接的步骤? 链接器（linker）的作用 内存划分 .section .section 将代码划分若干个段，程序执行时，每个段会被加载到不同的内存地址 .section 含义 作用 .data 数据段 存放已初始化的全局、静态变量 .bss 数据段 存放未初始化的全局、静态变量 .text 代码段 存放只读的代码 .heap 堆 动态分配的内存 .stack 栈 函数局部变量等 内存划分如图所示： 其中除了堆和栈是动态分配的，其他都是静态预先分配的内存 调用size [target]查看各个段的内存大小 # 示例见上面的汇编代码 size hello text data bss dec hex filename 23 8 0 31 1f out \"\"\" text: 代码段大小 data, bss: 全局/静态变量大小 dec: 总结大小 (hex是十六进制) \"\"\" 统计代码段的内存大小 0x401000&lt;+0&gt;: 0xb8 0x34 0x12 0x00 0x00 ---&gt; mov $0x1234, %eax 0x401000&lt;+5&gt;: 0xb0 0x12 0x00 ---&gt; movb $0x1, %el 0x401000&lt;+7&gt;: ... \"\"\" mov和movb都是操作符, 占1个字节, 分别是0xb8与0xb0 因为mov的操作数是16位，因此占2个字节，而movb占1个字节 eax和el寄存器也是，分别占2个和1个字节 \"\"\" Linux上可以查看所有虚拟内存的分配：/proc/[pid]/maps 可以通过 man proc 阅读linux文档。 观察到：内存 heap 位于低地址，而 stack 位于高地址，没有 pathname 的一般是通过 mmap 分配的匿名内存 而读写属性有如下几种： r = read w = write x = execute s = shared p = private (copy on write) address perms offset dev inode pathname 561155768000-5611557b5000 r--p 00000000 fe:01 410132 /usr/bin/python2.7 5611557b5000-56115594a000 r-xp 0004d000 fe:01 410132 /usr/bin/python2.7 561155ad9000-561155afc000 rw-p 00000000 00:00 0 561156b9f000-561156c7d000 rw-p 00000000 00:00 0 [heap] 7f7265abe000-7f7265da5000 r--p 00000000 fe:01 393252 /usr/lib/locale/locale-archive 7f7265da5000-7f7265f1b000 rw-p 00000000 00:00 0 7f7265f1b000-7f7265f3d000 r--p 00000000 fe:01 431545 /usr/lib/x86_64-linux-gnu/libc-2.31.so 7f7266278000-7f7266279000 rw-p 0001c000 fe:01 442692 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so 7f7266279000-7f726627f000 rw-p 00000000 00:00 0 7f72662b2000-7f72662b3000 rw-p 0002a000 fe:01 431541 /usr/lib/x86_64-linux-gnu/ld-2.31.so 7f72662b3000-7f72662b4000 rw-p 00000000 00:00 0 7ffd4c51b000-7ffd4c53c000 rw-p 00000000 00:00 0 [stack] 7ffd4c59e000-7ffd4c5a2000 r--p 00000000 00:00 0 [vvar] 7ffd4c5a2000-7ffd4c5a4000 r-xp 00000000 00:00 0 [vdso] 数据类型 文本字符: .ascii 整型: .byte(8位) .short(16位) .int(32位) 浮点: .float .double 指令后缀同时代表精度: b, w, l, q: 分别代表8，16，32，64位 _start函数 就像C++的main函数一样，_start是整个汇编程序的入口，你必须显示的定义它 且需要通过.globl _start，来告诉链接器如何查找_start的符号地址 系统调用 Unix下通过int $0x80进行系统调用，其中参数存在%eax等寄存器中： 查阅对照表: Linux System Call Table %eax 名称 %ebx %ecx ％edx 1 sys_exit - - - 2 sys_fork struct pt_regs - - 3 sys_read usigned int char * size_t 4 sys_write usigned int const char* size_t ⭐ TODO push/pop 栈相关 loop 循环 系统调用不够细 PA实验"},{"title":"汇编（二）：基础寄存器","date":"2023-03-04T03:27:04.000Z","path":"posts/14G1VW3/","text":"约定如下原则： ax与AX都代表同一寄存器，不区分大小写 0xAA、0xaa、AAH都代表十六进制的写法 本文汇编基于Intel vs. AT&amp;T syntax 什么是寄存器? 寄存器是cpu中负责数据存储的电子器件 它的传输速度最快，大于l1、l2 cache，远大于RAM和磁盘 一个16位的寄存器，可以存储2字节的数据，最大可表示0~65536范围的数据 寄存器一般用约定俗成的命名，来区分其具体用途 通用寄存器 存储一般性数据的寄存器，如AX, BX, CX, DX… 汇编 作用 mov ax, 18 将18写入寄存器ax mov ax, bx 将bx的数据写入ax add ax, bx 将ax,bx的值相加，并写入ax sub ax, bx 将ax,bx的值相减，并写入ax 寄存器数据溢出时，会自动舍弃最高位，例如： 8位寄存器：ax(0xff), bx(0x01) 执行add ax, bx后, ax中的值为 0x00 段寄存器 根据 《汇编（一）：计算机架构入门》：物理地址 = 段地址 * 16 + 偏移地址 因此，CS存储代码段的段地址，EIP存储代码段的偏移地址! 代码执行地址为：(CS) * 16 + (EIP)，且每次执行一行后，EIP会根据指令长度偏移若干字节 计算机每次运行，会根据如上计算出的物理地址，取出对应的指令去运行 详解下图过程： 1.取出CS,EIP的值，并放入地址加法器，得到结果是0x20000 2.将物理地址0x20000送上地址总线 3.读取到该处指令为mov ax, 0123H，并送入数据总线 4.CPU ALU获取到该指令，将其执行（涉及AX, BX的读写） DS存储要访问数据的段地址 当我们要将al中的数据写入0x1000的内存时： mov bx, 0x1000 mov ds, bx: 将bx值写入到ds，注意，不支持直接往ds寄存器写数据! mov [0], al: [0]代表读取以ds为段地址，以0为偏移的内存地址上的值 [ax]的特殊用法⭐ : 表示以寄存器ax上的值，为偏移地址（段地址在ds中），此时去对应物理地址寻值 栈寄存器 什么栈（stack）？ 后进先出的操作规则：LIFO(Last in First out)，就像往枪膛里填子弹 程序在运行时，会将一段连续的内存空间划分为栈，这里的操作原则符合LIFO SS存放栈顶的地址，SP存放栈的偏移地址 汇编 作用 push ax 将ax值写入栈顶，即写到SS+SP，并将SP位置下移 pop ax 将栈顶值写入ax，并将SP位置上移 什么是Stack Overflow? 因为程序中的系统调用，都是用堆栈实现的，但默认分配的大小为固定的； 当你写如下一个Python无限递归时，就会因堆栈溢出而导致RuntimeError而程序退出 def f(n): return f(n-1) f(100) # RuntimeError: maximum recursion depth exceeded 内联汇编 TODO 关于 内联汇编（inline asm） 可以单独开一篇学习之 GCC-Inline-Assembly-HOWTO C内联汇编 写汇编经常遇到 movq %0, %%rsp 的写法，其中的 %0 是什么含义? 它一般用于 C++内联汇编： int a=10, b; asm (\"movl %1, %%eax; movl %%eax, %0;\" : \"=r\"(b) /* output */ : \"r\"(a) /* input */ : \"%eax\" /* clobbered register */ ); \"=r\"(b) 表示把 %0 寄存器的值输出给 变量b \"r\"(a)\" 表示分配一个寄存器 %1 保存变量a 的值 因此这段代码的作用是：将a赋值给b 进阶示例: 下面这段代码，能够切换到指定的堆栈（sp），并执行对应的函数调用（entry arg） static inline void stack_switch_call(void *sp, void *entry, uintptr_t arg) { asm volatile ( #if __x86_64__ \"movq %0, %%rsp; movq %2, %%rdi; jmp *%1\" : : \"b\"((uintptr_t)sp), \"d\"(entry), \"a\"(arg) : \"memory\" #else \"movl %0, %%esp; movl %2, 4(%0); jmp *%1\" : : \"b\"((uintptr_t)sp - 8), \"d\"(entry), \"a\"(arg) : \"memory\" #endif ); } 输出修饰符: a: 使用 eax/ax/al 寄存器； b: 使用 ebx/bx/bl 寄存器； c: 使用 ecx/cx/cl 寄存器； d: 使用 edx/dx/dl 寄存器； r: 使用任何可用的通用寄存器；m: 使用变量的内存位置； 这段代码一共使用了3个寄存器： \"b\"((uintptr_t)sp): 使用 ebx 寄存器（%0）保存 sp 的值; \"d\"(entry): 使用 edx 寄存器（%1） 保存 entry 的值; \"a\"(arg): 使用 eax 寄存器（%2） 保存 arg 的值; 此时再去理解汇编代码，其作用是： movq %0, %%rsp: 将 sp 的值传递给 rsp寄存器（函数堆栈）; movq %2, %%rdi: 将 args 的值传递给 rdi寄存器（传递参数）; jmp *%1\": 跳转去执行 entry 函数; 对照表 寄存器 作用 英文 AX, BX, CX 通用寄存器 Register CS （代码段）段寄存器 Code-Segment (E)IP （代码段偏移）寄存器 (Extend)Instruction-Pointer DS （数据段）段寄存器 Data-Segment SS （栈顶）段寄存器 Stack-Segment SP （栈顶偏移）段寄存器 Stack-Segment"},{"title":"汇编（一）：计算机架构入门","date":"2023-03-03T14:15:32.000Z","path":"posts/3RBTN4W/","text":"介绍CPU、寄存器、物理内存、寻址等硬件架构与概念 架构图 这张架构图清晰的解释了计算机各个硬件之间的关系与作用 第一次看不懂，先理解下面各个器件的作用 箭头连线代表电信号的传输，从计算机角度就是数据的传输 存储器 存储器是存放计算机数据的器件，根据读写属性分为两类： ROM（Read-Only-Memory） 只读，一般是显卡、网卡上的默认系统，如BIOS RAM（Random-Access-Memory） 可读可写，显卡上的RAM又成为显存 数据总线 Data-bus 数据总线是为CPU与存储器提供数据传输的 1根数据总线（宽度为1），一次能传送1位（2bit）的二进制数据 数据总线的宽度，决定CPU与外界传输数据的速度 地址总线 Address-bus 读写操作时，CPU通过地址总线来指定存储单元的位置 宽度为10的地址总线，寻址能力为2^10个内存单元 控制总线 Control-bus 代表CPU对计算机器件的控制能力 如有一根“读线”控制发送内存读取的信号，有一根“写线”控制写信号 CPU 寄存器负责存 对于一个16位寄存器，能存储的最大数值是2^16 逻辑算数单元（ALU）负责算 控制器负责控制各个器件 ? CPU也有自己的内部总线, 同上 主频用来衡量CPU的执行性能，如2.0GHz的CPU，每个时钟周期是0.5ns 可以通过时钟周期衡量各个器件的传输效率 器件 消耗cpu时钟周期 (&lt;1ns) Register 0.5 L1 cache 3 L2 cache 15 L3 cache 45 RAM内存 300 SSD固态盘 300000 HDD机械盘 &gt;&gt;SSD 延伸阅读: 为什么 SRAM 读写速度更快? 存储技术SRAM详解 物理地址 计算机的内存单元是一个线性的地址 假设总内存大小1M的计算机，(1M=2^20=16^5)，可以理解为[0x0, 0xFFFFF]这样的一维数组 当内存较大，但地址总线较小时，通常采用寻址的方式： 物理地址 = 段地址 x 16 + 偏移地址 因此通常将内存分段, 但物理意义上内存是连续的 《汇编语言》(王爽第三版)P23，列举了一个学校、图书馆位置的例子，很好解释了寻址的思想"},{"title":"【C++】编码规范","date":"2023-02-23T14:05:16.000Z","path":"posts/WTFJWR/","text":"Linux kernel coding style 🔥 聊聊 C++ 的优雅写法 Names and Order of Includes 当一个cpp存在非常多的 include 时，请合理地对其进行排序。这个编码规范在很多语言都值得引起注意，如 python、JS/TS。 顺序逻辑如下，不同模块间请用一行空格隔开： self header C header C++ header libraries project Preincrement and Predecrement 使用 ++i/--i 代替 i++/i--，因为后者会产生一个临时变量的开销。 分割线 1. 缩进 Linux指定缩进为 8 个空格 python pep8 使用 4 空格缩进 ✔ 一些 C/C++ 开源框架式用 2 空格缩进: leveldb 当缩进层数较多（n&gt;=3），应该考虑代码的设计问题！👍 2. 单行长度 限制在80字符内，利用\\换行 （可以借助VSCode提示监督） 3. 大括号 {} 对于函数定义，大括号单独换行 int function(int x) { return x; } 4. 空格 对于二元、三元运算符，左右都留空 int a = b + c; 对于一元运算符，右侧不留空 s = sizeof(struct file); 5. 命名 全局变量，使用详细的命名 g_info ❌ g_send_msg_info ✔ 局部变量，力求短小精悍 is_decoration_always_open ❌ is_open ✔ 避免种族歧视的命名 ⚠ master -&gt; primary blacklist -&gt; denylist 6. 函数规范 声明函数原型时，需要包含变量名（尽管编译器允许只写变量类型） __init void * __must_check action(enum magic value, size_t size, u8 count, char *fmt, ...) __printf(4, 5) __malloc; .h的函数声明包含默认参数的，.cpp中使用注释注明 // a.h void action(size_t a, size_t b = 10); // a.cpp void action(size_t a, size_t b /* = 10 */) { // todo } 7. 注释 注释是解释What，而不是解释How What -&gt; 注释 How -&gt; 文档、Readme 多行注释的格式如下： /* * This is the preferred style for multi-line * comments in the Linux kernel source code. * Please use it consistently. * * Description: A column of asterisks on the left side, * with beginning and ending almost-blank lines. */ 8. 宏定义 常量的宏定义，应该大写 宏定义 如果使用操作符，务必使用括号扩起 #define CONSTANT 0x4000 #define CONSTEXP (CONSTANT | 3) 函数的宏定义，应该小写 跨行函数，应该使用do-while ❓ #define macrofun(a, b, c) \\ do { \\ if (a == 5) \\ do_this(b, c); \\ } while (0)"},{"title":"Forward Lighting的技术优化","date":"2023-02-22T02:37:09.000Z","path":"posts/2KDTR1T/","text":"Foward管线下实时光照计算的若干优化技术 复杂度分析 谈优化前，先分析一波复杂度 Forward Lighting 遍历场景所有的mesh和光源分别计算光照, 复杂度是O(mesh*light) for mesh in scene for light in scene color += Calc(mesh, light) 当场景的光源数量上升时，GPU计算开销会骤增，显然吃不消； 题外话，为什么Deferred管线下，能驾驭多光源的实时计算呢? Deferred Lighting 在包含SceneColor, SceneNormal的GBuffer上进行光照计算, 复杂度是O(light) for light in scene color += Calc(Gbuffer, light) 而Deferred管线的弊端，网上很多没说清，因此提一嘴： 硬件不支持MRT 不用考虑，根据2020年移动端白皮书，gles 3.0下的占有率已接近0，海外市场具体问题具体分析 不支持透明渲染 代价低的方案是，在Deferred结束后，新开一个ForwardPass去渲染透明物体，缺点是透明物没有光照 不支持MSAA 一方面是对GBuffer做AA无意义，另一方面Multi-Sample会使带宽问题雪上加霜 带宽瓶颈 移动端硬伤, 标准的GBuffer4最低就是128-bits的带宽 优化方向 对于Forward lighting 已知：复杂度是O(mesh*light) 问：如何优化? 答：要么降低Mesh数量（也可理解为Gemotry数量）, 要么减少计算光源数量 1. 降低Mesh Vertex Lighting 正常的光照计算是在pixel shader, 但如果在顶点做光照计算, 复杂度就很可控 但是画面表现很差, 推荐在低画质使用 Pre-Z 因为Pixel-Shader是在Depth-Test阶段前进行； 那么某个Mesh即便经过光照计算，最终也未必呈现在屏幕上，所造成的算力浪费，就是OverDraw问题； Pre-Z可以在Pixel之前拿到DepthBuffer，就能只对通过深度测试的点做计算: for mesh in scene if (DepthPass(mesh.depth)) for light in scene color += Calc(mesh, light) 2. 降低光源数 如何优化光源数量? 一方面，光源较多时，适当阉割几盏，对整体光照效果影响不大； 另一方面，光源范围都是有限的，适当做一点剔除，也能起优化作用； Overlap 如上图，一个像素接受了8盏光源的影响，增加计算量的同时，最后呈现的效果又不明显。 不妨先根据距离、强度等信息对光源排序，对应A~H 8盏： 方案一：只计算前几盏光源； 方案二：根据贡献度混合计算，如： 近（ABC）用Pixel-Lighting 中（DEF）用Vertex-Lighting 远（GH）用球谐光照 此时复杂度就下降为O(k*mesh), 且丢失的光照细节很有限 Tiled Based Lighting Clustered Based Lighting 对于每个像素, 当我们无脑遍历每个光源时, 思考一个问题: 光源的影响范围真有这么大吗? Tiled的主要思想, 就是把屏幕划分多个区域, 记录每个tiles能影响的光源id, shader阶段只用计算受他们影响的光源 Clustered是Tiled的三维划分版本, 将视锥空间沿xyz划分成 24*8*16 个cluster 接下来cpu负责计算，对于每个cluster影响到的光源id和分布, gpu负责计算剔除后的light shading 根据光源类型如下，需要做如下相交测试: Light Intersection AreaLight AABB &amp; AABB求交 PointLight AABB &amp; 球求交 SpotLight ⭐ AABB &amp; 圆锥求交 严谨的相交检测，在物理引擎中使用较多，可以尝试学习： 🔥 Separating Axis Theorem (分离轴定律) 🔥 Realtime Rendering: Static Object Intersections 圆锥&amp;AABB求交优化: 在做Spotlight的视锥剔除时，传统方案是, 用圆锥的AABB包围盒，或者是包围球，与和视锥的AABB求交。 这样就转化为AABB&amp;AABB 或 AABB&amp;球体 的求交问题，相对比较简单，但从剔除率堪忧，因为圆锥占其包围盒的体积比很小，不足三分之一，这里就是我们的优化点 我们改成用圆锥与视锥的包围球相交，方案如下： 首先圆锥由2个部分组成：侧面、底面，若两者都未与球相交，则说明无相交： 底面相交: 只需计算锥顶到球心的投影（如图红线），范围在(-r, r+h)之间，则判定相交； 侧面相交: 只需计算球到圆锥侧面的最短距离（高中数学题3D版），若小于半径r，则判定相交； 光源信息的建表和查表 首先需要一个32位int存储如下信息，以及一张光源信息表 struct ClusterDataDesc { uint16_t light_idx; // 对应去查light信息表 uint8_t pointlight_count; uint8_t spotlight_count; } 查表过程比较繁琐，原理不细讲了，对着下图去看代码会更清楚： 原理看这里： NeoX Wiki: Clustered Shading 3. 球谐SH 这篇KM写得很清楚，就不再赘述 基于球谐的动态点光优化方案 引用 NeoX Wiki: Clustered Shading (NeoX Clustered实现方案) DOOM(2016)- Graphics Study (DOOM Clustered实现方案) Practical Clustered Shading by Emil Persson (正当防卫引擎的Clustered实现方案) A Primer On Efficient Rendering Algorithms &amp; Clustered Shading (好文, 系统且详细地讲解了大部分lighting方案及优化) RealtimeRendering: Static Object Intersections (realtimerednering文档，含游戏中常用几何体求交的算法及数学证明) Optimizing spotlight intersection in tiled/clustered light culling (利用AABB的包围球，近似的算AABB&amp;Cone求交) Cull that cone! Improved cone/spotlight visibility tests for tiled and clustered lighting (同利用AABB的包围球，近似的算AABB&amp;Cone求交)"},{"title":"什么是复权价格?","date":"2023-02-20T16:16:18.000Z","path":"posts/3RWWC79/","text":"ASK 为什么分红、送转后, 股票总面值却没有增加? 为什么A股涨跌幅10%, 却常出现断崖式(如50%)的涨跌? 原则1: 分红/拆股/送转, 不会改变你的总市值 什么是分红 假设A公司每10股派发10元, 不是额外给了你10元, 而是将股票面值中的10元兑成现金送给你了: 什么是拆股 假设A公司因为股价太高（如茅台）, 将每1股拆成5股, 对应的股价也会变为之前的五分之一: 原则2: 计算复权价格，是为了让股价保持连续性 当分红&amp;拆股后 此时就算股价不涨不跌, 由于分红&amp;拆股原因, 股价面值也会大幅波动 这非常影响看盘和策略的计算, 因此提出如下的复权价格 先除息，再除权: 复权价 = (收盘价 - 每股分红) / 送转率 示例: 002648卫星化学, 每10股送转4股，每10股分红4元，除权日为2022年10月13日 每股分红算0.4元，送转率是1.4，前复权选择往前推算，因此计算12日的复权价是 (20.11 - 0.4) / 1.4 = 14.08元 因此13日当天的实际涨跌是：-5.18% 日期 (未复权)收盘价 (前复权)收盘价 涨跌幅 10.12 20.11 (20.11-0.4)/1.4=14.08 - 10.13 13.35 13.35 -5.18% 10.14 13.36 13.36 +0.07% 通俗解释, 假设你有1元硬币 前复权: 你爸说，这1元等你长大了最多值2毛钱 ——&gt; 推算之前价格 后复权: 你爷爷又说，我那时候1元钱，在你们这时候起码值100元 ———&gt; 推算之后价格 不复权: 你很无感，走出家门，踏上公交车，投币，一元 ——&gt; 维持面值(股价) 1元的面值不变, 但1元的购买力在不断变化, 复权价格就是在衡量购买力的变化 引用 知乎: 通俗易懂的解释前复权，不复权和后复权有什么区别？"},{"title":"Echarts可视化库","date":"2023-02-11T14:12:01.000Z","path":"posts/M53XVE/","text":"pyecharts Apache Echarts shawshank/ChartManager.py 写这个目的是不是搬运代码和图片，而是封装一个便于自己常用的绘制库. echarts简介 echarts是百度开源的一款图表绘制库，包括且不限于折线图、柱状图、蜡烛图及3D图表 pyecharts是移植于python的三方库 安装方式: pip install pyecharts 应用重点: 性能分析数据: 如帧率折线图、flamegraph火焰图 量化金融数据：如K线图 装B应用：地图、词云等 代码示例 0. 基础代码 写法一：python风格 from pyecharts.charts import Bar bar = Bar() bar.add_xaxis([\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"]) bar.add_yaxis(\"商家A\", [5, 20, 36, 10, 75, 90]) bar.render() # 默认是./render.html 写法二：链式调用 （推荐👍） from pyecharts.charts import Bar ( Bar() .add_xaxis([\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"]) .add_yaxis(\"商家A\", [5, 20, 36, 10, 75, 90]) .render() # 默认是./render.html ) Fake库：生存随机数据，方便测试 from pyecharts.faker import Faker Faker.choose() # 生成x-axis Faker.values() # 生成y-axis is_smooth: 曲线平滑 is_symbol_show: 显示数据详情 1. Line-折线图 按年度生成600519贵州茅台的日线价格走势: timeline = Timeline() df = G.dm.parse(file_name) code = file_name.split('/')[-1] if split_year: min_year, max_year = df.index[0], df.index[-1] for year in range(min_year.year, max_year.year + 1): _df = df[str(year) : str(year)] line = ( Line() .add_xaxis(list(map(lambda x: x.date(), _df.index))) .add_yaxis(f'{code} {year}', _df.close.to_list(), is_smooth=True) .set_global_opts( # NOTE: y轴分割线 yaxis_opts=opts.AxisOpts( splitline_opts=opts.SplitLineOpts(is_show=True), split_number=10 ) ) ) timeline.add(line, str(year)) timeline.render() 2. Kline-K线图 按年度生成600519贵州茅台的日K线: timeline = Timeline(init_opts=opts.InitOpts('1500px', '500px')) df = G.dm.parse(file_name) code = file_name.split('/')[-1] if split_year: min_year, max_year = df.index[0], df.index[-1] for year in range(min_year.year, max_year.year + 1): _df = df[str(year) : str(year)] oclh = _df[['open', 'close', 'low', 'high']].values.tolist() kline = ( Kline() .add_xaxis(list(map(lambda x: x.date(), _df.index))) # open, close, low, high .add_yaxis(f'{year}年度', oclh) .set_global_opts( xaxis_opts=opts.AxisOpts(is_scale=True), yaxis_opts=opts.AxisOpts( is_scale=True, splitarea_opts=opts.SplitAreaOpts( is_show=True, areastyle_opts=opts.AreaStyleOpts(opacity=1) ), ), datazoom_opts=[opts.DataZoomOpts(pos_bottom=\"-2%\")], title_opts=opts.TitleOpts(title=\"贵州茅台 600519 日线\"), ) ) timeline.add(kline, str(year)) timeline.render() TODO 搞懂opts每个配置项对应的图表含义 MarkAreaOpts: 标记区域 增加按钮, 在页面打开html flamegraph火焰图"},{"title":"Shawshank量化引擎","date":"2023-02-10T16:27:47.000Z","path":"posts/5WQSBJ/","text":"b3dc07a81f6459d120ce338ccca55046671b4a11946133462b62f833fff124b243e3ba385d06b0c10183eeb45d16e9e64555c878540b005ee8e510d0594fc3b902c0d537dbb3164621b9c0205b017e355210d0c78c2605d9c7942d4c53b98952e0d777f5611cf0b6c8d5b8ccc5bd4ecc512ebeca9d8df7e0c714a88c4753e7ad813913b027b69cd7669ff98b33d4a171b92e8e8d5a124a26efaf77696207d20670ce64f39d9d504dd0f78f778d71b9aa21832e8b184d50f1c073ed7ab020d45a1911a4e1b34e6a9f77cb43de7cea7aa28b7491145ecb8ddd4e01fdf98f8967c0db18fd2a6b716c8fffe9d882ef6af7bf250c189dec757bfd82462ed19f9e5f84ffea7e2775783ee525034204ab7f1f09b53d10ae22b63523b95c5056ee7003e809c32a7b643c652bc262ad27b07a0e6158f01be1fc97031b5149e676a76bdbb3a39cf800563fb67f4b772f54db05df296746895c6704542db9d2b6be09c8c52b7d4f62ea2ea723f681e3ce3f3dc612074d7b8a4d3fa2e725602ac1031e5a8cc4830f430e52dc95e3aeaca0a6550d2003cc7b4fcbb61862a538a65a2085357b98726baef9a9a96dd0e07ccdeb5d260209eaffb10e51241a528796327c61feda9f35bd7c26e265829ee071967dba739e0b4cefdc2076c1ba1d55f408afc50102e181417e0fc5c871fd55b4df196206da7bf3cd6b80230799bcaaa7db8f2fd4beef7ff079a4ac3d7a13793c897059f4a1fbd1031e9b05af2a61b0aaaaaa72048f3fb38eac6001713f6a61b779a6d168d441d6417a9d4472ad83d6b68b2e1696ea6a249aeb644a68e48108accbc6b69b14d024318911fd12f864fd62deb1d1fe4f418ac39e7db1911dc37eb37bdf04d47ef9ef5b0fd9d1c127ce3242be9c9a7b72329d99bae74db3a070d4071032ac136d1342996c5681ce0bd791f44ed8d06bb0655c4947d04b4502eb4bd51fdb49e588f90279f78d6e7caa67abc1411d4d89e17ac42314d8dd70e8f3f1ab20811c53b1914b0683cfa8a7f98e3e4b7500e9f4fcf8988ea28a6ae5b0c7fa13711253da404bf3b2b181061071df4adb59036ecea575a7f48f047850e0cad960d4ea3bbf849a7fc5dcb05e9a6cb89f6c74985c2fc35f72b0b54fe19ade9b3fe67ff120c852e9b96f32d4c0ab88d8a1e9e22ec62b7c9d235e0fc0e9b10af234971e6171cf0669636dabd76a26d3ce886608ce2ec4c270e8812deaca9e268a7bd814f3af77926c60489936c54305ee7a7a0bf769cee70fe1888e1f91c4eb0d9d036aea789c39abfcc3c544014d538124c41cd8ec67b09a0b8770c0ac1ef53ebc3e6467dc9cba0f2c971c6f58e7e21f9206f0a0d65818bcf375f560f2deee3f1e308a1ca827a1a45510f7194578d5a05ec135fda5f32969aec8d367f2e2ca03b5042a805e577fbe4b50cdc84890bc76b5d198bbf3a1eb457d6281461bcbff76ee32dc6843542a9d2b012fac541a18c541ef56ed359ea876a2bd1421e416c98b645fde72cd77da45e79ad68a2b410054348571ba0b87f054ae4607a5ebb111b8f99a5bbdb3b7fe9b4adc57c76693e184e538dce47eb7f2df1e026b8259f16978fced0689e49a0a478e31d91f254a479ed96ec78ea78010bd21cb6edd5624ab82f24d406dff33082a4447c65b76c9fb924788698f5bc738c6ab469676effcc0f5245e7b2e6be24e85b41aa12e3d888e6046eb8d62b0dbf76d1a47a834dabec7b574a75f0b2b56b5ed7168d3e51fd05c82f36dcc4f6dc6e75f1bac9a91e133c0e150704b02c00e5e0334b66f6bd6781f2216d5d477447d7d2c1c2294db255dc6d5d098d59ff0b3a0256f9de29261d23f2dd283b9ab46d9cae2cfa1a9f563836b5c28ace938c6e7438fa45ee7fc232a9fca722a0aaf07fc9a70a8cb6ab8688d644bf3216e049c3126f9a5363fac9990700bb5eee2cad740be734ad32639649d91335f1e21581d18c56a36461f2ba6e3c4dd4cdf25947cc47a67ce927a5d68b7a1af667f93d59f0bfe1d40bd0e1d3462856b97a3c49464969ca46940df79def7e7a441a477c176d73ac0d4b43983f7da9e3e10737abbecbe460eada35163b3b2834aa916ba915427d79bf2fb4a6d896e85d402d5b41a5ee0118388411a4d8485d3678e4ab3c25cef4b04ddbbbee96097edb71ff205e7be270ca1f729de17f13250c65b649656b76906e2ec7239b694534ffb768f28b5d0e9cf8e4967346f42d5ab44f8b0c31fd2fc69edc8b8c85f31b9b1cc243720139538efeeeafaf01c00397514e738b27d74d49570f7f2a8e4269f39166da202da079916092ba3ca8efa4f610acf793ddd39580b9da3f43aed6f0c3790d194b15246686bf5fcd8a874386e51b4ce4fd935f3393298666a36bff452ef21eda83a3d3da017c2c1efae590a28ad63739884966b2fd3484da0988487d255102377641b15629320e8c5a151300c1427750e6b7754eec907b2c4f8ef7a4c8321a11bcd8c219b58a45ff5184ccfea87e1131ffb1259cd91126eac07908060c1621c2a669e29f3440880ea74befd03b7244ef95a5aa4fda43757bdc40a6556c22042a2543ee83f8d956766a18b1b067f2a550cddeddaebba08ffa6f262b4bbdd8c2734822f1ce17b193400a37a0ef645b91beed574cdc48552c0eee439d045990f4866dd2d403ba3a82019c31b003353d1e536dd0eaecea57bf5123c6be53ca05c0176858990f554e8a102022d93b957579860033eac3a31254d96a4624b792e15ba891f9c3c7c5793aa39b9b2f8bda628e214886dc82d0b2eeb560e5b5e3c74a7627d769bf4ff842ee13766915883019f0bc33ae39e3ec2b96d41d330fbccc9e536f88b70441eab669e6b64886ee196d13b43d561944d757956b3b8eb57392290ba050c22f03b80939370f2b0fdb24c93ff757ac2cf692e8d34860984ac44efc708a89ff5e358d64e0729b73c09eef94fb5d088c6e268a5c746dfd04b873883caea68f65f5790fe0153385295c4be49b07ca1c0b740ff5364e2f83f471ff4393000453e9db1d4251d891761d01e85c371976784546be80ac44bcb7a6dec549e3a03ba374aedde751390deebf7e2f6bf4df26ae7de293aa2b8043559d2c12d6986a84ab4fe1bf1941dbcfd37236f1e2dd0c625f4a14255ade0b168dc41396b1a3329585f99c62be5b8cc894ce0e3d2fc3bc779ac2f09494a26c52009cf7d3368260655138ad7f15c1f4a4847cabdcef83b99c5639fb8e2bb98b34e28dde738d9ae4866b3e3f38205ce3ef5df35741c7cbb31d0187832b41ae450b92963a094f4574bc8aeb0e5499700508912e3368a06c5f5aa112b1abe1612cdfea156ef0c6edb262b742c5198680d195159d299c366a4a0f64897c8015f978bc0a66758c95ec128e85c09f4511c27cc87267b71f2dd2049f92b223d8d53daeebb12ef411795746bf5c64bc45bc35751c718f4a132c9d55aa3f01a0ac79cd35b8a764e7fa218b5f3dbe560218c77dec242eba6a0d2f496a8c100d8de8af6600f54edaad5e9554d26c8bf6812ec4205b8ec1fcc5f445ebc16c56d859d09c6347b1729ed4d3566c1ef6f67e5baeaf352277362c978aa1b6f0fa75a8456388feba31a077a7c2dbaa99c7799fae8ac6b9ea4c883411b09b9c1ecea596d9afaa53347720071614c58a5b39d37a865cddf7fcb9d78a5e7d856af0a6300b628fd88b37cb44b17d23e223bbf514cd33cf4cd8cd61bfc9a6524b1a3fd82bc80e43986cda61158ebe7b314d1fd83186793800ce9c6d0f416897e96d51dd84f8856a98ca81f89f42d752f002ad82fc2dcb58dd35b978f8cfb26a44ccf9a5bd28ad5659bd3dcf1e5c49338dc582928619b255057dfaf091ce90166e0bd9465f1c86d9c5b8391cb6bf8cf2bcda16b4090a348931cff86c2cf572c3e17a0811b6f4345989d730bc719a3b3f7746556f0f1a53f70e7b96ea4ab50ea20d73284c4d8d24a1bf0948fb01376981c393501a89d427682550cbfe42daa24d9a0c054c071fcb5f6a665eb052185700e28f4e697caeae960ad1993926afda4720d77d06b09bdc1528b5e38598a8c86550f6dd741793755fc49a31a2ae1d2c3677fdab5fdd65df14526a1ef43d95ed70130423049cf0b46c518a2930dea3d55aea6331793638460de8701423f23b19aadb34e78b45c01cd2467421e0d5c53cfb69ca64bb01beef0ed0956ba840276f176a857002456b1436572c54d44216d284e596053b8f58300f0f162 Hey, password is required here."},{"title":"Pandas数据处理","date":"2023-02-09T13:50:14.000Z","path":"posts/2QT24MY/","text":"🔥 Python量化中所有数据处理都由Pandas完成 看文档！看文档！看文档！ 存储 推荐使用feather进行数据的读写，查阅文档 pandas IO tools 下面选取截止2022-12-31的A股所有日线数据为例： [26415674 rows x 8 columns] 其中columns为: code,time,open,high,low,close,volume,amount 方式 占用空间 读取耗时 描述 csv 1.5G 20s 可读性高 pickle 1.8G 3.5s 二进制 feather 0.9G 2s 二进制 jay 1.9G 0.0015s 二进制(datatable库) 性能专题 numba 读取较多个csv文件耗时较长, 如何用 multiprocess + pandas 读取? from multiprocessing import Pool def read_csv(file_name): return pandas.read_csv(file_name) file_list = [...] with Pool(processes=6) as pool: df_list = pool.map(read_csv, file_list) df_all = pd.concat(df_list, ignore_index=True) \"\"\" 推荐在read_csv里将数据写到一个全局的dict \"\"\" 内存专题 为了节省runtime内存, DataFrame默认读取的是float64 &amp; int64格式, 占用内存大且浪费 np.dtype('int32'): 表示int32类型 np.iinfo('int64').max: 获取int64的最大值 np.finfo('float64').max: float64 int64: 64 bits = 8 byte 建议如下: 不考虑负数, 用uint代替int 能用int16, 就不要用int32 为什么float64比int64表示范围大? 占内存是一样的 时间专题 这里要写很多篇幅, 先介绍Pandas自带的转化: TODO pandas.to_datetime(df): 返回类型是pandas的timestamp, 可以访问.date(), .day Warning &amp; Error 读取中文报错: pd.read_csv(file_name, encoding = \"gbk\") UserWarning: Pandas doesn’t allow columns to be created via a new attribute name 正确写法: df['name'] = xxx 错误写法: df.name = xxx 复杂操作 groupby Pandas Groupby 知乎 DataFrame.groupby(by=None): 按照by这一column筛选 Group.get_group(): 获取指定的group, 返回DataFrame merge DataFrame, Series之间任意合并 注意left, right, outer等几种方式, 底层就是SQL的逻辑 merge完赋值如果不对齐，可以去重: mf = mf[~mf.index.duplicated()]"},{"title":"量化数据介绍","date":"2023-02-08T13:47:35.000Z","path":"posts/11HCGGE/","text":"介绍量化数据的类型、数据源、和处理格式 数据类型 1.金融数据只有两种, 最原始的tick数据 和 聚合加工成的bar数据: tick 对于商品期货，是500ms一次的最小交易间隔 对于A股，是一次下单、撤单或交易撮合 如上行成的一条数据，就成为一个tick bar 将tick数据在时间尺度上累加，就得到bar数据 常见的有 5分钟K线，日k等等 股票看盘软件中的一个蜡烛图，就是由该时间段内的信息累加而成的 2.股票软件（如同花顺），做了哪些事？ 从交易所接受最原始的tick数据 （后端） 清洗、整理数据，获取bar数据 （数据中台） 生成直观的涨跌 蜡烛图、k线图（前端） 数据源 这里推荐2个常用的数据来源： 🔥 金数源数据 有免费的A股日K数据 期货tick卖的挺贵，一个月50RMB 🔥 天勤量化 收费版(可试用2周)提供期货tick/bar的下载 股票数据不全 论数据之于量化的意义 个人认为两个作用: Off time: 离线时，用作策略回测，验证与优化 Run time: 实盘时，根据实时数据，决定下一秒如何下单交易 由此可见，数据的规范性、正确性显得尤其重要!!! 数据格式 金融数据，不论tick还是bar，都是高度序列化的，因此推荐下面2种： csv: 逗号分割，易于python解析和excel打开 hdf5: 二进制，读写速度更胜一筹 如下是 螺纹钢rb2205 2022年1月4日 的tick数据，基于csv格式:"},{"title":"Linux Crontab定时任务","date":"2023-02-02T14:45:01.000Z","path":"posts/15G1D76/","text":"资料 🔥 菜鸟教程crontab 在线验证 crontab 技术背景 服务器经常定时执行任务（如每日9点开盘），自己维护定时器又容易出Bug，还得做日志模块… Windows Server 推荐 Windows定时任务（有GUI和命令行） Linux 推荐 Crontab（纯命令行） crontab 基本使用 crontab -e: 编辑配置 service cron restart: 重启cron服务 service cron reload: 重新载入cron配置, 修改配置后需要reload 定时语法 # Part 1: * * * * * task - - - - - | | | | | | | | | +----- 星期 (0 - 6) (周日为0) | | | +---------- 月份 (1 - 12) | | +--------------- 日期 (1 - 31) | +-------------------- 小时 (0 - 23) +------------------------- 分钟 (0 - 59) # Part 2: */5: 代表每5分钟 1-5: 代表第1-5分钟都执行 如果不需要任何输出: xxx.bat &gt; /dev/null 2&gt;&amp;1 附上服务器上的crontab量化相关配置 Q&amp;A crontab没有日志 /etc/rsyslog.conf: 取消crontab的log注释 service rsyslog restart: 重启syslog /var/log/cron.log: 接着就可以看crontab的log! 没有 service 指令 使用 /etc/init.d/cron reload 等代替"},{"title":"2022年总结（写在除夕夜）","date":"2023-01-21T14:35:32.000Z","path":"posts/19KZ887/","text":"b3dc07a81f6459d120ce338ccca5504661c2b6d199f8abfa2402c5b16901e347024de2c78f361d0ef47e1cde1303c3a8822026a64881b4638ef155338ea76cb1ccbcc2fbbf742a4f3070a7d9b42e431dcbe95d92f1417cbb887e9e54af2d88a5a74520860d80486fcb86fc73e942bf7941a9773e852aedb8200286cb2ab906047f86456675c6bde6c0093bea5239620ad245c2a7ec1b9400de4c95235d9104a6ddc0446748fb69b6a1aa305dfbef999715b3b1ac87d1bab79af8437885d4c9b329e8c8a813b335cdf221b6b663d6c00890b0744d6e159f8a7068da64977cbde3d4d1401637450aa42464b2e281778f55feae741b3c097361af34421b519372dd5a8b7746dc61ea4b32c7f4bea23222785afd438726ff91feb0ef36aba4254fb27b9a63d01ad7e6ea981f479f9e6ec4451625982918852962ef58ed53f9330592f7bf685f81e01f04d76b06e9ddf6926adf50fdcd88aa613666e097f169cf84a95604ad4f25f68b2a116a41f0df70c3befcc81e646b095525205bf86a72b2eb303219e01bb38c361effc1b5cb8afb26e83363549511f6734cb3383abeffd5dcff07f4b6ccf93eb452106d17843bf1f914ce7905f5413eda38f5f2836fa58f194557a356afab190ed393e8b724dbd498f495b8ba5f7c98ad748b1175b35233c91593d4c3f61ad88b9a035d039f9ed1a5c9efea66d4d25da3f152b3ca6da335eddb4e20ab7e226dc390a458a291698af63b9a13755af75ea9cca27893a5aa82591bea44c53d0d154c97c839f627d1b4432801bec0d7d5c0e2337f72e3213e4824321f75f08d64bca7980c9ebe4c06e3c187bb1966858cad410f2089ca030eb0a3a03a87d5d64279eb1f200554e8eac027aa72b1dfb4c6538d3a4dff03ebef5b7a3acf547b6c58849716a5d9f296fc941c5cfe5158c93e7397007a7ac07c2021ef1648594a0caebbf35b5c98147e8353bbaab8eb98bc042e36e4ba143abc072d2f5dad3b6fa06e0909a3ae70da5472a6916588ce97990a6ba87e09cb4cad834b91f3ec0913bb00ebf96561c2c1393939ebbee8bf840ce33d1785f44e1f762e1eae1e58322b80766a61f53cf8b7f854c7a2938c58ee846ce6744fc3038e01a86ae9c43b83683087ab08a73b30a79c8bb7abdd06ba8c558771a3c3455b6c8a6e00ae579d52cacaabc7d9e55cdc7c4c4b756f7d6ebb29faa160243b0268a8c65b76e06a858a324ddfb63c4fe354783e7e876e67ae7e4d682752880eaf589f5be9375c526216f51eb6f1a82a01b4d4fc9f1684fca005eb2e098e35b17fc8fdf45717a7d3ed2d4136ee100ff4263acdc6e8f883b84a894a63d69de30ebe7cda09c4d3a3004cd8e45ec0c04a49ad8c3fc076f6736474cbf50f92f6c1696dcbcebbbb459425970a6be01f93e5b3f2d7b30ceaa79c80c4ede7bc003d91c0f5727bfe25c70b825b0ce263f0f05c57c1ed72d818c9559657a9e3463aca1f95c7589bc39f914bab887fd8aa124379803207b31c344e3a82814c964a0802d00b323ad1cc77c6ffd30255d9629a2b9730657f236f9520eb338d5392b6860f209502f3caac9da96a99f6a2c36543ca6e6e8e63eaac0224a84de69b67d0214aef4b961e9474574049aaf374e78721f0e03693e4d1ceb07c5e8008a632ee4882ddae973edd56059225658172572dbaa6f9eee2825eeab4b3f7189d6cc7fd5428e23a55c4d843a46a52d6a494da2213d844eb1d7bf035c103ee9bb87d7218b11e8208f2aa25a436fe436fbefb18e6596a6786f3d55118207063ceb868366f2dcceab03743286181d4d5937b969bba9b98c29792217dcf01ab51a14b9834d07eb4daae0ea73757bf2419425fac6c695bd88f38b3a546582369255212371fa7466d4607ad4ab1f46e9b4a74d27b1110ccb1e1bcdba65bc1fb6f927fc144f8afd31a208854a61a5f0c0ade394cac9d97c6600eb2bccfff2321d983e7e4b9627f769d4e49e7d01efe7712bb89643bb4c3c435c92bc45a25fc1b884dda77a42f2ec1e21b22b9159b9cb453cde0e5a301f3bf8d85844bf81225dbe1767d75d881be2e636eaa6450bc5f3eed4a8453f7c3632c9eef82a2e0f27c1b34187c047622d6f7f4f5d240138861be413ca74911e7d0558c2d92d5d9e9989828364fb3aaddd143a5fdea53d5e4508c5a307bec84753e5d09370a3e807c3043467a01ee5cd2f855236eb2903f1f126a32d3540db886fa679e73417bdd61f9196d302e45777d0676ab26183c5d9984485a2d2e0c4cca536b76dce3cc8bdade92dad936f58f6c62e8c9a400e0541d40ea1f1658d31a5a94037b320acf85c9b544628bed424214739d0fe52bd2b3ee52305ef9c69fb8fbde13598b09eee99c0c2485a46478d3e6458696f09f3ae5bb60b5895c7a68b8c08f5e68ad1bfd6f64d8e9769c92ce5a8362c27a14fea013aaba724a13a84715cae254748e4f6811d1877f714808d46871893831af89489765d9cc25a7b9272ecf2f20044f92aed2d0c7645d681fbc72e8c980cfd1c733bc519604bfb4feca7779b6b358d277484b63959ec3a4fd86e9c12d4bbe8853461a05d32df6399257df2f2599d65b5b0873e3d24d9f02ed87cc28e6152929b4f920550abe4086dfffe9f306b66b9398545c4a84a46738582bde79c411f8844eb53d5136911fbaadd907d64266144b716dbe3d6b9c240e0e7457e4f1d9c3de0bcd492653f98e18bd47b46132c78ce6504442e629dd6795ea064477d5cedb8f280b3f5d94587991400905e089d9346a063f7b8674fe9ee640a49b0626ee183106da7606575ec9e845a0f998c8e3946bd8721cfd06bbca7870b0e4bacdfa7bf49532c42976b1f87e87b6310907da874f448543dc628aa991053df6608752c2d3b1e3bd1c2ec1c5f04a0cd56f4d615a11af5db83229a103d4581a24b8e846c01c9eba5784ef6ddd165ed553c37041f9ca7c49e6c26ef9432c7514e96983a22b49d28dca8ac8a6d6488c5009e13773c42175dd68afdde5d4e380ddf6e8d69b21827201ed24c34139a571c322f78a3e1f9bdb5000f5674b24c2ef0069a8bce1f0504591b0ae81f060861cb6d4586aa7b16549dcea5219c329b9779d9aa3ba27767f04eea1411e602fc265ea77b5bbd861fb70201bb1c861cc51240195685454366ed9d07ef4a289156c7e6fb8c2454d222572a1fe0bbfbb7916f9e6705ab9f6ec40fd180a04d7d3417ac3eb0dc5ce92b29c559702bf12b922552582e1cdf68fa6207abf5ef763d8168cd372f0c1ad75ff40daa90af561aa00c40bd102fa1b0f0ce80befbb96845ad7d1d7e765076588fde40dad6b83a8cf9dda68926a637e86422a5b6f038630f50f72f0887517100c6f2e1f45cab53018145a2036632c4dd46dbb47c4c3aaa3ab73ff1f5882e034e51c86cf042bf95ceceb5f3d9a305b5993e036deb6e1aedddb9fa55ed76d847090ee72c56bd0f055a05f37d1a621409e9ea927ffb670610e09edc5fb Hey, password is required here."},{"title":"火焰图flamegraph","date":"2023-01-20T17:52:34.000Z","path":"posts/38ZNGYA/","text":"什么是火焰图? 首先火焰图, 是一个性能排查的可视化工具, 广泛应用于函数调用开销、内存占用统计等… 如图长这样: 它有两大优势: 1.可以看清调用关系, 2. 一眼看出性能瓶颈; 如何生成火焰图? 常见的开源flamegraph都是基于perf结果解析出的svg, 再用浏览器打开就是火焰图了; 比较经典的开源是这个: 🔥 brendangregg/FlameGraph 但比较可惜，作者基于Perl写的，windows下运行比较麻烦（因为你得为每台工作机装个perl环境吧…） 推荐一个在线看火焰图的网站: speedscope.app"},{"title":"C++ 汇总","date":"2023-01-01T11:00:38.000Z","path":"posts/2N6K1PK/","text":"语言特性 时间 特性 C++98 1998 the original standard C++11 2011 almost a new language C++14 2014 some improvements C++17 2017 new features &amp; library extensions C++20 2020 game-changing new features &amp; libraries ISO Standard C++ since Got nullptr c++11 ✔ constexpr c++11 ✔ auto c++11 ✔ decltype c++11 decltype(auto) c++14 lambda c++11 ✔ shared_ptr c++11 unique_ptr c++11 weak_ptr c++11 make_unique c++14 constexpr 阅读材料: cppreference: constexpr Microsoft: constexpr constexpr和const有什么区别? stackoverflow const simply means that value cannot be changed constexpr creates a compile-time constant 核心在于, constexpr在编译期就已经完成值计算. compile flag 阅读资料：Important GCC Flags in Linux，Gcc Option-Summary compile flags，使用合理的编译选项来让你的程序更健壮和友好，掌握如下重点： -Wall：打印所有的 warning -Werror：所有 warning 当做 error 处理 -o：指定输出文件 -l：链接共享库，如-lpthread -g：编译包含debug信息 -std=c++11：指定C++标准 -O[0|g|1|2|s|3]：优化级别，-O0不含任何优化 Value or Reference? 引用自《C++ Templates》，总体说使用类对象时传递值，使用基础类型时传递引用。 quote Modern C++ Tutorial https://changkun.de/modern-cpp/en-us/01-intro/ cpphacking https://hackingcpp.com/index.html 强推这个网站 fmt库 https://github.com/fmtlib/fmt 基于C++17的python解释器 https://github.com/blueloveTH/pocketpy/blob/main/src/main.cpp 搭配这个看, python写的py解释器 https://aosabook.org/en/500L/a-python-interpreter-written-in-python.html 工具 学习 Makefile 学习 cmake 学习 编译选项"},{"title":"【Linux】命令行大全","date":"2022-05-31T15:57:22.000Z","path":"posts/2G7VBZ2/","text":"记录常用的Linux指令、踩坑经历 导读 查阅 man 手册是最根本的办法，但某些用法要牢记! The art of command line explain shell，解释任意指令 重定向 Linux 的宗旨是 everythin is file，对于进程、IO、设备等，都是以文件的形式存在，这些文件都可以用文件描述符（file descriptor）来表示。 Linux 默认有三个文件描述符，你可以始终默认它们是存在的： stdin（0）：可以理解为键盘设备的输入信号 stdout（1）：标准输出 stderr（2）：标准错误 符号 重定向操作的格式: shell命令 + 重定向符号 + &lt;文件、文件描述符、设备&gt; “&gt;” 默认重定向 stdout，会覆盖原内容 cmd &gt; file，等价于 cmd 1 &gt; file “&gt;&gt;” 是追加，不会覆盖 “&lt;” 重定向 stdin，可以从输入设备、文件内读取 wc -l &lt; file，会统计文件的行数 “&gt;&amp;” 符号实现 stdout、stderr 之间的重新绑定。 cmd 1&gt;&amp;2，会将所有 stdout 输出到 stderr 忽略 /dev/null 是linux下的一个device，相当于黑洞，任何输出重定向到这里都会被吞掉（即忽略）。 cmd &gt; /dev/null，会忽略所有的stdout，但会保留stderr，想要忽略任何输出，可以使用 cmd 1&gt;/dev/null 2&gt;&amp;1 pipe管道 管道（“|”） 和 “&gt;” 的区别在于，它仅仅支持将一个（前面）指令的 stdout 传递给 下一个指令。 cat file | grep luhao，即将file的内容传递给grep，以匹配luhao字段 理解pipe：将上一个指令的stdout，重定向到下一个指令的stdin 阅读材料：linux管道和重定向区别 here document command &lt;&lt; EOF document EOF here document 是 linux 一种特殊的重定向方式，它会将两个EOF之间的字符重定向给 command（或者一个程序）。 一种常见的用法是，结合 cat 实现多行字符的输出。 xargs 前面说到 管道 可以在两个指令间传递信息，但很遗憾的是一些指令并不支持管道，例如 echo。 这个时候就需要 xargs （eXtended ARGuments）发挥作用！ xargs [-options] [command] xargs 本质是 将stdin转化为command的参数（结合管道使用） $ xargs find -name 回车后会等待用户输入，然后按下 ctrl+d，会执行 find -name [input] $ echo \"test\" | xargs mkdir 实际上等价于 mkdir test，如果不加xargs会报错 xargs -d xargs默认根据 “空格” 进行分割，可以用参数 -d 调整其分割策略 echo \"one two three\" | xargs mkdir 实际会创建名为one, two, three的三个目录 echo -e \"a\\tb\\t\\c\" | xargs -d \"\\t\" 即按照\\t分割，实际输出a b c NOTE -p：解析完参数，请求用户确认 （当你不确定时请用 -p） -t：打印出参数，直接执行 xargs + find 这两个指令搭配好为例无穷，举个例子，搜索目录下所有 *.txt 中是否包含 luhao 的字符： find . -name \"*.txt\" | xargs grep \"abc\" ✔ find . -name \"*.txt\" | grep \"abc\" ❌ 再例如，删除所有以 test 开头的文件：（-print0是处理文件名含空格） find . -name \"test* -print0\" | xargs -0 rm 高级应用，统计所有 .cpp 文件的代码行数： find ./source -type f -name \"*.cpp\" | xargs wc -l 管道和xargs区别? 管道 将上一个stdout一股脑丢到stdin执行 xargs 会将上一个stdout根据空格等分离，再一个一个丢进来执行 匹配 linux下有两种匹配规则，分别是 RE正则表达式 和 Glob通配符。 Glob一般在shell指令下使用较多，因为较多的指令不支持正则表达式。例如 ls、find、sed… regex 正则表达式 glob 通配符 linux关于匹配的指令也有多种，使用最多的是 find、grep… 推荐查阅man手册来学习 grep grep 会将匹配的部分高亮输出到 stdout，需要牢记如下几个参数： -i：ignore-case -o：only-matching，只打印完全匹配的部分 -v：invert-match，只输出“不匹配” find TODO：用到时候再来学习 watch linux cat 指令会将文件所有的内容输出到 stdout，当文件很大的时候会占用很大的缓冲区，并造成卡顿和等待。因此学会如下几个指令： less：打印部分，借助vim指令上下滚动 head：打印头部 tail：打印尾部 可选参数常用的有两种： -f：follow模式，当文件增长时会刷新stdout -n：打印指定的行数 监测日志时，使用 tail -f *.log | grep xxx 非常有帮助 curl curl 是用来请求web服务器的命令行工具，其名字是 client &amp; url 的结合体。Postman跟它的作用类似，但是带有GUI界面。 curl https://www.google.com/：无任何参数的curl，就是调用一次 GET 请求。 -d：发送 POST 请求 --head：发送 HEAD 请求 -o：将服务器的返回保存为文件，等同于 wget -X：指定HTTP请求方法，如 curl -X POST ... apt-get debian如何换国内源? sudo sed -i -e 's/deb.debian.org/mirrors.aliyun.com/g' -e 's/security.debian.org/mirrors.aliyun.com/g' /etc/apt/sources.list sudo apt-get update 分割线，下面内容要整理重写 port Unix: lsof: 打印所有端口的占用情况 lsof -i:4000: 查看占用4000端口的进程 Windows: netstat -ano | findstr :6000: 查看占用6000端口的进程 taskkill /PID 12345 /F: 杀死进程12345, /F表示强制关闭 sed: stream editor sed -i: 直接替换源文件 sed '4a newline' [file]: 第4行新增 sed '1,5s/a/b/' [file]: 1~5行的a替换为b $: 表示末行 scp 上传/下载 scp [local file] root@xx.xx.xx:/root: 上传到服务器 scp root@xx.xx.xx:/root/ [local_path]: 从服务器下载到本地 scp -r: 文件夹操作 scp -P 32200 ...: 带端口的scp disk df -lh: 查看磁盘剩余空间 du -lh: 查看含目录的大小 rm -f *: 删除目录下所有文件 l --color: 彩色格式显示 ll: 显示详细信息, 如最后修改时间 ls | wc -l: 统计当前文件数, wc表示word count, -l是行数 nohup 看这篇cnblog就够了: nohup和&amp;后台运行 compression zip unar xx.zip: 可以自动解码中文 vim xx.zip: 查看zip压缩文件结构 tar # .gz ------------------ tar -czf x.gz [file] tar -xzvf x.gz # .bz2 ------------------ tar -cjf x.bz2 [file] tar -xjvf x.bz2 # .rar ------------------ rar a x.rar [file] unrar e x.rar # .zip ------------------ zip x.zip [file] unzip x.zip shell脚本 如何写一个自己的脚本? xxx.sh: 如/luhao/bin/demo.sh ln -s /luhao/bin/demo.sh /usr/bin/demo: 加入环境变量, 可以直接demo访问 自定义start, end, restart function start() { } case \"$1\" in start) start ;; *) esac ps, kill, pkill 进程相关 ps -e: 所有进程 ps -u: 按用户打印进程 ps -x: 没有终端的进程, 后台python应用需要！ kill -9 [pid]: 杀死对应pid的进程 pkill -f [pattern]: 杀死制定名称的进程 挂载云硬盘 fdisk -l: 查看新磁盘名称, 如/dev/vdb mount -t ext4 /dev/vdb /data: 将/dev/vdb挂载到/data目录 df -lh: 查看对应硬盘"},{"title":"《直击本质》书摘","date":"2022-04-23T16:54:46.000Z","path":"posts/3819NVV/","text":"概要 《直击本质：洞察事物底层逻辑的思考方法》，专注于“思考方法”的书 本文旨在记录书中有共鸣、有感触的语句 理解事物本质 思考事物的根本属性，是学一样东西、论述一个原理、解决一个问题、判断一个趋势的基础； 当你做到以下中的任何一件，你就理解了事物的本质： 给出清晰的定义 “商品”是用来交换的劳动产品; 做出简单、准确的类比 “谈判”就是“找交集” 切忌用一件晦涩的事物去解释另一件事物，容易将简单的问题复杂化； 升维思考 跳出眼前问题的限制与常规解法，通过层级、时间、视角、边界、位置、结构的变换，重新思考问题及其解决之道的思维方式 爱因斯坦：“我们不能用制造问题时的同一水平思维来解决问题。” 1. 层级思考法 上三层： 愿景层：人生使命，比如灭霸为了维护宇宙平衡； 身份层：我是谁，我想成为谁； 价值观层：好坏对错之分； 下三层： 能力层：技能、状态、策略； 行为层：具体的行动，每天做了什么？ 环境层：学校、职场、家庭的环境影响 上层对下层拥有指导作用。当你懒得背单词（行为层），想象你想考上怎样的大学（身份层），背单词就有了驱动力，正是这个道理； 面对下层的现象，从上层介入思考会更直击本质。这也是为什么通过一个人的交友圈子（环境层）、言语交谈（行为层）和处事策略（能力层），你基本能推断出其三观与身份特征。 如果我们只在下层做出改变，而上层的意识没有变化，下层的改变常常是难以持久的。 2. 拉长时间轴 消除痛苦与烦恼。站在更远的时间线外看待当下，你会觉得，一切的痛苦都会随时间烟消云散。 3. 上帝视角 为什么你能教别人做事，却过不好自己的生活？居高临下，跳出剧本，才能拥有上帝视角（这我想起了罗永浩的\"大局观\"） 上帝视角让我们摆脱自我情绪和感受的束缚； 上帝视角利于拥有全局观、大局观； 普鲁斯特：“真正的发现之旅不在于发现新风景，而在于获得新视角。” 4. 第三选择 我们经常陷入非黑即白、非此即彼的二选一思维模式，即“点状思维”。以至于条件反射般地将事物一分为二或两极对立：男人与女人，原告与被告、资本家与工人等等… 只有机器人才会只拥有0和1两种选择，试着寻找“第三选择” 5. 无边界思考 哲学家卡斯将人类所有活动比作两类游戏： 有限游戏：制定一系列机制与规则（如政治、法律），以取胜为目的（如战争、官司）； 无限游戏：没有任何规则，以延续为目的，拥有无限可能与结局（如文化、艺术）； 我们总是习惯性给自己限定框架，进行“有限游戏”。如“我只是大专毕业，怎么找得到好工作”；如“我是女生，我一定会受到歧视”；一切身份限制、性别限制、输赢限制等等，都在无形中束缚了我们的发展。 所谓无边界思考，即打破人生得到种种限制。关键包括三点：消除时空边界、消除角色边界、修改规则"},{"title":"VPN搭建一条龙","date":"2022-03-12T17:28:31.000Z","path":"posts/2R7AP5Z/","text":"Windows/Mac/IOS/Android通用的VPN搭建教程，收费的 1. Shadowrocket安装 美区App Store利用 $2.99 购买 shadowrocket app 🔥 注册美区 Apple ID 帐号的终极指南 美区app如何充值？移步万能的淘宝，搜索AppStore美区礼品卡，买$3的就行 2. shadowsocket配置 认准这个网站: 🔥 v2ww.com 里面有详细的Shadowrocket配置教程，和梯子价格清单，🔥建议购买月￥9.9 的10GB套餐"},{"title":"游戏记录：ARK方舟生存进化","date":"2022-02-20T14:21:16.000Z","path":"posts/160HQCD/","text":"概要 方舟:生存进化是一款开放世界游戏； 方舟听宇网 方舟资料网站（英文） 说几句 这个游戏晕死我了，两个月来玩了200小时，主要是孤岛和焦土DLC。 基本玩两小时就恶心发晕，我就是个菜鸡。 玩了100小时才知道这游戏有主线和BOSS，不过感觉没啥意思。 觉得最大乐趣是探图、建家、抓恐龙，并乐此不疲，像是虚拟世界的一个家园，一片净土吧… DLC介绍 游戏包含付费DLC和免费DLC, 按照时间顺序: 付费DLC 孤岛（The Island）★ 焦土（Scorched Earth） 畸变（Aberration） 灭绝（Extinction） 创世纪一二（Genesis） 免费DLC 中心岛（The Center） 仙境（Ragnarok）★ 瓦尔盖罗（Valguero） 水晶岛（Crystal Isies） 迷失岛（Lost Island） 本体+全dlc安装，硬盘空间 400G 闪退白框修复 【方舟问题】解决方舟所有白框问题。网络问题，驱动问题，地图问题 方舟这个破游戏经常会各种UE的Crash，本人遇到最多的是 NetConnection 的闪退，俗称 4096。 搜寻网上各种外行和玄学的解决方案，没有一个百分百有效的。 总结如下： 使用UU加速器（没用） 插拔路由器（没试过） 清空所有浏览器缓存（没用） 修改本机配置 ...\\steam\\steamapps\\common\\ARK\\ShooterGame\\Saved\\Config\\WindowsNoEditor 如何修改恐龙等级、刷新规则? GameUserSettings.ini: 修改恐龙等级、刷新规则等 可以订阅这个调等级的MOD: Custom Dino Levels 配置文档 其中官方设置的难度表示一个level的等级间隔（如5表示5级）, MinLevel=30 表示最小等级限制为 难度 x MinLvel # GameUserSettings.ini [CustomLevelDistrib] MinLevel=15.000000 MaxLevel=30.000000 WantsEqualLevels=True # 刷新概率 TinyWeight=1.000000 # 5-25 LowWeight=0.3500000 # 30-60 MediumWeight=0.250000 # 65-100 HighWeight=0.250000 # 105-150 重置地图请删除: ARK\\ShooterGame\\Saved\\LocalProfiles 方舟私服 如果在本机玩，方舟就是个单机游戏，想要和别的玩家一起玩，就得找服务器。（推荐去听宇网找） 一般服务器的介绍是 “PVE15通 采3驯10…” 分PVE/PVP两种服务器 15通: 表示共有15个地图可以互通 采n驯m: 表示游戏加速的倍率 实用MOD MODs 作用 Awesome SpyGlass A+镜，观察恐龙的等级、晕眩度、加点等 Ultra Stacks 可以堆叠物品，节省背包的容量！ Automatic Death Recovery 死亡物品不掉路！ Pet Finder 恐龙丢了用这个找！ Kraken’s Better Dinos 修改刷新恐龙的等级、比例 Upgrade Station 可以升级鞍具、工具的工作台！ Baby Premium Care 100%留痕药、飞龙奶等！ 游戏资源推荐 B站 老司机hot《方舟生存进化》 游戏配置（备忘）"},{"title":"TypeScript概览","date":"2022-01-03T14:55:04.000Z","path":"posts/286HTVQ/","text":"Note 在此之前，先看看什么是JavaScript? JavaScript 中文介绍 | What is JavaScript? TypeScript其实就是Typed JavaScript at Any Scale. ts基本特性 特性 解释 Coding Staticlly Typed 静态类型 let foo = 1; foo.split(' '); =&gt; 编译报错 Weakly Typed 允许隐式类型转化 console.log(1 + '1'); =&gt; 打印11 Type Annotations 允许类型注释 let foo: string = '1'; import, export Import statements in TypeScript: which syntax to use 代码 解释 import * as path from 'path commonjs模块 import fs = require('fs') commonjs模块, export=xx const xx = require('xx) 无类型声明 var、let、const TypeScript - Variable 使用场景 var 全局作用域 let 块作用域 const 块作用域、只读 function 下面是一个求和函数的示例： function add(a: number, b: number): number { return a + b; } class 下面是一个类声明的示例： class Point { // 成员变量, 可用readonly, 不可用const x: number; y: number; // 构造函数 constructor(x = 0, y = 0) { this.x = x; this.y = y; } // 成员方法 getScale(): number { return this.x + this.y; } } // 实例化一个类 var point = new Point(1, 2) 参考 TypeScript官网 一个中文的TypeScript入门教程"},{"title":"【Python】优雅输出","date":"2021-12-16T14:17:59.000Z","path":"posts/1MJH73F/","text":"前提 Linux命令下, 见识了如gcc, apt, pip之流的优雅输出； 这篇博客想仿照之，借Python实现一些优美的输出与交互； 何为优雅? 鄙人低俗, 仅想从样式与外在谈论优雅 清晰的输出、高亮的样式… 这些就是开源软件的优雅! 1. pip 2. oh-my-zsh 3. VScode Extension 4. ipython 何为优雅? 彩色文字区分 如SUCCEED，ERROR，都应该有专门的色彩，起到警示和强调的作用; 进度条 对于耗时较长的程序，应该打印一个进度条，让用户对完成进度有一个直观的概念； 条例清晰的LOG 每一个指令，都该包含指引(-h)、运行中和运行结果的Log提示； 二、ANSI实现丰富的终端样式 ANSI escape code ANSI是一种能想终端打印彩色输出的标准编码，你可以理解为富文本! 这是一段python示例代码，我们需要关注0, 30, 42这三个数值: print '\\033[0;30;42m' + '...' + '\\033[0m' 内容 图示 作用 Style 0 字体样式 Bgcolor 30 背景色 Color 42 字色 下图罗列了一些字色和背景色： 1. Style 下面是常用的字体样式 作用 编码 示例 Normal \\033[0m Hello World Bold \\033[1m Hello World Underlined \\033[4m Hello World Changing \\033[5m Delete \\033[9m Hello World 2. Color todo下面汇总一些常用颜色 颜色 编码 示例 black \\033[30m Hello World red \\033[31m Hello World green \\033[32m Hello World yellow \\033[33m Hello World blue \\033[34m Hello World white \\033[37m Hello World 3. Cursor 如何控制箭头（终端的闪烁符）移动？ 下面{n}中表示移动的单位数 作用 编码 备注 Up \\033[{n}A 上移箭头 Down \\033[{n}B 下移箭头 Right \\033[{n}C 右移箭头 Left \\033[{n}D 左移箭头 Next Line \\033[{n}E 移到下一行 Prev Line \\033[{n}F 移到上一行 Set Column \\033[{n}G 第n列 Set Position \\033[{n};{m}H 第n行m列 Clear Screen \\033[{n}J 清屏 Clear Line \\033[{n}K 清行 对于清屏和清行: J = 0: 清除光标到末尾（行位） J = 1: 清除光标到开头（行首） J = 2: 清除整个屏幕（整行） 我们可以借此实现一个百分比的进度更新： for i in range(0, 100): # 10秒跑完 time.sleep(0.1) sys.stdout.write(u\"\\u001b[100D\" + str(i + 1) + \"%\") sys.stdout.flush() 下面模拟一个实时滚动的进度条，且只停留在最底栏 n = 10 for i in range(n): sys.stdout.write(u\"\\033[-1;0H\") sys.stdout.write(u'\\033[2K') sys.stdout.write(u'\\033[100D') print i print 'Processing: [' + '#' * i + '.' * (n - 1 - i) + ']' + ' %d%%' % (i+1), sleep(1) 参考 ANSI escape code How to print colored text to the terminal"},{"title":"【Python】性能分析","date":"2021-12-14T15:31:37.000Z","path":"posts/2NFFW5M/","text":"NOTE推荐最快的Profile方法: python -m cProfile -o tmp.prof xxx.py snakeviz tmp.prof Profiler工具原理 性能分析的原理是什么？有哪些常用的profile方法呢？ 1. Instrumentation （插装） 这应该是最容易理解的方式，看下面代码 import time t1 = time.time() # do something t2 = time.time() cost_time = t2 - t1 # s 插装的本质就是：统计运行时间或次数 常见方法： 1.首尾手动记录时间/次数… 2.profile工具自动插入源码； 3.profile工具修改汇编码/中间码； 海森堡Bug 由于修改了源码，插装有概率会使程序发生不一样的结果，尤其是多进程的情况下； 2. Sampling （采样） 每隔一段时间中断进程，获取当前堆栈信息，并从统计学上估计每段代码的运行时间； Visual Studio Profiler 就是基于采样实现 几乎大部分Profiler都是采样实现，因为它有如下几个优点： 1.不需要修改代码，不需要重新编译； 2.可以动态修改中断的interval，控制采样精度和开销的平衡； 3.对程序的性能影响小，结果可靠； Python Profiler 下面介绍几个常用的python profile库： [1. cProfile](https://docs.python.org/2.7/library/profile.html) 这是一段官方文档示例 import cProfile, pstats, StringIO pr = cProfile.Profile() pr.enable() # ... do something ... pr.disable() s = StringIO.StringIO() sortby = 'cumulative' ps = pstats.Stats(pr, stream=s).sort_stats(sortby) ps.print_stats() print s.getvalue() 下面是cProfile的结果，很清晰： totime：函数本身花费时间 cumtime：函数累计花费时间（包含子函数递归） [2. snakeviz](https://jiffyclub.github.io/snakeviz/) snakeviz其实是解析了cProfile的结果，做了个网页端的可视化界面； snakeviz使用步骤： 先使用cProfile生成prof文件： python -m cProfile -o res.prof demo.py 再解析prof生成网页： snakeviz res.prof 得到如上精美的profiler火焰图； Profile注意点 1. 多进程 不要把cProfile放在父进程，不然profile结果只有acquire； 这是因为父进程只起了调度和fork的作用，要在子进程中 profile； 🔥 Stackoverflow: 90% of the time is spent on method ‘acquire’ of ‘thread.lock’ objects 参考资料 CPU性能分析工具原理 How can you profile a Python script? Python程序性能分析 穷人的程序性能分析器"},{"title":"【Python】多进程multiprocess","date":"2021-12-12T06:52:20.000Z","path":"posts/2A7ENQS/","text":"概要 多进程（并发）是现代计算机的基本组成之一； 介绍了进程、线程、协程是什么，以及相互关系； 1. 一篇CSDN博客 这是我大学操作系统期间写的一篇CSDN博客，看到有3w+访问和700+的收藏，这是我意想不到的； 回头看这篇文章，几乎没有专业词汇，而是用类比的方式解释了进程相关的基础知识； 摘取片段如下： ===================================================== 单CPU：一台单核处理器计算机 = 一个车间； 多CPU：一台多核处理器计算机 = 一座工厂； 进程：一个车间 = 一个进程； （即一个运行的程序） 多进程：一座工厂可以同时运行多个车间； CPU和进程：单CPU只能同时运行单个进程，多CPU可以同时运行多个进程。 线程：车间内一个工人 = 一个线程； 进程与线程关系：一个进程可以包括多个线程。 ===================================================== 什么是进程 (Process) A process is a program that is running on your computer 单核机器为什么给人可以同时处理一堆程序 的错觉？似乎和多核差不多？ 如下图，这些任务其实是依次执行，这叫并发 (concurrency)； 如下图，对于多CPU机器，很多任务可以同时执行，这叫并行 (parallelism)； 进程间通信 (Process Communication) 进程间是互相独立，不共享任何数据的，那么跨进程如何交互呢？ 🔥 What is Interprocess Communication? 进程通信的例子 linux grep、windows任务管理器... 什么是线程 (thread) 🔥What is the difference between a process and a thread? 先问一个问题：为什么需要线程，只靠进程不够使用吗？ 假如OS中只有进程... 处理input的进程，每当用户敲击键盘，系统就要给出相应处理； 想象当你以飞快的速度敲击作输入，而进程又处理不过来呢，电脑是不是就巨卡无比？ 多线程的意义：某个任务会阻塞，但又不希望影响到别的任务进行下去； 如图所示： 线程存在于进程内，且多线程共享进程内存； 多线程间有自己的寄存器和堆栈，互不影响； 下图是windows的任务管理器，可以清楚得看到进程与线程之间的从属关系！ 什么是协程 (coroutinue) 通俗讲，协程是对线程的一种更小粒度的划分 （这里就不多介绍了） 扩展阅读 借助 C setjmp.h 实现简单的协程 2. Python? 写到这里突然扪心自问，这与python有何关系😅？ 本来是使用Python2的multiprocessing和subprocess踩了坑，想写篇文章记录下； 但随着白天查阅资料，大多问题已然解决；💪 等以后有缘再来补上吧 参考资料 进程和线程的深入理解 What is Interprocess Communication? Threads What is the difference between a process and a thread? What is a coroutine? Building Coroutines"},{"title":"资源汇总帖（效率、专业知识）","date":"2021-12-06T16:06:30.000Z","path":"posts/FYK74B/","text":"效率工具 Listary 全局文件搜索，类似于everything Snipaste 截图神器，支持桌面悬浮、历史记录 Directory Opus Windows资源管理器 神器! Beyond Compare 代码比对神器，看Diff Traffic Monitor CPU、内存监视器 网页工具 jsoncrack json在线可视化 godbolt 在线看python、cpp汇编 speedscope 在线生成火焰图 m3u8-downloader 网页m3u8视频下载 专业书籍 《汇编语言》（王爽） 交叉：计算机系统架构 + 汇编 + Unix操作系统 《Data Abstraction and Problem Solving With C++》 交叉：算法/数据结构 + C++11语言特性 + 设计模式与思想"},{"title":"Windows Batch脚本","date":"2021-12-06T14:48:15.000Z","path":"posts/2R1N3XK/","text":"概要 Batch(批处理)是 Microsoft 提供的一门基于cmd.exe解释器的脚本语言； 客观讲很不好用，但是windows下开发尝尝难以避免； Batch常用语法 🔥 传送门: Windows Batch Scripting 1. 基本指令 语法 作用 示例 echo 输出字符 echo hello world rem 注释 rem 这是一条注释 pause 暂停命令 pause call 调用指定bat call demo.bat start 调用exe start demo.exe goto 跳转到:xx goto 1 :1 call demo.bat set 设置变量 set path=C:\\ @ 屏蔽回显 @echo off &gt; 重定向 echo test &gt; a.txt | 管道，前面的输出重定向到后面的命令 echo /Y | start demo.exe 2. 高级语法 1. 判断某个路径是否存在 if exist C:\\Python27\\python.exe ( ... ) 2. 寻找python的sys path路径 for /f %%p in ('where python') do( set PY=%%p exit ) 3. 关闭batch指令的打印（回显） @echo off 4. 利用管道回到命令行的输入请求 可以将/Y作为输出传给后面的指令 echo /Y | xxxxx 3. 建议 Windows Batch不是很好写，建议用Python脚本或Linux Shell…"},{"title":"Regex：正则表达式","date":"2021-12-02T15:00:24.000Z","path":"posts/3SAT4K7/","text":"NOTEregex：regular expressions 本文介绍了正则表达式的基本常用语法 这篇文章有一些进阶regex应用 【vscode插件】function decoration Good Resources 下面是一些介绍Regex的网站： 这些内容很优秀，我写博客仅仅是为了自我记录、及筛选对自己有用的部分； learn-regex (github) Regex Online test RegexOne RegexLearn Regex在线调试: regex101 推荐一个在线Regex做题的网站，难度很高! https://alf.nu/RegexGolf 这是一个在线regex测试的网站： https://tool.oschina.net/regex/ Regex Grammar 1.完全匹配 1.区分大小写、空格等，严格匹配每个字母的顺序； 2.实际用(xyz)表示完全匹配； (The) =&gt; The fat cat sat on the mat. 2.基本字符 字符 用法 示例 . 匹配换行符外的任意字符 .ar =&gt; The car parked in the garage. [] 匹配[]内的任意字符 [Tt]he =&gt; The car parked in the garage. ^ 反义符 [^c]ar =&gt; The car parked in the garage. * 匹配$\\geq0$个字符 [a-z]* =&gt; The car parked in the garage #21. + 匹配$\\geq1$个字符 c.+t =&gt; The fat cat sat on the mat. ? ?之前的为可选 [T]?he =&gt; The car is parked in the garage. {n, m} 匹配$n\\leq k\\leq m$的重复次数 [0-9]{3} =&gt; The number was 9.9997 but we rounded it off to 10.0. (xyz) 完全匹配 the =&gt; The fat cat sat on the mat. A|B 匹配A或B字符 (c|g|p)ar =&gt; The car is parked in the garage. \\ 转义，表示[]().?等 \\. =&gt; a.b 3.特殊匹配 字符 用法 等同于 \\w 所有数字or字母 [a-zA-Z0-9_] \\W 所有非数字or字母 [^\\w] \\d 所有数字 [0-9] \\D 所有非数字 [^\\d] \\s 所有空白字符 [\\t\\n\\f\\r\\p{Z}] \\S 所有非空白字符 [^\\s] Regex进阶 /g /m /i: Flags Flag Description i Case insensitive: 忽略大小写 g Global Search:全局匹配 m Multiline: 匹配多行 ?: lazy matching 默认的正则会匹配尽可能多满足条件的字符 (greedy matching) 通过使用?, 可以在第一次匹配到的时候即停止 (lazy matching) MODE grammar result normal /(.*at)/ The fat cat sat on the mat lazy /(.*?at)/ The fat cat sat on the mat"},{"title":"Depth testing","date":"2021-11-30T14:37:50.000Z","path":"posts/2M66594/","text":"概要 深度测试，决定了投影空间下的物体是否被遮挡，即是否需要绘制； 一些关键的技术，离不开精确的深度测试结果； Depth-test and Depth-buffer 先阅读这篇文章： 🔥 Occlusion: 可见性与剔除 depth buffer (z-buffer) depth-buffer存储着每个pixel的深度信息（可以理解为一个0-1范围的float值）； 而depth-test就是写深度（write depth-buffer）的过程 depth-test是在pixel shader后进行 为什么是这样的次序？ 如果在pixel shader之前做深度测试，有什么后果呢？ OpenGL Code glEnable OpenGL是默认关闭深度测试的，因此需要手动开启它； 这句标志着，depth-buffer是可写的，且会在每一帧不断写入它； glEnable(GL_DEPTH_TEST); glClear 每一帧绘制完，需要手动清空这一帧的color-buffer和depth-buffer； 不然会残留上一帧的深度数据，导致显示Bug； glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glDepthMask 当某一帧不想写深度了怎么办？ 它用来标记depth-buffer是只读，还是可写； glDepthMask(GL_FALSE); glDepthFunc 深度测试，会将每个pixel新的深度信息，与旧的比较，如果满足条件则通过（写入并覆盖旧值）； 下面一些参数是不同的通过规则： Function Desc GF_ALWAYS 永不通过，后画的在前面，与远近无关 GL_NEVER 与上面相反 GL_LESS ✔ 小值通过 GL_EQUAL 等于的通过 GL_GREATER 大于的通过，远的反倒画在前面 … … Depth precision z-value，也就是深度值，是怎么计算的呢？ 线性方案： $$Z = \\frac {z - near} {far - near}， Z \\in [0, 1]$$ 缺点： 近处和远处的depth，拥有一样的精度； 是不是很浪费？游戏中我们更关注靠近相机的物体！ 非线性方案： 不如把$z$取个倒数，这样是不是近处的精度就更大了呢？ $$Z = \\frac {1 / z - 1 / near} {1 / far - 1 / near}， Z \\in [0, 1]$$ Debug输出z-buffer TODO 调试输出，需要转化到NDC空间，感受下z-buffer的变化 多截图，多说明 Z-fighting 这是一个常见的artifact：当两个三角面离得足够近（coplane）时，做深度测试时由于精度问题，导致两个三角面的计算结果总是反复横跳的，表现上是奇怪的锯齿花纹： 解决方案 避免物体摆放过近； 增大近裁面的值，相当于提高了整体的z精度； 提高z-buffer的精度，比如从24bit -&gt; 32bit，但是带宽消耗也变大了； 参考资料 Depth-testing Depth Buffer and Z-fighting"},{"title":"Model and Mesh","date":"2021-11-28T10:52:52.000Z","path":"posts/2WF6HFQ/","text":"概要 实际的游戏开发中，（模型）美术会制作fbx,max等资源给程序使用; 因此我们要讨论如何导入，以及如何渲染这些3D模型 3D Formats 美术使用的3D软件很多，如Blender、3DMax、Maya等等； 不同软件有自己的3D模型格式（虽然大都提供了互相导入导出），所以了解这些常见的格式很关键； 格式 特点 FBX 含动画、材质、骨骼等 glTF 含动画、材质、骨骼等几乎所有信息 OBJ 仅模型和材质信息 FBX .FBX 是MotionBuilder使用的格式，它是一个动画制作平台； FBX支持动画、材质、贴图、骨骼、灯光、摄像机等信息； FBX支持法线和贴图坐标，可以写入贴图路径； Wikipedia: FBX glTF .gltf 是OpenGL和Vulkan背后的3D图形标准组织Khronos所定义，它具有最标准与精简的格式，可谓3D模型的JPG； gltf支持动画、材质、场景、摄像机等几乎所有，甚至可以包含shader程序； gltf采用json的格式，因此可读性和兼容性很高； gltf可以编译成二进制：bgltf； wikipedia: GLTF OBJ .obj 是Wavefront公司推出的跨平台3D模型格式； OBJ是纯3D模型，不包含动画（区别FBX）、贴图路径、材质等信息； OBJ支持法线和贴图坐标，但需要手动制认贴图； Wikipedia: Wavefront.obj 这是一篇介绍OBJ的好文章: 🔥 Tutorial 7 : Model loading OBJ格式分析 这是一个简单的Cube的obj文件: # Desc xxx 这里都是注释 mtllib cube.mtl # mathlib或usemtl记录了使用的材质 # v是vertex v 1.000000 -1.000000 -1.000000 v 1.000000 -1.000000 1.000000 ... # vt是texture uv vt 0.748573 0.750412 vt 0.749279 0.501284 ... # vn是normal vn 0.000000 0.000000 -1.000000 vn -1.000000 -0.000000 -0.000000 ... # f是face, 描述每个三角面的v/vt/vn s off f 5/1/1 1/2/1 4/3/1 f 5/1/1 4/3/1 8/4/1 f（face）怎么理解 假设对于某一行：f 8/11/7 7/12/7 6/10/7： 8/11/7是三角面的第一个点； 7/12/7是三角面的第二个点； 6/10/7是三角面的第三个点； 对于每个三角面： 8是指第8个vertex，找对应的v； 11是指第11个vertex texture uv，找对应的vt； 7是指第7个vertex normal，找对应的vn； 以上利用了索引（indices）的思想，本质是用时间换空间，节省了内存！ 动手尝试 这么看下来，是不是自己也可以写一个obj的解析器了呢？ Mesh 既然Model是由很多Mesh组成，那么什么是Mesh？ A mesh is a collection of vertices, edges and faces that define the shape of a 3D object. mesh是一些顶点、边、面的组合，它们定义了一个3D物体的形状. 我们通常用triangle mesh来代表物体，为什么？ 几乎任何图形都可以用多个三角形表示，比如一个圆，可以是无数个三角形模拟而成； 所以三角面越多越复杂，往往意味着模型的面数越高、精度越高；（如下图） Assimp Open Asset Import Library: 一款支持多种模型格式导入与加载的标准库 下图是Assimp中一个model的架构： Scene scene包含一个RootNode指针，以及所有的Mesh和Material对象； RootNode RootNode对象中的Children[]中，递归包含了所有Model的指针； 它还包含了所有的Mesh对象； Mesh 什么是Mesh？它包含了所有Rendering需要的信息：vertex（顶点）, normal（法线）, texture（贴图）, materials（材质）等… 问题汇总 “由于找不到assimp-vc140-mt.dll，无法继续执行代码。重新安装程序可能会解决此问题。” 参考资料 3D graphics file formats What is a mesh Tutorial 7 : Model loading"},{"title":"博客写作规范","date":"2021-11-27T08:56:28.000Z","path":"posts/docs/","text":"导读 使用push指令代替hexo，一键生成、发布、更新config todo: 常用文章自己指定 abbrlink todo: 较长文章开头写 思维导图 大纲 为什么写博客 📄 随时查阅的手册 ✏️ 锻炼写文档的能力 💪 收获感，满足感，正向推动学习的坚持 💡 反复の增、删、该，是一个逐渐 “加深理解” 的过程 🎉 博客网页的不断打磨，是一个满足 “强迫症” 的过程 虽然 www.luhao.wiki 公开了ip，但这是一个完全 “面向自己” 的博客 汇总一些优秀的个人博客: lianglianglee 👍 酷壳 - CoolShell BOT Man (Tecent) 云风的 Blog 博客特性 Config todo: true: 标记未完成, 文章首页显示 📌TODO top: xxx: 置顶的序号, 文章首页显示 ⭐置顶 thumbnail: /images/xxx.png: 首页的文章icon, 使用 100x100 的像素 password: xxx: 加密, 但愿不会被破解 Description 描述xxx&lt;!-- more --&gt;: 对应封面描述 当文章标题不够清晰时, 请在 “箭头处” 添加额外文字 Heading 文章内标题以 ## 开始, 样式会标注为棕红色 更低级的标题以 ###, **** 等开始 Latex latex失效看后面的问题汇总 $sin \\alpha + sin \\beta = 2 sin \\frac{\\alpha + \\beta}{2} cos \\frac{\\alpha + \\beta}{2}$ Code 要标注代码的语言, 才能正确开启高亮 Emoji 表情仅用作视觉区分 or 强调，不要滥用 ✔ ❌ 🔥 ⭐ 🎉 💡 警示框 Admonition 是一种基于html的警示样式, 规定语法如下: !!! NOTE/ERROR/TODO/WARNING title paragraph ... Admonition示例 This is a demo for admonition. 链接 基本的链接格式是： ![text](link)，其中两个部分要严格按照规范： 图片 所有png、gif资源都放在 ./themes/pure/source/images/ 目录下，因此链接的格式为 ![](/images/***.png) 文章锚点 所有markdown h1, h2, h3都会插入html锚点，链接格式为 [text](#html-id)，注意最好填入 “html源码中的id值”，因为html源码会把空格、特殊字符等作一个替换 图表 其实是内嵌html文件, 示例如下: &lt;iframe src=\"https://luhao.wiki/html/render.html\" 替换这里的html height=500 width=100% 修改高度即可 frameborder=0 scrolling=yes&gt; 支持滚动条 &lt;/iframe&gt; 视频 利用html语法内嵌视频 (资源来源于w3school) 你的浏览器不支持HTML5视频 &lt;video width=\"400\" controls&gt;&lt;source src=\"https://www.w3schools.com/html/mov_bbb.mp4\" type=\"video/mp4\"&gt;你的浏览器不支持HTML5视频&lt;/video&gt; 更新日志 🎉 备注: html报错 Uncaught ReferenceError: $ is not defined? 确认 *.ejs 中填写的路径不要是绝对路径 错误: /images/a.png 正确: images/a.png 3月, 首页文章新增 thumbnail 缩略图 修改 themes/pure/layout/_partial/post/title.ejs，根据post对应属性来添加html样式 所有缩略图在 icons8 网站使用 100x100 的png图标 4月7日, 修复Latex失效问题 确保安装的包是 hexo-renderer-mathjax 需要将node_modules/hexo-renderer-mathjax/mathjax.html中的script替换为: &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 4月30日, 优化代码高亮样式 弃用 hexo原生的 highlight.js, 转投 google/code-prettify 的怀抱, 目前功能如下: 支持所有主流语言（带自动识别） 支持行号 字体编程友好 Consolas 准备将 inline-code 仍然沿用之前的 橙色加外边框 todo 参考：Hexo 接入google高亮的教程 5月5日, 集成hexo指令到 push 命令为 . push, 点号表示在当前路径运行 push 考虑添加 git 提交次数, git rev-list --all --count 6月4日，新增html 红色下划线样式 效果预览：int *p = *a 借助html代码实现： &lt;u class=\"error\"&gt;text&lt;/u&gt; 6月11日，主页左侧新增分类栏 实现方式为在 header.ejs 中遍历添加 site.categories 中的元素。 同时关闭了 “所有分类” 的按钮入口。 通过 _config.yml 的 enable_left_categories 字段控制开关 6月13日，上传图片脚本 windows下通过一个 push.bat（放到环境目录）实现png上传到对应hexo目录 同时将 id_rsa.pub 拷贝到 ~/.ssh/authroized_keys 下以避免密码输入 scp %1.png root@1.15.115.4:/root/hexo-workspace/themes/pure/source/images/%1.png hexo-blog-encrypt 加密文本 此加密插件会在首页的缩略文字加上 “Here's something encrypted, password is required to continue reading.” 的文字，需要修改如下代码去除： node_modules/hexo-blog-encrypt/index.js 将 data.excerpt = data.more = config.abstract; 修改为 data.more = config.abstract; 2023.6.18 迁移到新服务器 必要组件 zsh ： 【Shell】oh-my-zsh Node.js： Node.js hexo： Hexo：轻量的博客框架 迁移服务 hexo 个人日志 ✔ apache 文件服务器 ✔ crontab ✔ 迁移ssh私钥和公钥 直接拷贝 id_rsa 和 id_rsa.pub 到新机器的对应目录下 ssh-add id_rsa 如果遇到报错，执行 chmod 400 ~/.ssh/id_rsa 支持思维导图 hexo-markmap Github: hexo-markmap npm install hexo-markmap --save 通过缩进控制归属层级，示例如下 {% markmap 300px %} # Testa ## test1 ## test2 # Testb ## test1 ## test2 {% endmarkmap %} 修复源码 hexo-markmap/lib/template.js 中自定义css的bug一处，配置的css路径为 /html/markmap.css@0.2.7，主要是修改了字体样式 有空尝试另一种 minimap：https://hunterx.xyz/use-mindmap-in-hexo.html 分类页切为首页样式 修改 category.ejs，将生成html的代码直接替换为 index.ejs 同款； git commit"},{"title":"Lighting","date":"2021-11-24T13:45:07.000Z","path":"posts/S7WXS5/","text":"概要 lighting主要分为：平行光、点光、聚光灯； 本文介绍了每种lighting的原理与实现细节； Directional Light 平行光：（如太阳光） 影响范围无限大 所有点强度一样，只受方向影响 定义如下： struct DirectionalLight { vec3 direction; vec3 ambient; vec3 diffuse; vec3 specular; }; void main() { vec3 lightDir = normalize(-light.direction); [...] } Point Light 点光： （如电灯泡） 影响范围是个球体 强度随距离衰减 Attenuation 怎么衡量这种衰减呢？ linear equation 强度随距离线性衰减，表现效果比较差！ $F{att} = 1.0 - dist / range$ quadiratic 强度随距离二次衰减，效果贴近现实！ $F{att} = \\frac{1.0}{K{c} + K{l}*d + K{q} * d^2}$ Ogre3D’s Wiki, 给了一些取值的参考; Spot Light 聚光灯： (如手电筒) 影响范围是个圆锥 强度随距离和半径衰减 都是 基于OpenGL撸一遍代码； 尝试抓帧看一看； 引擎层，尝试构建一个Lighting的forward管线； 参考资料"},{"title":"Colors and Materials","date":"2021-11-18T15:15:17.000Z","path":"posts/SZGATA/","text":"概要 自然界的颜色可以看做是由Ambient, Diffuse, Specular三种组成； 不同的材质（Materials），决定了颜色的不同显示性质； Colors 物体的颜色是如何产生的？ 观察下图: 太阳光包含所有可见色（7种），当照射在物体上时（如红色），只能反射大部分的红光，如下图所示: 用公式表示简单的反射颜色: $reflectColor = lightColor * ObjectColor$ RGB颜色表示: $red = (1, 0, 0)$ $green = (0, 1, 0)$ $blue = (0, 0, 1)$ $black = (0, 0, 0)$ $white = (1, 1, 1)$ 为什么黑色是0, 白色是1? 从能量看：黑色能量最低，白色能量最高 从反射公式看：黑色不反射任何颜色(0)，白色会反射任何颜色(1) Phong lighting model 了解了Colors原理，我们学习如何表示现实中的lighting; 三个组成: ambient + diffuse + specular Ambient 环境光: 各种复杂光源反射的颜色，通常表现在较暗的环境下; 通常会取一个环境光强度(ambientStrength)，乘以光照强度，以计算ambient: $color = ambientStrenth * lightColor * ObjectColor$ Diffuse 漫反射光：直接光照反射的颜色，受光照角度的直接影响； 既然考虑角度，所以引入normal(法线)的概念：垂直于顶点所在平面的向量 当光垂直入射平面，反射最强，平行入射则最弱； $color = max(dot(normal, lightDir), 0.0) * lightColor * ObjectColor$ 怎么算顶点法线? todo Specular 高光：光泽表面反射的颜色， 如下图所示，当视角与光的反射角度越来越小时，我们看到的高光也会越来越强烈 （假设这是一面镜子）； 显然：高光强度是受 光入射角 + 面法线 + 视角 共同影响的； 与Diffuse的计算有一点区别，我们使用pow来让越接近反射光线的区域，反射强度越大； $color = pow(max(dot(reflectDir, viewDir), 0.0), 32) * lightColor * ObjectColor$ 32的系数是什么？ 用作pow的系数越大，表示高光影响的范围越小，高光强度也越大； 下图可以看到不同系数的效果； 最后如何叠加三种颜色呢？ $color = ambient + diffuse + specular$ Materials 什么是材质？ 自然界中，不同物体对光照的反应不同； 木头和水泥不会对光产生很强的反射，他们几乎没有高光；但水晶和镜子就会显得闪闪发光… 它们本质是各种反射属性和数值的组合，我们将它定义为Materials(材质) #version 330 core struct Material { vec3 ambient; vec3 diffuse; vec3 specular; float shininess; // pow的指数, 衡量高光区域 }; uniform Material material; 对应的，我们也可以维护灯光的简单属性: struct Light { vec3 position; vec3 ambient; vec3 diffuse; vec3 specular; }; uniform Light light; 下面看一个使用材质和灯光属性的示例： // lighting properties lightingShader.setVec3(\"light.ambient\", 0.2f, 0.2f, 0.2f); lightingShader.setVec3(\"light.diffuse\", 0.5f, 0.5f, 0.5f); lightingShader.setVec3(\"light.specular\", 1.0f, 1.0f, 1.0f); // material properties lightingShader.setVec3(\"material.ambient\", 1.0f, 0.5f, 0.31f); lightingShader.setVec3(\"material.diffuse\", 1.0f, 0.5f, 0.31f); lightingShader.setVec3(\"material.specular\", 0.5f, 0.5f, 0.5f); // specular lighting doesn't have full effect on this object's material lightingShader.setFloat(\"material.shininess\", 32.0f); Lightmap 想象在实际工作中，我们怎么制定一个真实物体的Materials呢？ 这就是美术同学的工作啦，在编辑器中指定diffuse、specular、normal等贴图，这样就赋予了它复杂而美丽的纹理； Shader Sampler shader提供了sampler2D，它能够读取各种格式的图片； struct Material { sampler2D diffuse; sampler2D specular; float shininess; }; in vec2 TexCoords; uniform Material material; 感受一下带了diffuse和specular贴图的效果： 参考资料 LearOpenGL-Colors LearOpenGL-Basic Lighting"},{"title":"第一次来家的小边牧","date":"2021-10-24T15:07:42.000Z","path":"posts/25374YZ/","text":"b3dc07a81f6459d120ce338ccca5504603780459e0306826441972681af56d62e5c8df8a8c8b786c064334936495b3bf83228f3b2ead8556cc3cb8048ae26847c8e914621b496b7004fe6882233afe5393b8f32076abfef2f234949bd027a34fbf09d28542fb2cc9c5f9882b568746dcc9aea531b78b578a89781affff46dd1fa58374a252f3877e2b223950d522ca7cacd9c23dee53d4b8288a5801e1c270173893a321c6d4866a1106b1f2e3d1bd31cfb33f0ef0bbd13a9a6e3efa3041006a6d1576d762df28279bb82c05381621827456933196e65ce91c8a134de12c5d48bc681e9207fa4387d1f13347d00eeb4e7190aef02c9513be1e862bb60500d43c83233e444878c99296bfe050082bd5cdf2f32703a2b57f2d5928be52b3366befa83be0205358c86a0fce6a5508a95d0617cadca5c8480cc959948670fa465a55b5f6c427a93185c1cf24271dd50957cf2e5b471f307e600f0c25322309622fa1b1c82e5afc3d54ebcd43e8a7f03e3b5176df84df132992817a53fb25162159aa8f03c78fd67b3b81f4d3595886a042e2e1a0206922bcb6b55d9b50aa83df3c5a70b3247450adbb77dbe39633af9649e89833d053d297fb8b73ee37ef9622bdff7e9b3c02c239613c0c3e0036761d286765d189d5438dcca12ba9ecca925c4fdab1d40880b9a21be5c1361c7f7975b724504e50e32909f9bec7b70c6c1d233363194069cdc2ba141128e908f6fc86a5972e30e57f0488a239f64b4e7d5d31a19f4df49d62fba002a1582c6132b6c2477ae4144a67c9fb67f678b5c690751403a12cfef8634f3e4fd581848f8315f480765fed82ed91d6d2409be289d9cc00bed14e07f70916af1c4edede9b247687347b5ce51f51a4edfb73adfd1e2adbc6ed857a2673f9186802d37db3d031e4dc3d0f7b2d34334fb86e37a07620e1d31bd5b4a2b6f94846c89be35ceb990c9c3519777b6b79b5891ae6172af4e3022497c29242e0d8bb3c43d60a15698d9920f9467d7b405ef0aa77bd8238b748756df5f948b13bd8897c0193c5b6f7d09629328daf529260519b8978c33c8575b273f692cb92fcbc5d68f7cae83734753c61e50291a4519333669048d4c5b9b178ec8c9200c00b323beabe7af5d16f7246d89e49e18349103172f558bbde40e2bb49ee930611d333dff7114201598e391867be30b19af33792be16be58f377a0dab347d6fc Hey, password is required here."},{"title":"Textures","date":"2021-10-22T14:50:23.000Z","path":"posts/1EF3PT0/","text":"概要 Textures 纹理，让游戏中的物体拥有丰富的色彩表现； 其本质是，如何将顶点坐标映射到uv坐标； What is texture? A texture is a 2D image (even 1D/3D exist) to add detail to objects; Texture coord. 纹理坐标，又称$uv$坐标，是$[0,1]$的浮点数； 对于下图我们尝试如下定义$uv$坐标： float texCoords[] = { 0.0f, 0.0f, // lower-left corner 1.0f, 0.0f, // lower-right corner 0.5f, 1.0f // top-center corner }; Texture Wrapping 对于超过$(0,0)$和$(1,1)$的uv坐标，我们如何去填充呢？ OpenGL提供了如下几种方式： Texture Filtering Determine the texture mapped uv (using the nearby pixels…) 想象CPU传来的$uv$坐标是$(0.3, 0.3)$，纹理尺寸是$64 * 64$； 通过计算$0.3*64$，我们得到应该采样$(19.2, 19.2)$； 那么问题来了，像素是一块一块采样的，$19.2$到底采哪里呢？ 如下两种情形必然会出现错误： 纹理大于模型表面：多对少，错位与丢失像素； 纹理小于模型表面：少对多，马赛克； note想象一张图片，经过缩小，会看不清；经过放大，会出现马赛克；就是这个意思 OpenGL给了如下两种基本方案: 1. nearest-neighbor filtering 选取离周围4个pixel最近的一个； 2. bilinear filtering 取周围4个pixel取均值； 两种filtering效果对比： 3. trilinear filtering 由于bilinear是在同一个Mipmap level做平滑，因此tri-filtering考虑了最接近的两层Mipmap level，并对最后结果做一次线性平滑； 4. anisotropic filtering 前面是基于Texture与模型表面平行下，如果两者形成角度，就会有如下Artifacts； 4X AF表示需要多采样4倍的pixel；16X同理； 想象一下，当图片倾斜与平面，我们需要采样更多的点来涂满这个区域! FAQ 这里要扣一下原理与Coding! AF都用硬件做了，但可以尝试用Pixel Shader模拟下玩玩 5. Performance ★ 采样的像素数越多，性能开销越大~ Filering Samples nearest-neighbor 1 bilinear 4 trilinear 8 AF 4X 32 AF 16X 128 Mipmaps 想象三维空间成千上万的物体，如果远处的与近处拥有一样大小精度的纹理（贴图），是不是很浪费呢？（远处的成像后未必看得清楚） 并且，大纹理映射到小物体，更导致一些列Artifacts； a collection of texture images where each subsequent texture is twice as small compared to the previous one. glGenerateMipmaps: 帮助我们为一张Texture创建对应的Mipmap； Coding实现 Vertex data格式: 单单Pos和Color已经不能满足要求，我们需要扩充一个uv坐标来用于纹理采样 float vertices[] = { // positions // colors // texture coords 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, // top right 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f // top left }; Vertex Shader: 根据上面Vertex Data的格式，得出location分别是pos, color, texture： #version 330 core layout (location = 0) in vec3 aPos; layout (location = 1) in vec3 aColor; layout (location = 2) in vec2 aTexCoord; out vec3 ourColor; out vec2 TexCoord; void main() { gl_Position = vec4(aPos, 1.0); ourColor = aColor; TexCoord = aTexCoord; } Pixel Shader: pixel shader只需要输出颜色即可 Texture Sampler 如何将texture传给GPU呢？GLSL提供了一个Sampler的东西； 看ps中的sampler2D #version 330 core out vec4 FragColor; in vec3 ourColor; in vec2 TexCoord; // texture sampler uniform sampler2D texture1; void main() { FragColor = texture(texture1, TexCoord); } 参考资料 纹理过滤模式中的Bilinear、Trilinear以及Anistropic Filtering"},{"title":"Shaders","date":"2021-10-20T14:51:51.000Z","path":"posts/3GZKBFK/","text":"概要 Shader, 理解为一种GPU Program 不要尝试用中文翻译它! Graphics Pipeline The process of transforming 3D coordinates to 2D pixels 我曾尝试去理解什么是“渲染管线”？ 这其实是一个很抽象的翻译，不仿用造房子来比喻。 建筑工程，其实是从设计图纸到高楼大厦的过程，其中有画设计图、打地基、该楼层、装修，等等。 渲染管线恰恰与他相反，是一个把高楼大厦复原到图纸（即屏幕）上的过程。 渲染管线，即从三维模型处理到最终二维的屏幕输出。 从上面图片可以看一个大概的流程 （当然实际应用复杂的多！） Shaders: small programs running on GPU. vertex and pixel shader is neccessary in OpenGL! 1. Vertex Shader Takes a single point and can adjust it. 这一步是为了处理顶点数据，对Vertex坐标做各种变化，然后再输出给Geometry/Pixel Shader； FAQ Vertex Shader会处理颜色吗？是否存Color属性呢？ 2. Geometry Shader Takes each transformed primitive (triangle, etc) and can perform calculations on it. 处理图元数据，输入可以是三角形等，可以输出多种三角形 3. Rasterization maps the resulting primitives to the corresponding pixels on the final screen. 光栅化负责将所有Vertex坐标，映射到不同分辨率的显示屏上； 这里有很多研究领域，比如**采样、抗锯齿（AA）**等等； 4. Pixel Shader (Fragment Sahder) Calculates the colour of a pixel on the screen based on vertex shader, textures and others (shadow, lighting…). 这是渲染管线比较重要的一步； 常见的贴图、光、阴影等各种着色都在这里计算； 因此，Nvidia又称之为Texture Shader 5. Alpha test and Blending alpha test: blending 透明材质、混合材质等，由于其特殊性，会在渲染管线比较靠后的位置；不然怎么表现透明呢？ Pratice: 第一个Shader Vertex data NDC: Normalized Device Coordinates. vertex shader的输入，就是定义在NDC坐标下. 如下我们定义一个三角形: float vertices[] = { -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f }; 接下来，我们要将这些数据传给GPU，用于Vertex Shader的计算！ VBO：Vertex Buffer Objects，存放以上数据的GPU Memory OpenGL有很多VBO的类型：GL_ARRAY_BUFFER是比较常用的; unsigned int VBO; glGenBuffers(1, &amp;VBO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData: 将顶点数据真正的喂给GPU glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); Vertex Shader 后面会介绍一些简单的语法: #version 330 core layout (location = 0) in vec3 aPos; void main() { gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0); } Compile Vertex Shader (run-time) 先对char[]编译，后续会扩展开发! const char *vertexShaderSource = \"#version 330 core\\n\" \"layout (location = 0) in vec3 aPos;\\n\" \"void main()\\n\" \"{\\n\" \" gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n\" \"}\\0\"; 如何编译VS? unsigned int vertexShader; vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL); glCompileShader(vertexShader); Pixel Shader 同理，ps更关心的是color，vs则关心位置 const char *fragmentShaderSource = \"#version 330 core\\n\" \"out vec4 FragColor;\\n\" \"void main()\\n\" \"{\\n\" \" FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\" \"}\\n\\0\"; unsigned int fragmentShader; fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL); glCompileShader(fragmentShader); Link and Combine Shader编译完，需要链接并整合起来 unsigned int shaderProgram; shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); 渲染线程中开始绘制: glUserProgram() glUseProgram(shaderProgram); // 记得回收 glDeleteShader(vertexShader); glDeleteShader(fragmentShader); 到这里我们通过vs+ps实现了一个三角形的绘制! EBO: element buffer objects 假设我们需要画一个正方形, 那么需要两个三角形，即如下6个点: float vertices[] = { // first triangle 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, 0.5f, 0.0f, // top left // second triangle 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left }; 是不是很浪费? 因为其中两个顶点可以复用，所以其实4个Vertex就够啦！ 尝试用vertex + indices，用4个vertex画出一个正方形! float vertices[] = { 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left }; unsigned int indices[] = { // note that we start from 0! 0, 1, 3, // first triangle 1, 2, 3 // second triangle }; unsigned int EBO; glGenBuffers(1, &amp;EBO); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); // 这里指定用EBO+索引的方式，省了2个Vertex glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); Shaders语法 先看代码示例 #version version_number in type in_variable_name; in type in_variable_name; out type out_variable_name; uniform type uniform_name; void main() { // process input(s) and do some weird graphics stuff ... // output processed stuff to output variable out_variable_name = weird_stuff_we_processed; } 1. Types vec类型 vec2 vect = vec2(0.5, 0.7); vec4 result = vec4(vect, 0.0, 0.0); vec4 otherResult = vec4(result.xyz, 1.0); 2. In and out #version: opengl版本 in: shader的输入 out: shader的输出 Vertex Shader需要 layout关键词来获取vertex data location = 0 代表采的indice #version 330 core layout (location = 0) in vec3 aPos; // the position variable has attribute position 0 out vec4 vertexColor; // specify a color output to the fragment shader void main() { gl_Position = vec4(aPos, 1.0); // see how we directly give a vec3 to vec4's constructor vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // set the output variable to a dark-red color } Pixel Shader的输出必然是一个vec4的Color #version 330 core out vec4 FragColor; in vec4 vertexColor; // the input variable from the vertex shader (same name and same type) void main() { FragColor = vertexColor; } 3. Uniforms uniforms是一种重要的从CPU-&gt;GPU传数据的方式 uniforms是global变量，任意stage的任意shader都可以访问! 换个思路，它是不是很费很耗？ Shader通用框架开发 ★★★ 痛点1：咱们总不能每次写个Char*去编译Shader吧？ 痛点2：PC(dx11)到android(gl)到ios(meta)的shader互不兼容，我们每个平台都要写一遍shader吗? (fuck) Writing, Compiling and Managing Shaders Github Page: 🔥 gshader.cpp ./shader目录：存放所有vs/ps源码 问题汇总 1. OpenGL的VAO、VBO、EBO区别? VBO: 存储大量顶点信息，给Vertex Shader用 VAO: 告诉GPU如何使用VBO，使用哪个VBO EBO: 利用索引节省Vertex的内存开销 2. Vertex shader与Pixel shader的区别? Vertex shader：对顶点坐标作运算； Pixel shader：对每个像素的颜色作运算；（Nvidia又称之为Texture Shader) 参考资料 Stackoverflow: What are Vertex and Pixel shaders? LearOpenGL: Hello-Triangle"},{"title":"Git操作指南","date":"2021-10-19T15:47:07.000Z","path":"posts/git/","text":"概要 Git使用指南； 汇总了使用Git时遇到的一些坑! Git原理 🔥 这篇文章讲得非常棒：我用四个命令概括了 GIT 的所有套路 Git本质是：三个分支之间的状态转移与维护： work dir：自己的工作目录 stage：本地暂存区（缓冲） history：本地历史区（永久保存） Git操作 man git git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] [--super-prefix=&lt;path&gt;] [--config-env=&lt;name&gt;=&lt;envvar&gt;] &lt;command&gt; [&lt;args&gt;] Git问题 fatal: unable to access https://github.com/xxx.git/:Failed to connect to github.com port 443: Timed out stackoverflow 尝试 git config --global --unset https.proxy Git Error: OpenSSL SSL_read: Connection was reset, errno 10054 … Git插件 VSCode推荐使用 GitLens 插件, 支持逐行实时Blame, 但是似乎收费?"},{"title":"【Algorithm】String matching","date":"2021-10-16T15:51:06.000Z","path":"posts/1RJC6HF/","text":"概要 linux grep的效率令人称奇! 字符串匹配的常用算法与原理； 字符串匹配算法 问题描述 在父串$(String, len=n)$中寻找一个合法子串$(Pattern, len=m)$； 例如，abcdef的一个合法子串是abc，但ac就不是 warning不要尝试写代码和图解，侧重算法思想和推导过程！ 如果连一个非CS专业的都能看懂，那才叫棒； 算法 时间复杂度 精髓 Brute Force $O(nm)$ 有脑子就行 Robin-Karp $O(n+km)$ 字符串Hash，$k$ 是hash hit但不匹配的次数 KMP $O(n+m)$ LPS数组 Boyer-Moore Sunday 暴力匹配 两层$for$循环的遍历： 父串$S$中共有$n$个长度为$m$的子串，复杂度$O(n)$ 将长度为$m$的子串与$Pattern$逐字符比较，复杂度$O(m)$ 暴力的复杂度是$O(nm)$； Robin-Karp算法 暴力中逐字符对比很浪费，尝试Hash算法，可以从$O(m)$ 降低到 $O(1)$； 但考虑到hash collision，即使hash hit，也需要逐字符对比来验证； 时间复杂是 $O(n+km), k$ 为hash hit但不匹配的次数； 缺陷 假设每次都hash hit但又不匹配，那Robin-Karp就退化为了暴力算法；(显然不可能) 因此越选择精确的Hash算法，Robin-Karp的效率就越高； KMP算法 如何更好地理解和掌握 KMP 算法? Knuth-Morris-Pratt Algorithm KMP的精髓在于，如何跳过一些明显不可能的匹配？ 如上图，当字母d匹配失败时，暴力法会回到字母b处重新开始对比； 这显然是效率低下的；因为回到字母ab处匹配会更好； 为什么回到ab处呢？因为ab是$p$的一个前缀！ LPS数组 longest prefix and suffix. 最长公共前后缀 对比abcab，它的LPS就是ab，长度为2； 这就是为什么，上图中我们要移动到ab处； 如何计算LPS数组？ 利用了递推的思想，有空详细解释下~ LPS[m] # 构建的数组 i, j = 0, 1 LPS[0] = 0 while j &lt;= m: if P[i] == P[j]: LPS[j] = i + 1 i++; j++ else: if i == 0: LPS[j] = 0 j++ else: i = LPS[i-1] 复杂度 时间复杂度$O(m)$，$m$是子串P的长度； 利用LPS数组做匹配 i = 0 # 父串S下标 j = 0 # 子串P下标 while i &lt; len(S): if S[i] == P[j]: i++; j++ elif j &gt; 0: j = LPS[j-1] else: i++ if j = len(P): # Match Success pass 这一步时间复杂度是len(S)，即$O(n)$ KMP算法的复杂度即$O(n+m)$ FAQ 笔者python测试对比如上三种算法（随机字符n=1000w, m=10），时间如下： BF: 5.6s Robin-Karp: 1.18s KMP: 1.41s 为什么KMP稳定比RK算法慢？ 虽然KMP严重依赖Pattern的性质，但不至于稳定差 参考资料 如何更好地理解和掌握 KMP 算法?"},{"title":"【Algorithm】Sorting","date":"2021-10-16T12:43:21.000Z","path":"posts/1CKQG3J/","text":"这是大学时期写的 排序算法的深入分析和实现 1.1 排序的定义 对一序列对象根据某个关键字进行排序。 1.2 术语说明 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序In-place：所有排序操作都在内存中完成； 外排序Out-place：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 1.3 算法总结 排序算法 时间复杂度 空间复杂度 冒泡排序 O(n2) O(1) 选择排序 O(n2) O(1) 插入排序 O(n2) O(1) 归并排序 O(nlogn) O(n) 快速排序 O(nlogn) O(logn) 堆排序 O(nlogn) O(1) 捅排序 O(n+k) O(n+k) 1、冒泡排序（Bubble Sort） 相邻两个元素比较大小，一次外循环比较(n-1)次； 如跑完第一次循环，最大的元素被移到最后一位； 内循环跑(n-i)次，因为最后i个元素已排好序； 时间复杂度分析： 比较次数：不管怎样，冒泡排序都要比较(n+(n-1)+…+2+1)次，即n(n-1)/2 ，O(N^2); 交换次数：有序不需要交换，逆序交换n(n-1)/2次；O(N^2); 稳定性分析： 相邻两元素大小一样，自然不会多此一举去交换，因此稳定； C++代码实现： //冒泡排序 void bubble_sort(int *a, int n){ for (int i=0; i&lt;n-1; i++){ //外循环n-1次 for (int j=0; j&lt;n-i-1; j++){ //内循环找出前n-i个中最大元素，不断往末尾移 if (a[j]&gt;a[j+1]){ int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; } } } } 2、选择排序（Select Sort） 每次选择第i小的元素，把它放在index为i的位置上； 一共n次外循环，第一次选出最小元素，放在第一个；第i次选出第i小的元素； 每次内循环要比较(n-i)次，最终选出后(n-i)个元素中最小的，放到i位置上。 时间复杂度分析： 比较次数：选择排序同样比较(n+(n-1)+…+2+1)次，即n(n-1)/2 ，O(N^2); 交换次数：有序不需要交换，逆序交换n(n-1)/2次；O(N^2); 稳定性分析： 因为涉及相隔较远的元素交换位置！ 例如3 2 3 1，第一次循环结束，3和1交换，破坏了稳定。显然选择排序是不稳定。 C++代码实现： //选择排序 void select_sort(int *a, int n){ for (int i=0; i&lt;n-1; i++){ //外循环n-1次 int min = a[i], index = i; for (int j=i; j&lt;n; j++){ //内循环找出后n-i个中最小元素，放到第i位置 if (a[j] &lt; min){ min = a[j]; index = j; } } a[index] = a[i]; a[i] = min; } } 3、插入排序（Insert Sort） 类比平时打牌时插牌，拿到新元素，把它放到已排好序的元素中的适当位置； 外循环n次，第i次外循环结束，则前i个数已排好序，第一个默认排好序； 内循环为执行(n-i)次，将新元素和前i个排好序的依次比较，是一个不断往前插的过程； 时间复杂度分析： 比较次数：同O(N^2); 交换次数：有序不需要交换，逆序交换n(n-1)/2次；O(N^2); 稳定性分析： 插入排序是稳定的；例如 1 2 3 3，前三个已经排好序，最后的3显然不会再往前插； C++代码实现： //插入排序 void insert_sort(int *a, int n){ for (int i=1; i&lt;n; i++){ //外循环n-1次，第i次外循环结束前i+1个元素排好序列 int index = i; for (int j=i-1; j&gt;=0; j--){ //内循环将第i个元素往前插 if (a[index]&lt;a[j]){ int tmp = a[index]; a[index] = a[j]; a[j] = tmp; index = j; } } } } 4、归并排序（Merge Sort） 采用分治法，将序列分成两个n/2长度的子序列，合并时依次按大小输出到新序列； 占用额外空间，非原址排序； 时间复杂度分析： 每次递归复杂度O(n)，递归层数O(lgn)，所以复杂度为O(nlgn); 稳定性分析： 归并排序是稳定的，合并过程左右两个序列的比较大小保证了这种稳定性； C++代码实现： //归并排序 void merge(int *a, int *b, int p, int r, int q){ //合并下标为p到r 与 r+1到q 这两部分 int write = p; //写入b的下标 int i=p,j=r+1; //分别标记左右序列正要读的位置 while (i&lt;=r &amp;&amp; j &lt;= q){ if (a[i]&lt;=a[j]) b[write++] = a[i++]; else if (a[i]&gt;a[j]) b[write++] = a[j++]; } //此时左、右序列可能有一个未写完 while (i&lt;=r) b[write++] = a[i++]; while (j&lt;=q) b[write++] = a[j++]; for (int k=p; k&lt;=q; k++) a[k] = b[k]; } void merge_sort(int *a, int *b, int beg, int end){ if (end==beg){ //1个元素直接返回 return; } if (end-beg == 1){ //2个元素，排个序 if (a[beg]&gt;a[end]){ int tmp = a[beg]; a[beg] = a[end]; a [end] = tmp; } return; } merge_sort(a,b,beg,(beg+end)/2); merge_sort(a,b,(beg+end)/2+1,end); merge(a,b,beg,(beg+end)/2,end); } 5、快速排序（Quick Sort） 从数列中挑出一个元素，称为 “基准”(pivot)； 重新排序数列，所有比pivot小的摆放在基准前面，所有比pivot大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； Partition操作实现： pivot选择末尾元素，维护i和j，i指向头，j指向pivot前一个。i不断往后搜索直到找到第一个大于pivot的元素；j不断往前搜索直到找到第一个小于pivot的元素。i,j都找到时交换i,j上的元素，如果j&lt;i，退出循环，此时交换pivot和i位置，满足pivot(即i原来位置)左边都比它小，右边都比它大； 时间复杂度分析： 每次递归复杂度O(n)，递归层数O(lgn)，所以复杂度为O(nlgn); 稳定性分析： 快速排序是不稳定的； 因为间隔元素的交换，很可能打破原有相同元素的顺序关系； 例如3 3 1 1 2，选择2为pivot，那么第一次循环，3和1就发生了交换，打乱了稳定性； C++代码实现： //快速排序 int partition(int *a, int p, int q){ int pivot = q; //选择最后一个元素作为pivot int i=0,j=q-1; while (i&lt;=j){ while (a[i]&lt;=a[pivot] &amp;&amp; i&lt;q ){ //i左边都&lt;=pivot i++; } while (a[j]&gt;a[pivot] &amp;&amp; j&gt;=p ){ //j右边都&gt;pivot j--; } if (i&lt;j){ //i不会等于j int tmp = a[i]; a[i] = a[j]; a[j] = tmp; } } //交换i和pivot int tmp = a[i]; a[i] = a[pivot]; a[pivot] = tmp; return i; //partition结束，满足左边&lt;=它，右边&gt;它 } void quick_sort(int *a, int beg, int end){ if (beg&gt;=end) return; int pivot = partition(a,beg,end); quick_sort(a,beg,pivot-1); quick_sort(a,pivot+1,end); } 参考资料"},{"title":"Occlusion: 可见性与剔除","date":"2021-10-14T14:10:29.000Z","path":"posts/2AR5BC4/","text":"概要 光栅化决定如何将三维场景画到二维屏幕上； 但以什么样的顺序绘制？（Visibility） 是否所有的物体都要绘制到屏幕上? （Occlusion） Occlusion 一叶障目，不见泰山 想象你的视线，远处的物体总被近处的遮挡，这就是Occlusion! 将“看不见”的物体剔除掉，是图形学优化的重要方向之一! Painter’s Algorithm 画家算法：由远到近绘制物体，远处总被近处的遮挡； 因此又称Depth-sort Algorithm; 算法分析: 需要对n个物体排序: $O(nlogn)$的复杂度，对$n$面数; 不能处理多面重叠的情形; Z-Buffer 对于每个三角形面片中每个Pixel$(x,y,z$），不断取其$z_{min}$，并赋值位z-buffer上该pixel的值 # init zbuffer for +∞ for (each tri T): for (each pixel (x,y,z) in T): if (z &lt; zbuffer[x][y]): framebuffer[x][y] = rgb; # also as color buffer zbuffer[x][y] = z; # also as depth buffer else: # occlusion now! 算法分析: 省略了排序，因此是$O(n)$的复杂度，对$n$面数； 不能处理两个三角形，存在深度值z相同的pixel的情形；（虽然这种情况很少发生，因为是float32） 什么是framebuffer与zbuffer? 通俗的说，它们都是一块内存（RAM）; framebuffer：存储rgb的颜色值 z-buffer (depth-buffer)：存储深度信息 图解z-buffer的生成过程 可以看出，计算z-buffer就是一个不断取$min$的过程！ TODO补充一张Nsight抓帧的frame-buffer, depth-buffer截图~ Futhermore… 常用的culling方案 hlod"},{"title":"关于开发理念: Simple is Good","date":"2021-10-10T10:03:53.000Z","path":"posts/1ZMZBDW/","text":"希望这个理念，能够伴随我所有的开发生涯 优秀的开发，是大道至简，而不是简单问题复杂化 在这之前 大学身边有一帮要好的文科朋友，经常会观察到这些现象： 理工科出身的同志，喜欢提枪就上，埋头苦干，就算没思路也要把电脑敲的噼里啪啦响； 文科出身的同志，喜欢事前构思、冥想，甚至磨半天也挤不出几个字； 如果要双方取长补短的话， 我希望程序员的世界，多一些主观性的理念的东西， 就是在每次敲代码之前，有个尼采一样的诗人在你耳边朗诵一遍： “1.少用宏； 2.做好封装；3.保持代码整洁 …” 程序员喜欢review，把问题留给Bug和Review阶段， 但为什么不学文科生， 脑海中树立一些宏观的、虚头巴脑的、理念的东西， 每次动键盘前，有个“社会主义核心价值观”在脑子里过一遍： 虽然玄学了些，但我觉得是个好建议。 这就是我写这些随笔的原因。 Simple is Good 我尝试用一些观点来论证why simple is good 运行更快 Bug几率更低 维护成本更低 有两种软件设计方法: 第一种是使得软件足够简单以至于显然没有错误; 第二种是使得软件足够复杂以至于没有显然的错误。 (最难的是第一种) - Tony Hoare (1980图领奖得主) 如果你说如何让一个复杂的功能保持simple？ 试试 封装 优化经常是一个不断删除代码的过程 simple不是无脑删除，合理的解耦与拆分也是一种simple 你可以尽可能地控制“少”，但你永远无法控制“多”； 想象一万个人对同一个需求的不同实现，总是千奇百怪。 Simple 拓展阅读 🔥 代码整洁之道 🔥 知乎: 一百行以下有哪些给力代码？"},{"title":"中英文档","date":"2021-10-10T08:06:11.000Z","path":"posts/XPRTBH/","text":"NOTE 罗列了常用、令人困惑的英文专有词汇，可结合站内 右上角的搜索 速查! 本篇已停更一段时间，尽量使用 “英语阅读，中文写作” 的方式 好的翻译多重要? 先祭出CS领域的经典垃圾翻译: socket: 套接字 robust: 鲁棒性 handle: 句柄 再看看什么经典优秀翻译: context: 上下文 (通俗) process/thread: 进程/线程 (进行中的程序) garbage collection: 垃圾回收 (直译就够了) 欢迎移步知乎话题: 为什么handle会被翻译成句柄？ 哪些专业名词翻译得特别烂？ 中英对照 关于对照表 1.Wikipedia的解释准确且全面，但可能不易理解； 2.某些社区(如知乎、博客)会有一些精彩而巧妙的理解，因此贴出来； 3.个人备注栏，添加了一些自己的理解； ❌意味着远离中文! 英文 中文 官方 个人备注 socket 套接字 Wikipedia robust 鲁棒性 Wikipedia 功能健壮, 具有高扩展性 handle 句柄 Wikipedia 对一段资源的引用, 像pointer? Cartesian coord. 笛卡尔坐标系 Wikipedia Homogeneous coord. 齐次坐标系 知乎 n+1维表示n维 我的博客 Viewport 屏幕 Projection 投影 我的博客 Orthographic 正交 我的博客 Perspective 透视 我的博客 rasterization 光栅化 Wikipedia 三维场景渲染到二维屏幕 anti-aliasing 抗锯齿(AA) Wikipedia framebuffer Wikipedia GPU memory to store Z-Buffer/Depth-Buffer Wikipedia 我的博客 painter’s algorithm 画家算法 Wikipedia 由远到近排序后绘制，近的覆盖远的 NDC Normalized Device Coordinates VBO vertex buffer object Wikipedia 我的博客 VAO vertex array object EBO element buffer objects vs vertex shader ps(fs) pixel (fragment) shader uv 纹理坐标 Texture filtering 纹理过滤 Wikipedia Artifacts ❌ Wikipedia 凡是不接近真实的图形表现 Mipmap LearnOpenGL Phong lighting model ❌ Wikipedia Colors and Materials Ambient 环境光 Colors and Materials Diffuse 漫反射光 Colors and Materials Specular 高光 Colors and Materials Lightmap ❌ Colors and Materials directional light 平行光 Lighting point light 点光 Lighting spot light 聚光灯 Lighting hover 鼠标悬停态 CSS hover Assembly-Language 汇编 AT&amp;T Syntax AT&amp;T汇编格式 Syntax versus Intel Syntax Intel汇编格式 Syntax versus | socket | | Wikipedia | |"},{"title":"TypeScript数据类型","date":"2021-10-08T16:13:59.000Z","path":"posts/3YE7XY8/","text":"Note🔥 Type Challenge 这是为TypeScript打造的Online Judge, 可以考察对其类型的理解 Builtin Primitives Types string 单引号与双引号皆可 (同python); ${expr}用来嵌入表达式; number 没有int, float之分; 0x, 0o都是ES6的进制表示法; boolean true, false 空值 undefined, null: 变量赋值 void: 函数返回值 Object Types Array … Any 当不确定类型时，使用any，这样后面可以赋予它任何类型 let foo: any; foo = true; foo = 'abcd'; let arr: any[] = ['John', 88, true]; arr.push('luhao'); any对象可以调用任意属性与方法! let foo: any; console.log(foo.name); // OK foo.setName('luhao'); // OK 没有申明类型的变量，等价于any // 两者等价 let foo; let foo: any stackoverflow: 申明any与否的意义? tsconfig.json中有如果对\"strict\"定义为true，那么对所有any的非法访问都是错误的! Inference 类型推论: 对于没有指定类型但已经赋值的变量，TypeScript会推断出一个类型： let foo = 'luhao'; // 此时TS已推断foo为string foo = 100; // Error // error TS2322: Type 'number' is not assignable to type 'string'. Union 联合类型使用 | 表示几个类型的并集： let foo: string | number; foo = 'luhao'; // OK foo = 100; // OK foo = true; // Error 联合类型一旦被赋值，其类型就是唯一的： let foo: string | number; foo = 'luhao'; console.log(foo.length); // OK foo = 100; console.log(foo.length); // Error, 此时foo是number类型 interface 它就像C中的struck: interface IPerson { name: string; // 必选属性 age?: number; // 可选属性 readonly gender: boolean; // 只读属性 [optName: string]: any; // 任意属性 } let person: IPerson = { name: 'luhao', // age: 24, // 可选 gender: true, school: 'NJU', } Assertion: 类型断言 !!! todo"},{"title":"【VSCode插件】Markdown-snippet","date":"2021-10-07T07:45:37.000Z","path":"posts/2167JH4/","text":"实现了一款用于Markdown代码补全、CSS样式插入等功能的VScode插件 开发环境：VScode, TypeScript Github Repo 🏠 VScode-Markdown-Snippet TODO 这个是若干年前的项目，准备捞回来完善下； 支持fontawesome 支持骚的html语法 支持表情的检索 支持size/color快速自定义 插件功能概述 支持Markdown基本语法插入与补全：表格、超链接、图片… 支持对选中内容：加粗、下划线、划去线… 支持内嵌多种css样式：改变颜色、左右对齐、字号… 支持图片直接复制粘贴到VScode； W1: 环境搭建与Demo 直接上文档: VScode API npm install -g yo generator-code : 安装依赖环境 yo code : 进入开发环境, 如下图 观察一下开发目录： extension.ts: 插件的脚本逻辑: TypeScript package.json: 所有的环境配置选项: 插件名、版本号、command… README.md: 发布后的文档 第一个Demo: 对选中内容加粗显示 **这段文字是加粗显示的** #这是markdown加粗语法 下面是实现的ts逻辑 showQuickPick API insertSnippet API // 当surround插件被激活时，会进入activate函数 export function activate(context: vscode.ExtensionContext) { // 输出一行Log console.log('Congratulations, your extension \"surround\" is now active!'); // surround.sur 定义在package.json中 let disposable = vscode.commands.registerCommand('surround.sur', function () { interface CommandQuickPickItem extends vscode.QuickPickItem { command: () =&gt; Promise&lt;void&gt;; } let items: CommandQuickPickItem[] = []; items.push({ description: '对选中的字体加粗', label: 'Font Bold', command: surroundWithBold }); vscode.window.showQuickPick(items, { matchOnDetail: true, matchOnDescription: true }).then(selectedItem =&gt; { if (selectedItem &amp;&amp; typeof selectedItem.command === 'function') { selectedItem.command(); } });; } // 对选中的内容进行加粗 function surroundWithBold() { let msg = \"**\"; let snippet = msg + '${TM_SELECTED_TEXT}' + msg; vscode.commands.executeCommand('editor.action.insertSnippet', {'snippet': snippet} ) } VScode插件打包与发布 本地打包测试 这里推荐打包为visx，并使用VScode安装 npm i vsce -g: 安装vsce打包工具 vsce package: 在插件目录打包 xxx.vsix: 在VScode的插件右上角选择Install from VSIX 发布到VScode Marketplace 使用Azue注册一个开发组织 vsce login &lt;publish-name&gt;: 登录自己的开发者账户, 需要tokens vsce publish: 发布到marketplace vsce publish patch: 使发布的version自增, 会自动修改package.json中的版本号 vsce unpublish &lt;publish-name&gt;.&lt;extension-name&gt;: 下架 这是我的VScode Marketplace的个人主页 已上架VScode Marketplace 参考资料 Building your VScode extension TypeScript VScode插件开发 中文文档 VScode LaTex Snippets开发教程 VScode插件开发全攻略十篇"},{"title":"【VIM】Vi Improved","date":"2021-10-01T07:56:55.000Z","path":"posts/vim/","text":"vi/vim is the best editor in the world! 骚操作 终端输入 set -o vi，在命令行使用vim模式（set -o emacs以回退） gim配置vim：git config --global core.editor \"vim\" 1、Vim: Vi improvment 先从一个stackoverflow经典问题看起： How do I exit the Vim editor? 这是回答： Hit the Esc key to enter “Normal mode”. Then you can type : to enter “Command-line mode”. A colon (:) will appear at the bottom of the screen and you can type in one of the following commands. To execute a command, press the Enter key. :q to quit (short for :quit) :q! to quit without saving (short for :quit!) :wq to write and quit … 到这里，你至少不用窘迫的不知如何退出Vim界面了！ 技巧：所有Vim Operation，都源于英文的缩写 （例如 q 表示 quit）, 因此下面的所有Vim快捷键，我都会尽可能列出其英文含义，已帮助你更快得记住它！ 2、Vim modes 什么是mode？ 模式，几乎所有的编辑器只有一种模式，即insert 插入 但是，Vim有起码3种重要的模式：normal, insert, visual 引自3中一句话：Programming大多数的时间消耗，不是在Writing上，而是review和Editing。 normal 模式 如何移动光标? h - ← move left j - ↓ move down k - ↑ move up l - → move right 更高效得，如何以单词为单位移动? w - move to beginning of next word (word) b - move to previous beginning of word (back word) e - move to end of word (end word) just type 'vim' in terminal, and check these with your hands! insert 模式 使用i来进入insert模式，使用Esc来退出insert。 i - insert text before cursor (insert) a - insert text after cursor (insert after) o - Start a new line below cursor, insert text (??) visual 模式 你一定猜到了，使用v可以进入visual模式。 此时可以批量成段的选择、编辑文本！ 3、Vim commands 直到阅读这篇文章前，我都不曾理解vim command的真正要义： Vim Text Objects: The Definitive Guide 在Vim的眼中，一切内容分为两种：text和objects 试想一下，一串无规律的字符串，它在编辑器眼里是text，这不无道理。 但如果是一个word，一个sentence，甚至是argument，那vim会视其为一个text object，以实现个更高效的操作。 &lt;number&gt;&lt;command&gt;&lt;text object&gt; 这构成了几乎vim 90%的操作。 daw – (delete a(around) word) 没错，它执行了删除一个单词的操作，并取决于你光标所在的位置。 diw - (delete inner word) inner于around有什么区别？around删除了周围的空白符，但是inner只删除了单词！ vf) - (visual(select) until(find) first )) 选中直到)的所有字符，并进入visual模式！ （需要稍加理解） 下面罗列了几乎所有的command和obejct，标星的表示常用！ Command d - delete ★ y - yank (经典ctrl c) ★ c - change (delete and insert) ★ v - visual (选中并进入visual模式) ★ r - replace (delte and insert) Object w - word ★ s - sentence p - paragraph (其实对不同于语言的识别不佳) a - argument ★ (编辑函数很有用) \" - quoted ★ (引号内) ), ], }, :… 一切皆可 4、vimrc ~/.viminfo是vim的cache，包括历史操作等 vim的配置是在~/.vimrc, 比较多且难记, 可以查看 Vim 配置入门 例如: set number是显示行号 5、vim pro 多行编辑 v键盘进入visual block模式，然后选中要编辑的所有行 I进入多行编辑模式, Esc退出生效 快速光标移动 %: 配对括号、引号等 {、}: 上一个/下一个 空行 [[、]]: 上一个/下一个 代码段 +、-: 上一行/下一行 非空白字符 Enter: 下一行 非空白字符 f+单字符: 行内搜索+快速移动, 按 分号键; 可以继续查找 运用数字表示重复 3j: 表示往下3行 3igo: 结束按esc, 即输入3遍go 不熟练操作 ~: 转大小写 O: 大写O在上方插入新行 c: 改写操作 cc: 删除当前行, 并进插入模式 cw: 改写下个单词 5、关于Vim的更多 vim 杂谈 - 关于快速编辑 StackOverflow: How do I exit the Vim editor? Introduction to Vim Modes VimGolf"},{"title":"写给三年内的技术成长目标","date":"2021-09-30T22:52:16.000Z","path":"posts/goal-2024/","text":"以下 写于2023年7月 继续惊觉时间飞逝 有收获，但也有走弯路 剩余一年时间，保持现有节奏之余，坚持两个核心 核心一：提高效率 当追求细化文档、扩散式学习（遇到陌生的点就深挖）后，工作的效率（指做完主线）明显降低。 中短期来看，这是不好的迹象，期望通过 区分任务主次 来改善。 核心二：攻城略地 期望 “染指” 更多中大型模块，快速弥补经验上的欠缺。 同时，攻坚 modern cpp、linux kernel、network、algorithm… 等领域，计算机的 “万丈高楼平地起”，恰恰依赖这些基础知识。 以下 写于2022年5月 惊觉半年已逝； 回看曾经的目标，宏大却不够具体，因此缺乏坚持的动力； 这次来细化下目标吧! 坚持阅读、写作 每周 1+ 篇博客, 不限题材（算命的、风水的都行） 每月阅读 1+ 本书籍 （技术 or 思维 …） 每月做 1+ 篇陌生技术的积累（前沿的、其他行业的） 尝试捣鼓一些小玩意，如破解插件、工具脚本，并将这些成果发布在开源网站上! 以下 写于2021年国庆 希望在三年后(2024.10)，能够达到如下的水平 精通2+ 脚本语言 python 2/3 ➜ 使用层面 ✔ JS/TS 精通1+ 静态类型语言 C/C++ ➜ C++ 11/14/17 精通3+ Gameplay模块 熟悉常见 Gameplay 模块 ✔ 手写一套基于OpenGL的渲染管线 基于引擎实现具体中小模块的 增删查改 Shader (compiler and manager) ➜ cross-platform shadercompiler Texture ➜ texture-budget Camera Lighting ➜ Cluster Lighting Shadows ➜ CSM Model/Mesh ➜ Culling Instancing Postprocess ➜ SSR Animation … Editor (Image, Scene, Model…) ✔ Debug Tools ➜ ImGUI、Tracy、RenderDoc… ✔ 图形引擎其他 良好的数学基础 图形学基础 ➜ GAMES UE4/Unity的学习借鉴 前沿技术的积累 Learning and Coding Reading Paper (GDC…) Reading Document (API…) Code review ➜ MR ✔ Blog Recording (Markdown!) ✔ Learn from open-source"},{"title":"【Algorithm】BinaryTree","date":"2019-09-22T16:00:00.000Z","path":"posts/1E2J1Y0/","text":"这篇文章是大学写的 二叉搜索树 1.0 定义 每个节点包含属性left,right和p，分别指向左右子节点和父节点 二叉搜索树的性质: x.left&lt;= x &lt;= x.right； 左子树&lt;父节点&lt;右子树 基本操作与树的高度有关，即O(lgn) 数据结构 查找 插入,删除 数组 O(n) O(n) 有序数组 O(lgn) O(n) 二叉树 O(lgn) O(lgn) struct Node { int val; struct Node* left; struct Node* right; Node(int x): val(x), left(nullptr), right(nullptr) {} }; //定义二叉树类型 typedef Node TNode; typedef Node* pNode; class AVL { // 平衡二叉树 public: pNode root; AVL() {root = nullptr;}; ~AVL() {delete root;}; int empty() {return (root==nullptr);}; int maxDepth(pNode p); // 该节点的最大深度 int minDepth(pNode p); // 该节点的最小深度 int findMax(); // 二叉树最大值 int findMin(); // 二叉树最小值 pNode search(int x); pNode _search(pNode p, int x); void insert(int x); pNode findParent(pNode p); // 返回该节点的父节点 pNode successor(int x); // 返回节点x的后继节点 void Delete(int x); // 删除值为x的节点 void levelOrder(); // 层次遍历，用换行表示层数递进 void preOrder(pNode p); // 前序遍历 void inOrder(pNode p); // 中序遍历 void postOrder(pNode p); // 后序遍历 }; 2.0 查找二叉树的最大最小值 最小值一定在树的最左节点，最大值一定在树的最右节点 不停向左(右)子节点搜索直到NULL即可 int AVL::findMax() { pNode p = root; while (p-&gt;right) p = p-&gt;right; return p-&gt;val; } int AVL::findMin() { pNode p = root; while (p-&gt;left) p = p-&gt;left; return p-&gt;val; } 2.1 返回二叉树的最大、最小深度 深度Depth定义：根节点root到叶子节点的距离 最大深度：即不断返回左右子树的深度中的较大值+1，递归实现 最小深度：即不断返回左右子树的深度中的较小值+1，递归实现 特殊情况：根节点只有一个子节点的时候，最小深度不是1，因为根节点不是叶子节点！ 处理方式：只有一个孩子，其最小深度就是该子节点的最小深度+1 int AVL::maxDepth(pNode p){ if (!p) return 0; return max(maxDepth(p-&gt;right), maxDepth(p-&gt;left)) + 1; } int AVL::minDepth(pNode p) { // 深度的定义：p到某个叶子节点的距离; // 因此当p只有一个孩子时,它的深度并不是1 if (!p) return 0; if (p-&gt;right &amp;&amp; p-&gt;left) // 有两个孩子，返回较小的深度 return min(minDepth(p-&gt;left), minDepth(p-&gt;right)) + 1; else // 只有一个孩子，返回此孩子的深度 return minDepth(p-&gt;right) + minDepth(p-&gt;left) + 1; } 2.2 二叉树的查找 search(x)：查找key为x的节点，返回其指针 先和根节点比较，小的话去左子树搜，大的话去右子树搜，等于则返回 pNode AVL::_search(pNode p, int x) { if (p-&gt;val == x) return p; if (x &gt; p-&gt;val) return _search(p-&gt;right, x); return _search(p-&gt;left, x); } pNode AVL::search(int x) { return _search(root, x); } 2.2 二叉树的后继节点 x的后继节点(successor node): key值大于x的节点中key最小的一个 x的前驱节点(prior node): key值小于x的节点中key最大的一个 查找x的后继节点，要对x进行讨论： x有右子节点，那么后继节点是右子节点的最左子节点 x没有右子节点，再分两种讨论 x自身是左子节点，那么后继节点是它的父节点 x自身是右子节点，那么后继节点是根节点，且必须满足x小于根节点，否则x没有后继节点 pNode AVL::successor(int x) { // 后继节点，大于x中最下的那个 pNode p = search(x); pNode tmp; if (p == root &amp;&amp; !p-&gt;right) // 根节点且没有右孩子 return nullptr; if (p-&gt;right) { // 如果p有右孩子，那么后继节点就是右孩子的最左孩子 tmp = p-&gt;right; while (tmp-&gt;left) tmp = tmp-&gt;left; return tmp; } else { // p没有右孩子 pNode par = findParent(p); if (p == par-&gt;left) { // p自身是左孩子 return par; } else { // p自身是右孩子, 返回层数最靠近p的有左孩子de节点 if (p-&gt;val &gt; root-&gt;val) return nullptr; pNode ppar = findParent(par); while (ppar) { if (par == ppar-&gt;left) return ppar; par = ppar; ppar = findParent(ppar); } return nullptr; } } } 2.3 二叉树的插入和删除 insert(x):插入新节点，同时维持二叉树的性质 若树空，直接插入root 若树不空，通过不断和左右孩子比较，往下移动直到找出合适的位置 void AVL::insert(int x) { pNode p = new TNode(x); if (!root) { root = p; return; } pNode tmp = root; pNode par; while (tmp) { par = tmp; if (tmp-&gt;val &lt; x) { tmp = tmp-&gt;right; } else { tmp = tmp-&gt;left; } } if (par-&gt;val &gt; x) { par-&gt;left = p; } else { par-&gt;right = p; } } delete(x): 删除已存在的某个节点x，同时维持二叉树的性质 若x是根节点，直接删除 若x只有一个孩子，用该子节点替换x 若x有两个孩子，找到x的后继节点nex并替换x 先用nex的key替换x的key，接着删除nex节点即可 若nex是它父节点的左孩子，那么把nex的左孩子顶上来 若nex是它父节点的右孩子，那么把nex的右孩子顶上来 void AVL::Delete(int x) { pNode p = search(x); if (!p) { cout &lt;&lt; \"Not Existed\" &lt;&lt; endl; return; } // case 1: p 没有孩子节点， 直接删除 if (!p-&gt;left &amp;&amp; !p-&gt;right) { if (p == root) root = nullptr; else { pNode par = findParent(p); if (par-&gt;right == p) par-&gt;right = nullptr; else par-&gt;left = nullptr; } } else if (p-&gt;left &amp;&amp; !p-&gt;right) { // case 2: 只有一个左孩子，替换即可 if (p == root) root = p-&gt;left; else { pNode par = findParent(p); if (par-&gt;right == p) par-&gt;right = p-&gt;left; else par-&gt;left = p-&gt;left; } } else if (p-&gt;right &amp;&amp; !p-&gt;left) { // case 3: 只有一个右孩子，替换即可 if (p == root) root = p-&gt;right; else { pNode par = findParent(p); if (par-&gt;right == p) par-&gt;right = p-&gt;right; else par-&gt;left = p-&gt;right; } } else { // case 4: 有两个孩子, 把它的后继节点替换到该位置即可 pNode suc = successor(p-&gt;val); int key = suc-&gt;val; Delete(key); p-&gt;val = suc-&gt;val; } } 二叉树的各种遍历 遍历方式 遍历顺序 应用和意义 层次遍历 按一层一层遍历 符合人的直观感受 前序遍历 根结点 —&gt; 左子树 —&gt; 右子树 打印目录结构：如每个文件夹下的文件 中序遍历 左子树—&gt; 根结点 —&gt; 右子树 编译底层：实现表达式树 后序遍历 左子树 —&gt; 右子树 —&gt; 根结点 回溯法: 实则就是采用后序遍历的形式 层次遍历：1 2 3 4 5 6 7 8 前序遍历：1 2 4 5 7 8 3 6 中序遍历：4 2 7 5 8 1 3 6 后序遍历：4 7 8 5 2 6 3 1 层次遍历 通过队列实现，每搜索一个节点，将它的孩子按先左后右的顺序加入队列； 这样保证了 1：层数越低的越先搜索； 2：左子树先于右子树搜索 void AVL::levelOrder(){ if (empty()) { cout &lt;&lt; \"empty Tree\" &lt;&lt; endl; return; } queue&lt;pNode&gt; Queue; queue&lt;int&gt; Level; Queue.push(root); // 记录节点 Level.push(0); // 记录层数 pNode p; int h; int last_h = 0; while (!Queue.empty()) { p = Queue.front(); h = Level.front(); if (last_h &lt; h ) cout &lt;&lt; endl; cout &lt;&lt; p-&gt;val &lt;&lt; ' '; if (p-&gt;left) { Queue.push(p-&gt;left); Level.push(h+1); } if (p-&gt;right) { Queue.push(p-&gt;right); Level.push(h+1); } Queue.pop(); Level.pop(); last_h = h; } cout &lt;&lt; endl; } 前序遍历 搜索顺序：根结点 —&gt; 左子树 —&gt; 右子树 算法实现：1.访问根节点 2.前序遍历左节点 3.前序遍历右节点 void AVL::preOrder(pNode p) { // 先序遍历：根-&gt;左右节点 if (!p) return; cout &lt;&lt; p-&gt;val &lt;&lt; ' '; preOrder(p-&gt;left); preOrder(p-&gt;right); } 中序遍历 搜索顺序：左子树 —&gt; 根结点 —&gt; 右子树 算法实现：1.前序遍历左节点 2.访问根节点 3.后序遍历右节点 void AVL::inOrder(pNode p) { // 中序遍历：左-&gt;根-&gt;右 if (!p) return; inOrder(p-&gt;left); cout &lt;&lt; p-&gt;val &lt;&lt; ' '; inOrder(p-&gt;right); } 后序遍历 搜索顺序：左子树 —&gt; 右子树 —&gt; 根节点 算法实现：1.前序遍历左节点 2.后序遍历右节点 3.访问根节点 void AVL::postOrder(pNode p) { // 后序遍历：左右节点-&gt;根 if (!p) return; postOrder(p-&gt;left); postOrder(p-&gt;right); cout &lt;&lt; p-&gt;val &lt;&lt; ' '; } 3.0 扩展概念 满二叉树 顾名思义：每层铺满的二叉树，n层满二叉树有2^n-1个节点 完全二叉树 即倒数第二层以上都铺满，最后一层紧左边铺的二叉树 平衡二叉树（AVL） 递归地满足：左右子树高度差不超过1的树 为什么需要AVL? 因为当二叉树形似链表时，查找效率从O(lgn)变成O(n)，所以想办法使得树的高度尽量平衡 平衡因子： 某节点的左右子树高度之差 二叉树的整个插入过程，分为四种形态："},{"title":"【Python】pyautogui","date":"2019-07-24T05:27:11.000Z","path":"posts/2KGMM94/","text":"Python纯GUI自动化工具 备注 这篇是大学于CSDN所写，移植过来 借助 pyautogui 实现鼠标键盘控制，实现一些自动化操作 pyautogui是一个可以控制鼠标和键盘的python库，类似的还有pywin32。 pyautogui的安装 pip3 install python3-xlib 依赖库 sudo apt-get install scrot 依赖库 pip3 install pyautogui python3下安装pyautogui库 import pyautogui 引入该库 pyautogui的使用 保护措施 为了防止pyautogui夺取了鼠标的控制权导致我们无法关掉该程序，它提供了一个保护措施，即把鼠标移到最左上角，此时程序报错退出； 默认FAILSAFE=True，保护模式开启 FAILSAFE = False 关闭保护措施 获取屏幕信息 size() 获取当前屏幕的分辨率，如(1920,1080)二元组 注意：屏幕左上角是原点(0,0)，整个屏幕相当于第一象限 position() 获取鼠标当前坐标 onScreen(x,y) 判断点(x,y)是否在屏幕范围内，如负值一定返回False 移动鼠标 moveTo(x,y,duration=0.25) 用0.25s的时间将鼠标移到(x,y)位置 moveRel(x,y,duration=0.25) 以鼠标所在位置为原点，将鼠标移动到(x,y)处 下面代码，让鼠标在指定位置绕一个正方形转动１０圈 import pyautogui for i in range(10): pyautogui.moveTo(300, 300, duration=0.25) pyautogui.moveTo(400, 300, duration=0.25) pyautogui.moveTo(400, 400, duration=0.25) pyautogui.moveTo(300, 400, duration=0.25) 下面代码，让鼠标绕当前位置绕正方形转１０圈 import pyautogui for i in range(10): pyautogui.moveRel(100, 0, duration=0.25) pyautogui.moveRel(0, 100, duration=0.25) pyautogui.moveRel(-100, 0, duration=0.25) pyautogui.moveRel(0, -100, duration=0.25) 鼠标事件 点击鼠标 click(x, y, button='left', click=3, interval=0.5) button有３个选项:left,middle,right，不加则默认点击鼠标左键 click表示单击次数 interval表示每次单击之间的时间间隔 click()函数实际由mouseDown()和mouseUp()组成，即按下和松开； pyautogui.doubleClick() 鼠标双击，其实就是执行两次click()函数。 pyautogui.rightClick() 右击 pyautogui.middleClick() 中击 鼠标滚轮 scroll(200) 控制鼠标的滚轮，正值上滚，负值下滚 拖拽鼠标 dragTo() dragRel() 按下鼠标，并拖拽到指定位置，用法同moveTo(),moveRel() 窗口截图处理、寻找目标按钮 截图功能 im = screenshot( region=(x,y,width,heigth) ) 截取以(x,y)为左上角且指定宽高的区域，不加参数，默认截取整个屏幕 im.getpixel( (x,y) ) 获取指定位置的像素，是一个三元组(注意输入格式) pixelMatchesColor(x,y,(R,G,B)) 判断(x,y)处的像素是否等于RGB im.save('xx.png') 保存为x.png 寻找按钮 locateOnscreen('xx.png') 寻找屏幕中和xx.png一样的图标位置，是一个四元组 click( center( locateOnscreen('xx.png') ) ) 点击该图标的中心，center用来获取图标中心点的坐标 比如把网易云音乐的应用存为music.png，上述就执行自动点击网易云的图标"},{"title":"【Python】tkinter","date":"2019-07-24T05:25:01.000Z","path":"posts/1AMJ55J/","text":"python + tkinter 实现绘图板 备注 这篇是大学于CSDN所写，移植过来 背景是课程作业 python+tkinter实现绘图板 github项目地址: 593413198/DrawingBoard 创建时间： 2019/5/10 搭建环境： Ubuntu 18.04 + python 3.6 + tkinter 使用指南： 上方菜单提供了用户界面的所有操作； 下方文本框提供了命令行接口，按\"执行命令\"按钮即可执行指令 最底部显示canvas上的所有图元，包括 “类型”+“ID”** 实现功能： 重置画布 resetCanvas width height 删除canvas所有元素，然后重置窗口大小即可(canvas是始终铺满窗口的) 保存画布 saveCanvas name.bmp 因为linux下通过截屏实现，所有保存的画布实际是整个屏幕 设置画笔颜色 setColor R G B tkinter内使用16进制，要转换 设置画笔粗细 setWidth width 绘制线段 drawLine id x1 y1 x2 y2 algorithm Bresenham DDA 绘制椭圆 drawEllipse id x y rx ry 中点圆生成算法 绘制多边形 drawPolygon id n x1 y1 x2 y2 … xn yn 通过Bresenham绘制多条线段即可 对图元平移 translate id dx dy 对图元旋转 rotate id x y r 对图元缩放 scale id x y s 代码架构： 第三方库 from tkinter import * import tkinter.messagebox as messagebox # 弹窗 import pyscreenshot as ImageGrab # 截图功能 for linux #from PIL import ImageGrab # 截图功能 for MacOS and Windows 窗口及菜单 window = Tk() # 主窗口window canvas = Canvas(window, ...) # 主画布canvas menu = Menu(windows) # 顶部主菜单menu entry = Entry(..) # 接受命令行指令的输入 button = Button(..) # 读入指令并执行 全局变量 Type_draw # 记录画图的类型 1:直线 2:点 3:椭圆 Flag_draw # 记录是否允许画图 0:不允许 1:允许 Color_pen # 画笔颜色 采用16进制表示 Width_pen # 画笔粗细 鼠标事件 onLeftDown() # 鼠标左键单击，允许开始画图 onLeftMove() # 鼠标左键拖动，开始画图 onLeftUp() # 鼠标左键松开，停止画图 绘图算法 Bresenham() # bresenham算法画直线 Draw_ellipse() # 中点圆生成算法画椭圆 相关函数 toHex() # 将RGB转化成十六进制色彩表示 rotate() # 旋转指定点 execute() # 读入命令行并执行"},{"title":"【Algorithm】Graphs","date":"2019-07-24T05:23:40.000Z","path":"posts/2W1G2XP/","text":"备注 这篇是大学于CSDN所写，移植过来 图算法的总结和实现 1.0 图的表示 图通常用两种数据结构表示：邻接矩阵-&gt;稠密图、邻接链表-&gt;稀疏图 对于图 G = (V, E) ，V是点集，E是边集，|V| |E|分别表示点、边的数目 稀疏图：边数很少的图 稠密图：边数接近|V|^2的图（一个图边数最多是点数的平方，只考虑单边图） 邻接矩阵 维护一个n*n的数组，n是图的点数|V| 根据图的性质，数组对角线都为0，上下半角都对称 矩阵存储的特点，不论边数|E|多大，永远都开|V|*|V|大小的数组 因为矩阵的大小取决于|V|，所以当边数足够多的时候，采用邻接矩阵表示对空间的利用率最高 邻接链表 每个节点维护一个链表，储存所有与它邻接的点 所有链表的头部储存在一个数组中 数组空间O(|V|)，链表空间是O(|E|)、最坏空间是O(|V|^2) 因为链表大小取决于|E|，所以当边数足够小时，采用邻接链表表示 python代码如下： class Graph(): ''' 无向图，点下标从0开始 G[x][y] = 1 存在边xy ; G[x][y] = 0 不存在边xy ''' def __init__(self,n): # 声明一个有n个点的图G self.n = n # |V|点数 self.node = [i for i in range(n)] # 所有点 self.G = [[0]*n for i in range(n)] # 邻接矩阵 self.d = [0]*n # 记录宽搜中每个点到起点的距离 self.order = [] # 记录深搜的顺序 def add(self,x,y,w=0): # 添加一条(x,y)的无向边 # 不输入边权重的情况默认为1 self.G[x][y] = 1 if not w else w self.G[y][x] = 1 if not w else w def remove(self,x,y): # 删除一条(x,y)的无向边 self.G[x][y] = 0 self.G[y][x] = 0 def neighbour(self,x): # 返回与x邻接的点 # rtype: 列表 ans = [] for i in range(self.n): if self.G[x][i]: ans.append(i) return ans def isEdge(self,x,y): # 判断点x,y是否邻接 return self.G[x][y] 1.1 图的宽搜和深搜 BFS：广度优先搜索 采用优先队列，先将起点x入队列 不断从队列中取出元素，访问其所有的邻点，再将其中未访问过的邻点加入队列 当队列空时搜索结束 DFS：深度优先搜索 深搜的顺序不是唯一的；从任一节点开始都可以 对某一节点，只要找到一个邻点，就对邻点继续搜索邻点的邻点 理论上的深搜，是对所有节点执行一次上一步骤，这样保证了所有节点都能被搜索完，实际操作中可以维护一个set来记录已经访问过的节点 以1为起点的BFS路径: 1 2 5 3 4 以1为起点的DFS路径: 1 2 3 4 5 python代码如下: # 广度优先搜索 def BFS(self,x): # 从点x开始宽搜 vis = [0]*self.n # 记录节点是否搜索过 Q = [x] while Q: v = Q.pop(0) vis[v] = 1 for i in self.neighbour(v): # neighbour表示v的邻点的集合 if not vis[i]: Q.append(i) self.d[i] = self.d[v] + 1 vis[i] = 1 # 深度优先搜索 def DFS(self,x): # 从点x开始深搜 vis = [0]*self.n # 记录节点是否搜索过 def dfs(node): vis[node] = 1 self.order.append(node) for i in self.neighbour(node): if not vis[i]: dfs(i) dfs(x) for i in self.node: if not vis[i]: dfs(i) 1.2 图的最短路径算法 单源最短路径问题：求出某一节点到其他所有节点的最短距离 Dijkstra算法 Bellman-Ford算法 所有节点对最短路径问题：求出每个节点到其他所有节点的最短距离 Floyd算法 Dijkstra算法 给定某一起点x，计算它到所有节点的最短距离 dist[v] 记录起点到点v的最短距离，即最终返回结果 S 一个集合，存放已经处理过的节点 初始状态：令起点的dist为0，它的邻点的dist就是两点距离，其他节点的dist赋为无穷大 循环过程：不断取当前dist最小的节点v出来，对它的邻点i做松弛操作，当前最小节点视为已处理节点，放入集合S 松弛： if dist[i] &gt; dist[v] + G[i][v] { dist[i] = dist [v] + G[i][v] } 终止状态：所有节点都已放入S，即都处理完毕 # dijkstra算法的python实现 def dijkstra(self,x): # dijkstra算法求x到所有节点的最短路径,采用贪心策略 dist = [99999]*self.n S = set([x]) # 记录已经找到最短路径的节点 for i in self.neighbour(x): dist[i] = self.G[x][i] dist[x] = 0 while len(S) != self.n: # 找到当前距离最小的点，这里用到最下优先队列 MIN = 99999 MIN_i = 0 for i in range(self.n): if dist[i] &lt; MIN and i not in S: MIN = dist[i] MIN_i = i # 松弛relax操作 S.add(MIN_i) for i in self.neighbour(MIN_i): if dist[i] &gt; dist[MIN_i] + self.G[i][MIN_i]: dist[i] = dist[MIN_i] + self.G[i][MIN_i] return dist"},{"title":"【CSDN】进程和线程的深入理解","date":"2019-04-24T16:14:40.000Z","path":"posts/2TKZZE3/","text":"备注 这篇是大学于CSDN所写，移植过来 回头看有点肤浅，但是这种类比学习的思维还是很难得呀 下面是抽象类比： 单CPU：一台单核处理器计算机 = 一个车间； 多CPU：一台多核处理器计算机 = 一座工厂； 进程：一个车间 = 一个进程； （即一个运行的程序） 多进程：一座工厂可以同时运行多个车间； CPU和进程：单CPU只能同时运行单个进程，多CPU可以同时运行多个进程。 线程：车间内一个工人 = 一个线程； 进程与线程：一个进程可以包括多个线程。 线程间内存共享：车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。 一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 内存安全：可是，每个车间容纳大小不同，有的最多只能容纳一个人。车间人满的时候，其他人就进不去了。 一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 互斥锁：一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。 这就叫\"互斥锁\"–Mutex，防止两个线程同时读写某一块内存区域。 信号量：这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。 这种做法叫做\"信号量\"（Semaphore），用来保证多个线程不会互相冲突。 锁和信号量：不难看出，互斥锁是信号量的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 操作系统的资源分配与调度逻辑 以多进程形式，允许多个任务同时运行； 以多线程形式，允许单个任务分成不同的部分运行； 提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。 下面是严谨的解释： 进程 进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。 线程 线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 进程和线程的关系 线程是进程的一部分 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程 进程和线程的区别 理解它们的差别，我从资源使用的角度出发。（所谓的资源就是计算机里的中央处理器，内存，文件，网络等等） 根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位 开销方面：每个进程都有独立的代码和数据空间（程序上下文），进程之间切换开销大；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行） 内存分配：系统为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源 包含关系：线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程"}]}