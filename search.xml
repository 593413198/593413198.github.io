<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【量化】OrderFlow 订单流策略研究</title>
      <link href="/posts/orderflow/"/>
      <url>/posts/orderflow/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c750ca525e9654be01e293fa0f1ea199f239f17ef5ea9601042bbfcb818bac8c">b3dc07a81f6459d120ce338ccca5504603780459e0306826441972681af56d624582f341449102626e559c75af687736c2dbe4e6baf6a934a24c0f78af13a83ced8b74c5e59aa1777c6d8a7c473d8eeb65368e9c8d836d47c12efb54e65da712f7ce30f43d95ed5d1faedfb647a5ab9ead8e3ea35bd6ffb81f3b46f64dfb989dad5998fbd968d8322f354aea44b5ba730decb5ac815450b1672014ccad9da2c73da7476fe270af5d2cff0cff70aeac6ccfd1fe160cace9d4e1a0ddc43cc0c379326660785b5fa0934f65e2fbaba535db0dbf085a0c6ca61625a8846c4855b0bb0f52ea598f22a9c9a53c1c2151f04eecf16c58c96444c417e73d4037ef69a461f975df7e624370078210fb5f983c29ee8e3f0ef2c6cc50e939615ee37e33c92992883c6c9ff8828c4bee8ac6287103ab26f6c658c0aa9dd6990058d3f440d0cc673a6d3db6cc7c6b646feeeee67bb10eef676edeb707e4d7b9f10b7243868021dab0b094fd3638281b2bb15d96acb1be6b5daec423d2e6ad1c133e3eade3055787e356da765caa8c93f298959510f5e4ce2c50265106bfb4408cfff89f290d2e96955727eeb52a627ffa26da381cad9a0aeaf46a1cf4cb7fd56a2090c3762662e44863a550a9bfffa3a98c86ed1db8194b6a9d66129cfcf34367f3c86c7904d8d915251f1e5dcd81ff6a9936d7f52369388053ba60113acf175086dd5b31521dbd052dd0a7e59248f5dbad97ba6aa059a6ab76036ca2dc21e607d79c68c041e1ee288628f460fa00c5a79ee62d0f625d2c767a7bc8e5fa99ca83b009a20d1db280d774f026ba2a8f343156db04b7cab70872e48ef48d7db1ddb4e81711d788a4ebc7741615ae93a92cdb89b685fa8f0096ec789dbd769ad90ec5c2f56de877398efdd0f56a840891a627e008d0c402015ee2225d3a1f837d5eef62bce525e0ebbd5a432116e54d8099f7623137ba9ea7c1431bce4c902435fc690d589958813c54c09118355a8ebdbec39ddbec6966144b43f689a0e1b267a1f97a4b9048f352544f920109c7ef2ad0994092ab990ff3e84441639b2914f23c312a608acd23e3551722bb515062b39835df49e0507719aab9b52a65ecc00603c18d51c3fd613aa4732536ed84399e7246f81a40c36d5b42dbd59dec4217f1ff9d054dd4bcae4d8c3406ce5ed05cbde2b0faf6cb7410312d768f1ecf50af72d695fe9b8df12c4ab45d6ea1398a998d8c221e92134a79d1e0c7f7d342ad164d51a331501f97917b1fdb9badb901a5007a5ade86f2551d5a002273a622a5bffea692dba9c677d1b8efce53dd4d9443ec2fc638c5434dd7fc5d3d1b7cc49e92a2b5b623cc6377a42cd83382f2c47751cf8da811c35a9388494b086f74486b57127c61e1d96cec892d4af68ed55fb7c7e2d27cf1dcf90e28578b680936476d65f1a6a26eec30a0c1ce4a3829af2edbbbf9c935b6e91537f7e2ea5c46dfa534f3bba03e3c0b5e4d2ea2382acd99c108f9d740f5fc27780cfb92c308d72310e13d6b360d700e4afee1d33b6fc8e8c722a2d8a8b499843ec2cba4ef4e707bee1a6c5b8cc87b509af29ee50f69302df04f61b3ee2cf240496fe12271d89e601ab5d9587453b985cc3a08aa45a51db840066ff380afecd2440b7fac168eb97337d4192908def4a519b3f7545a190d01467ae2202e1cbbaecc16eb1139c9744c839747f60c7e8d9bc60368612b0cf8dbec3fc1631d070a8dcb15c11bebede7977de65a9e3c77331dc68ec20bfd528fbcf1973bc11afd1aee7919edb34e0ba1e93b121d6898bdc893a3c7a9742951d30d4c066aaefd4d03a88435b4619a4061c9cd1926a70805849ae72caca09972271f205c51be5a43e1dcd10703b06e63f7c1ed8d3e4c5bc82e52612271b1a9c22ca1d4684c7841bd4148a584f6ca6a7b809e72593f435800f946213709b7c81ed7a6f8d761de4caa4e5e86d6da13f6ac8921c77ae62d7444ab9f5729ac4d71f05567215727e74ff4f21bb539191e981a16e7e517422f722bb95365bf9e59a20c0f0e847ee7ccfd56f6f842944363b3794a843ae7aa09e82fd9156d57c2911c59769a07eb6312aab076f813aab2902b62b66fea66d32cbd05f65213577218a350ff7b1c6ae6d6a1d5c45c26a0281da3197f131519f02c2ed9c4bd78a8d617b207d69ceef6e1f8191232d94b31f17f7304d1f588af716ec79993073a24dd377de2343d4296230f331f6194203112c3a11b615dc9854226f1968b0aad4c7a00b39f215581f58150c20a97c3d91cda58de60fad048fd29c6af7b61ade4f0745e3ccc4388e4d30bc8ae9de604b0af3d1a528cb2390aef7b0651ad7aeda09cfd732af9d3ed31a28b8d8e4711960b727e04813e7c1c3c89075a6cb4a57041ec50fa5ff024e06ffd2f2749935ea5a00ac83efc90c76ca12ebff152476e2a3221c68585b03b042e78529aae192d15a3e711538a2b990baca79c6f431f91177a3033bc45d67ee83ecf72b5058ef04f8aeaf1d07bd8fef948998f355b5121418a5e00d466273f40dc71b8946f839a1882f2acdb843c2485104debb6d8bda86e84450fe97c17d364a8a38815bca3cdb02a0748f94644032b54abffa85dd1f03e2d8f1288b73630253aa2937648782d3a913c921364664a65927f33e7c6c3e61396a9a4ca6951d662bfba35ce124bd60c23554dbd2845955ce9d491760791d715215e74b3e16b7bfcd19f05f01ab3d0a50199eed6908e2320a1d7afad701c2c094209224688281b7f384a35bf80728c0e8b420c7da93c5477559945469fdca2ef7201d05509b9e3f73f340cef23a5bd3ce75f5aafda72ca4be814fe628187eca41bbf4ad0caedafb174cf2ddfc991be05c6d0a75b8f4fcef051161f787ed39299c8241751f418433b4427d01b5ad331835ffab5a30acd3201e73ac97eb75111492101b8c953fc46a279847452edc24ad390425e3ae565fdd85f8598c8e297fdea42ac3b6ddd241dfb345a451d7ae51725855f2936e983ff9ffb51ab8a6225250a756ddcc74740299b33473ab0edc44a72fed6c19e6e46f05932d2d2c46b9ab180cf8a5d94f88be393ca3fda49a7e4693307a2377172a296b7776b954e87be460622d4bb28a09033e9fe1e7b332ea42b0bac6d71f5a013e8e395e713e7bd4799df7b857be0a950ea72b48c1f430984ec71aedcdbfaae4364ed82312c77f2b31493ef9864c471548b913d77a1dda411f2fa3eed3bc769e257d555bdf2ed94a3a36ae7d2bb86e096b7bd46247aa773497d3a9f24cf33cf288096677b86e71656d47b168033fb77db04c134709c640bdc254b77b1262c6e79cd38db756b8535481984c4334da5f85c965c612c1ea2e0d237b22fdb88df7286e71a3a7d3708b981b868c1cf64625d0cc89d41793c9a58b3e46dcf8fca0925cb14cf3785606a4162a194c0faa4c8bc18a084f30d2a08dd3718dce5e75f4828e469382f4e70b714db87c1358caccb085b4b73fde7948367b8eaa58c1b0d682bb355c2a384e5c389fa8bafe0ce1e6346e32512285956a56acde97aa116aa3c8a1d5d76685341324597ecfa4ed3d9d40232c2332ca8e7f627039c7ec796728b14c8c111379a3695e7c69fa3024ad8e58fb6416438403b7c0cddd3e842e75fe682d72f5f6bae7ec02bee396b4404eecd92153140f1c1fb5e07e9b0e62263993e6355d02c2a8e3e8da6d8b42349c5b216bc052815d2f0ecdd7651985b8895833b62d41c665a31e1594abecdabf767490e0162b31853a4dc7aad9fb37a8b06cfeafd8438268d96967a62d81cdd4992341326db636e8a3d13806f24f4b45fa2cd424b5ec5dbdd15e408062351e1938177f5ef0c77d7c314835adc1a0db41e58f53b679e163ea7dfa9dfb7b866149d6d557816cfc99ef3f53941cfedb1459efba099061c09849e18d9075c6d83af8bd52fd1ab122e6f736977337a5b272e18b0edfbfd1556a4c262287f614d4f9a756f0afcc16fd31e83b24e880f699ad444e3aab4b35aa3b84a06498af87cfe5d8602ed5db7fe857302b10ebabbb0d2626e36720b13f90659afce901754a871aadb07826d5bcc510347b6cb2fd04bcbe4e1ad1011cdbd0c5fd3fe5f13e6cd8d8ea27263cdb5e71cb927759ed434046a1578866733367cc4a901642303d2c0ae0142f8ae920e1489cf3af3c4cc53188ab33fa3fde5938937e696487efccd2555ed3b03d240f03ba1e7370c20d41141a624a3faa3eefc9d50c9354380cc95389f5b6e4761969caa478d54e0b69a4fdec62a782d655097b183367fabb13861dbc8d48611cd8a9b1282fcc59577aee9b4b900649e5daa2aceda32ed7efcf94f65db70a6f07620a3777c4f8caf5f9202d021f648fc30aa5fc8e2f9068ce68f1265f1bee5cada83efd9595c6db801ae5fee210fbbda4ff82ce732bdc9c315e52b8e41888dae0ee568a74573955630375142ac2a188c3057c6dd81ef2cd0161c6dd03d21e8438346266d599172bb8c2431dc1f9714171970fb10da06da170eda165763752c922f0277fd1d7244d38da976a371bbaa0a3297af4c7b4c3c40a7d20143fdfbdf8cc2009347edf754050791abd379de9978ad7e9861f7dc09e205e85d0be167a7ee30894d085235897f6feef5a7e72049c237a68508073c4f31c431bc467224beaf507069eaecf0dfa86c226cbafab2dbb5b242244c82743b96fc9bfd2170f93ff0bf433fca512dafe98e33b2dae48f9642183e0c1850c8e990e9761183e2d2734d269f95fcc03e2a5d825b87947e247a34a0dae638ae1587caac9fe720017da8c311a231ae5a045cbc6e709d607b6feae98702302aa0c5b43cf20245a78cd9c112d4d2913c2ca1fe35121e4b74090f88fff946c2199cf8a96dfcccc74dc7e447adfb866ff43afab78d73df9f31e384dfdfc3fb3ae85c17f2e2e0296d3b35299a55191ad7ae0fd91855528b3e9f090e94d4b89792f7929c0e3b739c558670ee8efa2b0ca064f3737d687705016553fa3126569781a046481fe5129f6d949fbfb9fa7fd582cae2d0dbdcc2f42a1c6e6ee8055da6c3918412f485575f30d30d24c86c301a69aa4b5ef70b75eb6605f2a894a6cb0495a04e674a699d7bba665a1ba04fb5b0396a0568f98df9f7bbcd8b8f08a6b1f17d4d64d80128d7bb3b6cb126ae0b185ea02af6e1fc5c2f3c514f3d2980e0b850bcbae9c48fc46090f0750e81cde2b59cfaccac8280ca927f935d9e1eb515c60d016f98057ee063b50bd3428016da1027af7db39c87a529d69392f7320ab4ed41a243087b1a576b27eb940b41d13d3f7301d1145bc25374761e80b7a0196eb0152619e0c940800c6653322b1cdb90fb6fa215e04a9b52a8bd381e545268b4da98a023e3711d6b3ca26fad961364da257afdb1667c809ff27536990502f1989bc63231be229411356ca597a3e1575c94dc7c1beb9610c7548d7afe646683beb9f5391b61f34cd79ced2cfee7b6ae690c22212aad0de5344053bfab7726797dd9dd6b8309adcc137ee606b1d2c7c57926ea9c03e3d72226f1a8bbfd370cd8a400621156c0396a013f730a054ebd80da58be01e88bef9f4a1ac322d0767a9ed6d3b315cd3dea66879aa6d98a5ad32e7d19f86d1ca98ff9d2c6d5ed23f17c1d59440342f1b8effc94d082d3181bd63538c163b00ce0fdbf35f7bee2e059c385c4d15504c39b37c214b57b1c04bbb7c59fa1ae638ccc8f07550d115ab5fcb9271e828b972927bac8d5bc86327539e0c578ed5463a08cd79671f4c96a2afaccd2863f8f24e9440d67f84eb1e5f023a11f296efd8f1f79d58d72e955989cd1b38b07ad5c1ef039c917c3e5cc27933964523c394d8be1b8d0994f0e81e1d7e40e0dcbe789e78d98ce931e869c3f8d58d2acc06e66fcb7d47ea81622b845b3c046f8c36b44713db6db2fe982727cd13cd42cf3d7f243e6d0ba15fc462970ee35e8a1187e1be7f49d42ab32882c2832c725f46c4c6fa3e790318531ee071f08f4d8f13f86d4066859bd04651792ca0eb962e7167f4fe2d4d2d51c7c0321b76ec722af3ac80707036207a36d496cc65bfc1d88ecf79731279e32804c65bf313a827b4e3bb133e4a64e4b5b22d811f8bd666c8c936cc0e35e8a9ec286e60f5a3c8da43799a891e55952eb35098de9ab28430f4f18a3ef99d27bdf5713514101493c864e79ace4a524a1d6e60f5bf086a3d5f720c9aba9800e98c29696b21a7a826888f5a30386313d8d2511243dadb31649ceab33d070b85d0e067c754d0a7597071dfb99b4a6edcdf176bdfb4b27f0a52384cff1923e5b484ce99bf9fee25ab5dcd37c31dfb1f67fb97cb267eb1e0c10532dc0389380618922f69be7c703886a6fb56c24e07cac9e0926682b2f961c5bb51823abdb9c3af3131b6545626d37683ff103f53aa7d2146392ad36da978fe22d1e1d8b775b968bb9e5d9b510cb8fd3fd6a04bdeb8a3114c489a03c020a8bfb94bd792210a5eae43b58855966a887fd9c9a16102194386914b9a38c6357fc8dba78a80519bc9c3bcbcb3e6ac372f09e675cd52187ec011b1cd17e9aebde4d573107f4328f503716d291ef3ac2557ddfba5b1c3cd72afe7ac821d340842c7c93f934b090cbdaf186ce936468de9a02f4b5f317785ff6e0428872e9833fcabd1a383808541eb44a2474cc6b70bb5394e09ea04bb7f53ce0a318ecee68a60f2e6d758c86dfe0a592200d195fe9ee4d387cf8152d93ae35995b82ba945ad7d423d790cf4bbe1f0be624b7ac0c93e2ee2df496d2498172861854b6b9383dd6d6d1fd304bea08d5e3816a62fb52c5599672fddb0c6b8d16649440ad970704129ef74286a1b824d010c31cfc4c1fc84b629ac513c88e7027f0d3ed0bb8009f9f4405976673e343e1a068bad2e97e28cb9b199336960a447c9a77f09a2056d4e2295a2f78ee41673763f83daeed5733dbd2d3579f11e7405656483ec949c193160b5b046f5684ffb45d6355a92314b53bebf8c3b9862fddade531bcbc502f8e584a1619eedff7ca4d854b5e9b241a3c968f97506f6a34b487d3e2991c516337a248bfb0b3be933dc7844f9d2704086fc369513b80074b1f174bc383635038c9a6e60d260b35c8885df295e0e1233b4b21a100207b1a2311dc45ddb9c9f698f0c5cf9a6b6e8e032810ff63a0af427e163067e919cd94c0062689580d0621ea564a31b0bba6ecc921006dabf854c8ba05179a540b0c8c80a53ae28a49edaf0f42be88f590e52c82da52e45e7957f067dfb4308f11624b6a9517d4bbff3fd0a699895c4f27b28e34c4a044b7768190c699c2821e3f3a0a652596d33fe1de288b18284f584ff0a65f1a3b1d5ff2221c2f70917a930336ec52f084208b1cd33ba6a901ebcfb5a99f038b3507bd3028eed9d643fad8bfbbd99f813e5547f69efbcfa5cb9af6db88107faa7a786c9eca85b34841f9cd691777433b631250c0a8c3452b6472d80380bd3ab496fe52f2880363e59ca36d3068c320d4be455d6ce960bf0483f3362d7ee00fec6071d22cec968ad795e2622500ba9b0c41fa9b18009a070225082f1b192c7b4216330d15e3cae2b5c2818851cbc75130a206baaf3f169020feabf40a65caf63453434683ba9f49b48d31025b73249cf899a0c0886e151133999b58489e20d197fc21e6e910cb75647c210cff47177b5a61e60e501febc666313951c6d9d3fdac51d59d8421d9670d2033e5f4614e16be3bf0ccd077e171196836bbfc240223d374325e5d88841075d3c054080a20f526a622fa993993807d20c3a321a493a9d627bab8701e01428301f603e8518eb42a0b055f1a0cb60258edb5ac3757453e1d58e0b73f2bf3e612bf4f945b7e073bb063891c66fefd025989a3b402233f20bc02b0852056ee667125ee68309b485d7bee78b4dca153992f64f9d184915cb8cd1ba7748b83136b0e7cfed13606b507318b6ab75267d0de2c9651f934511c918cb34be870cff9545f52e36da28885cefb37091bb281018a0b8fb742cdae92f5618a5ad00a30b0799432adc9ddc9f06e1389bbac41e781d366301f2d1d6f629d7601518dc9d3e3c0f3ccab651628bc58fd304bf7992b39ebb8141217ba1810659ae2a66a889cbe2053bff7c1a10e3a05297f1a71b247cb1c552523dd1620690b52f98ce7aa6be7be9429247af16eeb1e622cc54d720ccce58e830e1e0b713dd01a1aef278df17ba5e894e78e133e11a45861a9db61914d9f8901123ea3e2e4e4e690947c60387a63dd3308de311930b091b68a980d59d4adc5336db9c7a8c9b551a31c03a39f00aa9677a52387409b81ba83abd0cdebfc057e19acebc18599fef898863e0d8365f8e4f046cb8b74abaf68b1ca3a69b5c5a0e68b5840b2270f1f904755120c5017121ded683fc7850e9c9cd05a0c32617c63cbd8ba5c07d7e7e96f8bea5c3cc561fcb6c547ffa7110f5db38a8994aae2fee2668adc4d0af819354804eaa025801251c3923358843efb2c0e7b0368e7444ea72bb6bc3eef85e522bb3288428f44a4c02dafbc462ed4d02cc54a36107662e76c795873489c2a7423512b59a4c9fef7195ecb2fe229c1588bca12aad96517aec8c97f39c75e8bad6014581169c3b11b474123d54d7bd532ee44bd22172169daf7ddc118b6ce1776698c01e614d855553b2c876087900ed1199e206ae2fcb5241af0b05bb62a32d9faa3335913abdc1981e6391359a3763bd47e673235eab4212b1ccba51123d988af26fcb7f6073ff58d0624f5ba232329d1632c94d66ddc5b81a33632d506a90d064f067e91a2225b2265f99c6b2d0120915bfde56c23a915d553f16b49190a16efe9c337c790c4b722c32e386625f3b14a9bb9c71cbccd06c3428f25a4994ea0c06ab98d776e82162ba836b75fd8f8bc5d306d77cf8336bce74c1e9523a70ff476be5b0aa03d044b3acbe21502238cf3b2018406e1475c6a8fb70c46cbaebe5b749a89b47a5cac0e8bbf0f9da2c109efa896d271372df1146bd550c0d59fef8246839c11277af18331050d480c5a5341a01dce1d001607ea75fcae39282adab3744976ef56bd2f22b19cdd34e29029c0e5e1c20636579f9ed2c7c52aa2b950ed345bd19c2a8f1a24c567a1d1fe7f64851a9345a0ce2dc2b8fe7a7115510c700fcc515b14d65d1450214a28f9c973216d313e87698db39209f3b0640750315241823d128f1e9f84ddc0d924fc6f3ffe4419078f9ceccc408bfae7674dfe44df80ab8d89cef5940fe7121b67da10d8d3cf1e9137f988163eda0e6f0880a1424558fd669195dfe08e078fbab9e4efdac91093458fed08df11cfcf4d320cd77b91ad1f851d601d92e66c38a092d8b6ab948b356ef45a4f2195c9419c2f9f4b7fc372faf59d41deefaef76f6493f611ce1f3944390320c65c10033a644eb78f28886639e08c5f2f17755ae236dab1202113f7527b5db6ef4d3474389c7fe41f71316f72e6fda575841223090d5896d1f96c29b4fdc1399d3a762f71febe7da01e23cc1cce4f625de43aa321049fc6d5503090992f83115e2f393469544ddca733129c0418f9dda73727eb39389214e335c90f4f662ff205c99a43b7ce596ddeb711123afd1a1f1ae5370467ad65356a205b10a4fffa5af9d87c60e171e0cf5cfb34309a0f524e603f2aaea52415408905e6d24179c7612d10b835c15c63669ce9f0c213aaf4b28784f26ce6ce90e79ec116b2a66a9571dd5ee5f48041f2688ed270db5206475c12c17432e825f92202e96bb9fc092626ea793bb06a58021dce0a5690fa65633a182c8b6438411c55f72deccc30142629e5162319ea83f50574580294cb9bf2bd3c0faafc44460071d32135c5ce5336fac5a2f321705697b65fabe6ce2d7318cb4dbe96c830c5d6394964e20d4c67b82dd6c5f838cbbf232366c432a33d38cf854cd9a69d0c4d5894d4e9d07368508527521730e35aa1109b4e42ff8ffd2a06d26860136aa17fbee98244f39c02ecb7ac86a20b6f3f88cd04f08f42f970eb85903c379bceddd8cc3d8f1ba5b7297edde50a71b2af6941642ac80ad1eaf325617dc7889bd95f371a3f9be8d004b849333ca2b94392d24b0df31a15fc85cc5c25e6e509b7678aaf309b3727d1b2aa4bd18dabcb33a97bde86e04142b0ab6e33f633b6dca6a4df84e6bc0b7ff3ee615b90071c9d6e6d354675848f21a85c67bbb5b041247a62def49a6e044acbf7f4ae15a5785e6e2b96f137bb73ba4fedabe5ec462b45757d203a0ef33b371d54ff27120b97f67627321d1022a6e7a609015193b3c7f64309001b762c979b31bcd48a253479f2a6c4f40f040a365bc81ded92916bc18ca2b8b29ce6941628a7418857bc1841485e31101fc1020e1416371e9909e8b5d9752537eeece34ea1194c95332494aaf0ab2d8d5ef57c0c753cf63143987d5c867ee1f0184e7eb7071f791e9aca2584118e29b70c905e32724da772d6f0529616f9c90c1e7e8dd16334cf28a489812bd4e2c22b1c131278137ccf2f37fc528a925e7e383601168943f28b2e01f5d9e4167c02e40807bb12f4ffae1af56c9dccdbccbed18c6e287b5440efb3bb82d18b7942f717098d5e73f5731300a8f8ce53a212fe7a37eb9ea3cf11e0ff45fb060ee26d31dedc5da345fb54b5acce32b3d662d4664beb459c03067912587c6961715e7d409b16e9deb01de9cacd925a04f0f201dfedc1f872ed4f88381dddc32dacea82f3d9d9bf8b5f6f118954b8de2328908ef91544f0d4f026bb8b3e895b01d911588bfdd0b34c5e82225761497a55d11a7f48a477498674b3d8004e1a3e4e17a8b534abb13c172632d5919f242312eb595f3cdab596bbfeb1e5f11a0c8c2119fb3cfaf0fb98dfe400b46cc7b2f9b4842f6f604ba5188e09e5ec5fc2e4b073ee340d0dfdbd1ea839e3283708b16a9f3eda15a3a1a9d1385c50747f503c69bc83d6fa8535f8a4893ce1aede80436f29b1754074d1c88b4063279ac3164382ac416d2a8afdfd801deec0b57b8fb58fb36139c05884d8be6fc29d25ece25456442f533b32be67f75a6ee5956b5ecde59dcd0337c6b5e3180fe8df154e04f05500e1e9ab4c0897e91a5e1f81b886d1e4f20dc6678f2301a163457f6bdd6da9909bf667534e74de03bcdc4af204f10448dbd78b122fe1acee9effe4526ea788e656e2cc2bbc091583ac2053b485d09abf4700882978b1d4f329ae5ef5c3eeceb29eee5367b18bd3be8d671ef47e9c1c69257f751d8421c2f2d1eb76aae92db22aba3a05da421a86b7d382ad7e15e8fbeb6c513efde5f020f39a25fc6fedcea0dabdb3118e3ad2baa2ab577efbc8dcb4d41d6ef26cdc52caed401cc742a71c74fa4abb9c8053230939f01b0c304c7938b1b5728e72eb23a832d5b49bdb7274a0d572a8aff25c5b83f735ba452c7071a5257acb246e540f1327ee772a7664ea8db7ef0c9420456a221fb16f8be2a027f065c63b21a50be428efc42d7e683f7e9e3520ca3fe519fd95b19294f8fb09360aba394ceb970ca99945a08e9407cde6fe2c9906f8fef856da01866e9e93cbf8fcaeb893c55f96cf3f36667bb8d3ae6fa3a92cb801db23ab89fa79c38ceec561019aab783ea7539dd2129fca04c5ab4148c43cd342c935694dc3932d6fcbec6c4f32db2f9285843fafa0c3eea12507916ab8bb61587e6b85ee34b8520b70bdd4e32ba187f8c8a1137f7e91ffc51bab6c061210f39d48c13d4bcc22d9413ad1e1197db112735a81a0c99d3cb33d2eb515f3ebe8aaf588c678f3496d3612a280aa98440f74b0bf0a0a9fe7d84285cf227dcebc351e661527be67e024221390148d1b7bad316af23da1d13304969e35c50edb727c850e5cf1cfcca9d9869a389ec99adefe5104d96e6ca20a5c9f2c3bdea207c6dc0bbfc4699896b617d7bc744f0c5cfe0e013f7f9f96e9587ed65536a3c1b5cab444265f223e8ad776fdeea2da02820952878561726f86ed37fca32b4390e86e8650da9232e853abf7c370f7204eb6b7756a552b1ebe1b9046eea5d7bf224c45fd552de43472ce2481ce837e5ff8b2c3ff6594d786f950418e865c476dcdccf25a95d5386a4a32e6badc6b14467d71a61e75a3d5c5b30b2296911793611fc23a0729dd0dd2cdfb8202d3f0de3c9802b33a3ee7793a07b42d9ffada0362aa3d1f58871243e28e051756362b0a97a2efb2e1f948f888db759c3f52318d12af8174990d151ddf37a6d5fd776303a3ffcd69ee2e02b211f320431aaca36fbb7475f6d2f420000d6d7c9bcd6e264e5c83962d1f15d49bc2e582daa33b6beea8ab666eb26ad13aa08d361dc3e2f7e32d50d87012f8d0f7c68cd2b1daf9ac945174adc28b9731f1a189884068d1402a4589b904bbcbe369dbab2af9ba9313e6896946f58e567341db43fdc5d6b41d051665d7d66b0aca543883d8622ce33f577fa0401c26c4f8609ddaef3aeeeee855081530d3990d259b72f4dd323de5f704454899e88f19860738e74dc4a3ed63421398c8cae25fe46b4b4da1fd03b9a6b45f2e253a10e0dafed2207580cfed8ac7ab2092273cf67b15fa314bc502e5981506777a3233</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 量化交易 </category>
          
          <category> 量化交易 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日志：2023年11月</title>
      <link href="/posts/2023/11/"/>
      <url>/posts/2023/11/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0430d8f9ba91d364b6743c5faa800f19d654114999459555019a12b1e726ab1c">b3dc07a81f6459d120ce338ccca55046116de9af7135eccfa9c61a82756948fc6e40b7ee42f6eac3ae66c5a3f1d8dbbb5eea6634592359066b80e746a453ae2e39e7fd7297005ffdbdf3bc606e9b5a6553098419cd2cc14c6159781c66f22c5d000fe1a146feeb0bd2b3b4d300ae9f1a573b839e12e104ac85e2d3d11df1bceb4a6a1ac5fe572142148ac19b50c634562af5903bdc8eeacc362524beb2360000f9a5fe305a6b4be3f1e2b9dbfada1772087b002744befad90e9e4b6b2f632fc2d26fa81977a5e1e53a68e98dfa4bdba8b949b0522fbae8a10a09bbe274c16212582fd964a57326604c041db3ce01c24b1f70ea5f7516d68296b6e8f76946623f05de4d6c958cdd0b8d8dd0194610079024123e802749fc62276928aaa18ba47d34fc99c76db0bd1cde5f409296422cee92913a54c0d351de2857ffb4a2353dab3dda19a91983580885bef3941deeb28aaed0d4893167195fa66a36b08bc2e78d12fd0977874605a65f34cf5b34ffc5fbb376e6b512a77d7f4a81542f48676db39a1c71c1eec924e59a4c35c06cbfbb38e7eef4bed434e88e676bef75d98b062caa257084ce4843584150e7bf69888b159bf5e6fe0474263c26fe6c51eab461c083f344aabf413c9f46d42ab1623f37802f3fa6de6cea6555718f4f3100334ef2dfbba77764d6ff057be4f97ba5ba87ff2478eb48acfc60984b432dd754f3394286ceea7863c87845aaa0a5c31f30bfd9786196d8b93eb9d876a0301ce20efa175329bf6e4db5d1e57aeaa4ae7d500fc2f1e410ad160dacb7e9547e6a55061e173996331ad0db343030f04002febe6e6d64465f50a0f71eeb79ac08ca45707bfec9284caa1cc1b301ca001b6c40ef82ab8c9be70f82cae6984306543d5b0f7121f0cafd0bfdd56068615c85626d808776dbb0cfdb623238af7c2e72a8ab1a1b46de28742259b4a743c64273d3e5e93d6fffb9ce5a62c6729009ea6b2c8dc8c36c7db966c4671c3710975c43021b0fdccdf0b741af1f47734a791820989ace24c7d581795d5a89a1bbaa2fc042427c84d3b6507c10115930a0a26b5b795e9bc485c10a835b21cc7e79bebbe848b2c16b58d70fbed0d7e978d4211c8235ded706f9fde8b6839917587c446414007b3020be8634394db38c45fba786f7874d9bf9560a2449cd50ac4afe996d18881ee45a05b8d7f5ba852c650c3b987af9bd824926be553048e5dedaddda8e916e3180ded5c77676761d8fb40e481086dcf7952ff2009403bcabff583875e44436a81243bee0171083c4ffc550fc3ca5ef2c49b6090d5f1bd0510a34320a213114a0e9ebff9a6351a033a41da230e6488ed355fd1e31bdb8371f21770cb7e41d1fce928f53146cbb2eaa087fa9f1ef7bf595c83537e64205894b2988a1b7f79a7b6d9ae572eeb98fce3fe5a9dccc6eb17723a64b28295b03de1272f90d3d033e80861dcfe6c56fdf69fc74340577d4419d2899acbea31780613c6379aba6e9b36203b2c8667d0c851550867bf7beafb1d92fbdae176f0e95ccd96c2200ba4db8367a5a768d3fd5a321b39ebfc6c60e860045a957ff3232ba3a04605a7746f3aa25c1ce022fd66d4f9d49dfeb8d4bcf8a70bb6c77dc045710bbf31ed0ff793dba461dfea73b4c08ed3020731e644b0adbacd685117715d4ca61a56dd02c3ed5bc831b725e74338feb428aa1594487f5bcb74472bb27666384bb8de8c12e1e2463b9347a040f663fe59e67f1b0f44004a1c67df2ca1ea08f910f71b031c8e74b066094f9f17e5a6760322883537c3fc7597b8aef7bc6d2088be8bb7d74fe931374ada313dc9af64bf533780c3163cf8a8d84ee4e7559bdfc9e530e95259932b0970b20ab865772db2115cbdef38650bee7b82624f249a63b8e22d12b5fa3c0994b9bd7ee7a74dcc8ed8dcd0a356c39d7b9346928e8827e8eaba869c0ae2169f1f140734be03804808ca2a27aaab0c57543169e1b410ee754cac91732b6c9cd4c10f34a3fff6054bd950b59b14150b69a0ae05d1a1850522e02530ab7f1ac95dee3ec2c9b2bda44a2102a6f94fd110034c3c2b3f6ebed9deb415b1df9de99ca28005680025ea0fae602d7bc76aa7a895b4874beb01fd1d583fe51c75b5a61b1cc4a9dfa7303017869915c3bec64c9891a81821c6e1d7f2657591f4f71289b41e7083f1958f1d7701f0cfc3602b2b39b9417184ebb94afbe814f055b80ca59f33d6ac5c4a669ebeb3287cf5a5a8aa04302e6c5713bb2d99e14232ad652a8c7df90ebdede3375c597040eac269fbd0db86015e20c8b45962fb3f529579baa01e52c47e538b33fd1eccca85987881aeeb206d44198b69dc66b7be9357d01474833789b511ac954ed7a80a6f581e8a48582dfa7294ded9d774bb982f93299a5b67ea85e8857d0f19683051394d04164fa98c8941b98ee859d0f77e2c818c1736b03457fe30432030f47823153a2dcc3f8923382c2c6db4d86962064d1b45e8f8843a32640f6c7e55ef89304063276eb823d3a9ef4981b12183fbbbff6639bfbc590eed8cced0f34135697ba392e8926653c917c5e2e002119cc5bc24ead8cddeae37356e3889f9a219750f55cd9cc902d1787281d6c48d756e7e947e4293eb5031b91c04d1036fcf648eaf16ece1443322ef08b6d9c4457d232e98cbbc792f86220938c310630de56fb3a4b212bfa7385597fb686ed20be111a7af9b0c880a5005eea1400f1ab40fa4c10915bad18fabb9f3f389d22ba8f1ef64cc13f2389b9a1d5726527dc929ce1204ce5c68de22bedbd34556051de7c5439b32e8837f231597f6a87e5dce1250b224efcefa174b593b38829d43526306074d40b76eec431bc71e4bfcc74b9e3273b078bad7766b279e6baeb7814580c8b02e652588f6e73a84d196bb3e32e6c14ee2d977009cd328cebd28d8d63a777e75c493bf99fa952f42b028c2fb619cb0b8a3f10ae60d4b168a1c7b96754c5f93b2f003bb708192373abc9e2131560796d5281af04b061e438970a23921ceebe2dbebf9699d7401385bf2949076dca2efb47f22895d22753a393c8b9934f5ec0eaddcee6428ef7d86288dcecf0cf59deff2a8f12146080c91187571cd1c3620730d3d1037a7aa02759c4ae73fb103fee228b0abaf2c3da62f8252f8e08d787664dfb507ad4d640a89985b7aaaa2e1b0a10f7f9fc35aa72a96de773e78622c46a08879723549612228435db245ae03529599c409ca096f2cf6ae039c52421229e5f2447df2e1726b2fdcf2ca7211089f6099ccd001fb0f409eb2a87186a4f70653e3dfa5a0635e14e79dea105083934d58f2cdb0a0dc99293d28ec6f6b8875c3b2e312e8dd7b582642f86d713ccdd7b9669fcecce1a4d9037a0986bc86c329e721615f0b2e1dda43153c664aef51cac9187dfde38751826b9e157fb84205d4a7abb8f81d61fe50c482d44001da1406ad0a3aa8763009fd0c42a2ee56821534b5be3c8717cca6a33791b64ee85223b4f068f99b3dbfd83019a21e028835fa8a58fe1e6f6bb23c11904037d8f540d9c53363879ce689f7f20b169d51cfbd26972cd5c57266d16e5ed153ad6d36ffba6eedfcbe4fc8d1c8a4b4b13ae24866aa7f5289c1caa718858d793b4a1289eacdcf35fb2adef54aca495a5490b5b8c340fbb53b90472e8fdd9100ee5b7eed5480b73c251c360f4b626b24531c6505717570a319e7f975b7f2f55e3da4f2c7a18a3165d82b3d6ee77246c0cdfc73a4e646e1ff463958c3e36fc0bc2911c3e1f4b0253b60b533b9e2a85013172e044aa6d732e581ba82089b741355fb3c8ff842651458245294dcd0007c65f7188e20edaf16bd7918beb26c9ba5ae88fbda50da22cf8fe848ba015e84c49ba49684967bc9fabff5370ec89dfba3e7a1ad2f850d6fa65016a1c44fecc34e51b8b5e38c35cd715debb8c41abdfe09ae31e90360cd3637ee59d5492e69685b4565ff33832f5e584e1bf4a7136a6933a8877d7f6b827e8093179a9453fb4c9f3128c5d432445499dacd22561930e75f26d8d1e0bb06839547fbf0f96b64b01de88fd2c8592ed7a539d67369154e295ebb3407094ff0230b984a16887c451cbb8579a6083a56cc9f87e36b4656dacc7dfd548297fbb5d80f0909ea5feb05132a0c21be950e2ac817c02402fa907582fbc54c57cc0813b4ee471b07429eb96b554c0602d609c3dba92e294007ac32d47f3b9745cb35911bf116dc038c83a7c88f57e29895e7205ac1a2024d9d0835ec68ecfcb353dcada46ef400339eefe1f3d125c6c005d7ca4660db79181ad393c042c790e4cca4b71daa4bcaa57dd13c2bf91415344dcb679a1dd6f9a9d86ef93b68765b336b0eca14ab185cb957d8f8cc023780d6153034689b4cd4e61c2717d92c6319b101618a680ff6a1fc43b8a76ac2910d72441b2eefe0edf11621a8a5cbae659565653a4fe5d14cd49af6eb9f611e92da35fac2a39ece009eae1661cc400097fab3490399c3dc6be5a962ce1c45a13c4bd6a2f2029393fb44e79bedf4e31ce9bb007cc5f2d0afbe93f77fa933a3770d4f23e11f7d71cab82787547654bb29906511330f93f72cb859ac75540401ba22b077f63e1837828beb25ffa0a643f7814c14c2b8e2cdb1e980b7ed99b28ec0e0ab59af0ae0786c037af60186271b3bbe824c0f99d81027c4fca1be8a2f487dbf979a0c46f0b641d1e787863a03fe425f1d3fed2113da1965e9ece13a82bb59c3aaac8ed49520d62b81c369f7f5c77cb90bcb3ffab520f0ee44a96929d43efc36d1d5c1d14b66ae9569f3d2a1a053d24eac431298dbb7a6e3e0b801edae529cf67152e1affc16fdcbf72</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nova Engine</title>
      <link href="/posts/nova/"/>
      <url>/posts/nova/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5e4d59f2f8594ae07d4721c23c071ee4f3af66d9ed6f0b071af4ab7c9f3153e2">98b8a949c3f5e1d69458982c9c25fd5a277e65ba1cda03eb6d2ff14892b14fd18dfc2abea7d0dda28454dd441dfcfddf5256ea3ef416f3008451c8ec4c947f50581d8adf8a746cad45debbef0d23ccb525a4257da90ff423f8ca55ce004ca272b74a907fe0ff56e7528111a01a18638d4d83151023295ba2a119975b827cc19ac0bc0848395477022d70d26ac953938d1533b93399aaaa586da713023b7b2b9bcd360cd6723f66b6505843d232111e629554b5730f71cbead394b1a4a2e2ac0b4635f8c31e557bcbe3615ebd7659557debc984516eece166fa2bb07e6096b0424c8e543f1b340c98c20a46f00e12d570b47f3cb47c5a297be2e7c5972127b16d08653009db4bc3c1257c4dc59d60b0072a6fe996f410fd5c002abd1736b32fab0afc00981d40fe487ebc25e0b98c80d078603dda4d2d6bb38742a37cb8e23f706c0cfc7d432bc51409a7a0c886cc431fbdfb3656fe46d9050d4e3994854dcfe5d588f2f97ad74e90b1b7a923f3be92cd81f9903101995e557fcd1b509ef4ec6e4c1a80cf9c2107d244039328b27a46bc8b323ff66049e09bdcac86466fa26e2f86929e2553b5fa5cba6d7efdd0264945c216672e7e6b66bbf7e3e4896bfb31224514935a6a7431cfd7bb00ed7b11bc116202520d192c85cf5d842cc8916ee3b4e5945146e7138d29debddaab33ebe506905103eadc7ccdc104217abbab3a2263a8c8af83f3bdc97128c4ba30b0dae7d7dc849f4978751e8fb1fa4aea07c18f472369c7a1cd16185d09e0a8b0070b381a8cca5c4cac2f257056cd89b3a05dfd0814f8d3e9e7e33331941ce42511d6ef021837037d7ee56388771b9ac46dca33d117f41cc1f4463e9ad718c6cdd72d1ad9d9731fd0c64c888121126104f5a68ba9b9909e1e685745dd39e3989f4c4323576fa2d9ba6f041391b62fb2dda65b674193a9caddad6bb36be5f32ea2a0b295792ce6e88e71448536ca06ae6231e4003f0265bbc97fa58c7d3be1440b73d20aedf631ce798abfa145562c9419b9f5354f4dcc9a2c8313bf17a0e2055f76cd5bec1b393a14ec04db0a52a96eca4645d3d230322dc0b60818c10ea1dcbdb1de4d599fb7310a880523f773dff70669b4c252f1da1880f8a2fd18eaaea212e3c061713893d77e04abae033d6cc45c207be76cf70aafb4651ab5bf11b898cae922d71e240874d95af9b4b3fcdb4ebc71e0c388fb49c785d244065bf381b9a58cc5b7fb81e97663c20d9a233f28c9f14fb5e6d3d6e38b3f74991565dfcbd9068fc8ee8f2ea120e28c8fce730a6297c8c34fb0100ff587902adacdf9d3fff4dbac341dafa0fdcb8f8245def639f0403e1c95dd7cedfdd3d83148eed6a719bab33bb668e25a3b2c5488d62aa8d60a0ebc91698024f97d5a66a1896111f5b4eec3c87cbc3ea45c50923dc4329d567fc10a16dc5c79c3ed9b036afab408067e0dab6245f91e3c667100c6654779a5fcf13dd09944be78522ee20396bba575a8c81f2bb65d2812bddfc46b7bea2af5329f749a4f21b3bbbe182b12324104605d4c8eaa0f69fe33b3d0687bf1893a06e3bd28ba092f808ebb484a89d1fe78cbb2b335b8c41ef7db341c8ac715cab721ab37ce32b587f5385f9b930ac9e27133d5fed5c49067f9a2d6e6d1dc46994f20c26aff1d0fe82852f0555da8d972c404b9f2b0e802bf548a6e126ca7abad02eb22efb13c2d9e4a2ce26c2d8296fe3ee64165ded9fbf2aba4c35ee79beaf732532427f9ec103db9c5e8aca5e9b25066766020702c00d83f7c2a2e489f3f3f52b4191a7a7d3a91a15643774fe89bd8e6db78dfadcb405cfe51b48be0323aba941a9a49113111a63bcfa81a3aac36270e9e9ce8ad76fd8e7778fe422254fe122e9f8398dd030b9056b92f68208456021f727a0fd6c2bc885205527c71d0b06e24a594c146bdcace19c280d5f167020f0729f847ff474ec573794ffc682429cf8a8c32ed20f3e26ebc4a8545a0472eff5de61bbfd699b38facf320f079fae4445b5ba7504489d9f0f6ad272cc00f1ab1a8fc9655c6d278eb58bccf458bc66adf8867a64e22e90880f08ed400f8d7c17e6b694d027eecd081dd9a95c706006010ea64e6f702ad82f38e487c0ce6fe94a94342e712e1908fe575615f457f938ceae07d2401080d34e14a8a86e9485f94ab86920bc4586f83a2321d6ebe66f967c2fb66d5c70cd811aa2adda4ee0a78fde29c0cb62651528eb1667ff21cbb31e2aa0540fd5fcc6e2e16210e3899e776847505870652b414ba7c39120322eab9bbc813ef5b1a7fdaa5b166cd8417fe99f525dbe0226e5775fb6a7ee3924d02cbdd25976cf16fd2d6ec512b3d1266b3c415664174487a8fcd149b34ff6a301b30b59bff9e1ce9d12bc15716060bd9e0a462ab26f93419cb7e67f3f3627d6e134bb879c3eec1a567dd3a05faf991404a176f5bfc2fee949ea2e5c661dba1762d8b388272630c47f052a2049d27163ca5644c9e34c44cbd1930760f54dba94d30e40c6a324ca032788125a952b2ca3e015bbee2f1697d97f7d1a48462bcdcc51b0563b502155fc14de5d2f72e2a03bf4cccffb734f067ec14c37f5831a04cc401adef709da660b8a06d1563fbdd87f849d0784afcaa7817856cd504d6934d1d3affeee40b405ca4dd8527584fea0733ef1c7468fb4e7b12e2674e6acc31f115b47ed03fb2b80566e652507d35f2e1db77704b33821e7caa952a6d8973417113ac1cc625eb96e4310a7f512796c4d4a9a06d579a3026353dab195c98c55302714cd3d63f1a067cb8b8cf53946a1ac1de06f8310c382672c8656f95b4d91efa54ec62ccae180289f2e3071c3106447ed5e463fab2d6d767503f36e45f53401acc6b0dd9c591314d7ab2aafbeb26e3e87b7c187a27e8ef1910853c747ccebad2875a12ab831f21d6ecd9edce1b7ef6de136353ed77986df45e1234f0e0f25e61f0723259493ba08ef477c1a80fa2b00ceac9e8788021e171fcb112bc40a2dd0a9f60a1ddce482349225ecb53b46d5723332d2bc934c483c30af2b2facce2acbb55d6a868568a178ff8d855dbbe3321d7667a0525e6ec80cd56fa196cba9a17f34989bc66610c9dc94079bbcbf45b58b7fc7bc650a30e1187edabec79ff596ae459b34016470e3d9a0881e5f12e279bc02f39730cb6b00ebb14622f006efd63269d03d44c8c4c7974aa30aa3a28b2fab6d6bcc88a3ea891cdfd071aa3ca99a0d5d69b70b9016562d5378f142ed07a086dee2ab3a0dc22c48d4b3d0a3df51a5c6fd54e024a72349b7478ffb93fb4efd01a1650eef8531533b51daba00752411c2df1b1bfe874f7499fd82ada82849fa5cf21e34e333b59e6d8b2d73f45c8fc15abdcff54fd894fb6f6cb71b360b2582fdf231ec24b2f1a6d4b513f76c7ffe56b0f6adeb095946c3011382f7f26c63c00e8a0de5a57e4e9db0341aecfa64e782de8c865878b26bce19517eb4caf19c92f5bcfedbb5f0d83abcedd657c5a2eb1edd0bc00a66afaf7f742de1d10663aab64d87351d29fd6dcc9619e8c23410e72570b413a6652395795ba70684b03a7945ca2191f428b73b2a81883cad269c321ae6e7d16200748fe3a814e54ed0bcac8b900e75ec9fc4d16a37cdcd38b61bbf823964dd590da92f043e444e56eb09e4c786e77ec57c390c80d1fc0d98875b7858e5bf6075b965f720495aaf147ca97dd70987d5e7f1944388548a317ca562a57fa4836305e341a0290c791af398afe160cf1941775658ea653ef506ebaf391249c44e8d6e60eb1b7454aef378f510f62a234d97dea7bb5f23127f3aaff9d54613e4cb6f9ec228923d3226242ea096f32bb88b70b68b0387111f49db2c2647ee2bdbcc74edd8ad1e1bfb6d6e9af3e58bdaa9bfbc0840c9036d9c3228875a0e85a6bd53fa23466acc580cccfa0c7d5ceba672d231e987df6b539703ee2db348d8d9b4d31120341a5540108e125b2e4d5709770757174d08b7bf64cceda2897bc3c70cac7affba939ce1195ce3e12703bff54ae8d5ecb8e2013ca4e33d262fcb4ebe6e561257dec64408b194303d4106f3af4e5f9a50436bee606935f6a0d17449536720b625c4668e251ed18418919829d4d3f893a49c26ed00ee2ada578b399846329ea143235293ece9d94e4924d047fd3e04d23a894dfe3df9196bbb59ef4a8c8888e9ce8c08c1acce553a61dd75af2a7c65430f0019dabbac129ab7a6431dab65d449adfd52199e3a548362268e35c78831646db32027bc5bbf9fd0177dd43c988c63143252dfff57342a971a0db627ed5f809c8cd4f7ffdcb88e85a7405e2fd1ccd591099baea7c03030e66bbf39ac8963e538db097a47a4b1b05991407239392bca424b8903bec2324cfad35d421b9dcc091c64675ec227d5796f48bae3fe476e4e489eab32e9cdb54f3e1c03fba177b79be5ead2d930b1ba18190eb69cbdc9003f30c61e5e78ffe1f146feed1d17e6479b2a902e952a509ed969812513a3d1746d5e851f8f562582a32dd64560e6c786ac8f4d02d5d554f78c0fbb3d5a25424865dcc45f61ddaf1a3951436f4f6aefea6054c00f69853a16847e865d039245a084e5c47411d8e8713219c792db3dcd4053f02c2aaa5e3d9b18639584b254ab3240e433b6eae57ecc78344b9742fde4eda64fec3b805547d69e83280550c1e018d4ebf38f23fb495644866c3fc329d21746c53f8392e1f12e004f791d6666aa4a46846a9b292e0fc10366afd0cb3b4219fe6374b881328b3506f55b3c1a2e2274692b92b1d411f356ad65ebdd35d7377aa81f8b543f502b04b99874963ceba3bd0c90f888b846bc85ab481d99036ea1623f689e2db77e896479c5737b4845b089393d26f474e940c7965e55f0ba3bc1b0b11524fbb03bbab9d8d5ee98f25c1ffd6bab753164e55fcdbcf67955aa92f9f4651b9dd974b6b7d1a9a353ef69abc4791919c484eba5108f2c1686a8edade0c3cd8b8f3b85afe1f6c0c039f2ba556b94dae7bd635a51ae312aafed0a95eeffd9a68403bd6a64a289f87bf3b8fba624143f25867d6ac0e2be3bda7eadbf4424a810bbd12e9c7d2c0c48aade59840b2bc32cf2fae6df94fec6eefff1799c435155188036bce551946b62d28838c3196f3781d5abadd66eb583b1e9aef6a3be118148837aa38fdc98711c9eee5df0048aa3bf676d136cd3ad753dda0cdb4afe38fe723286dd140ac5883634ab2b036a4d275040f8e01a2a44f73f41a9bb9b038607546cb1c5c6f662395f5fec98f99ad631c79575826b6ed0540bf435ae4a230572d71397f861c28091bb0eceb5a23e8a9e98fe25412e7e0b95cee3096921e8d3dad8cffb746eaf6c6a9cf17340b12492e577453d7ae0069c80fb42ce9bff3e934e610e06480d2023c98e91ff201052204f156eb5d359aac9f5380fbcaead4a144bbda7cd8c5a1b28cf7318fbe98819dd96a69ef69b34f1ab8059ce7c74c0c88b004151a0cbb89c0d8a0141e0aec2dda2bc82f5e32ea6bb025e364e8c4f587afbb58bb55044d2a4140b6318f2fe1210e0f3b7b71bd990ed519a9d6ab39eb426dfb66a2a134e26f8f6392d368094e3292d5b720ff388b2ccb09f460b9aee733f50930dc58a50bad4c181a0c01dcef1d14d4bfb11eeca7842f3cc1d12535494e1c6987e6eb545d0ef404a11578179f4d0a311a347a8fa666ac133bf43a58ac40c6be13c1e436f56f3fec8ffa67784ed3cffc926e151f704fdeb468db75e0d21d09a5f763c85100e03b9360f875ec0adc3110cb25cc2894135d538b12b50212d104cc6295af3d012334551273969d4d3bcfc43e8d5a334bcedf94adf4c89b54b5bac98aebe5d95bc90b35c14f8e922d58d2b2b1258134a9d737ba54ca2109a1b08c4516ce89af8130dcd3c29eb37c4356ad4db7dfc9ddc87d3e90e43e2b726714b5c6b0602bad7a3777a60606e01428df0069d4e669406a7bd98b513f08e00cfc8f9b104a66c9560dc8bb5d5775a833841c8858f92a311a797fd425b90b47fadca4885c5a03c3b948a0f2e18b8d5630cee916211c11d70265334273b83404a5db67a3b64367b242ed75eba591a9d0ea37102216ce80722255a82309f67edd529e58e22847270d9f4768772b0c55d828c75bb678d6f9d7bb7a019c18681cc6c7158f8607ac4c6f195e71ccb308a6efde143cbcecd7f1105951e937dd4976feada9af3a89302059f6e0d54787a2b035784aecacbd214b5a106181501f05cabbaea78b1b6943d30bb243285db3f560170c2b79e3f3d9e248df2bdc6cd2aed30518dda6342dc60e3019deead6c7f25b530e56cfadcfed6ef933ba75131ac578e5001ff49d6df83589e224e516e5371d68e836a9d4674edfdbe3c827749c27d80de1dbe5bbf182eb78a85566030a5f65fd69f697460d222cf09edeb8d724f1f76f439bc862e3424d15d41527f6daab6eb66de1b6795f77a7e7c9eeae68f72360177762405bbd255ccb6233078647c6c7c30110b4f5c6653e425dbd6693e1ebee33752faecfcb294faad93d216ace2e4a574dce67bbc27f22cf40cb05b98554f95597bb4c4679cd791f1b8befdc43b980bcdfc718d55e2447f4c20042b7b83e90d26b56b7cd960eea43eae1d84a53610871d3c76a33783f1ec350fc470a75215e98bc6a0877cbb20814db2b888ea3a840b66e1f720ab54b4f1ce1c456826420baff3cbfaf41101460eb99475c0e9c68cad597f5e51e05b46e85bec99921303cad7b7a24b5ad05ebefc177c24572ab0495b64e8263bf66882207d74b894356d655afb8f92c291fc7cd7bf5ee74fe0fa7fb2bcf203f75c3bdf56a311bf70208c6d8b4a9df6b1f85d162a3824e5d5649ee0dbcdc97423bdd859a1e65994cbb7f20f1edf163baf8228b0e6d7a733e02282ba58d32e26a1e4f334ff41c8228203001a5632100618baef479dd9ae744f1918a027305ef8c602f5aa3652ed4f7e946f2a786d515fc2c7b49c52df08a3dfc387072074e6e4802662c3f7ba6e488a7e0a25f644859a49b348d85acb683fd5b6b71ed8f24ddf34c79a7a3f4fa7b291999e4e23b376d4537581345f520fd5468308ed4827aececbfa035ec1174a4ef1cdbdbf369d92ab8ab97a0804bb7180ea02c8d3d4e70a9d3889323a24e3305136fb212d30e7406d05245344203d5c45ab009bf7cfd0a21d9354db31908c6638297b1bfa54156c517537c63fec918d1cc4836193d5de8f433f250bb266120b015ba06b0b2809aaf5d357a1f6540ea6b0ea1e2188ea53f5cf67bde2fc37b03e506630689cc49ec897f1339206e9a89ff0ad5d78d7f2702d512e42c521eaeeaabffe43f3375133c985fffcd089578b972936a425142c08efec93091d368b7fa359c3031262b5b30223c78dbbd0bb3f612747b76706e3548cf220ecafc6b60c3b255cea0a1101b73424b00f5de906862547e2351bca13eb5bb422bde7ad3f76ed684358f3b5e7b66844897713ec1225708a20d0c6f6c426f2894f881cce164778b6f4d00bcb6e193d3341fc494b2658042a39e507f1b0ea51515de19e9e0fd52f64cb99894c95f3ed8c3ea1883949dbd56daeab813060d1dee335adcce8e1b2a8ecb3f1ee1f23dc819dee62a51b38d6ed69c284f03a24c1dddce08137c4580e251e022a6352397067289ba44e572005e7e2c62065c4246e7659be3850d0fa3862c10ef2edfa97c69138323f92f1bc475e6e79349cdfac88121583e0c93086109ba289103f23c6edc72907baf9140c3db255641ee7d7fedaa8bf3d96a984e4546c4719fc4a26260752bc5ef08020de68deec0b28eb32159227c109b7b5ec9aa4a78cc20b92354a0414b20375fd9fe4dd2f18bef8a72efb5a4d24772032a1ca9912df90a70812c1182aebbd300331bd30894428239219841a2d998c00fda943356ec332458f21f678a58a5175aa3aa05b8575a2516fa7d33272f0a98cf155a7199f86cc443413098ec054433ab3fcb701a22247342fdc05b4d7dab2d2870aec40aefd90bab2d499a2fca5293942d179be4f816d86e4d423875bdf9b7e911a99bc04e766b348f52bdd646b5757707f4cc79c66d71332588a297feb8076742d59b13b855fd35e03a25305df8425aa1da3bc37708ce46533a5ae8584323153eecbd661aca904cdba211d43bd0089d9a6847306b3eb58d5da58946b702b3a98ee81dd05d36fe919a669b52fd0371d115ac3280665f9f4c9fc898f5eca960268833fbd84e631e0dfd36d0a2adf1958882611a323859949f5d46645d8f296865ccaf3186407e088e94ef5892f3ddeed6a1bf4c93846f69c1c8983c8cfc1a08275696ad838b6259a1da83d730120336312ca844b801a4da980d880186a0447e10e75228eecc1701c967f6da055cc051b6ccbbafbc464cfc5a1efbb4baa087aff3998ebf873d38705768092b6a7b716a0a531d74459a12f24ab6d4b5fb12f7b6011a46eeef78efe3d47e06d5cd0f9fb836c1b87a200967ad8c9f08e7587580535552c7cbd9148806b0902144c436339e31bba6c9cb8bc6dd13644cd503cd056156aa703fe358febc48ebac09efbbf7fb8a31ec2edb45689785556eeac50ae2f0e82607bb015dae3b631c1249a59684c61a0b058eb9b9e4b3a155fa2724c9797ae1e5493839812878710d749c7c4d0edbaf624f3304dc41fb2f59011f13d47a8f7ea4130f4afb7d3454aee8d8da742b60ffc2076370d99fffcd814bc4572e46000f38702ac0c417a95afe52f8e31a820afa00663654238df7ea738f317829b811f96138f0b135fb180d7e6ebb859b76c65de5923266754cd6c5f8c6fb4e4a8ad339a8520acb62e1d82d2715f9f356bf3c2ac435700134357f562d0de5734f2121f8ad088824810a18da64724202cd01ef4ef40dac7309d8d9c589b062614d543cb1c18e6281624a503b069672fd9099c6737187b865e752456914e64ea1849b2e8c9085594b7b451594b19e37804e528905cef3a4d513128c826d155a153370c2c3d1d99d0c8197d28a9e8d3263b57c7bc20dfad5c0a4fac7a49f5225dce3fcf5b857f232ecac7088c23c2eed5e4443d08a0598af5b5649a47412cffb33d26b80b929a8135d95799b3714e5adac709c129305f1223557023d00f8fdf8681435b46ab5052d321a9df1b31a2c26736f49b0c00099514aaf3fcfc84c6e414826788b3012b550c24c639b86c3aa61dbadd4fcd11c68b16f102515025d846f298c6ae129b848da3b192c9b25a1b2a29858de91503d4ce46f537ece12763574ba4d0c098399d1aaa0e1b98e0c711dff38aeb56ea38e3d3220640ef5e34734fba2f629ed967a9f248aeb6af1a32754b3ba8068e23a19f2021bb0ec2803600ac18890998eb24cbea639af82e4bb3e951dca3350f166532122203d543eb4f48b22bd941c432bed73a4470f35ab12093d582deaa1934cccf0647aa0d9fe8f2c40edc8eb9cb0a0f91bfd2cee8ab9a697f1964c1b1f92f602320b43648b3a15ef35097fe48952d48fa05518ba39ddb4ac101645bd3e5e938fa2c637bca31bf8fc045385125005a6a6e533d5b705b670b58d99fc9ba36c381cc18cf7f964f1110aebf94dc139721fc2a7d59e5e7dd224bd46eaa1c6b2e6e039dd60167f5825bd1cb8f2d2c9e00b38e2144e71a2f03c2baf983f16ff39a821d2b290aa18798c674023343564b5c12bba94244aa47e73cac3e3bf681fb5ce45eec21a0e57591a2e9614d0a0d8b9a3131e61d5d4a4a549ba658a4187dd58dc077ffe649ae117b89019ed2394436afb8d82c5fc0f2b9b5c979f864ed940fe40fbb5768d6200aa535c7ab6c33bca14072dd76c2bde13cdcdc1ed61f481406bec00cf5351c7c110c4f18791d1bac2a2992effa6cb404e9a13fc08fb9e2cb1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 3D Engine </category>
          
          <category> 3D Engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【工具】LaTeX教程（附模板）</title>
      <link href="/posts/2TXFVDF/"/>
      <url>/posts/2TXFVDF/</url>
      
        <content type="html"><![CDATA[<p>Latex 对于学术党的作用是写论文，对于工作党的作用，那便是写简历了！<br>github 上有非常多的优秀简历 latex 模板，可以自己去搜，改起来非常容易。<br>本文简要记录 <strong>Latex 的安装、开发和发布流程</strong>。<br>github resume: <a href="https://github.com/593413198/Resume">https://github.com/593413198/Resume</a></p><h3 id="安装">安装</h3><p>只讨论 Windows 环境下的安装使用，Linux 实在很难搞定中文字体（你都没好用的图形界面用个der的Latex啊…）</p><p>下载下面的安装包，直接一路点到底（就像你小时候装盗版单机游戏那样…）</p><ul><li><a href="https://www.tug.org/texlive/windows.html#install">latex easy install</a></li></ul><h3 id="开发">开发</h3><p>Latex 每次编辑，依赖于<strong>重新编译</strong>生成可视化文件（如pdf），这是非常影响开发效率的（对比markdown）。<br>聪明的 VSCode 爱好者没有错过这样的机会，勤劳的他们开发出一款 <code>LaTeX Workshop</code> 的插件，真正做到了 <strong>所见即所得</strong>。</p><ul><li><a href="https://marketplace.visualstudio.com/items?itemName=James-Yu.latex-workshop">LaTeX Workshop</a></li></ul><p>使用方式，在VSCode市场安装该插件后，将如下配置写入到 <code>setting.json</code>：</p><pre><code>{    "latex-workshop.synctex.afterBuild.enabled": true,    "latex-workshop.latex.autoBuild.run": "onSave",    "latex-workshop.view.pdf.viewer": "tab",}</code></pre><p>此时每次修改完 latex 文件，按下 <code>ctrl + s</code> 保存键后，VSCode会<strong>自动编译生成</strong>同名的pdf文件。<br>接着使用 <code>LaTeX Workshop: View LaTeX PDF file</code> 新开一个窗口预览 pdf 的实时修改即可！</p><h3 id="发布">发布</h3><ul><li><code>pdflatex ${filename}</code><br>其中 <code>$filename</code> 是 tex 的文件名（不需要输入后缀）</li></ul><h3 id="模板">模板</h3><p>附github上一些优秀的简历模板：</p><ul><li>中文简历：<a href="https://github.com/dyweb/awesome-resume-for-chinese">Awesome Resume for Chinese</a></li><li>英文简历：<a href="https://github.com/posquit0/Awesome-CV">Awesome-CV</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SIGGRAPH23】Large Scale Terrain Rendering in Call of Duty</title>
      <link href="/posts/siggraph/23/terrain-of-cod/"/>
      <url>/posts/siggraph/23/terrain-of-cod/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/siggraph23-cod-ppt-demo.png" alt=""></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li>这篇 SIGGRAPH 主要描述 COD 中的大规模地形渲染，并大量引用了之前GDC的技术分享</li><li>NETEASE WARNING: 已脱敏、与工作无关</li></ul></div><h3 id="技术参考">技术参考</h3><ul><li><a href="https://advances.realtimerendering.com/s2023/index.html#CODTerrain">SIGGRAPH 2023: Large Scale Terrain Rendering in Call of Duty</a></li><li><a href="https://research.activision.com/publications/2021/09/boots-on-the-ground--the-terrain-of-call-of-duty">GDC 2021: The Terrain of CoD</a></li><li><a href="https://www.gdcvault.com/play/1025480/Terrain-Rendering-in-Far-Cry">GDC 2018: Terrain Rendering in Far Cry 5</a></li><li><a href="https://www.gdcvault.com/play/1021761/Adaptive-Virtual-Texture-Rendering-in">GDC 2015: Adaptive Virtual Texture Rendering in Far Cry 4</a></li></ul><h3 id="大纲">大纲</h3><ul><li><a href="#Why-New-Terrain">Why New Terrain</a></li><li><a href="#Render-Process">Render Process</a></li><li><a href="#Virtual-Texture">Virtual Texture (GDC-15)</a></li><li><a href="#Color-Remap">Color Remap</a></li><li><a href="#Cliff-Shading">Cliff Shading (GDC-18)</a></li><li><a href="#Stiching-Fix">Stiching Fix</a></li></ul><p>TODO:</p><ul><li>Displacement Decal</li><li>One Material Per Vertex (OMPV)</li></ul><h2 id="Why-New-Terrain">Why New Terrain</h2><p>作者阐述，之所需要开发新的地形系统，是因为传统的地形系统无法满足 现有的游戏需求（即策划不满意）。而传统地形主要有如下两个特征：</p><ol><li>地形范围小（如室内地面装饰）</li><li>依赖手动编辑（如魔兽争霸地图）</li></ol><p>作为对比，新的地形系统提出如下三个要求和挑战：</p><ol><li>Lerge-Scale（水平 + 垂直两个维度）   -&gt; 解决性能问题 runtime</li><li>画面多样性、细节保证                 -&gt; 解决表现问题 bugfix, tradeoff</li><li>依赖程序化生产                       -&gt; 解决工具问题 PCG</li></ol><p><img src="/images/siggraph23-cod-new-terrain.png" alt=""></p><h2 id="Render-Process">Render Process</h2><p>作者展示如何在forward管线下绘制一个朴素的地形：</p><ul><li><p><strong>VS Input</strong><br>Vertex Shader 的输出就是一些平铺状的mesh顶点，它是没有任何高度信息的<br><img src="/images/siggraph23-cod-vs-input.png" alt=""></p></li><li><p><strong>VS Offset</strong><br>这一步通过采样 Height Map 的高度信息，对 VS 顶点作出一些偏移，从而模拟出地形高度的形状<br><img src="/images/siggraph23-cod-vs-offset.png" alt=""></p></li><li><p><strong>PS Shading</strong><br>Pixel Shader 阶段采样各种 Diffuse、Normal 贴图进行着色计算，为了弥补地形的细节，美术会叠加多层的 Layers 进行混合。<br>通常还会引入底层API支持的 <code>Texture Array</code> 技术进行优化<br><img src="/images/siggraph23-cod-ps.png" alt=""></p></li><li><p><strong>Quad - Tree</strong><br>因为地形只考虑平面结构，所以想到利用四叉树进行遍历、剔除的优化。<br>以COD的地形为例，<code>10km x 10km</code>的总规模，<code>64m x 64m</code>的单个地块尺寸，所以约有2w多个地块，即使经过视锥剔除等优化手段，还是有成百上千个Chunks需要渲染，因此<strong>性能压力非常大</strong>！<br><img src="/images/siggraph23-cod-quard-tree.png" alt=""></p></li></ul><h2 id="Virtual-Texture">Virtual Texture</h2><p><code>Virtual Texture</code> 是 GDC-2015 提出的一个技术，在弄懂改技术之前，先了解它在尝试解决什么问题。</p><p>继续上一节的结论，当开发大世界游戏逐渐兴起，每帧需要渲染的 Chunks 数量急剧增长，每个 Chunks 都拥有自己的贴图，<strong>这无疑给硬件内存带来巨大的挑战。</strong> 但是如何解决呢?</p><p>参考 <a href="/posts/virtual-memory/"><strong><code>Virtual Memory</code></strong></a> 的提出（即物理内存无法满足需求时，计算机抽象出了虚拟内存这样的中间层），计算机科学有一条非常重要的公理：<strong>即软件（或硬件）层面无法解决的问题，往往可以引入一个中间层。</strong></p><p>因此 <code>Virtal Texture</code> 基于此思想，它将所有贴图试做 内存 意义上的贴图，不会一次性加载到显存，而是使用的时候才会去加载。参考 GDC 的图片：</p><ul><li>Virutal Texture：内存（磁盘）意义上的贴图</li><li>Indirection Texture：寻址结构，类似与虚拟内存中的 页表</li><li>Physical Texture：实际采样的贴图</li></ul><p><img src="/images/siggraph23-cod-vt.png" alt=""></p><hr><h3 id="Adaptive-Virtual-Texture">Adaptive Virtual Texture</h3><p>VT 技术有一个非常明显的缺陷：<strong>不论 Chunk 距离相机远近如何，但在 VT 中的像素比重却相同</strong>。</p><p>基于这点，AVT 提出了一种基于相机距离的 VT优化技术。其中红色框表示距离相机较近的 Chunk（像素也较高即 64k x 64k），而绿色框距离相机较远（像素分辨率也很低 16k x 16k）</p><p><img src="/images/siggraph23-cod-avt.png" alt=""></p><h2 id="Cliff-Shading">Cliff Shading</h2><p>COD游戏中有大量山坡和悬崖的渲染（参考PUBG），因此开发人员在 GDC-18 中花费大量笔墨讲述了 <code>Cliff Shading</code>，Cliff又翻译成 <strong>悬崖、峭壁</strong>。</p><p>先看看 Cliff Shading 首要解决的是什么问题，当 Chunk 的贴图使用在平坦地面时，表现是完美。但因为山坡峭壁的y轴是非常陡峭的，因此会出现严重的拉伸 tiling 现象：</p><p><img src="/images/siggraph23-cod-cliff-bug.png" alt=""></p><h3 id="原因">原因</h3><p>将世界坐标 (x, y, z) 映射到 贴图空间 (u, v)，首先考虑如下几种朴素的方式（即选取任意两个轴采样）：<br><img src="/images/siggraph23-cod-cliff-xy.png" alt=""></p><p>因为丢失了某一个维度的信息，因此效果是不尽满意的。</p><h3 id="Tri-Planar-Mapping">Tri-Planar Mapping</h3><p>COD团队首先尝试了业界著名的 Tri-Planar Mapping 方案，即分别从 x, y, z 三个方向投影得到映射效果，然后根据法线与三个轴的夹角关系，将三个结果作融合得到最终的效果：</p><p><img src="/images/siggraph23-cod-cliff-triplanar.png" alt=""></p><p><img src="/images/siggraph23-cod-cliff-shader.png" alt=""></p><p>关于 <code>Tri-Planar Mapping</code> 参考阅读：</p><ul><li><a href="https://catlikecoding.com/unity/tutorials/advanced-rendering/triplanar-mapping/">Triplanar Mapping</a></li><li><a href="https://gamedevelopment.tutsplus.com/use-tri-planar-texture-mapping-for-better-terrain--gamedev-13821a">Use Tri-Planar Texture Mapping for Better Terrain</a></li></ul><h3 id="问题">问题</h3><p>采用 <code>Tri-Planar Mapping</code> 方案后有明显的两个问题：</p><ol><li>性能非常差（采样数 x3)</li><li>远处 Texture Tiling 非常严重<br><img src="/images/siggraph23-cod-cliff-tiling.png" alt=""></li></ol><p>性能问题先不考虑（因为是PC端游戏），开发团队后面主要描述如何解决山坡上的Tiling问题。<br>关于如何消除重复，最简单的方案就是<strong>引入随机数</strong>，这里采用了 Nividia 发表的一篇论文中的噪声函数，最终的做法是将 正常的Blending值 + 噪声值，</p><p><img src="/images/siggraph23-cod-cliff-random.png" alt=""></p><p>观察黑色框中放大的部分，可以看到明显的噪声值，但是整体的效果反而更好的。引用GDC中非常经典的一句话：<strong>“单个像素是错误的，但是放到整体（平均下来）又是正确的”</strong></p><p><img src="/images/siggraph23-cod-cliff-improve.png" alt=""></p><h2 id="Stiching-Fix">Stiching Fix</h2><p>新的地形系统采用将不同 Chunk 拼接渲染的方式，那么是否会导致渲染的缝隙、不连贯呢?<br>答案是：会的。</p><p><code>Stiching Fix</code> 重点讲述了COD如何修复地形渲染的一些缝隙，而 <code>Stiching</code> 的中文翻译便是缝隙。</p><h3 id="1-LOD之间缝隙">1. LOD之间缝隙</h3><p>如下图，不同LOD层级之间的 mesh data 差异较大，会出现同一个顶点在两边的信息不共享，这在渲染时会出现明显的错误。<strong>（具体是什么错误?）</strong><br><img src="/images/siggraph23-cod-stiching-1.png" alt=""></p><p>修复的方式比较朴素，即 <strong>将边缘的顶点，移动到另一个lod最近的顶点</strong></p><ul><li><p>跨一层LOD的情形<br><img src="/images/siggraph23-cod-stiching-2.png" alt=""></p></li><li><p>跨两层LOD的情形<br><img src="/images/siggraph23-cod-stiching-3.png" alt=""></p></li></ul><h3 id="2-与树木、石头之间的缝隙">2. 与树木、石头之间的缝隙</h3><p>主要是做一个贴地处理，即根据 Chunk HeightMap 的高度信息，对树木、石头的高度在 Vertex Shader 中做一个高度插值处理，从而实现将它们 <strong>贴在地表</strong></p><p><img src="/images/siggraph23-cod-stiching-4.png" alt=""></p><h2 id="总结、展望">总结、展望</h2><ul><li>地形系统主要细分两个方面：<ol><li>卷细节: pcg, texture layers …</li><li>卷性能: avt，gpu pipeline …</li></ol></li><li>从 GDC 2015、2018、2021 再到 Siggraph 的集大成者，任何一项技术的发展都需要持续迭代、集思广益</li><li>了解一个技术，和实现一个技术，两者相差 1~2 个数量级</li></ul>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>csv, hdf5, feather 数据性能对比</title>
      <link href="/posts/data-perf/"/>
      <url>/posts/data-perf/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="/posts/quant-data/">这篇blog</a> 介绍了金融相关的数据特性，它对于读写和存储性能有极高要求</li><li>本篇blog 会结合跑测数据，分析三种格式的性能</li></ul></div><h2 id="测试结论">测试结论</h2><p>结论放在最前面，测试数据见 <a href="#%E6%80%A7%E8%83%BD%E6%B1%87%E6%80%BB">文末</a></p><ul><li>数据量小，无脑使用 csv</li><li>数据量大，如果坚持 csv，请使用 <strong>zip</strong> 参数压缩（尽管这会降低读写速率）</li><li>百M级别以上数据，推荐使用 hdf5（而不是feather）<ul><li>性能强于 csv，<strong>读写快5~10倍</strong></li><li>hdf5 对于 Python/C++ 的API支持较好</li><li>feather 虽然性能更强，但限制更多 TODO</li></ul></li><li>切记！ <strong>此结论并不适用于所有类型的数据样本</strong>，最好自己针对性跑测，找到最适合自己数据的格式！<ul><li>对于期货 tick 数据（由于大量重复值），csv.zip 压缩比率能达到 15%，feather 能达到 30%</li></ul></li></ul><h2 id="基本介绍">基本介绍</h2><h3 id="csv"><a href="https://en.wikipedia.org/wiki/Comma-separated_values">csv</a></h3><p><code>csv</code> 全称是 <code>Comma-separated values</code>，<strong>即以逗号分隔的纯文本格式</strong>，常用后缀是 <code>*.csv</code>。<br>正因为其纯文本的性质，常见的编辑器（或者excel）都可以预览csv文件，所以它的优点是 <strong>简单直观</strong>。<br>然而事物都具有两面性，就像 <code>json</code> 存储格式，直观的代价往往是性能的损失。</p><h3 id="hdf5"><a href="https://en.wikipedia.org/wiki/Hierarchical_Data_Format">hdf5</a></h3><p>全称是 <code>Hierarchical Data Format version 5</code>，<strong>即高度层次化的二进制格式</strong>，常用后缀是 <code>*.h5</code>。<br>hdf5格式从设计之初，就是服务于大型数据。</p><h3 id="feather"><a href="https://arrow.apache.org/docs/python/feather.html">feather</a></h3><p>feather 是一种用于存储数据的 <strong>快速地、轻量级的二进制格式</strong>，常用后缀是 <code>*.fea</code>。<br>它早起就是为 Python(Pandas) 和 R 这两种编程语言所设计的。<br>目前广泛使用的其实是 feather v2 版本，它区别于早期的 v1 版本，这个不用过多了解。</p><h2 id="测试标准">测试标准</h2><p>主要从四个维度测量性能：</p><ul><li>1.写入速度</li><li>2.读取速度</li><li>3.磁盘大小</li><li>4.读取内存 (TODO)</li></ul><p>同时考虑到金融数据的存储格式，大多是 <code>int64</code>、<code>float64</code> 和 <code>timestamp</code>，因此也会分别考量 在这三种格式下的性能表现。</p><h3 id="压缩性">压缩性</h3><p>因为写入的csv文件较大，所以考虑 csv 结合各种压缩算法测试（压缩本质是牺牲性能、换取空间）。<br><code>df.to_csv('', compression)</code> 可以传入 <code>zip</code>、<code>gz</code>、<s><code>bz2</code></s> 等等参数。</p><h3 id="benchmark">benchmark</h3><p>使用 800w x 10 的DataFrame数据，取值范围是 0 ~ 16亿，格式是 <code>np.int64</code>。<br>数据大概长这样：</p><pre><code class="language-csv">0                d0                d1                d2                d3                d4                d5                d6                d70  5680658661046001  6886564689964211   777947290120004  6223515736992396  2823728071993317  8416657213663291  3500805963228465  10097481526053971  8952870328278778   306015862731108  9726241400443289  4237512935832667  2875425479333067  6311517969042662   878720088161354  87871182730650332  6858523177136352  1733196075769152   840572662722070  8438133907754012  6671944540650125  1147224095855703  1583106816125259  27980685687731413  2940819554234759  3142545317839947  4641209159206074  8194125756197731  4958881218032026  4405637321734842   500692399773906  35316179424621364  8149680042981168  6793238579260437  3891639455885689  3690167863144449  7552248224604567  6411717840330018  9556078695826276  4851668202438122......[8000000 rows x 9 columns]</code></pre><h3 id="测试源码">测试源码</h3><pre><code class="language-python">class DataPerf(object):    """ 数据 性能测试    """    @staticmethod    def get_random_datas(rows, cols):        """ 随机生成 rows行 x cols列 的DataFrame数据        :param rows: 行        :param cols: 列        """        data = np.random.randint(low=0, high=pow(10, 16), size=(rows, cols), dtype=np.int64)        df = pd.DataFrame(data, columns=[f'd{i}' for i in range(cols)])        return df        @staticmethod    def perf_write_speed():        """ 测试写入速度        """        df = DataPerf.get_random_datas(800 * 10000, 8)        PERF_TIME()        df.to_hdf('perf.h5', 'data')        PERF_TIME('hdf5')        df.to_feather('perf.fea')        PERF_TIME('fea')        df.to_csv('perf.csv')        PERF_TIME('csv')        df.to_csv('perf.csv.gz', compression='gzip')        PERF_TIME('csv (gz)')        df.to_csv('perf.csv.zip', compression='zip')        PERF_TIME('csv (zip)')        @staticmethod    def perf_read_speed():        """ 测试读取速度        """        PERF_TIME()        d1 = pd.read_csv('perf.csv')        PERF_TIME('csv')        d2 = pd.read_csv('perf.csv.gz', compression='gzip')        PERF_TIME('csv (gz)')        d3 = pd.read_csv('perf.csv.zip', compression='zip')        PERF_TIME('csv (zip)')        d4 = pd.read_hdf('perf.h5')        PERF_TIME('hdf5')        d5 = pd.read_feather('perf.fea')        PERF_TIME('fea')if __name__ == '__main__':    dp = DataPerf()    dp.perf_write_speed()    dp.perf_read_speed()</code></pre><h2 id="测试数据">测试数据</h2><h3 id="1-写入速度">1. 写入速度</h3><p>注意：因为 追加、覆盖 等模式会影响性能，所以重复测试前，记得删除已写入的数据。</p><table><thead><tr><th style="text-align:center">format</th><th style="text-align:center">write time (s)</th></tr></thead><tbody><tr><td style="text-align:center">csv</td><td style="text-align:center">33.5</td></tr><tr><td style="text-align:center">csv (gz)</td><td style="text-align:center">135</td></tr><tr><td style="text-align:center">csv (zip)</td><td style="text-align:center">128</td></tr><tr><td style="text-align:center">hdf5</td><td style="text-align:center">1.8</td></tr><tr><td style="text-align:center">feather 👍</td><td style="text-align:center">1.3</td></tr></tbody></table><h3 id="2-读取速度">2. 读取速度</h3><p>测试接口，全部选择 <code>pandas read_***</code> 系列，会全部转化为 DataFrame 格式。</p><table><thead><tr><th style="text-align:center">format</th><th style="text-align:center">read time (s)</th></tr></thead><tbody><tr><td style="text-align:center">csv</td><td style="text-align:center">10.8</td></tr><tr><td style="text-align:center">csv (gz)</td><td style="text-align:center">15.0</td></tr><tr><td style="text-align:center">csv (zip)</td><td style="text-align:center">14.1</td></tr><tr><td style="text-align:center">hdf5</td><td style="text-align:center">4.2</td></tr><tr><td style="text-align:center">feather 👍</td><td style="text-align:center">2.0</td></tr></tbody></table><h3 id="3-磁盘大小">3. 磁盘大小</h3><table><thead><tr><th style="text-align:center">format</th><th style="text-align:center">file size (GB)</th></tr></thead><tbody><tr><td style="text-align:center">csv</td><td style="text-align:center">1.10</td></tr><tr><td style="text-align:center">csv (gz)</td><td style="text-align:center">0.53 (48%)</td></tr><tr><td style="text-align:center">csv (zip)</td><td style="text-align:center">0.53 (48%)</td></tr><tr><td style="text-align:center">hdf5</td><td style="text-align:center">0.55 (50%)</td></tr><tr><td style="text-align:center">feather 👍</td><td style="text-align:center">0.49 (44%)</td></tr></tbody></table><h2 id="性能汇总">性能汇总</h2><ul><li>以下统计的是 <strong>相对得分</strong>，数值越高说明性能越好</li></ul><iframe src="/html/data-perf-echart.html" 替换这里的html="" height="600" width="100%" 修改高度即可="" frameborder="0" scrolling="yes"> 支持滚动条</iframe>]]></content>
      
      
      <categories>
          
          <category> 量化交易 </category>
          
          <category> 量化交易 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【量化】爬虫获取东财数据</title>
      <link href="/posts/spider-easymoney/"/>
      <url>/posts/spider-easymoney/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li>这部分主要讨论<strong>基本面数据</strong>，获取<strong>行情数据</strong>看<a href="http://localhost:4000/posts/quant-data/#%E6%95%B0%E6%8D%AE%E6%8F%90%E4%BE%9B%E5%95%86">这篇文章</a></li><li>详细的爬取标准文档见这篇：<a href="/posts/cores/datasource/#Eastmoney">cores/datasource</a></li><li><strong>NOTE</strong>: <a href="https://akshare.xyz/index.html"><strong>akshare</strong></a> 已收录所有内容，不要重复造轮子啦</li></ul></div><div class="markmap-container" style="height:190px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;<a href=\&quot;#爬虫基础\&quot;>爬虫基础</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#爬取规则\&quot;>爬取规则(东财)</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;功能实现&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;<a href=\&quot;#功能实现\&quot;>源码</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#处理json\&quot;>处理json</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#数据存储\&quot;>数据存储</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#数据应用\&quot;>数据应用</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<a href=\&quot;#示例一：寻找-“A股大鳄”\&quot;>示例一：寻找“A股大鳄”</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;<a href=\&quot;#示例二：财报公布后股价走向\&quot;>示例二：财报公布后股价走向</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><hr><h3 id="爬虫基础">爬虫基础</h3><p>本章要爬取的东方财富，数据结构非常简单，在爬虫领域中属于入门级别，使用 <code>request</code> 库即可。<br>下面代码示例，爬取 贵州茅台<code>600519</code> 的一些基础操盘信息：</p><pre><code class="language-py">import requestsimport jsonurl = 'https://emweb.securities.eastmoney.com/PC_HSF10/OperationsRequired/PageAjax?code=%s'res = requests.get(url % 'SH600519') # 贵州茅台info = json.loads(res.text) # dict</code></pre><h3 id="爬取规则">爬取规则</h3><p>东方财富的数据（<a href="https://emweb.securities.eastmoney.com/PC_HSF10/OperationsRequired/Index">示例链接</a>）主要有两个特点：</p><ul><li>优点：链接条理清晰，便于爬取</li><li>缺点：采用拼音缩写的命名，贼坑（例如 <code>yjbg</code> 表示<code>研究报告</code>）…</li></ul><hr><p>先分析信息页的基本结构，<strong>第一层级</strong>是下图红框部分，<strong>东财将它分为十六个板块</strong>。<br>我们会挑选需要的数据板块来爬取。</p><p><img src="/images/eastmoney-head.png" alt=""></p><hr><p>以 <strong>股东研究</strong> 为例，<strong>内部还会细分为多个第二层级</strong>，例如：</p><ul><li>股东人数：每隔一段时间公布股东数量</li><li>十大股东：前十大持股的对象，包含增减比例</li><li>机构持仓：有哪些公募、私募基金的持仓</li><li>…</li></ul><p><img src="/images/eastmoney-partners.png" alt=""></p><hr><h3 id="功能实现">功能实现</h3><p>源码: <a href="https://github.com/593413198/Alpha-Bet/blob/master/cores/datasource/Eastmoney.py"><em>cores/datasource/Eastmoney.py</em></a></p><p>先实现一个基础的爬取指定 url + code 的函数：</p><pre><code class="language-py">def crawl_base(self,                code,                url,                fields):    """ 根据指定规则爬取    :param code: 股票代码，如SH600519 (str)    :param fields: 爬取的键值，映射到中文 (dict)    :param url: 爬取的链接，股票代码用%s代替 (str)    """    url = url % code    res = requests.get(url)    info = json.loads(res.text)    info = { fields[k] : v for k, v in info.items() if k in fields}    return info</code></pre><p>后面依次实现爬取不同模块的函数，并选取有价值的字段 …</p><ul><li>操盘必读 板块</li><li>股东研究 板块</li><li>其他略 …</li></ul><pre><code class="language-py">def _crawl_cpbd(self, code):    """ 【操盘必读】    需要字段如下：        √ tszb: 特殊指标        √ ssbk: 所属板块        √ zxzbhq: 最新指标    https://emweb.securities.eastmoney.com/PC_HSF10/OperationsRequired/Index?type=soft&amp;code=SH600519#    """    fields = {        'tszb'  : '特殊指标',        'ssbk'  : '所属板块',        'zxzbhq': '最新指标',    }    url = 'https://emweb.securities.eastmoney.com/PC_HSF10/OperationsRequired/PageAjax?code=%s'    return self.crawl_base(code, url, fields)def _crawl_partner(self, code):    """ 【股东研究】    需要字段如下：        √ gdrs: 股东人数，通常股东数越少，代表股价越集中，则更容易上涨        √ sdgd: 十大股东，包含持股数和变动比例            sdltgd: 十大流通股东            jgcc: 机构持仓            jjcg: 基金持股    https://emweb.securities.eastmoney.com/PC_HSF10/ShareholderResearch/Index?type=soft&amp;code=SH600519#    """    fields = {        'gdrs' : '股东人数',        'sdgd' : '十大股东',    }    url = 'https://emweb.securities.eastmoney.com/PC_HSF10/ShareholderResearch/PageAjax?code=%s'    return self.crawl_base(code, url, fields)# 其他省略 ...</code></pre><hr><h3 id="处理json">处理json</h3><p>写入 <code>json</code> 文件时，需要注意中文编码问题，下面是一个万能模板：</p><pre><code class="language-py">with open(json_path, 'w', encoding='utf8') as f:    # infos是要写入的 dict    content = json.dumps(infos, ensure_ascii=False, indent=4)    f.write(content)</code></pre><h3 id="数据存储">数据存储</h3><p>结合多进程爬取五千多只股票池，注意处理空数据、网络错误等情形，最后分别以 <code>json</code> 格式存储在本地。</p><p><img src="/images/eastmoney-json.png" alt=""></p><hr><h3 id="数据应用">数据应用</h3><p>量化金融追求一个实用注意，那么获取这些数据究竟有什么用途?<br>除了常见的<strong>用作策略因子</strong>外，下面展示几个与众不同的用法：</p><h3 id="示例一：寻找-“A股大鳄”">示例一：寻找 “A股大鳄”</h3><p>股票市场的股权拥有者，一般有两种，要么是个人，要么是企业/地方政府/国家。</p><p>下面我们尝试统计 5000 多支股票的十大股东（从东财爬取的数据），然后稍作拟合，再按照持有数值（也可以是持有公司数量）排名，便得到如下图表（绘图来自 pyecharts）:</p><blockquote><ol><li>带 <strong>香港结算</strong> 字样的主体(及HKSCC)，一般香港/外国投资者通过港交所购买的股份，即所谓的 “北向资金”</li><li>实际持仓最多的是 <strong>中国财政部</strong>，他基本持有了各大银行的股份</li><li>其他排名高的主体，基本分布在 <strong>石油、保险、电信、证券</strong> 等国有行业</li></ol></blockquote><iframe src="/html/sort_by_amout.html" 替换这里的html="" height="500" width="100%" 修改高度即可="" frameborder="0" scrolling="yes"> 支持滚动条</iframe><hr><p>看这些国有巨头的数据没啥意思，下面尝试筛选个人持股的排名。（筛选条件很简单，长度 <code>&lt;=3</code> 的便当做个人）</p><p>排名第一的大哥叫 <strong>魏巍</strong>（竟然是28家上市公司的前十大股东…），冲浪查一下，发现他位列 <strong>牛散F4</strong> 之一。<br>而排名第二的 <strong>徐开东</strong>，也是A股赫赫有名的个人投资者，跪了！<br>靠一己之力的买买买，坐拥如此多的上市公司（虽然只是前十股份），其艰难程度可想而知！</p><iframe src="/html/sort_by_num_personal.html" 替换这里的html="" height="500" width="100%" 修改高度即可="" frameborder="0" scrolling="yes"> 支持滚动条</iframe><hr><h3 id="示例二：财报公布后股价走向">示例二：财报公布后股价走向</h3><p><font color="#FF1E10"><strong>TODO</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> 量化交易 </category>
          
          <category> 量化交易 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>日志：2023年10月</title>
      <link href="/posts/2023/10/"/>
      <url>/posts/2023/10/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="70633d927d709480bbed1900c6022d41ab8aac0dc51eaccd23f7c75881c20b45">b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475de0b1305a637ea913974dff7410a14ed4dbbb40a5278eb14bbac34e59e12a284c7a294ab69a495d47e11e78ad50feb1070946a0084538613a8500fde76ee182cdc92156f5cc629c04691a80beeb70e034667984a29cb1db27ea11974521ef316310dd65dbfbb2a0d60f2a8ce6cab9f6cd825044604fed45aadefb22ba2321e19dee0566e6736947a45ad09061320fc246487e86167f696ce0b59ebd851781c74c35b8570834a7fb16ccddf85c541da4399962ab09e1e1ffa50d762e18e62c34615594554095f4effae7f3173f3242f7d285478fc1e6d0eb779e3ad11f1012997a7691d132e80e6dbc913b732d2137b6b8f57f694a4bbc70f994c2da6ae0c94e2f6c8c831f133927494996ba5792fd93c2fdfe0eb6f6f9331eea96358ec38968250bac0d7c070ca45382255703402e14b1c12f4b6575d19e98b134e304b397b7aae8ea19642fe8f01427dc67ab652cf56b4ef5303ef984d86a43e75e38f31fa2ee88ecf4338d7b0525c22f6a0239dae2eaa2bd1f594c7ec15c9ecc638c89d4a07eedaacb68410825e683c07c0953c99245fdb7567893d747df61cd912a11503c3fd4da64a36e87856618b775733cabcdeaad064836cce2c64d7777e31bffbf3b39f702ab793910862d380501b3be50aa526265eeffb3b510802d4dad98e511ae0ffed757f91e649b5fcc0f8cde1f9bcf6054be8c2434c50711ad3d54cefc96c0776fd334c84f3108aa4b6417393d4310021ade3ea87c841c093886cd78524a429172dd29da1e7d5002c8e3f28656021a6591edce5666dd9ebe1ebb1576689139f329ef1b3c741bfaec6a1b6de1d6f8c143382824e1ddd5744cb9ad223885f43f7541ff956a5041c29f957d7769b29b067fa9e16305dddeba77fd3d04a2555f5c4ce9a76454a000b2b4a15d2a70892d99bad0d2d90ec4b4d60dc1a6d7b8985a49136637a08f639935102fa843b0443b7e75c9c5d7d86d28a203937faaef4dbd7c0ec8cdb379bd118e686bf5b65b558f325b738f12bc4c1652b0e1d2b65cf17afadec738ae39b244ec2208fe3e1bdd5177f6d94070e482093d1d5978e52145163cd7d94c8778e1a680be7ba2f3f264ffd2a5bf487519e45a4623775b22a2e801bb986fbe8a6133c32a786e9c66149f540ca4273f922926e6460a0cd2caa5e13d3652f2fe9a9c7e7ce8681b3f5c0b404fc870b0c61404454d36dfb3b1bf7b3909136046e8290be28e6c82d5e974abd3f0d207ce677d455bb5652fe53927ebb2e50a3ad6dc1a77f5e10e74070ff59cadad82fdecffee5f60f8805f4cddc270416c343e126325b9b49963b9df72ea0f287ab445fc1043cb9aef960efaa7a3d0a07f47737e5fafc5f31872ae381de5d018a507ccf9c5448f48bcd96516a314284643c241f2f5bbb525829025833bcec3e927b1c932b24826c601d2601d2e6146f3c8e46aaec0820ffab38a31c0f50b209b3b7c70c50e09c4467049ed8336723a3f20d97294072fabad5419102c589a6f6f3c4d5468ec67265c88039e30424385ca8fe9b51a50cc77e21b4d73cc71e4c5754762c60d83470e3ce0022755d7630bf3ee009c2fd32128da5d155cd35950b47870348dcb92e52402d73f450b4ae56ca94748c88787f93e5733555a57ca77c19fba83dae595d97246d435444a4727be3dcad505593a74a4ade670032088934539d924c3421e219af2ac2a2958ccfcc5fff60a1e47c6af06e0774055f0c0d2de9438dae41dfe9c6bd0a89788d32a233d77987ac3980510444340c6f8d11750631d3175bde177b8de7dbfb0ff25056c396cd9dc597cdbcecff5483b543d0b61141bdacbc76edc296657bf3ed88730ffe741ef90d1ccbb96fc265249afd200e7d8c9c08c45033cb197d713a054d6acd59cda40c54b0b030a60902e1b3d56fec60e709de21d706604e83333058be491185d29eafc2e09269503fa7652ad30dcddd84707bb35ec91aaa80614753e2914023a70c015ac6523427291a18d2ce214643949fd34bee0c7041cae1560f10499faecfb8ad48b8a3dcd4d9ef69e1f5c3787935147bc2eee9148843ccad1e9c8432650d5264bdaec7a30567126e75d40df65d85805a1ba9ca65819c9d7243d222074570717b270263fe110785473367e29bfc344acfa6db173b1c493eaa081c002380484c10a20b9f2e547e499c7b962e6d525bafea81b322aa5e3107ea01f095e0ccbfac0dce867ed1ba0574b012b3f644314c22cfc0f5004c7ae06ac7169c5fc35d711e9e577b18bcf4c2d02ac44aa220d1ad5849852e9e6790786b0fbb57e3a0433492067ab8b272b275ec9f645c0553a4531feb03bb9a34e876c7b5fac23f3fd63ad4236d5eceddb7f5368d2d3379b657affc6722f46140b31e719d1aa60ffc182c06bda7b7132e9e95fd229cd2fa6be754dacd1fc7380a2cdeeeecf1652731694b935280793a66f55e84abc0939d3dfc37f9376c817a69db0f9aec926c62dd7ed73c18934e8464071e2438cdd41df20875220542ac80c0e42446050e34ac6c2b82c48b1a09d827963ceabad89fe0d2f27e706e994698edefd67f6c731fa454e864e439894ed3f2b2822bded480a79fd89b9b1eb2aa88f756bf833ad0e5f0b6cca0e6acc7b3905b17bb51b7a36ab6e64552515ede61d857ef4d9deb9216f1045d88fe20f12916c13c2d35c3c8160bcea7475ee055dab046ec85d6451b72ef6b746f25b48f246a1ef0bd8f6c187f40f362e3e3bfaed162ee482e4e90eef9c761b03c24d21e8428e34753a3c59f332ff38300514805d1e0439e0c31526fd95aa8057fcbeeecb21191d65c71f881b62d2d32c0932abcce78ce06c196b69d3a52235a2e111fa91844fc2e4a35c2109adf47f8fc7514e7cf9d6d952193955c9f5015782be51be7f6b865e246671950599d9622f8a5caa07087852873ea794853e026b52d9ec8ac97c906157dcf22fc0ab0a9ad96d13235511031257462db138b40592cce32641b7c7e9d4437346a223b8cc84aeecce2e0c567110c3c7359caf7af45a859cbb4cf5db22849eacc9e4f646b87b104be5bf2cf19090b637e0b6def1c42aeb4df72c802237f84bfc02f8a89ee7c752f5899fde421962f2d161ef0d496e5322d06c132bb9233feda99aa5bc0d40c6614a199813f4516ba9a09b7815c9d36f4dd75d0583b59616dece07380381a0bffb0f4208893603e9c7cdc2a58a4046229b5b2ae349b57ad4c4ebc859bae8660c9f6d70e473334eb93620444d39b496d16055ff13139cc45967df24fa7ed83020f1d6582cd0514e20e0e5c223ccbb248b3a49949748009f9cae16d0444ba5cbece68e2f363c963781a3ebdcf8bb7cae8104cde698040da97ca058b1142b22317c6239955e3a6f64fa652ae3fea57ab30d924a176db399fe01e7ac5cc5b2a9c9eb6c3bc23c349ad434598e1629f47cd7ef8b26261dc0e7d5381188dfc84da3333ce06cf53365a116f82fb3c923b358de4d71f172c13e2f63e05032e53bed7aeb24d2cf8c9139e4ef654d7d8fdd96b1eaefa19551f4251866c5d64e50b36e958872f784a33f962e9e3461a100b69e1f582ad56c157cb03ee3555ff810ee77674ad863fc441d16faf4b5ede8bd9a27a448dd1b56ca0beb534821532a0a8f94abfae979025eedf79bf09d46edcb3945aec4d39814ff9496abe7d7290b5a7ec2805aba7f1aa2cd1372ee01b08ec80d4e261be65e56706d3cdcad34ee48cab6cbf3759f572bf37be3fbe073e5f8a1231a893cb5de0fbf3a263bf81f83099e65266a4c7001e491126d6dba91dba73066b885e816269dafa4dcf3ce0001629a66f84c9ac6745da2c500c3b7adf669b0e58ea9d1e1079986e48a3f8f4e1f13cb652a3133dcb987c9bc3389b3fcc768100d993a757f4b4bdb8afd938b52ac7c5d61b0f6ddff386f2e4d912d83a2912fd2706023f40c46e7aca9ab04bfcd28d32dc021f556f640c51f7e4ebf359f952f05632aa849d97ecacc4f530f41264dafd11ad98db8023ba1a37ba3b7e85506739a52bef589a5d31559729be39b0f9e907c42ff7baeb03dff2d9aed0f0b648992aca08d58d5a74edc69d3892b3f2da6b719411b8adf55e8d8e6b24e40476c28a66bf4b9993920c4054c63c17a27451c1590bdb1330b1406f0e527bc9d9aae5ccfe0a023c7226f4b4c241db936a8c1f1002aa6d0d53da8b7e3a9af8b3a03015678abb07cabf06ccc9412fa3a4a6d1ba80a70841591bd300a9cf0044a3ad2c80a0ead283cb856137b6625c8e7dba6b5435085ebc2f82015dc60e17260e58a1edc7f11456780b6d2cff008b1d39a4c712c9eaf0841dbce5f3afa0512c4ff1009124e78e624a60760ab864c4dc1bbac03d2a3514b95cc9dd0930f6342aa895253cfd566221379818e52acf7cd1bd81102f03bc746717c90da817ad3512cd04223c8c0264e1c132c1ba99bdc393c6bf6f1e0c3fd9606392a586aeb832d47ef3443f471e8aadc53940ee7af5bd09d4cdb902bec979494423797ceb224e3835aab7d83dd3ff30e9ddd2bfb21f3c875011e3d057ea216fe67c429def8efbde1cbbc4a817d2eff6515c8d41fc4437e4c557fed3e11f301a2176d9a9975dfa7bb26b5a01ddb2dd2a029ad768b35b9ffd0c0182b1363715aa3712e2ac4d9e4639dbe1706c87ac633520a33f561bff60b47c5348e444f31dcb5f29f8c91b472abbbe11bba21d0708cc00c295baaff6deb696b6a51b17929ea32968f135e3cdbb8eb2409389106ff82a9d16449e99f5ca66a08fb647245f1c67860a1af24b2dabafd651f8e465f7cb724505aa6af55d00f8c24b7e4abaa09b8ba863880df79122b3a1f278c3612ae87d893cc9e64c38efa5600f9b88d01139a5fb90dbcf5853da2bf6f277d1bd7307b60f45e0286761364fde5cf15df78df87cbc6d84d8f42aac9582c64de72c710f3ae897eede27990d1821c8b0e8f66bbe58ebca1483ba5532e9cc84139961597f385b73f71673215c1df7dc53ad7a7cda73358bc2b79c7679ace10c262de19a6ee8e268b892b55b5dcf7215e9aa0947415b7060a85d5e4474ed98b5109452a8ad06f1afbf3b9330d66e2b5f2a17551d78d7f00f2dd3154074770f7b2a15bd82750a57ee1e75f8ea299ca50ff1ad4b05b5761b2cf7aca695cfb4789ec59d7ad60cb68d5d4b589c3d98784313d7b739ba6aa7f87bfec47b5631b9b4b5538f79347f9a5810b5dc06f35a91fe03b4119c8a34ec656fa66795717976edf0e3139a379b97def36bc47e7d6396724459212cc2fcd7dd7bb937939ab2c9b8c60996d534b2161920a6c3b1e006104080646182867139100115ff5ad598967e90337e31be254ab62c643cc38c43d9caafe25c15b831c0360cbd6e981a7a9ebcb32b16cc9d1f8942cd64d060823a54f4ff446342c2ba1c85b4787f5a3f838710751ed280d1de49f2f511707bdde67b9d7e61d21d6708bdaa2a962f0b16c6067320a6b2d6b6348abdf9adf4ca9ff0adad3709a4495835811869970b1028864c971b44eb4f5209b461dc916d627329bcac943329b759578bf7eea4e5fb7162565759ccc157100d37efeb0a6590e1807d29b1a6db569eceb58768a6bcce0988eee5441b362db819b545bbfa13af723aec5e9ef9ffad8ab78371d7c962c6a08519dc841fc0390804f45cb168c98fabbc1aa7ed77091c9f971497faddc6c1f81038f5ef585c191d162ada31e1c6086dca1ea0b7eceb1d4740765241de5baee0fce2dd819f39ab54bf20af4fe49cc8b96d5d0159ab8a292233ceb7619ebf2cb01d984f5e5565e9706e039c0dd83c4d0796e85008d8a24f271d0b43713a7ff8817a8d9ea726e01033d6a314a34a1d7386ab9a9338b8570370a279d2a9d729ec24d19627a693ca47f8864574b329e55e560fd19860ccf024280af1803a4b1b9303a072eccdcfc319337ac7ed1b4003f7589949493c0f9019da27d9006674093882a9a61f5a29c19581d50df32d9407f1c1ab1b9e02a27657e547861f4b7916ffe6b86cb8ba96a05826d250cb88b1184e28a7dd9620217740ac1c697b8033c8cb7f13d65c178ace97ba8f772c14f094d1c99740498881bca7820709de94c2b452b87c7922bff7c4626ff58841b0f6096f1e5fe1b6e7dffc6e196e7defa94b26c204cf7216c2e061985a38ee880897b65dffd29a3e18c532b74d9eefd9ab47ba1882969a2db6460d7116a97da69d7fcc096cc6ad06d858814d58d3d75a2e29d4b109e6cac09e80c7586e1e6dd94e01d9a555a533aa0679dd504fca015aa43c6d8e2cea29ac4b3b4dddbfd87634033cf254c2584ca6010e6bc885cd13000ea8d2a1fdc3fd867834d374571c52670be4950e9a811627126a36feed5e51ef85fa57474b64e8ab072a3359b0307a9b18f9e891777b2fe1c6a8959c07d109c80499d1d20fdfb6b7e3fef3a073c4549fe1a38d645cdb699c9030ffd390e8016fed7b7198a8c7393313199822a665048aa979fb005ada5a52c492b3ba58486ec967325e212bf499ca26e6d1df4dba2e40d9622e45e58b282858dbf2836518dc9afe5b08769bf5f311</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AlphaBet】cores/datasource</title>
      <link href="/posts/cores/datasource/"/>
      <url>/posts/cores/datasource/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0b1b8f656acec1ff98a93abbfc04f797fa7ebf713f291bb92451c4ace903fa56">b3dc07a81f6459d120ce338ccca5504625d42614b93020ffae3fe33410b4b3b7b132d51143295cdac39b893eaf193f19c019943d7e59177912cd230786c73130f76d9215c2bfeb61246a440ea10f1093f8813644e0539c6bf43af0a466ef4a3869f03545f2371c4406e374164f0141df491302831c878c9bcf684755d710c17cb4b0117718299701c3e92d7e680e2d2efa6064966556690e77b81a309d85d8062be1c5b16f52b901b914a1111d41228d16b637e33b3fb8dfd796dd947c22ca30563139d3e404d882931db783f4126db99a7310744b338a985b524a9dac8083a2a5a5aa404a7c2aba3842b8f7170f7f93a7593facb8e80f8a87e073ace10df1f6817abad52038b81e62d6a1a3b5bc4d762953c1267b1f408b00733262f7146a94e3cc80d2df634050dee46a6355ee9af83995a7b5f4b80a5627ca71066f60f41aae74b02944fe44fae3e3890718da71a40dac85b3a4877d7fcc4da2b4de3a90168081f652bad4aa16c8811955fe8cc5f31d48e9e6b338f3a16d72afc12c1b30979360689fc8ffa09031579ecc5c27ead8281c37a80b03115545b47cd91d5c57bc6503fcf138d0842fb48ab0e4172b9d4698818bfb1ceb274eac3a0d6b9c3588d345b8728b191f6c2a76bc31b7cfd2696bae0070bdb02e358907df38197b78dcfe73ee8453a3b0e5fe968017f26b66fc424a40812601fc222a55e5611d4a8588216b604291816ee56365c21979ea5309e05fbe4406a199a103f743cac2b4f5490ed210d312f7892b3cd2200a2d21dfdb5da61de40922326ab8ba2ad850c74083ed76534b200289b9d29bce4d5386cdf542920306aebdb9c3f8c6298c1ae30e68a9c24dd7117c5df3fd9c7deea388325380c97ce330b91d3ebb1fb0b033257940b7290eb571146644e8a93ac55e78aff64e321aef22ec9b15358bec56c2b3fd8da25dcf16af0bce5d57d453df12ea5406d0a74b0eedaeb1a9c7e47305f5b02c5446a0c9e4274cfe77954f49a64ba12cf0bc45a1a2dbc0afbeec373af4d6afa3495d4a6b0ecae0de608b00b884fb1f557d13f85725e01671ea88d5ae21a0b9330dacc81cfae76a95a04b0f2f1b2571d53274d9bd3ced52a666e7cb23ad553ee8208fdb807b4bca86092ed2c75bf74b1aa541e634cfdaf7324570274d5a956d43d0c9c8acceb5fb4ae741343a1541baec4798a1b90e46785bfb6776edf372f608809bb214bb938602dcad522bc85947299cfccbb3b82ae0bbe06a228ec5f5a51745a8d47a7b49213278d2a1a69f87deec6e6333cdc71635161ad51d49a3da3b09b8cb0192c4b44ced1a57ec859f6c767cf78e72532397dfa8711c1f4183761fd657018ed7ced1c41bf6a38aa2e17b945ec39a9d6c89bb4ee46ce084c5b3330350c1bd3181a8e43fdfa5c469f32b52d500899ce836250a75f55b36164f858641f417acb902d14ac00d4d578249fcca2cf13f02610a0ccd46ced8d1cc6b877443681997f635223b29c19f432eec63583a9cc76947bbb9aede27e3627873d2b3d8610ce976af5f09a85868ca27eadfd0b221d308a5eb00f98807aa234033dfeae4cb79d123d75a928c28d987d08d220b6ed82f922dee7f6ed63a927892e7d05c9cde9eda1910da379fa307677b2db814089e95fcee0ffa8fc77f67c28e89f4ed744b36c0074dcb5aa5970394a2edde2b6b372e5428552027fd5e152f7eea267dbfbc5fabdf6fd30a482cf5405a855497613698139b650e96e3697703aaccabc94e9238ac7df7aede7ceae407823a6caf5b164c88e88229e5976781c65d137c5292b3f212cd62548e6d26e38d0bbbe1ab74922bdae5cbf75d438082e7c9728d810d48a1b33cc1caec7f360c988efe754987db66faf5fd146d5765c046498601d43150f3757bd9c7d9b181f65e9c8c89a3a3c9e56788a8602a30f688e5c8ccb610f82d8433b46b8f0f503e92b6911a4d6633471246ac12e1e5f62f11f01c986fb06b5addbc2de2ce804ae602539298e728b3f0e32374a24f62117947617e2cfa584c4bca77296877f07271b4939fcba9d133e20b241aad65c20bf40012e53e045794079658b7f7a220d47d109cb8b96949cc37b3ed39be79c9cb1392049b476c81b62080e3de8759f1bf32b32ee4e9ee66804d3e4aeb7553126894666cde4fd36d5f2ef3bad7a9e634d680eb8ff3d3042813fbc24c5c4b945a115c949a473a24bfbaec6ff4cbf93a93f5bf8cc293a2dceb77e9f3628928510109302f70147ea35c95213168f585545d129ccdb24e6716774cfb7eb12a259c0df7814a4a60fbc879d91c15a3270a11c72a5a96e1672a3e910525e270d2c0b754261d7098c285ddf9632614465392df09cf6f2a51de2971f6c69fd925e139876990cb1bcf76af3cfb7e21390d3b7016115f853ce4e841a31fb157c0d117be05c030ad3112efb7942eb8d3dbe53e43d7184449b7ccd32d8436d758f449ff4a043d6532db51be35aaa720278150f8e6eb37932a71ed5139e001a99c48facbf8611cd32567bd0e753900ff548157b6ce628ba80d2c8ade57a43c3ea1bcd95aebee89bf3f707aa6664778cf378e97f171404f3ee2e545cc9bf5d7c232bd72830d02c078f09170e8b574a9b5a42cab62d77e5232b4b999990bb37577904b3cf30e0c679148384c355ea7fb3ce2d675f8de4d94caf6823840f508367ae512364309d5dffb4898c5b3acf9df38621fbe5138c62ce20e1c633c9f4ae8bc31ec8d1fe3960bb88f3e22b9d0eba64144c14abde3e14d2002abd7ec57ca4be265d935e3ae86333db06108373e7190f261c4f2ad274a39f8149302e5075d6a3075ba6f7caee39e60187a3c264520801622fddc943619b4e5c4f498208b58b00028dcaf273a431f46a4bfbeca5634567593b711b9f97d99e86c9c6830c9b23d00b7ba8994c780ebd5bf6fbfcc8d9896f86fe27b7c5a6a229bac38dd0c2143c8c7bb0f36a9f1d84f08577692a18a63a89c0ac402fbc820fbc5f2ca4f77adc3b37d5967ead5548042170e890818b097ea0a4c69894fa848ee39ae14ed4f25af1260c4639f7f6fcf1043476872034a194616834c15f92abb40240298b77d34744b032b51a3b6f9aa52bde8064954929e2866f2ddb45daf630b7e7bd664b9b68cd9b860753fa59d2ca39a8d881f293b8d66cf49e683716a976cee7cf7f2a2d3fa744d024980e15f97ee49a5747b530c4f4278563e0bec4e6304f9b44dc894f1968f59ff5604d76b33c9ff92d225554572f31459f5d87de3ca513eebca5df10843581438779d165326cb5d35828017a6f52c3e377a484348a67e05db4fab09e77f6a3feef9656696e69a77a6ecacbdae0c7195a2642c21080fa630f6e583fb6c11583aba3447986b0d6df732d96454955b759f154245c0e5e1367cfb9d8a40081f153af35403a042f64ae92c75055c9e1f03660c6fb602907bd2eae4eee7cf4c39970d6671016ec3b630cbb48106f4eaeb756b0d2363ec2adfd62ae770df9b89bf2d0ede1ae709cc8575e9fac8c0cd910006b240843190fcf320163afb1421a16e9c45ac152f9710427344d399639ced68ef07bae2ed4532489e64cc44ee12c18a034a29a6ab44588297e462533cda884585696884aeb5d5bc96b4c268d84af086b462dda95a296b2314dcd3d2b8d5a0dbf6835cc9890b23a3ea8d10d9cc426a5988b60c01a78761c618e67010b6804107b0f19286d974fb2ef58a43f7afcd8d04c018bc8e85696dbb9471b33f8cf0759ae8ee3584f31e317f62d56c94759ce59d0bfd7a85eb2e2970030b682b1a0cc66aa8a5939ff4ec137cb3f5b4b39dbf861bdf1e47df54dcb75b9d2c8e351baf67505f4c5faa964e6dffd043bb756c1df8fada50df8aaa4aebf68a59d96830840bc6f21baa66c77ba968a8d808f62d3ff99684371737a11fd15189a59960682831f4b542f0e8e2e9db8ddbeb6bf8209bb1aee6fac64a7f86695a394b750d0fa9cdf30fd6eca3fe769e5dfcaac87e3db0ce32dfa790becf81afe76974b440265c8e0d4a5f74ac3fba72bd63184ab603fb0f83a17bf7e3ec04fb2e63dd72ae99865418a42a0d8ab8f89dd286a58d3388eb89cd501bfa28504fbf2a372883d1da58c20f001964d472c9fb278adf2e50910d455d0c513900afb020780b044f930ba9903c79ddb8fd0b8273faa9a2a577dd020410a56f951844b5b76c6e9dd7e8e0f80b7978fe8f98f94936ea06ebd420de5a02a402afa6ace3de20bedecefee37398980e251984eaf0f6779aeddb7fc88ac76b9f3c67832ad6a56f0420d01aa75883ceb5dac50d64d0c158500ba22d12e8075665da3e407c19661a8818a7ad7a0191cd6d316bf292e09bd1932a8a13299a5bf07fc683e33dd2c5bf9eaf8dc8dc2383e719180758e38c7a3e1e0ea3dfbd047026d6993060cf03eebb117a814fd115c98f6806dfc1a1a7cf322f1f53125723ab68cd06305de0b0e06b2f538a57c2cbb18ce5945ee5cf15fb357bf97317d634e94f18f01267e147</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 量化交易 </category>
          
          <category> 量化交易 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泡芙成长日记</title>
      <link href="/posts/paofu/"/>
      <url>/posts/paofu/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c78bd27c6bd0046deeaabc5c71061689e5d203c29ed3504ca7fdaf20daa5382b">b3dc07a81f6459d120ce338ccca55046d81ca386354419b6b77d6b55182b8ed301b3c2040d78f9d2f509a2f04ee45763854c7c389b18ca9301f9504a65415536caed1f6078a5933a1e86da75ab9d764257ebf175c8703c4a30d15bbbf7d92b3e403a1caef391b1614091ab770b4e4595b54cd1b310f8dbe1536409c8de8f79bc4348c1bc29c770dfa2315e36ce54739a172780106782350060c52eb57d286eb75fa04878f3cda90fb70f7cea791758878e87bd9cea4101225d90f42573e9709ba039eafbf4ac3e239721445477b2bafdcfe803cc6391fae439e7f1a958ddfc372c8c5d3d8d141fd4a6afb2f9e54b7b3b41df860024fd18e08c38f6e52b445e4d939b03c40370f1e6b774e3b96f4516cdaecfb256a2cf30b57347eb8cb5e55a971b8c485bb317b25d86f0bb77d12436a0c4580debbf73cb1ef658a04fa8e00e45bb46dfb81abd531bbbcb397b64220491dfceafb37390ae4c9f9163510289192df6b4a6344439d771050ceebbdcc97c64a6d10bd96f462781511c3392a795ce2ea09d63547e217b36f148524427d0e0479768f0474dd3236f3a4511c3af35a1ee4b63bb6a81ef4c7f23117aa444ed51ce8893dbb891ed914fbc62b39350da2622ac8cb9d5848e745e8ab58c01e69db620d0f75f64a2fe19aa7c1f1215ef04e78a6f32e4cc5d829e6e3e3a9ea1f833531299902c6be1ac12b99b1afde30b3718a25a9e5db3d02f6fbf37bd04f66720b67d5e989718f121b016ecc5dab29b54b1b92946fc4540d0ba419f5c57b90c085211c31391e5c10b025cd4fd6e3e9b3207259b277f1edc6437cc367f06b2a49aef1458648d2afd281e27ba5a3d143e5925818800faf5e622bc250d3d3a60f518d6583a63b4c7e16d65b4ef39a65e4a057a2c3b6e370a408964621073ba6f300667b6f1575d60f5d322cf642ef70e5cc1f1d7981482633e3b29eb99d2c2eaf62abce6c1c61cd3735ce383cac93be0ec97311acfded14c1ddbec0f5ef581f35ff2ac3d361086e3d5f93e8a370a7ed8953a4173</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AlphaBet Engine</title>
      <link href="/posts/alphabet/"/>
      <url>/posts/alphabet/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="75e4a5b276026043a1c5219bf1b8ceeabd47858b13d2b048386240334003d627">b3dc07a81f6459d120ce338ccca5504603780459e0306826441972681af56d621023a3b1e87082893d7f9f5a9cfdcbb2d60925685910ad1c3f4c7c6703be17e884d98345b93e039e1a24d1a8ebed568715753ccb25d7df8c5c7bae546cb9dd2d7867d1d67996d19fd8b59c04551be490a583a1a45c65d3695787a511f866d3303b0cb5e321ad68da8c1ef4da903d3e648ede58035c1885789bf30ba933ca7e4f14435d2f066a07bf5e0a85980ce41972a9957a1b08d33989c6bbb481850b08c8011435cf746a31c7aa1c540ceb73d5f324e874511482d50b76c6fdeb25c7cc40b23444dfa998fe7d941d124645dcef994f823caa949e964f6c6ca7dd790db5d6273289337aa3cf4e96020fabb36c413aa93d7f8dbada47cc068065082033da5bc32a18b7f9043518cce839f66e6f1da77013912881d1c9da15b53c7edb06fb745bf474543fd299749c4db849f1f39d49a0d52044cf4f305220b72b0f7a0c8df6d39fc0b2f883f756e1ef9b8baa252f48fbd2a56901ced22b0cdec9099b37f293bd34f4ccff931396d57b0fc61a4535fe3c8bbc0ef66fcafb23d87de0be56947237d9bb89ddb050fa33288866c5e8c1a1d51d5d6c74f152e0fa6a7cacb824dc10370b850c541884aa4eb486b6430a92fd0d761cb9d9ca005754aced8c48ca64a0cfc4d690b3dbdf8e94d305ddfe0ce93b3a7b4ed5c5cd41fb2455a611c0f265aec0729761616b8c9bfc6eb1898eec51f3ef378e79a6b3e9add02a4052a05881b50cca21d04bce7158a0547ae526e5f5036bb6219215baf73a9c0613194c202f6e1bc28b62bbc857203209779ad53d641fb8089b40a3d4014f7b99d85866e3b1fb934c28f4f44ee7a07bf62b193b6f68a946d13e61a24a591499ebd4d983bd891b5111cd749957a85822ab7cecea20964c86fb79d298956a8f8956ee85f1385caeec00ec1502e68f9f0696adc88c7466688161c7e01e427acabd1fb584dc52e8becb8736ce328dfaf20732c8bfb0cfead620f7a445684e8ee43159b10a2ed172222c548cb70fc24ad7f48a95bf61603a41677e58f60452d16edc4703afeced57360e37545447936078f32a673c562e62f837bdd5f391c5038b30f13ef14fc5c13be8b9eb2b084ee3526e9859c5da33eddbb639ba349178ec46e48737c41644b6150e4d0337a3fadea4cf15c6e335a2eaf6fef3ec7036f474c0b6bc87f181846bdfa2b8add16e1ff55e0876f2f80df750516dc21175093a79e75f401c04f7a6b5dcbfa622d6713854b33e89ab18e7192cf473be58bbe91dce95b0fbd9190945a648af318acd6365bef13fc74cf6e1c316ca4a18ef3bb44c0bedb330f9b238cd822ea8a128002d405c85f9682efba2b9dbf8e7dcb9cfb2ef2087159f42f59ae0977813e1414d74e04f85a24937d24e8a9f5239b450183ef81e496cd6b099ebfe8fe101ad51f0b66d998a1580ffbcb3aa029e504456aee6c15fd66efcd8b2357479e16a0d049c731a761e6c99da2d7ad6b7d6afcafe8fce034182ac6d53ee37658e6799d05d58a0fae43c83fbcaa4c5be77a7a8e17c6e8724d1b3580556a46987132aeb834015a1615e6130b0748c34af6e6c192b77fe6edeb5f2c9a85235b48e22f0c4835458c30173697b2cbcaf71cf5297ac5c5e474b81e5b8221a4c323b180cfa5822d554af7330272880352ed6686e40f2327a14bdde8d0087bb74e285c5f1d7081a75771a58d2c980671f82b98cdbcdf3309ae3550ba3a30684252fbc2c3095ede8ed2be54a1203652b517041ffd79d186bb52d348a614564085d5400df9c856f736b6bd2c0b594912fd604833dd3d7d74b512a71f391198a00fef547bec560bebe46c0c62c76d38f7e79b8c702fd6fc4d6fa9c27de8f1adbf21f7e4173a10f2e8d087ac680c7edac98d474d89b4f5d21a8cb50d5363b601ebe2155ac376451</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 量化交易 </category>
          
          <category> 量化交易 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志：2023年9月</title>
      <link href="/posts/2023/9/"/>
      <url>/posts/2023/9/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="cbf1ecc07e1f6a61d57168f47d8b137e542242d8be7f083ef46933f12f70f3f2">b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475de0b1305a637ea913974dff7410a14ed4dbbb40a5278eb14bbac34e59e12a284c7a294ab69a495d47e11e78ad50feb1070a468302317925759b63d81d1a890d91bb247f88a2922744d34b0dccccece2ea7b156e500c0039cfd827310258914cf02387296f49579859a12f70fb57cd977715c82a3748c321a9a025e128a2cce7f1de3dc03b281972aa543ebeddc996b02a417d9199a94914424bfe81c44ba3eabf2c80e4e270af2ca8407ae2a85ff69b0c1fc536f95c6144a12dfa7ffb8ccdccd84134a688fc70c762745ffb27c1d7f5c04309f944cf5a21383babeb4809120af766173cd3913c8397f6e4c96eb7384f89954fa660cd52a67795cc60cbbdc39c1b58ae0a544dfa11a95645a948f05dae5f8e4a73672048fdc14fc952a5849dd401a3784b6c89bd951f0ab835ac1a4a9f70d444ae242f4dea85b2f9d8d9a7e9305be6ab28cad14ba0c2b7a571fa964999e0ffaa760a2fa7600eff40d891f5e0c65b1fc925a7af5120ff3379ed5731a4194270d519619feed43fd2b6a44c393002a33c3d67c746dee94be0af2ebd54e04a4b20731890f02c5682483b33ee0f28b7da3574f7d08c5f02bdfcf451a36a3333061975b30b4fe8d031b74c782518cab023906e9989aa95522ae03c37da39cda6fde3a576407660e733a7059c3a0f80e97991159b711d583d54f3289b252d70ab0038a7b288566f8903e8861af824a96f2fd0e681502bb84c68c7b026dbc1cdd48f77049005108be76f62fb72f817997c97f0a8f300c100eded8b35f427afd0b17a654dbfa3b8664dd933d00c755cdf46020a148ce26e82760da79b1455507d496518b8d707ff0bd13b0f0cae9e6b9150e6bd32060a04054c6c41140d97ff93653793ffe18ffdf7701d29c0df7b70ac5bd75df406b5d979447871f37bf928d3a76d46f5a28d7d625b444c0ce0e2f3cd6051830a7e1248d45e254e2e93a3f8570ffa7ecdb11e0084db744bbff2c61f2a851c84517e281db403919018b838efe44a580270d83c4ac3adf7aca236dfdb85b7fd93aafc866dc3671e7f15d4182c17043fd91ab23a517451a5e71a719c1324e7e3dfc13edca5bcbdd2c9b5d44300593869ea5e70b4eb2ff3631497ea992cf96107bb632236d00fbdb9c878d90beaaebbc8f45e1759d1ba4c940d200eb660b09a2d7a68b42600a23764e4725996059cd22d90473009bb50ef579822bb481b46b4cea1cf58ae2935fcb9ecbb2a88171e006ff6590583cdd66434631bd5139a8ed79443bb5c9801f184c9c03197e895989864722c465a8c92d88993a6ba26faac43ceac0f9d2522580fc5a24994c852b0e1d47360ca5dc0d1acdbff9c25629eade6fa687009be6397ce3048cf795071d7508e2648a2eb9a3ddb9d5be23570d89bed72fda368d04f427c23915628a2f5059728f3ff6e6c3a87c545465a0faefe26a2386232928017e481e7430a618cbd7c9103d7af6370f88110a6b8b9d62268d1cbff439e51921719ea9251416d227e8ba25874da2394926b328b29b3faca6fca6302468c78a87ef6bc4c01cb9f62a094255ea8246c27b6ce8a36f16e163ca3dc533f8a5f48fb144bffc910c17fc5a85963b6e1b858ac3a3132a05be5a976d78a9e6fb95f5f84845679039f951011c1f52454b4b1cbcc3f8c68549ac3b256431b44b945be0e8717e3a978636dbb454c22a3ba7ee90acc36290bf6dbcc507973d85ee7cce3db7ee3c55b722f813b509f5583b81643b46d9dae38a1eb98a81fe3165d046dc0038d9a2b098352bb655fbb1a7c6ee868de2e0d357748abd976dc89d3d9516473dea8143f4db516ef8c6266fb05d16357670eecf6f2214745bd9aed35dd3bd1612b1840885f22aac29f36731cba2b7c2756c3fdee8b3eda90fbf4b4d487b41128e61d60cf12927750a4b28cf4722a8c936fb7cf1f39a16ba7f0beffe31079dd0f0da462ec44d62270ce4b56fa66293ca95c218faff7b72ef70ef4a42d4ce50a65df10ed61eb32189e6d63bd178a84bef850852aeb50458b826c3fd2857b49428b1b630c83a660b88ed767bc7bd30cca9051f4f1d10ba700e3c969403170fb1372c610cb89a7e247e23f6e17a4a19fb93a0ac559f54e5860c613f6cbf5f52a99ab5493d8fb016cbd948c890e0ce001c3d8649f8a9f6a7f1e9965566fb2da0e5d5147152467dc3441b953aa054ce38a234ba257ddcbeb17f1403224f03a5e68b5ac4036f51b43530a457d19fbb98265858b4822281d07af0a2f205395da54b88dd11529fff47cfad68d842268b66497d90178bf85c43cd1b90048a8c35c8fc177d01f8eb428ae05768673d2dace3e426e2d193aa40c273702653ba8523fa752413ffb2ed2635efbd05be85aa69665531381c78f9a1242f6d49bf8829459b60da404bdcf775465d01daaf39b7b02288a68cae6531459d4cb43673baab5bb4eaa4431fcbd599542f45ef3cba579d3ac2a0beee72ee6143bf869a92a9ed20546b02da8f8824741a7f1e9c6365e19521183e0c3cd6d174e3ce008e0c732d88055f11eaa1efaf15d4c5ff8f0f8b0e441a3496936a181830cc1624f2c4b6a3a7fcaa4f2365297e7c14a9b5f111a8f317120a249afe2dcba85e096c54e561a8031184a8bfda19ee31a5783193dc26ef82f4c8f874638f3136272303f5b52e698f3c116c3e551d4cd811bfb16b2fec613152056dd53548cad1eed03474e6eae3b9f1edf61e2563d8a088bd8819beff6246d5ad831cf1a7a0e5d0cc297a09c71168c074f83a0f11369ee0907b819b86cc3eb91024f97e39b3e2ec1a0bf22cf1cd40bc9dbc86c06ca2a383b92be92c9d74589d4c966e0b6aff543d472add9881655e6559591ffe23738fded6d6bc322a1c127bbf88316ab83357c026e16036d9256869038d1d8bf344203421b3022affd4ded033c4d93d7c57f90ec36c5a7b8cf820bdc8f7f22047068bbcd6c71568ac32bcd20b7c41ce3cc026f8c6c756ed6e45ad43ba20ad54f370019d5ec550d3d4f07ceabc8e020fc37a95efdd85c5a3ed55d822f7441abe3c3fc70d2232fde2dfd7bc0ec50c274b62bc6d97a8931c289af2546e1e9f1fa217b0558fcd5a51133eadda1af7044ef317c241ecee30918013d92f8ee6d26da319a50adb30032d14c7a675c7126b857031bb01ab3896bf291c9f0313d8f0626b7b6e87234ca7c3f02e80b6983a156322dcb24997ff4b057b782058a6bb085b240aabd8186ee9c7e194bbd39639fe548f77a66f02b9f02d74db5246c85798d729bca96eb78e2205520c0fb216f26961e238d47db3bcbb2fd251296bbdaca80b2d83076954021e49a50d59698ebe9cb871a58212dc4b16fe25a926c5aa9b709f74b7f4fb8050eecd589c61ae60bc5abeb4f12ae3159f79596d30f8f3015b3fa8a5c50dc01527284da248747592689bbbad3d8de41bbc2de72772a3152009847e702a1fe23c8375822c9cc9375506fbcc5194c028d57a04f468c3bdc16c19af651e4c825fad715874e0408efe9f89b1ec866d87324c287685820291228168c903c9bc151e6163a4a466f6d16712080916781157dd02d1fe9d0e59c9f0741ad046afec2b2f4dc3c3c526ce3248326501e06aff3574c5d3a5bac9479b3e3584b738c748f53e29dfd7d999134ae922a425eecd06c2c0fb709f1aef9d9df125ddc07c9d02676dc6a705ffe7fa9672f57380fe88c9595ee6e341ffbc7b38b1cfe37c87a2bf1d35c7a770c1608bd1e4448542270913c880a56d372816a30bf8556edf8391bcecb8c89602e996e9958ec84c168e447117a650fba0ab3a297b566d3d5b58751be39798437f2fbb3eedbc03d8bb886f2a03b3e879e5db11708a8930ded16ad669b3dc19e811fecc967da05ee0b2a0b628da60abb45611736c790241679ee46a6bbfd7234aa86cf49f41f984971fe8c23e4e5296748c245ff7dc6711a3813139f69677a74385089d7f5a8ba439be63a72ed81caaed1891586b5ab4dcfea75a252bda347489b172babde966483bc78f8fda30b15edcc176311091f72dc7c6e73172658813784dfbc837e3a283c3cca3ea0d5f41718ade096db607377118b75381d2d9759f210790b8d1f6e5214aaa61d8bb0a4d0a3256aef437eada410c0d34563bcfd4678af647c9d4380af2e82b9e2b3924ff01715d6167e238ac868b5151c2cf48eb3e3c6b11b8369dc99be04c2653eedfc5711f21b48ba8996167b922b512b5d56f484d311251eccc94b7735c75c6735513c6e8cbc0f343a7cfe485dce5af6a7206980141a69dd81aefbbd0c9858428990567e3e2397fc22db911897c79e30de9ec0ed698357598ffd73c5674549d588a091a4377d73ef21201b319ad28ea3798ec1bf2cb3ca074d76ffff0aee2ad816041e6bb381acc79114215db200a8e7c724ecaffb92c20363763841662dd2a7161a9cac3a818d7375a0b4d83217f2056b0e3a1a52e98ced53619aaf537ce552ee0f4c433736752cc26c50ff86a7c402b3ce926cf6a27d2f003168c6e8b46003c967b854817d635c494cfaa2c53be2dbbaf32142dd503b1a45ec027d5314cf92988e3a8fbcd975a0e0c7ee04654</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【AI】chatgpt入门</title>
      <link href="/posts/3GDXTCB/"/>
      <url>/posts/3GDXTCB/</url>
      
        <content type="html"><![CDATA[<p>OpenAI注册闭坑、GPT Api调用指南<span id="more"></span></p><h3 id="注册-OpenAI">注册 <a href="https://openai.com/">OpenAI</a></h3><p>跟这个教程操作即可：<a href="https://www.awyerwu.com/9829.html">ChatGPT最新注册教程</a></p><p>核心问题是两个：</p><ol><li>借助 VPN 绕过 OpenAI 的IP检测封控，直接挂美国</li><li>借助 <a href="https://sms-activate.org/">sms-activate</a> 接收外国手机的验证码</li></ol><h3 id="调用-GPT-Api">调用 <a href="https://platform.openai.com/docs/api-reference">GPT Api</a></h3><p>开发环境使用 <code>python3</code>，通过 <code>pip3 install openai</code> 安装依赖包。<br>注意生产环境也要挂VPN，下面是一段测试代码：</p><pre><code class="language-python"># -*- coding: utf-8 -*-import openaiopenai.api_key = "***********************"completion = openai.ChatCompletion.create(  model="gpt-3.5-turbo-0613",  messages=[    {      "role": "user",       "content": "解释厄尔尼诺现象",    }  ],  temperature = 0.7)print (completion.choices[0].message.content)</code></pre><h3 id="开源推荐">开源推荐</h3><ul><li><a href="https://github.com/zhayujie/chatgpt-on-wechat">chatgpt-on-wechat</a></li></ul><p>微信聊天机器人，支持GPT3.5/GPT4.0/文心一言/讯飞星火模型，支持个人微信、公众号、企业微信，支持文本、语音和图片的处理。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【量化】数据专题</title>
      <link href="/posts/quant-data/"/>
      <url>/posts/quant-data/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li>交易需要与 <strong>哪些数据</strong> 打交道？</li><li>如何获取 <strong>可靠、实惠</strong> 的数据？</li><li>如何高效地 <strong>存储、读写、计算</strong> 数据？</li></ul></div><div class="markmap-container" style="height:300px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;数据管线&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;Tick&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Bar&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;K-line&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#数据类型\&quot;>数据类型</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;基本数据&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;市场(行情)数据&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;第三方数据&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;<a href=\&quot;#数据提供商\&quot;>数据提供商</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;<a href=\&quot;#数据格式\&quot;>数据格式</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;金融常识&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;<a href=\&quot;#复权\&quot;>复权</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;<a href=\&quot;#财报数据\&quot;>财报数据</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;#Pandas\&quot;>Pandas</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;<a href=\&quot;#性能相关\&quot;>性能相关</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;<a href=\&quot;#内存相关\&quot;>内存相关</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#时间相关\&quot;>时间相关</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="数据管线">数据管线</h2><p>交易数据可以分为三类（从左到右）：</p><p><img src="/images/quant-data-chart.png" alt=""></p><p>换一个角度理解：Bar是Tick数据的重要性采样（有点像光栅化），K-Line是Bar数据的可视化展现（有点像Pixel-Shading）。<br>在这个处理流程中，信息的原貌是不断被丢失的，因此<strong>越原始的数据，价值含量越高</strong>，就像《舌尖上的中国》所说：高端的食材，往往只需最简单的烹饪。</p><p>同时也不能忽略 图形化展示的意义，因为：</p><ul><li><strong>主观交易</strong> 依赖 K线图、技术指标 等作出趋势性、预测性地判断</li><li><strong>量化交易</strong> 往往需要借助 Tick数据 去解读更多的市场微观信息。</li></ul><p><strong>如何理解Tick数据?</strong></p><ul><li>交易所收发交易数据的<strong>最小间隔</strong></li><li>可能是每一笔撮合成交（A股），也可能是每500毫秒的交易快照（商品期货）</li></ul><h2 id="数据类型">数据类型</h2><p>狭义理解的金融数据，大概只有 成交量 和 价格 等关键值，但真正的金融市场是错综复杂、影响纷繁的，需要从如下几个领域考量：</p><ul><li><p><font color="#ef6d3b"><strong>Fundamental Data</strong></font><br><strong>基本面数据</strong>，主要是企业的营收、财报等宏观信息，传统投资领域中的分析师，往往是对着海量的财报作出投资决策的。</p></li><li><p><font color="#ef6d3b"><strong>Market Data</strong></font><br><strong>市场数据</strong>，主要是市值、市盈率、股价、成家量等金融数据，特点是 频率高、时效性强、噪声大，提取有价值信息的难度也非常大。</p></li><li><p><font color="#ef6d3b"><strong>Analytics Data</strong></font><br>（第三方）<strong>分析数据</strong>是很宽泛的概念，可能是机构的研报、社交舆情的数据，甚至是相关政策的颁布、天气信息的变幻等等。特点是获取难度大、归纳提取有效信息难度更大。</p></li></ul><hr><p>考虑到数据获取的难度因素，我们一般基于 <code>Market Data</code> 的数据进行提炼和研究，这部分信息获取公开、透明、平等，且能得到的数据量也是最大的。<br>下面介绍一些常见的市场数据的提供商（获取渠道）。</p><h2 id="数据提供商">数据提供商</h2><p>这里推荐几个具有一定性价比的渠道，相较于个人投资者（爱好者）而言：</p><table><thead><tr><th style="text-align:center">渠道</th><th style="text-align:center">价格</th><th style="text-align:center">准确度</th><th style="text-align:center">覆盖度</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://baostock.com/">baostock</a></td><td style="text-align:center">免费</td><td style="text-align:center">中</td><td style="text-align:center">A股</td></tr><tr><td style="text-align:center"><a href="http://www.jinshuyuan.net/">金数源</a></td><td style="text-align:center">中</td><td style="text-align:center">高</td><td style="text-align:center">期货、A股</td></tr><tr><td style="text-align:center"><a href="https://shinnytech.com/">天勤量化</a></td><td style="text-align:center">部分免费</td><td style="text-align:center">高</td><td style="text-align:center">期货、A股(18年起)</td></tr><tr><td style="text-align:center"><a href="http://www.juejinshuju.com/">掘金数据</a></td><td style="text-align:center">高</td><td style="text-align:center">高</td><td style="text-align:center">期货、A股、数字货币</td></tr></tbody></table><p>如果你的策略有所起色，甚至扭亏为盈了，后面可以考虑向专业的数据提供商（如<a href="https://www.wind.com.cn/mobile/WDS/zh.html">Wind</a>、同花顺）购买昂贵但准确的市场数据，有句话说得好：贵的东西总有贵的道理！</p><p><strong>再按照股票、期货细分来看：</strong></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">频率</th><th style="text-align:center">数据体量</th><th style="text-align:center">推荐数据源</th></tr></thead><tbody><tr><td style="text-align:center">A股 ①</td><td style="text-align:center">5档逐笔</td><td style="text-align:center">1T /年</td><td style="text-align:center">tqsdk白嫖</td></tr><tr><td style="text-align:center">1990年~2023年</td><td style="text-align:center">1 min</td><td style="text-align:center">25G /年</td><td style="text-align:center">tqsdk白嫖</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">5 min</td><td style="text-align:center">5G /年</td><td style="text-align:center">baostock免费</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">日k</td><td style="text-align:center">累计 2G</td><td style="text-align:center">baostock免费</td></tr><tr><td style="text-align:center">期货 ②</td><td style="text-align:center">tick</td><td style="text-align:center">单品种 1G /年</td><td style="text-align:center">taobao购买 / tqsdk</td></tr><tr><td style="text-align:center">2016年~2023年</td><td style="text-align:center">1 min</td><td style="text-align:center">累计 1.5G</td><td style="text-align:center">tqsdk</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">5 min</td><td style="text-align:center">累计 0.3G</td><td style="text-align:center">tqsdk</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">日k</td><td style="text-align:center">-</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数字货币</td><td style="text-align:center">tick</td><td style="text-align:center"></td><td style="text-align:center">掘金数据</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1 min</td><td style="text-align:center"></td><td style="text-align:center">掘金数据</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">5 min</td><td style="text-align:center"></td><td style="text-align:center">掘金数据</td></tr></tbody></table><ul><li>① <strong>国内主要上市股票约 5000 只</strong>，平均上市时间 11.9 个年份（截至发文日期 2023年10月）<ul><li><a href="http://www.sse.com.cn/market/stockdata/statistic/">上交所 2288只</a> 主板(1727)，科创板(561)</li><li><a href="https://www.szse.cn/market/">深交所 2827只</a> 主板(1506)，创业板(1321)</li><li>首支上市日期为 1990年 平安银行</li></ul></li><li>② <strong>国内商品期货、金融期货等，约 80 个种类</strong></li></ul><h2 id="数据格式">数据格式</h2><p>推荐阅读：<a href="/posts/data-perf/">csv, hdf5, feather 三种数据性能对比</a></p><h2 id="复权">复权</h2><p>在理解为什么要复权之前，先理解几个金融市场的基本概念：</p><ul><li><p><strong>分红：每10股派发6元</strong><br>本质是将股票市值中的6元兑换成现金，发放到你的账户，等同于套现</p></li><li><p><strong>拆股：每1股拆分为5股</strong><br>本质是因为股价过高作拆分，单只股票价格也会变成五分之一</p></li></ul><p>金融数据中的市场价格（包括开盘价、收盘价），往往都是不考虑分红、拆股的背景条件，因此经常见到股价突然腰斩 <code>90%</code> 的情况，其实并不是股价跌这么多，而是因为该上司公司拆股了。</p><p>因此，复权价格就是为了<strong>抹除非市场因素带来的涨跌，让价格保持平滑、连续性</strong></p><div class="admonition note"><p class="admonition-title">前复权和后复权</p><ul><li>前复权：以 <strong>第一天</strong> 的价格为基准，推算后面的价格</li><li>后复权：以 <strong>最后一天</strong> 的价格为基准，推算之前的价格</li><li><a href="https://www.zhihu.com/question/31004373">知乎: 通俗易懂的解释前复权，不复权和后复权有什么区别？</a></li></ul></div><h2 id="财报数据">财报数据</h2><p><strong>核心是区分毛利润和净利润</strong></p><ul><li>毛利润(gross profit) = 收入 - 生产成本</li><li>净利润(net income)= 毛利润 - 销售/管理/研发/财务成本 - 税收</li></ul><p>以白酒行业为例，假设一瓶售价为880的白酒，其原材料成本是80元，则其毛利率为 <code>800/880=91%</code>。观察国内相关上司企业，就能够发现 <code>90%+</code> 的毛利率是普遍现象。<br>但由于销售成本（如广告）和人工成本的存在，其真实的净利率往往在 <code>50%</code> 以下。</p><p><strong>指标的含义?</strong></p><ul><li>毛利润衡量的是<strong>产品价值</strong>，毛利率高，说明这是一门好生意（白酒、互联网）</li><li>净利润衡量的是<strong>企业价值</strong>，净利率高，说明其赚钱能力强（九安医疗 …）</li></ul><div class="admonition warning"><p class="admonition-title">留几个没想明白的问题</p><ol><li>对于没有实体的 <strong>互联网行业</strong>，如何衡量其生产成本?</li><li>毛利润是否扣除 <strong>员工工资</strong>?</li><li><strong>为什么要统计毛利率?</strong> 光有净利率不足够吗?</li></ol></div><h2 id="Pandas">Pandas</h2><p><a href="https://pandas.pydata.org/">Pandas</a> 是 应用最广泛的 Python数据处理库，在量化交易、数据清洗中非常重要。</p><h4 id="性能相关">性能相关</h4><ul><li><a href="https://numba.readthedocs.io/en/stable/user/5minguide.html"><font color="#1A9BFF"><em><strong>numba</strong></em></font></a></li><li>读取较多个csv文件耗时较长, 如何用 <font color="#1A9BFF"><em><strong>multiprocess + pandas</strong></em></font> 读取?</li></ul><pre><code class="language-python">from multiprocessing import Pooldef read_csv(file_name):    return pandas.read_csv(file_name)file_list = [...]with Pool(processes=6) as pool:    df_list = pool.map(read_csv, file_list)    df_all = pd.concat(df_list, ignore_index=True)    """ 推荐在read_csv里将数据写到一个全局的dict """</code></pre><h4 id="内存相关">内存相关</h4><p>为了节省runtime内存, DataFrame默认读取的是<code>float64</code> &amp; <code>int64</code>格式, 占用内存大且浪费</p><ul><li><code>np.dtype('int32')</code>: 表示int32类型</li><li><code>np.iinfo('int64').max</code>: 获取int64的最大值</li><li><code>np.finfo('float64').max</code>: float64</li><li><code>int64: 64 bits = 8 byte</code></li></ul><p>建议如下:</p><ul><li>不考虑负数, 用uint代替int</li><li>能用<code>int16</code>, 就不要用<code>int32</code></li><li><font color="#FF1E10"><strong>为什么<code>float64</code>比<code>int64</code>表示范围大? 占内存是一样的</strong></font></li></ul><h4 id="时间相关">时间相关</h4><p>这里要写很多篇幅, 先介绍Pandas自带的转化:<br><font color="#FF1E10"><strong><code>TODO</code></strong></font><br><code>pandas.to_datetime(df)</code>: 返回类型是pandas的timestamp, 可以访问.date(), .day</p><h4 id="注意项">注意项</h4><ul><li><p>读取中文报错: <code>pd.read_csv(file_name, encoding = "gbk")</code></p></li><li><p>UserWarning: Pandas doesn’t allow columns to be created via a new attribute name</p><ul><li>正确写法: <code>df['name'] = xxx</code></li><li><s>错误写法: <code>df.name = xxx</code></s></li></ul></li><li><p>Pandas Warning:</p></li></ul><pre><code class="language-python">SettingWithCopyWarning: A value is trying to be set on a copy of a slice from a DataFrame</code></pre><p>一般是链式赋值时会报，根本原因是尝试对 copy 出来的 DataFrame 尝试去赋值。<br>下面是一个典型的例子:</p><pre><code class="language-python">df.A.loc[df.B &gt; 100] = 0      # ×df.loc[df.B &gt; 100, 'A'] = 0   # √</code></pre><h4 id="复杂操作">复杂操作</h4><ul><li><p><strong>groupby</strong></p><ul><li><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html?highlight=groupby#pandas.DataFrame.groupby">Pandas Groupby</a></li><li><a href="https://zhuanlan.zhihu.com/p/101284491">知乎</a></li><li><code>DataFrame.groupby(by=None)</code>: 按照by这一column筛选</li><li><code>Group.get_group()</code>: 获取指定的group, 返回DataFrame</li></ul></li><li><p><strong>merge</strong></p><ul><li>DataFrame, Series之间任意合并</li><li>注意<code>left</code>, <code>right</code>, <code>outer</code>等几种方式, 底层就是<code>SQL</code>的逻辑</li><li>merge完赋值如果不对齐，可以去重: <code>mf = mf[~mf.index.duplicated()]</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 量化交易 </category>
          
          <category> 量化交易 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【名人访谈】BBC采访马斯克</title>
      <link href="/posts/2YS1Y71/"/>
      <url>/posts/2YS1Y71/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://www.youtube.com/watch?v=donC2VuVTtM"><strong>Youtube采访视频 2023年4月21日</strong></a></li><li><a href="https://www.bilibili.com/video/BV18F411y7ac"><strong>B站解说视频</strong></a></li><li>马斯克的核心技能：屌爆的思维逻辑 + 烂熟的辩论技巧</li><li>这一派还有个大佬是罗永浩，可以看他锤王自如的视频</li><li><font color="#FF1E10"><strong>TODO:</strong></font> 文章排版不满意，等录个视频锻炼口头表达</li></ul></div><h2 id="采访背景">采访背景</h2><h3 id="马斯克方面">马斯克方面</h3><blockquote><p>阅读材料：<a href="https://zh.wikipedia.org/zh-hans/%E5%9F%83%E9%9A%86%C2%B7%E9%A9%AC%E6%96%AF%E5%85%8B%E6%94%B6%E8%B4%AD%E6%8E%A8%E7%89%B9%E6%A1%88">维基百科 埃隆·马斯克收购推特案</a></p></blockquote><p>马斯克与 <strong>2022年10月</strong> 以 <strong>440亿美金</strong> 价格，收购美国社交巨头 <em><strong>Twitter</strong></em>，其过程经历三个阶段：</p><ul><li>【提出】马斯克提出收购，遭到Twitter和市场反对</li><li>【后悔】马斯克发现Twitter用户数据造假，尝试放弃收购计划</li><li>【被迫】马斯克迫于法律诉讼，被迫收购Twitter</li></ul><p>收购 <em>Twitter</em> 后，马斯克主要实行四大措施：</p><ul><li>大量裁员（8000人-&gt;1500人）</li><li>开源 <em>Twitter</em> 内容推荐算法</li><li>删除垃圾机器人</li><li>退出收费认证服务</li></ul><h3 id="BBC方面">BBC方面</h3><p>其次，BBC的采访素来以 <strong>尝试刁难采访者，角度狠辣，制造爆点话题</strong> 为主，围绕收购案本身，（从BBC角度）有如下几点值得 <strong>埋坑</strong>：</p><ol><li>【道德角度】接手公司后大量裁员</li><li>【媒体角度】Twitter充斥越来越多的虚假信息</li><li>【决策角度】收费认证被所有人吐槽</li></ol><p>所以，这次采访不是一个歌颂丰功伟绩的 “单口相声”，而更像是互相博弈的 “双人对线”，可以说火药味十足。</p><h2 id="采访正题">采访正题</h2><ul><li><font color="#ef6d3b"><strong>❓BBC: 聊聊Twitter收购案</strong></font></li></ul><p>这里马斯克谈了两点，【1】为什么停止收购，【2】强调最终收购是迫不得已。</p><blockquote><p>在谈【1】时，马斯克举了一个非常形象的例子：</p><ul><li>你想购买一袋大米，本来约定允许10%的米是坏的，最后发现30%的米都是坏的。这显然无法接受。</li></ul></blockquote><ul><li><font color="#ef6d3b"><strong>❓BBC【进攻三连】：1. 你解雇大量员工，2. 你裁员的行为很随意，3. 你毫无同情心</strong></font></li></ul><p>这里有三个观点，分别是【事实】-&gt;【表象】-&gt;【推断】，层层推进，层层致命。</p><blockquote><p><strong>马斯克的回复很经典</strong>，其实核心是马保国的 <strong>接化发</strong> （太极）：</p><ul><li>【接】：部分认同，但留有余旋 （Musk：确实裁员了…）</li><li>【化】：转移到对自己有利的话题 （Musk：公司账面只能4个月，不裁员所有人都死…）</li><li>【发】：用刁钻假设，反问对方（Musk：换做你怎么做? <a href="https://zhuanlan.zhihu.com/p/338604183">有轨电车难题</a>…）</li></ul></blockquote><ul><li><font color="#ef6d3b"><strong>❓BBC【换角度进攻】：你是世界首富，为什么不自己掏钱帮自己公司?</strong></font></li></ul><blockquote><p>这里马斯克没有技巧，全靠<strong>真诚+卖惨</strong>：我贱卖了很多特斯拉的股票才能买下Twitter（别再道德绑架俺…）</p></blockquote><ul><li><font color="#ef6d3b"><strong>❓BBC【问句埋坑】：你是否后悔裁员？</strong></font></li></ul><p>这是记者经典的疑问圈套，不论回答是否都是下策。</p><blockquote><p>回答是：马斯克认错了！亲口承认裁员不明智<br>回答否：马斯克心狠手辣！裁员毫无愧疚</p></blockquote><p>因此马斯克直接不回答该问题，而是侧面讲了两个自己的观点：</p><blockquote><p>【1】公司有自己的运转规律<br>【2】卖特斯拉股票很困难，它还导致其市值暴跌（寻求弱势低位）</p><ul><li>但如果光说第一点还不够，因为是 <strong>贱卖股票</strong> 让马斯克把自己放到了一个弱势地位，有效阻止记者继续纠缠。</li></ul></blockquote><ul><li><font color="#ef6d3b"><strong>❓BBC【聊政治，埋坑】：Twitter被你收购后解封了Trump，他何时回归?</strong></font></li></ul><p>政治是敏感话题，在西方也是如此。因此马斯克直截了当地说 <strong>不知道</strong>。<br>到这里还没完，高手厉害之处就是，<strong>抓住任何机会宣传自己的企业</strong>，于是他说：</p><blockquote><p>我在选举投了Biden，但解封了Trump，说明 <strong>Twitter是自由发声的地方</strong></p></blockquote><p>牛逼！但BBC也是高手，顺着自由发声的话题，立刻谈到Twitter的一些负面问题 ↓</p><ul><li><font color="#ef6d3b"><strong>❓BBC【开始抨击】：Twitter强调言论自由，是否助长错误信息（言论）?</strong></font></li></ul><p>再一次经典的疑问圈套，马斯克作为高手，自然不会落入俗套。他直接反问记者：<strong>谁定义错误信息？</strong>，<strong>BBC难道没有发布过错误信息？</strong></p><ul><li><font color="#ef6d3b"><strong>❓BBC【开始抨击】：Twitter裁掉整个内容审核部门，是否助长仇恨言论?</strong></font></li></ul><blockquote><p>这里介绍一个背景，大部分的社交媒体，都是通过人工（为主）+AI（为辅）过滤仇恨言论（如政治、宗教、法律），但马斯克背其道而行之（裁掉部门）。</p></blockquote><p>马斯克仍然 <strong>以反问起手</strong>：什么是仇恨言论？你用过Twitter吧（必然用过）。那举一个你见过的仇恨言论的例子。</p><blockquote><p>【若记者举了】可以逐点反驳击破，因为很多仇恨言论是片面的，如LSBT，且没法在公开场合说<br>【若记者不举】根据 “谁主张 谁举证” 的规则，其不攻自破</p></blockquote><h2 id="马斯克传达的观念">马斯克传达的观念</h2><p><strong>俗手总是去证明自己，高手往往是在表达自己</strong></p><p>抛开辩论技巧，大佬传达的观念也是值得学习的，马斯克在一个小时的采访中主要传达了这几个观点:</p><ul><li><p>【方法论】想生存? 降本增效</p><ul><li>一方面裁员，一方面裁设备（虽然导致服务崩溃）</li><li>拉回旧的广告商，提高收入</li></ul></li><li><p>【方法论】开源核心算法</p><ul><li>就像餐厅把自己的后厨公开到幕前。</li><li>只有公开透明的算法，才能让民众感到安心（尤其是社交领域）</li></ul></li><li><p>【价值观】社交媒体的意义</p><ul><li>马斯克不在乎赚钱（前提是企业能活下去）</li><li>好的社交媒体，是人们信赖的真相的来源，且人们会自发去评判和追求事物的真相</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【C++11】lvalue &amp; rvalue (references)</title>
      <link href="/posts/rvalue/"/>
      <url>/posts/rvalue/</url>
      
        <content type="html"><![CDATA[<p><code>C++</code> 左值、右值引用<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c"><em><strong>Understanding the meaning of lvalues and rvalues in C++</strong></em></a></li><li><a href="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners"><em><strong>C++ rvalue references and move semantics for beginners</strong></em></a></li><li><a href="https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html"><em><strong>Move semantics and rvalue references in C++11</strong></em></a></li></ul></div><div class="markmap-container" style="height:200px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;左值和右值&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#左值-→-右值\&quot;>左值 → 右值</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;<a href=\&quot;#右值-→-左值\&quot;>右值 → 左值</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;右值引用&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#move语义-🔥\&quot;>move语义</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#std-move\&quot;>std::move</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#std-remove-reference\&quot;>std::remove_reference</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<a href=\&quot;#三种传参\&quot;>三种传参</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;<a href=\&quot;#1-const-T\&quot;>const T</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;<a href=\&quot;#2-const-T\&quot;>const T&amp;amp;</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;<a href=\&quot;#3-T\&quot;>T&amp;amp;&amp;amp;</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="前言">前言</h2><p>从接触、学习、运用 <code>C++</code> 至今，左右值引用一直是自己困惑的点。伴随着现代C++的发展，它们开始扮演越来越重要的作用（如 <code>std::move</code>、<code>std::remove_reference</code>…）。<br>这篇争取彻底搞懂他们。</p><p>先看 <code>gcc</code> 一个编译报错，为什么 <code>666 = x</code> 的语法是错误的？<br><em><font color="#FF1E10"><strong>error:</strong></font> lvalue required as left operand of assignment</em></p><p>编译器是在说：<strong>赋值符号 <code>=</code> 的左操作数，必须是左值 <code>lvalue</code> ! 换句话说，这里的 <code>666</code> 不是一个左值。</strong></p><pre><code class="language-c">int x;666 = x;</code></pre><h2 id="左值和右值">左值和右值</h2><p>如何区分 左值 和 右值？</p><ul><li><strong><code>lvalue</code>：指向明确的内存地址</strong>，又称 <code>variable</code></li><li><strong><code>rvalue</code>：没有明确的内存地址</strong>，又称 <code>literal constant</code></li></ul><p>下面看几个示例：</p><ul><li><code>int x = 666</code>：<code>x</code> 是 <code>lvalue</code>，<code>666</code> 是 <code>rvalue</code></li><li><code>int* y = &amp;x</code>：<code>x</code> 是 <code>lvalue</code>，<code>y</code> 是 <code>lvalue reference</code></li></ul><p>编译规则，赋值<code>=</code> 和取地址<code>&amp;</code> 的左边必须是 <code>lvalue</code>，不然会报如下错误：</p><blockquote><p><em><font color="#FF1E10"><strong>error:</strong></font> lvalue required as left operand of assignment</em><br><em><font color="#FF1E10"><strong>error:</strong></font> lvalue required as unary ‘&amp;’ operand`</em></p></blockquote><div class="admonition warning"><p class="admonition-title">区分 左值 和 左值引用</p><ul><li><code>int x = 1</code>：x是左值</li><li><code>int&amp; y = x</code>：y是左值引用</li></ul></div><h3 id="function-reference">function reference</h3><p>函数的返回值可以是 左值，也可以是 右值。</p><ul><li>右值 ×</li></ul><pre><code class="language-c">int setValue() { return 6; };setValue() = 3; // error: lvalue required as left operand of assignment</code></pre><ul><li>左值 √</li></ul><pre><code class="language-c">int x = 100;int&amp; setValue() { return x; };setValue() = 1;</code></pre><h2 id="左值-→-右值">左值 → 右值</h2><p>左值 经常会被转化为 右值，如下示例：</p><ul><li><code>x, y</code> 都是 左值</li><li><code>x + y</code> 被转化为 右值</li></ul><pre><code class="language-c">int x = 1;int y = 3;int z = x + y;   // ok</code></pre><p>上面经历了一次 <strong>lvalue -&gt; rvalue</strong>  的隐式转换，很多操作符（<code>+, -, /</code>）都会提供。</p><h2 id="右值-→-左值">右值 → 左值</h2><p>右值 到 左值 的转换是被禁止的，如下代码是非法的：</p><pre><code class="language-c">int&amp; x = 10;// error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int'</code></pre><h2 id="右值引用-🔥">右值引用 🔥</h2><p>C++ 的一条重要编译规则是：<strong>你无法绑定一个 右值 的地址，除非绑定到一个 <code>const</code> 类型</strong>，例如：</p><pre><code class="language-c">int&amp; x = 666; // error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int'const int&amp; x = 666; // OKstd::string s1 = "Hello ";std::string s2 = "world";const std::string&amp; s3 = s1 + s2;s3 += " luhao";  // error: no match for 'operator+=' (operand types are 'const std::string'</code></pre><p>但是上面的写法有个弊端，<strong>即无法再修改 <code>s3</code> 的值</strong>。<br>为了能够修改右值（即临时变量），<code>C++11</code> 正式引入右值引用（<code>rvalue reference</code>），其符号是 <code>&amp;&amp;</code>：</p><pre><code class="language-c">std::string s1 = "Hello ";std::string s2 = "world";std::string&amp;&amp; s3 = s1 + s2;s3 += " luhao"; // OK</code></pre><p>上面的示例看出来用处不大，<strong>因为 <code>rvalue reference</code> 真正大展拳脚的地方，是在 移动语义（<code>move semantics</code>）。</strong></p><h2 id="move语义-🔥">move语义 🔥</h2><p>阅读资料</p><ul><li><a href="https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html"><em><strong>Move semantics and rvalue references in C++11</strong></em></a></li></ul><p><strong>移动语义 是一种利用右值引用的技术，来避免拷贝临时变量的优化手段。</strong></p><h3 id="为什么需要-move-semantics-💡">为什么需要 move semantics? 💡</h3><p>假设 <code>class Holder</code> 是一个(内存)非常繁重的类，考虑到如下的构造和拷贝构造函数。<br>当调用 <code>Holder h1(h)</code> 时，因为 <code>std::copy</code> 造成巨大的内存拷贝开销，如果后文中 <code>h</code> 也不再继续使用，为什么不尝试将 <code>h</code> 转交给 <code>h1</code> 呢?</p><pre><code class="language-c">class Holder{public:    Holder(int size) {        m_data = new int[size];        m_size = size;    }    Holder(const Holder&amp; other)    {        m_data = new int[other.m_size];        std::copy(other.m_data, other.m_data + other.m_size, m_data);        m_size = other.m_size;    }    ~Holder() { delete[] m_data; }private:    int*   m_data;    size_t m_size;}int main(){    Holder h(10000);    Holder h1(h); // 调用 std::copy 带来非必要开销    return 1;}</code></pre><p>借助移动语义，可以优化掉上面的拷贝。注意到下面使用了 <a href="#std-move"><em><strong>std::move</strong></em></a>，它能将左值转化为右值，是C++标准库的成员函数，后面有介绍。</p><pre><code class="language-c">Holder(Holder&amp;&amp; other){    // 赋值    m_data = other.m_data;    m_size = other.m_size;    // 清空other的状态    other.m_data = nullptr;    other.m_size = 0;}int main(){    Holder h(10000);    Holder h1(std::move(h));    return 1;}</code></pre><h3 id="std-move">std::move</h3><p>阅读材料：</p><ul><li><a href="https://en.cppreference.com/w/cpp/utility/move"><em>cppreference</em></a></li><li><a href="https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-api-4.5/a00936_source.html"><em>libstdc++: move.h</em></a></li></ul><p>阅读 <code>std::move</code> 的源码，其实只是作了类型转化，将 任意形式的<code>_Tp</code> 转化成右值:</p><ul><li><code>std::remove_reference</code>：去掉引用</li><li><code>static_cast</code>：隐式转换</li></ul><div class="admonition note"><p class="admonition-title">std::move</p><ul><li><code>move</code> 右值：直接返回</li><li><code>move</code> 左值：转成右值，并返回</li></ul></div><pre><code class="language-c">  /**   *  @brief  Convert a value to an rvalue.   *  @param  __t  A thing of arbitrary type.   *  @return The parameter cast to an rvalue-reference to allow moving it.  */  template&lt;typename _Tp&gt;    constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;    move(_Tp&amp;&amp; __t) noexcept    { return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); }</code></pre><h3 id="std-remove-reference">std::remove_reference</h3><p><code>remove_reference</code> 顾名思义，就是去除任意类型的引用，借助模板实现。<br>核心是对于 <code>_Tp&amp;</code> 和 <code>_Tp&amp;&amp;</code> 这两种带引用的传参，需要去掉其引用的部分，只获取其类型（通过 <code>::type</code> 获取）</p><pre><code class="language-c">  template&lt;typename _Tp&gt;    struct remove_reference    { typedef _Tp   type; };  // 特化  template&lt;typename _Tp&gt;    struct remove_reference&lt;_Tp&amp;&gt;    { typedef _Tp   type; };  // 特化  template&lt;typename _Tp&gt;    struct remove_reference&lt;_Tp&amp;&amp;&gt;    { typedef _Tp   type; };</code></pre><h2 id="三种传参">三种传参</h2><h3 id="1-const-T"><code>1. const T</code></h3><p>常量值传递，默认有一次拷贝开销。<br>如果是 <code>builtin-types (int、float ...)</code> 推荐使用这种传递方式</p><h3 id="2-const-T"><code>2. const T&amp;</code></h3><p>常量引用传递，<code>&amp;</code> 避免拷贝带来的开销，<code>const</code> 避免被修改。<br>但会将生命周期延续</p><h3 id="3-T"><code>3. T&amp;&amp;</code></h3><p>右值传递，避免拷贝带来的开销，推荐复杂结构体如 <code>std::vector ...</code><br>缺点是调用者必须传入右值，否则编译期间报错，如果是通用接口比较难受</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++17】refl-cpp</title>
      <link href="/posts/refl-cpp/"/>
      <url>/posts/refl-cpp/</url>
      
        <content type="html"><![CDATA[<p>品读<code>C++</code>经典反射库<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li>源码：<a href="https://github.com/veselink1/refl-cpp"><em><strong>veselink1/refl-cpp</strong></em></a></li><li>blog：<a href="https://veselink1.github.io/blog/cpp/metaprogramming/2019/07/13/refl-cpp-deep-dive.html"><em>refl-cpp — A deep dive into this compile-time reflection library for C++</em></a></li><li>这篇博客大致是英文版的 直译 + 自己理解，旨在提高对 <code>templates</code> + <code>reflections</code> 的掌握</li><li>精读blog ➜ 理解源码 ➜ 上手仿造</li></ul></div><h2 id="目录">目录</h2><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#compile-time%E5%8F%8D%E5%B0%84">compile-time反射</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98">构建类的成员</a></li><li><a href="#%E4%BD%BF%E7%94%A8-macros-%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81">使用 <code>macros</code> 组织代码</a></li><li><a href="#%E5%87%BD%E6%95%B0%E5%8F%8D%E5%B0%84">函数反射</a></li><li><a href="#%E9%81%8D%E5%8E%86%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98">遍历类的成员</a></li></ul><h2 id="前言">前言</h2><p><code>refl-cpp</code> 的设计初衷是：</p><ul><li>支持 在 <strong><code>C++17</code></strong> 及更高版本 <strong>提供编译期反射（Compile-time）</strong> 的方法。</li><li>支持 <code>enumeration</code>，<code>introspection</code><ul><li><code>enumeration</code>：类似 <code>Python dir()</code> 枚举对象所有的属性</li><li><code>introsection</code>：类似 <code>Python getattr</code> 访问对象的指定属性</li></ul></li><li>支持 类型模板、成员模板</li><li>支持 <code>attributes</code> <font color="#FF1E10"><strong>TODO</strong></font></li></ul><p><code>refl-cpp</code> 的设计避免如下：</p><ul><li>避免 使用宏魔法</li><li>避免 <code>Private</code> 私有成员的反射</li><li>避免 运行时 按名称查询类型信息</li></ul><h2 id="compile-time反射">compile-time反射</h2><p>首先 <code>refl-cpp</code> 是一个 <code>compile-time</code> 的反射库，这意味着它不会维护一个 runtime 的数据结构来实现反射目的，例如下面是不可取的：</p><pre><code class="language-c">struct TypeInfo {    std::string name;           // 对象的类型名称    std::vector&lt;?&gt; members;     // 对象的所有成员    std::vector&lt;?&gt; attributes;  // 对象的所有成员取值}// ↓ 维护一个全局的反射数据结构std::unordered_map&lt;std::string, TypeInfo&gt; s_typeRegistry;</code></pre><p>相反，<code>refl-cpp</code> 的做法是，通过 cpp模板特化 以一种类相关的方式（<code>type-dependent</code>）来存储 <code>metadata</code>，例如下面的做法：</p><pre><code class="language-c">template &lt;typename&gt; struct TypeInfo {};// ↓ Point类的编译期信息template &lt;&gt;struct TypeInfo&lt;Point&gt; {  static constexpr char name[] = "Point";  ??? members = {};  ??? attributes = {};};</code></pre><h2 id="构建类的成员">构建类的成员</h2><p>上一节提供了存储 类信息 的方法，但是如何存储 其成员变量（和方法）呢？<br><code>refl-cpp</code> 使用一种新颖的方式来存储：</p><pre><code class="language-c">template &lt;size_t N&gt;struct MemberInfo;/* 第0个成员的模板特化 */template &lt;&gt;struct MemberInfo&lt;0&gt; {  /* ... */};/* 第1个成员的模板特化 */template &lt;&gt;struct MemberInfo&lt;1&gt; {  /* ... */};static constexpr size_t MemberCount = 2;</code></pre><p><code>MemberInfo</code> 是类成员的模板特化，因此将其添加到 <code>TypeInfo</code> 的作用域（如下）。<br><code>typename Dummy</code> 是因为C++不允许成员完全模板特化，而部分成员的模板特化是允许的。<font color="#FF1E10"><strong>TODO</strong></font></p><pre><code class="language-c">template &lt;&gt;struct TypeInfo&lt;Point&gt; {  template &lt;size_t N, typename Dummy&gt;  struct MemberInfo;  /* 第0个成员的模板特化 */  template &lt;typename Dummy&gt;  struct MemberInfo&lt;0&gt; {    /* ... */  };  /* 第1个成员的模板特化 */  template &lt;typename Dummy&gt;  struct MemberInfo&lt;1&gt; {    /* ... */  };  static constexpr size_t MemberCount = 2;};</code></pre><h2 id="使用-macros-组织代码">使用 <code>macros</code> 组织代码</h2><p>上一节提供了粗略的 类 + 类成员 的反射方案，那么如何声明它们呢？<br>答案是借助 <code>macros</code> 实现（作者不是不建议使用宏么😂…）</p><ul><li><code>__COUNTER__</code> 是非标准库的宏，每次调用增加<code>1</code>，且从<code>0</code>开始</li><li>宏展开后的代码，可看示例：<a href="https://gist.github.com/veselink1/f4e2fa94bda0514631753f13a9b93f9b"><em>refl-cpp-deep-dive-5-generated.cpp</em></a></li><li>另外每个 <code>TypeInfo</code> 和 <code>MemberInfo</code> 还应该包含如下内容：<ul><li><code>static constexpr char name[] = …</code></li><li><code>static constexpr std::tuple&lt;…&gt; attributes = {…}</code></li><li><code>static constexpr auto* pointer = &amp;Type::MemberName</code></li></ul></li></ul><pre><code class="language-c">template &lt;typename T&gt;struct TypeInfo {};#define REFLECT_TYPE(TypeName) \  template&lt;&gt; struct TypeInfo&lt;TypeName&gt; { \    template &lt;size_t, typename&gt; struct MemberInfo; \    static constexpr size_t MemberIndexOffset = __COUNTER__ + 1; #define REFLECT_FIELD(FieldName) \  template &lt;typename Dummy&gt; struct MemberInfo&lt;__COUNTER__ - MemberIndexOffset&gt; \  {}; \#define REFLECT_END \    static constexpr size_t MemberCount = __COUNTER__ - MemberIndexOffset; \  };// Usage:REFLECT_TYPE(Point)   REFLECT_FIELD(x)   REFLECT_FIELD(y)REFLECT_END</code></pre><div class="admonition note"><p class="admonition-title">Tips: 借助 VisualStudio 查看宏展开</p><ul><li>鼠标悬停在宏上，点击 <code>Expand Inline</code><img src="/images/vs-macros-expand.png" alt=""></li></ul></div><h2 id="函数反射">函数反射</h2><p><code>refl-cpp</code> 还提供反射函数的功能。</p><p>为了区分成员（是变量还是方法），每个 <code>MemberInfo</code> 有一个公共的 <code>typedef</code>，它等同于 <code>refl::members::field</code> 和 <code>refl::members::function</code> 两者之一。而考虑到 函数的重载和模板，这部分功能（相对于反射成员）会更加复杂。</p><p><code>refl-cpp</code> 通过如下方法：<font color="#FF1E10"><strong>TODO</strong></font></p><pre><code class="language-c">template &lt;typename R, typename... Args&gt;auto resolve(R(*fn)(Args...), Args&amp;&amp;... args) -&gt; decltype(fn);/*   Imagine 12 more overloads of resolve for different pointer-to-member   combinations (plain, &amp;, &amp;&amp;, const, volatile qualifiers)*/template &lt;typename... Args&gt;static constexpr decltype(detail::resolve(&amp;Type::MemberName, std::declval&lt;Args&gt;()...)) pointer { &amp;Type::MemberName };</code></pre><p>↑ 上面这段代码理解起来较为困难，我们可以将其功能拆解一下，它是为了解决什么问题？</p><p>想象类型 <code>A</code> 具有两个函数重载：</p><ul><li><code>f(int)</code></li><li><code>f(const std::string)</code></li></ul><p>当拥有一个指向f的函数指针（<code>&amp;f</code>）时，编译器怎么知道调用哪个？<br><code>refl-cpp</code> 实际会帮助编译器 推导出正确的重载函数（通过将 <code>&amp;f</code> 作为参数传递给另一个函数的方式，来直接触发函数）。<br><code>resolve</code> 没有任何定义，它只是一个 <code>prototype</code>，作用是作为编译器的一个提示。</p><p>这种方法总结起来是：<strong>传递函数性质的参数（由 <code>std::decalval</code> 产生）</strong>。它的好处是：所有的参数类型转换都适用，即我们可以通过 <code>MemberInfo&lt;?&gt;::pointer&lt;int&gt;</code> 并得到一个 <code>void(*)(long)</code> 类型的指针作为结果。</p><h2 id="遍历类的成员">遍历类的成员</h2><p>前面讲了如何创建和存储类成员的 <code>metadata</code>，这节介绍如何遍历它们（<code>compile-time</code>）。<br>核心思想是 借助可变参数模板，创建一个 <code>TypeList</code> 的类型成员列表，并提供枚举的方法。</p><pre><code class="language-c">template &lt;typename... Ts&gt;struct TypeList {};</code></pre><p>!!! NOTE 这块讲的不是很细，没搞懂…</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cpp】Templates</title>
      <link href="/posts/templates/"/>
      <url>/posts/templates/</url>
      
        <content type="html"><![CDATA[<p>C++模板、meta-programming<span id="more"></span></p><div class="markmap-container" style="height:300px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Function Templates&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#模板基础\&quot;>模板基础</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;<a href=\&quot;#编译检查\&quot;>编译检查</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;<a href=\&quot;#参数推导\&quot;>参数推导</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#多参数\&quot;>多参数</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#函数重载\&quot;>函数重载</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;Class Templates&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<a href=\&quot;#模板特化\&quot;>模板特化</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;偏特化&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;<a href=\&quot;#模板特化-代码示例\&quot;>代码示例</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;SFINAE <font color=#FF1E10><strong>TODO</strong></font>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;std&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;<a href=\&quot;#⭐std-max\&quot;>std::max</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;#⭐std-pair\&quot;>std::pair</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;<a href=\&quot;#⭐type-traits\&quot;>type_traits::is_integral</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;<a href=\&quot;/posts/rvalue/#std-move\&quot;>std::move</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;反射 <font color=#FF1E10>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;/posts/refl-cpp/\&quot;>refl-cpp</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="Function-Templates">Function Templates</h2><h3 id="模板基础">模板基础</h3><p>下面是一个最简单的函数模板示例：</p><pre><code class="language-c">template &lt;typename T&gt;T max (T a, T b){    return b &lt; a ? a : b;}</code></pre><ul><li><code>T</code> 是定义类型的变量，它可以是 <code>int</code>、<code>float</code>、任何class…</li><li><code>typename</code> 是关键字，<code>template&lt;class T&gt;</code> 是兼容 C++98 的一种正确写法</li><li>上面有两个潜在约束：1. <code>T</code>必须支持<code>&lt;</code>操作符，2. <code>T</code>必须支持拷贝构造函数，为了<code>return</code></li></ul><p>下面是简单的模板使用实例：</p><pre><code class="language-c">::max(7, 8);          // 8::max(1.2, 1.5);      // 1.5::max("abc", "abcd"); // abcd</code></pre><p>当调用上者时，模板会自动实例化为：</p><pre><code>int max(int, int);double max(double, double);char const* max(char const*, char const*);</code></pre><h3 id="编译检查">编译检查</h3><p>模板的编译检查分为两个阶段（<code>Two-Phase Translation</code>）</p><ul><li>定义阶段</li><li>实例化阶段</li></ul><pre><code class="language-c">template &lt;typename T&gt;void foo(T t){    undeclared(); // 未定义函数，定义阶段报错    undeclared(t); // 引用了T，所以实例化阶段才报错}</code></pre><h3 id="参数推导">参数推导</h3><p>编译器会根据传入参数的类型，自动推导 <code>T</code> 的取值</p><ul><li>若引用传递：不允许类型转化</li><li>若值传递：只允许退化（<code>decay</code>），<code>const</code>和<code>volatile</code>会被忽略。引用会被转化成引用的类型。</li></ul><pre><code class="language-c">int const c = 42;int i = 1;::max(i, c); // OK: (int, int)::max(c, c); // OK: (int, int)int&amp; ir = i;::max(i, ir); // OK: (int, int)int arr[4];::max(&amp;i, arr); // OK: (int*, int*)</code></pre><h3 id="多参数">多参数</h3><p>模板允许定义多组不同的参数，以如下函数示例，其<strong>返回值的类型是不确定的</strong>：</p><pre><code class="language-c">template&lt;typename T1, typename T2&gt;T1 max (T1 a, T2 b){    return b &lt; a ? a : b;}</code></pre><ul><li><font color="#ef6d3b"><strong>返回类型推断</strong></font></li></ul><p>从<code>C++14</code>开始，允许使用 <code>auto</code> 声明函数的返回值，即让编译器自己决定。</p><pre><code class="language-c">template&lt;typename T1, typename T2&gt;auto max (T1 a, T2 b){    return b &lt; a ? a : b;}</code></pre><p>在<code>C++11</code>中，<code>auto</code>必须配合 <code>trailing return type</code> 使用，否则编译报错如下：</p><div class="admonition error"><p class="admonition-title">error: 'xxx' function uses 'auto' type specifier without trailing return type</p></div><pre><code class="language-c">template&lt;typename T1, typename T2&gt;auto max (T1 a, T2 b) -&gt; decltype(b&lt;a?a:b);</code></pre><ul><li><font color="#ef6d3b"><strong>类型萃取</strong></font></li></ul><pre><code class="language-c">#include &lt;type_traits&gt;template&lt;typename T1, typename T2&gt;std::common_type_t&lt;T1,T2&gt; max (T1 a, T2 b)</code></pre><div class="admonition note"><p class="admonition-title">Trick: C++如何获取变量x的类型?</p><ul><li><code>#include &lt;typeinfo&gt;</code></li><li><code>typeid(x).name()</code></li></ul></div><h2 id="Class-Templates">Class Templates</h2><h3 id="模板特化">模板特化</h3><ul><li>这篇中文资料说得通俗易懂：<a href="https://sg-first.gitbooks.io/cpp-template-tutorial/content/jie_te_hua_yu_pian_te_hua.html"><em><strong>深入理解特化与偏特化</strong></em></a></li><li>源码 推荐阅读： <a href="#%E2%AD%90type-traits"><em><strong>type_traits</strong></em></a></li></ul><p>模板特化的作用是，<strong>针对模板的参数类型，从而定义不同的实现</strong>。<br><font color="#ef6d3b"><strong>只要你教得好，它可以 “见人说人话，见鬼说鬼话”</strong></font><br>（有点类似 函数重载 和 虚函数继承 的思想）</p><p>模板特化实现思路是：</p><ul><li>先定义基本模板（能说话）</li><li>再针对每种参数实现特例（能见人下菜碟）</li></ul><p>下面仿照 <code>Python</code> 实现 <code>C++</code> 的 <code>type</code> 函数:</p><pre><code class="language-c">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;template&lt;typename T&gt;class TypeId{public:    static constexpr char const* type = "NULL";    TypeId(T t) {}};template&lt;&gt;class TypeId&lt;int&gt;{public:    static constexpr char const* type = "INT";    TypeId(int t) {}};template&lt;&gt;class TypeId&lt;std::string&gt;{public:    static constexpr char const* type = "STRING";    TypeId(std::string t) {}};int main(){    ::cout &lt;&lt; TypeId(1).type &lt;&lt; "\n";                   // INT    ::cout &lt;&lt; TypeId(std::string("abc")).type &lt;&lt; "\n";  // STRING    return 1;}</code></pre><h3 id="模板特化-规则">模板特化 规则</h3><p>模板特化 符合 函数重载 的两个条件之一：</p><ul><li>参数数量相同、类型不同</li><li>参数数量不同（<strong>特化只能少于等于</strong>）</li></ul><p>否则出现报错：</p><div class="admonition error"><p class="admonition-title">error: too many template arguments for class template xxx</p></div><p>示例如下：</p><pre><code class="language-c">template &lt;typename T, typename U&gt; struct X            ;    // 0 // 原型有两个类型参数// 所以下面的这些偏特化的实参列表// 也需要两个类型参数对应template &lt;typename T&gt;             struct X&lt;T,  T  &gt; {};    // 1template &lt;typename T&gt;             struct X&lt;T*, T  &gt; {};    // 2template &lt;typename T&gt;             struct X&lt;T,  T* &gt; {};    // 3template &lt;typename U&gt;             struct X&lt;U,  int&gt; {};    // 4template &lt;typename U&gt;             struct X&lt;U*, int&gt; {};    // 5template &lt;typename U, typename T&gt; struct X&lt;U*, T* &gt; {};    // 6template &lt;typename U, typename T&gt; struct X&lt;U,  T* &gt; {};    // 7template &lt;typename U, typename T&gt; struct X&lt;U,  T, T &gt; {};  // Error</code></pre><h3 id="模板特化-代码示例">模板特化 代码示例</h3><ul><li><a href="/code/refl-sum.cpp"><em><strong>refl-sum.cpp</strong></em></a></li><li><a href="/code/refl-factorial.cpp"><em><strong>refl-factorial.cpp</strong></em></a></li></ul><h2 id="std">std</h2><h3 id="⭐std-max"><a href="https://gcc.gnu.org/onlinedocs/gcc-4.9.2/libstdc++/api/a01226_source.html">⭐std::max</a></h3><ul><li><code>_GLIBCXX14_CONSTEXPR</code> 在 <code>C++14</code> 会被替换为 <code>constexpr</code></li><li>实际可以展开为：<code>constexpr inline const _Tp&amp; max(const _Tp&amp; __a, const _Tp&amp; __b)</code><ul><li><code>constexpr</code>无实质作用，重点是参数使用 <code>const &amp;</code></li></ul></li></ul><pre><code class="language-c">  template&lt;typename _Tp&gt;    _GLIBCXX14_CONSTEXPR    inline const _Tp&amp;    max(const _Tp&amp; __a, const _Tp&amp; __b)    {      // concept requirements      __glibcxx_function_requires(_LessThanComparableConcept&lt;_Tp&gt;)      //return  __a &lt; __b ? __b : __a;      if (__a &lt; __b)return __b;      return __a;    }</code></pre><!-- ### [⭐std::stack](https://gcc.gnu.org/onlinedocs/gcc-4.8.3/libstdc++/api/a01566_source.html) --><h3 id="⭐std-pair"><a href="https://gcc.gnu.org/onlinedocs/gcc-4.9.2/libstdc++/api/a01240_source.html">⭐std::pair</a></h3><ul><li><a href="https://en.cppreference.com/w/cpp/utility/pair/pair"><em><strong>[cppreference] std::pair</strong></em></a></li><li><a href="https://stackoverflow.com/a/9270585/16823597"><em><strong>[stackoverflow] What is the purpose of std::make_pair vs the constructor of std::pair?</strong></em></a><ul><li>c++14及之前，<code>std::pair</code>需要显式指定类型，<code>std::make_pair</code>不需要</li></ul></li></ul><pre><code class="language-c"> template&lt;typename _T1, typename _T2&gt;    struct pair    : private __pair_base&lt;_T1, _T2&gt;    {      typedef _T1 first_type;    ///&lt; The type of the `first` member      typedef _T2 second_type;   ///&lt; The type of the `second` member      _T1 first;                 ///&lt; The first member      _T2 second;                ///&lt; The second member      _GLIBCXX_CONSTEXPR pair()      : first(), second() { }      // ...    }</code></pre><h3 id="⭐type-traits"><a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.4/libstdc++/api/a01417_source.html">⭐type_traits</a></h3><ul><li>以 <code>is_integral</code> 为例，判断是否为整型</li></ul><pre><code class="language-c">  template&lt;typename _Tp&gt;    struct is_integral    : public __is_integral_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type    { };</code></pre><ul><li><code>__is_integral_helper</code> 是一个标准的模板特化，<strong>非常简单</strong>！</li></ul><pre><code class="language-c">template&lt;typename&gt;    struct __is_integral_helper    : public false_type { };  template&lt;&gt;    struct __is_integral_helper&lt;int&gt;    : public true_type { };  template&lt;&gt;    struct __is_integral_helper&lt;char&gt;    : public true_type { };  // ...</code></pre><ul><li><code>true_type</code> 相关定义如下，其<code>value</code>变量就是一个bool类型的 <code>true</code></li></ul><pre><code class="language-c">  /// integral_constant  template&lt;typename _Tp, _Tp __v&gt;    struct integral_constant    {      static constexpr _Tp                  value = __v;      typedef _Tp                           value_type;      typedef integral_constant&lt;_Tp, __v&gt;   type;      constexpr operator value_type() const noexcept { return value; }      // ...    };  template&lt;typename _Tp, _Tp __v&gt;    constexpr _Tp integral_constant&lt;_Tp, __v&gt;::value;  /// The type used as a compile-time boolean with true value.  typedef integral_constant&lt;bool, true&gt;     true_type;  /// The type used as a compile-time boolean with false value.  typedef integral_constant&lt;bool, false&gt;    false_type;</code></pre><h2 id="反射">反射</h2><p>先看看什么是 <a href="https://en.wikipedia.org/wiki/Reflective_programming"><em><strong>reflection</strong></em></a>:</p><blockquote><p><em>reflection is the ability of a process to examine, introspect, and modify its own structure and behavior.</em></p></blockquote><ul><li>通俗解释，反射就是从一个对象(<code>object</code>)，能够反推其类型、成员和方法</li><li>以<code>Python</code>为例，<code>getattr</code> 就是经典的反射功能</li></ul><div class="admonition warning"><p class="admonition-title">为什么cpp没有反射?</p><ul><li>反射会导致编译后文件过大</li><li>cpp很少用到元编程（相对于C#)</li><li>cpp有模板，足够应付大部分需求...</li></ul></div><h2 id="阅读材料">阅读材料</h2><ul><li><p><a href="http://110.42.228.178/pdf/CPP_Templates_2nd.pdf">CPP-Templates-2nd 英文</a></p><ul><li><a href="https://github.com/wuye9036/CppTemplateTutorial">CPP-Templates-2nd 中文版翻译</a></li><li><a href="https://github.com/r00tk1ts/cpp-templates-2nd">cpp-templates-2nd 中文版翻译</a></li></ul></li><li><p><a href="https://github.com/wuye9036/CppTemplateTutorial">C++ Template 进阶指南</a></p></li><li><p><a href="https://veselink1.github.io/blog/cpp/metaprogramming/2019/07/13/refl-cpp-deep-dive.html">refl-cpp</a></p></li><li><p><a href="https://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/">What Does Haskell Have to Do with C++?</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志：2023年8月</title>
      <link href="/posts/2023/8/"/>
      <url>/posts/2023/8/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="088c707709b995861e4e58c94a61b527368d8a83cfc58edb93edc304acbc9c56">b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475de0b1305a637ea913974dff7410a14ed4dbbb40a5278eb14bbac34e59e12a284c7a294ab69a495d47e11e78ad50feb1070429e58f3fbd737c20fb16c7243eddbb619e52c31eb507d6765e3b14dcaa7e9d13492120aa6f2d9638cdc372f2d3c81cf4232ed0874302eb77e0fba53c7b0ac1b5e05196961ebceabaee4415690ead6a710c137c2757694abdfd08eb8c2634a5d753274da2b1c7bef744740058d16d7091d22fa8304764b0d2f6294ca8c6a207e9631f260ac16e68b32cf9dfed4653d1dfd7ec34e029768744ff31cf46be9716e7586f7db03f6fdbb5424f4ac8476c5cf96e9dd587787781164d9d02b9abc39b1840ec2cd478ca480554f4049c941e50195a77f0b24330ba24922044d92ee1b7b07c0420d90b435163e9b6ff6a187c600a683de6c80ee99f40ad6f04c57b1038b59b7c5fa28d202cbb5b68ac169c96e956c701fa2733dd351daaf2c77420ef2c9d81b4f6567415a90f9806bbd90215c38f75a31cdc983a0ee93c2590e66b10f2f88cf627e9e7230e093277675ba2ffa1f8a9d71e9763c19c4389b0f2a0f8903c564dc10ab53981fc487ccee24df6454c9466089470df32dfe841773b273a2e9212119f7c977a60035ea301d47eb5078523d993c6370d7cfc69c6bec52ff9cd8c59c346f4af5adb805c21e170d244cd7ff29f9d3f70acaf5041b2b2aa0e2a48c06b1e7fe726ad391187a60e8153790242e965db2f618c5cb9f90bac81e9171a4082f761d56fd77065727d7a01568bdf1a92fd6b69a47d66ae586c041362e158cf6918e643df04270fbf2d7b6c83b81a3cabfdeb4cec43465d5d0d18f24d8eccd0eecbba24f24f0ca3cfdf63d71f027c56dd478870b5bb67d334dbe2b1d1e1bcd505a731da11641c35e59e867a6c505cbd4078a924a22c3f47ec3268a07f420acf3c6ed043d684e69bd88468885b77dd7385241e94561c5a2132be9a941fe048e6fb604daf1ffb603538ba15f37ac2a09be55fe1b1e40ceceeeea21877916031087ca10ff470729aabadb15870ac7a684dda40c886f3270bea5db51aab42a40b4c64579bc15a5f4489b5c5c1c5b433251d46b7188000fd63a7691272641c1bf76e00f4a8558e58d69bb2b2c0130608f044657dd53f25cce7b98e4630c9d52c24136a428286ecb66a66313c2881f168df75a2cb8453c0bcac9e32cb1434d6809996eae2b590ebbdaac6c9009739126e9f8e92976ce7d71b9bcbe7e7de2fe5ade15b4d1e8dc3e147d0be96aaad8c939e1e122aeb55ba72ba38d37329e489f7c6edae50f15673c33606c8b801c6b4ad8d2f770c80cafc9a3dc5912a35995572ad088d582045bcd1b1d6b7839cb8a03bf6de7aea3d25c808f25e92bcac20dd3a8d76aeaaee615e7f58c68cec17e2df0d43f0ff1b11f23e5e684e3e8ad0679ebb58877fa208ca34f7014e80b0c60429634ff4d88cc0aadae737dd83f077ec2e164fa493b7e95e55e979d8a315b57c50699903b463027e33cf890ceb17eb29ab76882555cf0acdce817698929fdc6ae42c726c15cd09f9876c2e4c2824c265912a1ce677d096667d049cdcd82d88a78bf874effcdc566f641455cd98637d4b7880b733545ba61714b012fc1e09c3988cdb32023c4e6679d4772f3aefe2be7b775447b05182da8750b8eb0ab9c7e2057e9165432399749ac975f2f5f4ed9a4d0dfb53a9fca27c539f3cde6dd71523ca62fd8503a0b26edb8ca15af6be9aa9350df5e93595bde5fe38fa8f77daf14cec1eb557af4dbf77a5503fa04f201a89d536e268281174dda349431b7b582df05a892d5baf6104a9c2dc4f0127bee4bb2d694cc63c7e401c3a8f9de45d2ec27306206a40444f066be06109511c0049c38c1aa3b302645ab2786db16e50d6392729ab724f74631f65b029ee199ecb8aa9adba4985c3323b83133db3508595c9a146c051f9669c9a6d793d656024b6e68fac42f21b9ec4cb0f6e456680fdadd514588c7dc2fcb1192d10b7a4ed512f92eb4f510849f16fd9bec830f1a9cbe52a5a344143e44e0bc9608ce50b3a3c96ca8ff6f033fe415254e1bc2a50c2d4e56b784876cbf8004c45f63a45356c08199fbc1f433cecbadc18e21d5fee429e8b1292e19f125e57d4aed4f05a0b2194a6e17d423c01774476f04219848cbbb9699ab58bf26ddaa99130657470c6599aab71db4077a077b2784db5bbf7a108f85c27cf2e90dc801ef7f4ecc3ca15e28099c73bb4d8ca8604537b05f16d23c66bc7c2e152fbc478293af95ebacf9c8796a586d70ef75ad618fa2d3bbc5fbe81a22d8ee36105b70adb9f636c3cd69228e9b53a463e890f103ddc72f0603a6815e32ffed8a79e7467a91c3ea6da318d7d6a2c1bc4e440b3987bec38c4fe6724ef9ec7ff7367ad45351339ce7e2fc68db732404b75e057dbb658e05f68678fc99eac0479ed9aefd6521b65b88cf162dc1ad81e2fcc26d259805213d06d68e632d484e95cd8bb09b8954262b5063afe43274e2033352daa9313db01c405cc29528aa7a6467b926951bc8252d36a967916a8f7b385dbbcf51af18bb0f8bf5d2d99cb334f9ec55f15b7c5e4a6a49207fbdf3ff0f032feeff053f0caf51525b5d934f0281b317a2591f7863541829e6d3e4dfd10f495d34e76a37a4cb1994dc5956695f2af5b29a34c58cd54d6c1b6b4a25d80244d0bba77e336c80bcfd98c258c670d3b0c5cc7cf34acfb2ba60c885f80373bc9ba82e83e3c18432bdab9d5ddcae387b5e0c552cda7fffdf87128451ca3c5a874d268fe2305bbbcf5910a4b978866328649f891014df094ad555bd32f76972994bbcc2302e8fc6cc5123317a028cfa93a9d2aa4d2e006b7a8e9895a90e49ea4a65b67af51c19e8e993a954e96235e9f150917fae2fd1705f21782d256946066b4e4f531af3c5cef513d4ed399f7c252c3fb5097e828a0058ad4e1089dfc8df4f5d0293d9382284328ba9c7adbcdcd09383dca737191ddf9b2969e6b02af4212cf4361894ebc708f00b16e7c64ff10e4432b65fe2c7b05e4889c5808949737998e7f6335bf48a4354828d177ea3dffd66c4df7c03a187862eab302fca251e5a5be70cce19df939b5efbdb527f6004dc35c8fa4bb309e4d1047dc84157379579bc9c7bf6b1805b97d117a654c1d579765989e0f4b12be0958da5b3c7c9bf86a15679a4fecd60f11f83ad11b9091f80343d3397747d9680c70f8e3a5db6f49dc2c7f0e3e0a91abaaee24635d20d1d72a74afadea6040b9288356a89e19f86781940d1a552ac5b327a1fc06959c7a3433042a2e98ce411575f087822beb5e58303077bc84f16d07bb4c36f7bad34b2b575af27e0ba4228abdabb3380d6c2666514d82f82814eaad75e3a39b999d563dadc7074005acdd320836230eaa8ff4f153d5fb1e6e3bf23891d8409a3aab2b9ca7282fe15c11b6f9d7819574ae7e05b42b29f5ab944dc5c26af551487c7b4dd302a40741f28a14f50391abb1684ba1c8d79ed5211ea977d5f7038e733432f469761af877cdbe2ae70f6654976e9fd65c1b841b0a7a75f4f3a6dbbdca6e0e7712589a8d683b86e9dc4624813421f786966137286b13ff885b73c912ff105e233a888faa682c5f2190772d64fc9f820da019d49fc757bd442fc9ab962a212e1cf55f700765fd22517eaf05202fb28e61ad0c354abb781ce08359a497ae7efbb34dd52ad49db933da2f5138b95fe37a89753584c755070361a9d1721eb707164d8d85cdbfd53011fb8ba98971f45e6eb6cb849a955902875d84a7bc9fb98477a81b1d2f077d2846381889e1ae1171cd9a86d92b0b8666ed73de0a282013ef9a009dd51b3b6002b05210c4ce883d2e13d27f61c577cc6af7d69ef8ede74aaa73554d9ef9591b1c00fb1863ae9809614950608dee1b35b60724ad4fd4ae5c1b91f0d9fbe7482e4edd2cb6182bc0af102a823b9b45e62376af8dbb0aa24ffd3e8137e3f9390ead53f34dc2204a239e1e7307cb8ae198c70ff0f3e62488627ed20b48da9cdd6aa7e3698774c8002e82f6dedd77abc97301269443fbfe203103ff3807139e6472ed40a4d67ec624e141e50e1234ba20e93df4fa080cc6d5f4a62ebabd5b63d51f198c9b8305c196ff559ca00b1750a747ca1a187c2b3f1f0548f99b3006a70b70ab4458f3de77fa25050ae50e9c31a3345876e12a48d5184846e6a711cfeeff25f984e5929465a19f8811addf40d930b75c6ab0a58a27d3ff51e949c2875b6621f6f4a986b5110114321dc1c62390aa67bd88f77a41d5b5b49322a95351d36782034a6d45b6db85ebafa79cf5b3f3002f2a714e11576d03b026f2c256c12ed04f2163daf93d2c500c7d3053827c1eadc2450f4a02703ef5bc1ebb2021a84029a68b25a2936d76341ab9e710263f2bc3688cefb26405a6fef0fb5d4ff2fa28aafbfe3016880820bcfd32b4b1fe203124d4027a483492bba57e5121f2a9b3e31e7caec33cf72b586944dda700dc922f626593558cb60ebfcaf656883a3786aaff323b53cd38d02dd785670eb9ea232692ae40965f1ed43fd933d0fa4f95cbdbf9bb03809efcc82eefe4020e15d6bf2b9828012589fd5074d139aeb55b80438ea9f500f06b899be9b2cc0c575dcfcaa6da869c182e2fd70eb3a7a75b5361ff28150b215d50851b8c3a0050331587f0959a2310b71e957ef18fad48dc7e16efdd8cc14ac82c89012eac8bc0738413646a19b38a5ee89c54a934f28be319d9aef11a7003d34a8d3b16a3e9981e1e640e04809a94d566ae69ab90e58ca1647844939159901d632c0744355c4fe0759d6f3b66b7430db18cb85f659cb2c3357cc99af3ea7a92540b2e6d6202e5eb3f7f0d3b686de0f52ae301ab564c490c744190cee9daaecb8ab644fc24fc6699f3c099b006f6281229c303afe87c87d297f77b14ea36875bdea69b667ff9e9271596408077c120dd67d2b14c77f1f98c4577981fc649984b6546e07931ab91755759537debd2dc68560228fac2fcc2738522e975060279ca6a0c9d3df1af329d432ea7f0da40b3e3c9587c54e1fe1318c6f118611f372a7ca1b8e8b6b19847e189de01880cf9be6dd73106aa6c6f1e548b2a4bcdca64c33073302ba8a9142032406c65d52e4a18ad95044c4d4bf78494e4964b79a7d35deb929af3c3e9d05dfc713ab5018d75a564846ad762b58e1f64e4bbaf0508b3301a2bc7111a3c3df41f1657bcc66354ad3c152d5aab95c5ccfca48fe101f199bd13bcd76e1e64b6019edb0156d481632228320c98bce931dbbd413db446b783d853edc9013bd3db83f1327ad3d3d0c3ba5f91915bf9e8bd6c56bb34fcda55f88f0448cfb1c3148a1b44a7c0b131237db2c01847746e6abced888260001b2291ade4763a4a54f64f0bd722a4d218287be3ab6e579d4785459b289b3faceb7feebf7466101f1dbb9a11f5558cb2782a709029f69886a06e621215fda6addadf141548d7307141b6a9ab599c41b8c0435dfd4628551db893f19af55d67057f4d01e230c3dcdcb45858fc84978cbfc864005b8756a53f7412b6f8fb3fa55b821c2798d2ff4f8e2be30f3bdb5cb0113f230db06059ec2500a601b33608107b7cb3e2b8fcafcd29e768d28d97f4deee56a8f3688b1541cc5963efcd4a4cdd04368a41676bff2f02a10821025119b95fbcb4c998d5f58754171aac564c41f95f304f12401e629853ffdb63f5e8911acf87978144439b2c25616242a622a3ab0ea84343f63e7c59bfed97b2e7682dba574a411641410e38a60e5be49f6197e6e664d5310a0e93a92d97d48e3c596ef3577e50ecc6f11434e02222b613209878a9b07cd3552df6d1e9234dad172da1f9378ac6a98a71fc0099a48d9572225e193c84de989f5ea68110f3a77eea1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【vscode】vim定制化插件</title>
      <link href="/posts/vscode-vim/"/>
      <url>/posts/vscode-vim/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://github.com/VSCodeVim/Vim">VSCodeVim</a> 是仿照vim的vscode插件</li><li>本文在其基础上添加一些额外的个性化功能</li></ul></div><h3 id="VSCodeVim">VSCodeVim</h3><p>vscode vim主流插件有两款，分别是:</p><ul><li><a href="https://github.com/VSCodeVim/Vim">VSCodeVim</a>：仿vim的插件，功能不全</li><li><a href="https://github.com/vscode-neovim/vscode-neovim">VSCode Neovim</a>：基于Neovim，功能较全，但依赖nvim环境且配置复杂</li></ul><p>笔者一直使用前者，因此本文全部围绕 VSCodeVim展开。</p><h3 id="缺陷-😞">缺陷 😞</h3><p>VSCodeVim Github 拥有 1.5k 未处理的 Issues，作者的维护迭代速度非常慢，因此有很多缺陷和功能不足之处：</p><ul><li>不支持 vimscript function</li><li>不支持 vim bash</li><li><font color="#FF1E10"><strong>【bug】</strong></font>经常Esc失效，弹窗报错 <code>vim.Escape is undefined</code>… 需要重装插件</li></ul><h3 id="亮点-🎉">亮点 🎉</h3><p>打开 <code>"vim.statusBarColorControl": true</code>，可以使底部 <code>statusBar</code> 跟随 vim模式 而改变颜色。<br>本文希望进而改变 Cursor 和 当前行 的颜色、高亮显示，并支持 config 配置，效果图如下：</p><p><img src="/images/vim-mode-demo.png" alt=""></p><h3 id="改进-💡">改进 💡</h3><ul><li><p><strong>支持配置 StatusBar, Highlight 等颜色配置</strong></p></li><li><p><strong>支持区分 Normal, Insert, Visual 三种模式的颜色</strong></p></li><li><p>下载链接:<br><a href="https://github.com/593413198/Vim/releases/tag/vim-mode-1.0">https://github.com/593413198/Vim/releases/tag/vim-mode-1.0</a></p></li><li><p>配置文件:</p></li></ul><pre><code>    "vim.statusBarColorControl": true,    "vim.alpha": "80",    "vim.statusBarColors.visual": "#005f5f",    "vim.statusBarColors.insert": "#5f0000",</code></pre>]]></content>
      
      
      <categories>
          
          <category> VSCode </category>
          
          <category> VSCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随手记</title>
      <link href="/posts/idea/"/>
      <url>/posts/idea/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0c5c25ccc3b1d155ad6ea1bcb79024d41de2d107cc1107c8a51186a23ed763b4">b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475debb79baf718116b8398ebb7a36965f5712db04a990a04196bf7d89b9188d2f5969b089300c199c887ad4490953d1810357cd375ac06e732d356d4ec27b642aa2d46c8fdf198d48a4b9620936f8c18efa99cd53c0e6c5befbd6da9ebb0e8d473ba88daf9814bf097589053470cd244c49759b29258898ae147d3b92406541ecc1426781b7f965d69488f8227468d25ace43c6b69c8a19f97354453e8ff96435fa7c142eabaa7418866597b071d73575a4fa98f09916a3b6256959c82764411afd8c8baf90fb4965fdfacbf4695b2488acf5d7f161a49b796a0b1b992232c56c8393b9705588b441acf55138be81fe973cf0e644444f60301071e149e7788696fb98684774596c09a87b8d44ff780e78e5a657a2a5580c8749587dc7d65ae05a8cb2594174783fd8fa497d8cc4a84947227afe8329650281ddb4595068235ed79e470b4868c26c2713685a5a93c0f1280e53b3df1720e4da8e8a09f8a6c99c3921a4b6850c328a6dc36e2202e0b4f1be867149ef931cb38587d704e6c911e58a15f05eab1e8cc352fd6424983c5800bf4f3d49dded1f663f23d4913e49064ba3cf91499fb213e96ac0af65deafd2c9fabc6e4e36b2dc5f38aaa95de286bcc604f0fe11b2f0bb8fcf181906004cd02cea773816c2f37a108e5bdf894e0d8012a39ba8b2ae6b924b924f6cf7384324e220677c36cbc43355060db7d4353fc4d2cf1e0f870385842ec30394027ac67562af4526e5a862983fcc5343ff658dd75ac60bf343a35df981950c50299447033daf22310f580432dd96559a8a198effa21454f024111215c9584bb1f2ce51ad7b39851bdc55c9adcbd4fa77d824d22167066cb7ad4f4ccd8fc8eac382e7f4eaa6436bf7cb8ee2b9c86bc7e2a6d318576055b79b6cfbc159ef03b44d59c10724d75f9869f93579be0f41be9412bae43c70d983b55a89660e48ba54240a3d1445b2aebca2752304a24161fedc49f17d991078ecc7b6d4864ecf742e1cd4e8d157ba47adf98e1ec449086362f097efcfe17ce562bdf7c5cc56733334d6f4b5b625b796230f58c7a9f1cda72376df7f986703ece3432b4a61b545e92dc888cf2a624961fb5a79ea69d4a73ae47a526bf867c6590695f393674b676152e38088676fdcd056be934930c4ef734512e90ae881e80e1d1ef962835704827aa85aeb62251707e90f0d8fcadeedc0c29abf6920ff959de86f14803b11c996289ea189d3f68cb9fa3be352f64b3e55649579438eb783d2f70f77997807e47094fd69a417bfc9431d19c843f74a8242599afd07f83fed5d8706cd44e33526ee1d1322853287d417c59aa62f14f89c0eb720d295d69054be38348ed1fc24e73345de69509daf98255a0c0d4ea3e967999cf53cf038c92ecb79e1e4a9f06fa8f600343839101e1c5dc1620e832ef1e0898898ae22727614645bd30fa7b987ab43cff16ff4d0a9053c0c4d7cd87c7191ad4c4dc3ca5a31a238292eabdea0e394959c378acc8aba059748f6ddada7efe8708b357e6b9b697556abf8b31523350af8a5487af0f457f2ce07e0cb25ee98bb758c359caf69a403993dafd0ab3760742759e114b3cf185e16559dca6fa67b5227d19e231078bc9b8d6f5af1de393abf5af8a3e9dfd4bff946608c0a3cc24e1360fc36e4af099c23b74bf0cf814384d79793dcbf658738314beb3421de4872867d68d45ffb6ea2a480d348d61d8180e2e6dd9f5b1302c6d71259d6d289a996dfd821329c365f66fa6fc412053481b4e0fce112e1512560f78b01a86332f0a8ca3ed32f89446a0dc2e0e315748bfad11ef53a7929da0f8cc7aefcd3ce9b25cbdf6042c795f8cfd9e8139436982f49dcbf76e8129707e743177f629b14e3c17ae6d2773315b267889735b70bbf1b6210ea3cf34f16cbe51e5c416adf52542e3c6b8ee1c37cf50bae1c6c831ec5d7b468cc8d3dbde615b3dacf79b70f7b3f12cb81c5f03caec57b1753a167389025c621c8ba684efa28af26fdde0cf2c845012fea0d28599054de052c2aa083f3a53b6b879863d6ebd770a7fd0ce776d181608f7a6154bd83d21171ba14b5ce589a1c0175c72f7faad0ce3a2f25b1c0f7b6f40d7031639d42e6a7dad316b3348b19d21575a21651291f76c34b1100b966602689e8eff43ed852221005af04e6a7219fdbf8215508f53b8810069be883565b9f160b119a9288d9bb1d6917aa588367f9f2c6903c2edb41e9d2076a14c7348aa9aa22e4d6ed89848a51256cff9f3b79e74949626d3b3a7241c3b7cfbdcd986c0bf04bb91488bab3efbfff476a1</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【表达技巧】跟罗永浩学演讲</title>
      <link href="/posts/talk/"/>
      <url>/posts/talk/</url>
      
        <content type="html"><![CDATA[<p><code>罗永浩15堂演讲私教课</code>学习总结<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li>B站视频：<a href="https://www.bilibili.com/video/BV1PP411T7fv">【演讲】罗永浩15堂演讲私教课</a></li><li>知乎：<a href="https://zhuanlan.zhihu.com/p/619973080">【学习笔记】罗永浩演讲私教课</a></li></ul></div><h2 id="前言">前言</h2><p>开这篇是因为近期，有一个在公司内部分享的计划。<br>因为不是技术类型的讲座，技巧因素占比就会很低（而技术分享更注重将东西解释清楚）。所以萌生学习这类演讲 + 表达技巧的念头。<br>认识罗永浩，最初是 6个亿 的负债梗，更深入的是在 脱口秀大会 作为嘉宾时期的发言，对其有几个认识：</p><ul><li><p><strong>听感</strong>：表达清晰连贯，但嗓音条件恶劣（据本人调侃是老太监音色）</p></li><li><p><strong>逻辑</strong>：知识涉猎广泛，且临场反应迅速（后者是幽默感 + 经验累积）</p></li><li><p><strong>内核</strong>：善于制造一句<strong>核心话题</strong>，并反复洗脑callback（如脱口秀的“大局观”，如演讲课的“因为大脑就是被这样设计的”…）</p></li></ul><h3 id="关于这个教程">关于这个教程</h3><p>基于罗老师 <strong>“演讲都是有套路和技巧”</strong> 的观点，将其演讲课的套路总结如下三点：</p><ul><li><p><strong>为什么要这样?（赢得认同）</strong></p></li><li><p><strong>如何达到这样?（方法论）</strong></p></li><li><p><strong>举例、类比论证（深入人心）</strong></p></li></ul><h2 id="十三个要素">十三个要素</h2><p>这些技巧比较多，难以短时间记忆和掌握，因此先记录一下核心观念，剩下的在实践中掌握和理解。</p><div class="markmap-container" style="height:350px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;让观众听下去&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<strong>讲笑话</strong>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;吹牛逼&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;装逼&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;让观众容易理解&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;讲故事&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<strong>作类比</strong>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<strong>三段式</strong>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;提问题&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;具有说服力&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;有逻辑&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;有数据&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;让观众产生共鸣&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;有激情&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;有情感&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;<strong>升华境界</strong>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;核心&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<strong>有画面</strong>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h3 id="精华摘要">精华摘要</h3><ul><li><p>开始一场演讲的最好方式，就是<font color="#ef6d3b"><strong>讲笑话或讲故事</strong></font>。（千万不能讲道理）</p></li><li><p>对于晦涩或陌生的事物，要<font color="#ef6d3b"><strong>巧用类比</strong></font>，如 谈判就是找交集。</p></li><li><p>开始主体内容前，用<font color="#ef6d3b"><strong>三段式</strong></font>介绍提纲。（思维导图）</p></li><li><p>讲故事的三要素：冲突（吸引注意力） + 行动（故事的发展） + 结局（表达的内涵）</p></li></ul><h2 id="其他技巧">其他技巧</h2><h3 id="1-用坐标系描述事物">1. 用坐标系描述事物</h3><p>举例，如何看待 <strong>“量化交易”</strong>?</p><p>首先，一个交易策略的评判标准有两个维度，分别是：</p><ul><li>Interpret：（金融底层的）解释能力</li><li>Predict：（金融市场的）预测能力</li></ul><p>因此，引入一个二维坐标系，甚至可以类比不同事物在其分布，例如：</p><ul><li>进化论：能解释为什么猿猴进化到人类，但无法预测人类未来进化的趋势</li><li>地心说：能预测太阳东升西落，但底层科学原理是错的</li></ul><p><img src="/images/interpret-predict.png" alt=""></p><p>最后，根据 量化交易 预测能力强，但无法自圆其说的特点，可以将它放在类似进化论的位置。</p><p><strong>该方法论可以让听众直观清晰地了解事物的多维度特征。</strong></p><hr><h3 id="2-结尾升华主题">2. 结尾升华主题</h3><ul><li><p>几天过后，观众未必会记得你讲了什么，但他们或许能从情感上认同你。</p></li><li><p>这很大程度上，来源于结尾的几句升华。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【cpp】Memory</title>
      <link href="/posts/memory/"/>
      <url>/posts/memory/</url>
      
        <content type="html"><![CDATA[<p>C++的内存分配与管理<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li>理论偏：<a href="/posts/virtual-memory/">【CSAPP】Virtual Memory</a></li><li>本篇结合 C/C++ 了解内存分配相关领域知识</li><li>ptmalloc，tcmalloc，jemalloc ...</li></ul></div><div class="markmap-container" style="height:300px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;malloc / free&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;new / delete&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;system-call&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;<a href=\&quot;#brk-sbrk\&quot;>brk / sbrk</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#mmap\&quot;>mmap</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;c-malloc&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#ptmalloc\&quot;>ptmalloc（glibc）</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;tcmalloc（google）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;jemalloc（facebok）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;mimalloc（microsoft）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;c++&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;std::allocator&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="malloc-free">malloc/free</h2><ul><li>阅读文档：<a href="https://en.cppreference.com/w/c/memory">cppreference: Dynamic memory management</a></li><li>使用的时候多查阅文档，注意 <code>malloc</code> 使用时要判断 <code>NULL</code> 避免内存分配失败</li></ul><pre><code class="language-c++">#include &lt;unistd.h&gt;void *malloc(size_t size);void *calloc( size_t num, size_t size );void *realloc( void *ptr, size_t new_size );</code></pre><ul><li>分配过程：↓</li><li>需要考虑字节对齐，注意被释放后的内存也可能重复利用，这也解释了为什么野指针的 <code>undefined behavior</code></li></ul><p><img src="/images/malloc-demo.png" alt=""></p><h2 id="new-delete">new/delete</h2><p><a href="/posts/virtual-memory/#u-class-black-mallco-free-u">malloc / free</a> 前面有介绍过。</p><p><strong>以 <code>A* a = new A</code>为例，通过 <a href="https://gcc.godbolt.org/">godbolt</a> 查看汇编代码，发现其有两段逻辑组成：</strong></p><ul><li>调用 <code>new operator</code></li><li>调用 <code>class's constructor</code></li></ul><pre><code class="language-asm">call    operator new(unsigned long)mov     rbx, raxmov     rdi, rbxcall    A::A() [complete object constructor]</code></pre><p><strong>相应的 <code>delete</code> 方法，也对应如下的两段逻辑：</strong></p><ul><li>调用 <code>class's destructor</code></li><li>调用 <code>delete operator</code></li></ul><p>下面重点展开对 <code>new / delete</code> 两个操作符的学习（推荐阅读 <a href="https://www.programiz.com/cpp-programming/operators">C++ Operators</a> 和 <a href="https://en.cppreference.com/w/cpp/language/operators">cppreference operator overloading</a>）</p><p><strong>先看 libc 的 <a href="https://codebrowser.dev/llvm/libcxx/src/new.cpp.html">源码实现</a>，可以看到是对 <code>malloc</code> 的一层封装。</strong><br>如果类自定义了 <code>new /delete</code>，则优先调用它们。</p><pre><code class="language-C++">void *operator new(std::size_t size) _THROW_BAD_ALLOC{    if (size == 0)        size = 1;    void* p;    while ((p = ::malloc(size)) == nullptr)    {        // If malloc fails and there is a new_handler,        // call it to try free up memory.        std::new_handler nh = std::get_new_handler();        if (nh)            nh();        else#ifndef _LIBCPP_HAS_NO_EXCEPTIONS            throw std::bad_alloc();#else            break;#endif    }    return p;}voidoperator delete(void* ptr) noexcept{    ::free(ptr);}</code></pre><h2 id="System-Call">System Call</h2><p>程序中的内存分配有三个层次，如下图。<br>最终调用的还是Linux/Windows中的操作系统API：如sbrk, mmap… 因此需要重点掌握这些系统调用。</p><p><img src="/images/memory-call.png" alt=""></p><h3 id="brk-sbrk">brk, sbrk</h3><blockquote><p><em>change data segment size</em></p></blockquote><p>参考阅读  <a href="https://www.cnblogs.com/sylar5/p/11508821.html">cnblog: brk 和 sbrk 区别</a></p><p>linux man 手册中描述两者的作用是改变 <code>data segment</code> 的结束地址。<br>通俗地理解就是，<code>brk</code>函数会重新设置 <code>heap</code> 的高位地址，而 <code>sbrk</code>函数会根据大小来调整 <code>heap</code> 的容量。</p><p>两个函数的定义如下：</p><pre><code class="language-C++"> #include &lt;unistd.h&gt;int brk(void *addr);void *sbrk(intptr_t increment);</code></pre><h3 id="mmap">mmap</h3><blockquote><p><em>map (or unmap) files or devices into memory</em></p></blockquote><pre><code class="language-C++">#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags,            int fd, off_t offset);int munmap(void *addr, size_t length);</code></pre><h2 id="ptmalloc">ptmalloc</h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志：2023年7月</title>
      <link href="/posts/2023/7/"/>
      <url>/posts/2023/7/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="97e14be9e854e1b3237cbaf95d9dc3cf8f8b75fab2a1a1bc54fde494d8cb23cd">b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475de0b1305a637ea913974dff7410a14ed4dbbb40a5278eb14bbac34e59e12a284c7a294ab69a495d47e11e78ad50feb107058e3275f75d936a554eb95bedbf96a7783a11b9f4096cfe1861725619e5a5317633279c3d957779453d57b5fa0ba64fc50c8a8867249b1e4e1b679e8a138ffe4e44ee9fd3637dc99e76ff334587dd2acf41dd9805cce4bf275cc1a585ab11cc84c7949a8c4e30c48778c74ce922226777c41d0403e225f7f266e27ebdc913e4f3b0bc811d619052f5d10bd439c7abdb7fa6a5c74b5a8b4c939d638e648ea06be90c69907d299438ee2c58f9f5cd7175c2f88ff07ca6f3b74e3c1e7e424dc71a31cd92fca1339935722708f2b8548366dfbf220add8202ae63bd0f61d1e2b8c30858b8e5cb1961461f31aa3f597e5e1adb652a72f747502c39390ff9e737034a058c8b11d06863b6a5b5f18a769141cd8150b3ea85bb1fcc5cea71202f61cca8762fc37fd67889befbc47916f913e2eaf895c32be1a951878ab4084c3d1edb2064b915ad9e3bf068fd9971f373c39af676c5edce063465935625bca670a695cfa507b62838d46af4a3a09099647d87c4095d6987040ca113d938096f7e41421c4c42540e606f60e3c50871af5464d332b97615d22822f5b4de3b53ce8d075e087c3877da3a120a16f7843f00a382283056c5d46ae2fc0e6a171f53b4d0a505614245e4bd03f8ce78719740161abd0ec71e84075ae40c4eef290dac819a9f645843f06cc21796aab1595932bc05ac984401060207100fdac93fff9badd829fc74e4aa0ff13ad6de5f506abb0b92ca5094bc5701d737ab28659315e27d070c76c7706c6f59bade15915c6e8af214bf5d33e5079f8731299b0517e571656bba9a7f6dac72cbcb797357071cb2b1f3a2e8bc99f014ac31b7061759a41b78bedc543d61b02123bdb85dafed55536872f1a0dc38ee17408b28d3068b3380b45b8c9b7731b685ce690733fa7bb0b046762bc834cb6d3efce14c8bfb6afa611310c3113d3b013e4093659a2a48aa3089a1318ac8fcd09fff675f13a5233ab6384cf7925e71f21e353542b173c100abbcec5bf92fc11bb09f325d4ec782f0696e264e9cb221f2642675a442a6816d0aeb80f8e8d1aadd9fb58a0e922db618dcdaf16363fdf09978b0534ae4e82f629afd76021debd8d45523748fe3186c4d48eff1b6595de700c0a8c40dc8a16f1bb53369ee838147f0d5a4befc78d9967033a18982453c17291a958380f29e1e3b465b61fbe779710a948056c77454035a6a5668ed000848adbf7b32ed3ef3b468684f935e395e234f0ae038dd5e307672c0307feca67877cf94fa61a02dbed70dc0af8062bc7c2f2f28badb1efbfbab9d894e0faada08742527d8eec99a24809289b8d172f2671044a3f8e7af52d54d1a047608eed3812c87afe68392f8fed5d632ed3067b5f2044004674ff317dff9712ba114861b3f4dfa85bfe5c5945dca7edbfafffa8b31a713bfd00ceb01bcfebc88b71a24cde8aa420dd9e24782fcd074323667037681f430b19c6d33960a6e64132617487789c83e6d8e4e6368ef7ccc33cfd4d2e793c1cdd85220f79849282aa3b0647b633c35cc41ce2a95ad6e88b2514bc406caefc067c2c6b813640760aebbd31967d290c7465460a5653606ce7f031560448d18fa8a801cbd322a041491269b000a4c300ef2d5b2ea6737a19048f88fe9c3fe396b494606614240e4d40299d791fd209208b152306cdf5dd3a1b2d740b6c82a95663ab48899b29398a0471b01a6f21a4178f5ea3282f78a4c53cb4e2c55ea6305b8c31ba87014f627ab418a8268d05ab608d25a614c4e16302be97ca3ea984d8ce30fdaa5c0c1be976ed17e200e18572fd2aa32af070b9c0e92bf578edbd0999f078f2d5890d6dff137366e0b770cbdb3bf337f9dffd1d9df9e927552ac556c096fede1f78c0f3437be08b9b4c415b37372f8eeec4522a45b777fc42fb3de3022f276ae2a14c0be67a7b50aa7b88dcf1b9a2969ab6facd3171091137f5595ab72ea3f6794b6cd451b9fbc8ff63f5ae08050318651b4b7396e24357069e5b5b98d5e2420a1608d2bec7fc8a6291541b2e582ffccd9fe8f46829eec756351542037533ee005b49cf6ad720508c8ba52241df29490f736d43e4499dc19456630ab1b3f0523e5d3086e33f6894a67849ddf5df832343e2f25a51258ecd0976ab807c5c725c497551eaf7e18ea9b8ae42d58fb6036bb473f25cef48bac20cafb2680ce68f539de2aa25b514182a920363c7fe185fb2ae5bdd073fed91413cebcd6fab0042006aa984f132442a3eabb8b916221dc04e28b6fbc769f47af0ce4b48d8c26a0922ebc74decb4704d5081f3de44469ea1cee6479ec013bc7d3d01acfd074a1dd14714cc76ed0e0d40c0ae2e9272bc569d16d873945ea9b970472d1f14c06176b346393d85f2e250821022e6e0afc37b7de9ecc600defee81e84e6488a01327726484df413200d2452ceb4bf5cb646e4aa7414421005864f56e8f2ba147388b8b1baae2181b46c35d274835952f653c063266fff48f5b2544b4e796dcca215c4751d7cd32aea23ab9dfa3a734b207f7d242c9b233dc789acbdbcddd87d81a3c6e19ab6e80903b6ee969c979e474d4d9d6eefbdff0aca5705d5b6cc46ae392b43baf10b1c58db7c5f6a41c4f6f160e6c418f015f5ce902a777b9fb3a68c933ad43b785a713d592f90533d9e35cd46a52457821e478e81299fb886670c073434ab388a983c821f435c6a5e4fbe5467a51b4b64ffda543c596efd8ac17da0e35858ab328ca385342e6f48fea6e59cec55b96ee5a434e15db34246d5dd739ee47cf7327444b4a8ed9a34ad63ac5b67ac91fe50034d2c8040e13d0bc09a982d1dea672fb15741e8b4c32850ee74fed103e72ff6a2c209e144d6f40fc5000750037d9c8a26027943f81d6d18d51a62dbe6d9f5fa509026d84e1a04759e7bc5fa6a56810ebc0efac3e0b664050b40cb81d45e314c7f6359ae273dea19615be0231e71eb9b371b03e1927294f235df8258efde83e268cdf6287013c856c50dd270644dc0fe66bca434d88599ba2979ac98a49a1cbb1597fe888ce001365bbd36205714f8fe02c520a28d79e438443f801d2fbd75181939935fa514ab474be8be724be174ea15808bd311f77770c06c9e47aa5c333f1221c534263a48e9edec4f96655ccbfd2bfa0144eb9acc66c0c7ed770c6e994e39ea71ef0eeefc85d5446b537c4d444cc97ce842fa576526a5e72fcaae3030184fef7d61c964f58813633eb0d767591785324ae5555d29b2f41f94b7eec44ccb3395ac00e102be44dd5087956e4c75fc8520dc0b400f17c2254c126098aa7e4de23a4d1de8bee988069f3a55a21a51f1095105bd73fa67a7e61c9d973f8913b18f518b3a7a58b868f2085105d10c2c0bb7bc953fbe73248a20a3a13c1e60bab87f8a77e881d91e5c7610fddfdba3a12225e5abd6e314320936c28990e5a5e2b41de8a5fd0a62d7ceb97c4720753980c90d2239edf31e5a5b2d1ffa3670ef5ee81f55183e3507deb6d7fd3e725c1cb537f1f9af7efe8dc88a5f88699887a64c1c3b48c64f4af05f8b9a6438b1e138b6c5f16393a8ef1fe294a48cb441fa97363a4b7c9813a77b81b37ee8a8b15011b00846bffcab0d63ea748d98560edcd6f0cfafdae5954685387b758a8be894be25f8ff7ee14b97325172efd3540b6330c1614cc9762544042525b2bcf5746efe9d77e7d1b44779a5e70b50c56451d49b32f8ebe8d8988d6e717b5b66a73c99477098e1ebd46733d8bd4e601533e9ae10c12d2816bc6570a0b1b4cc5c8fadaa4bdccbc2a3c7ee08da116a07d5da8386e6b308126725e3bb4932e8e1c580f683f2b287788e6019f6a3bc988cffbcdcac0710c073069fa833dccfcc8a0f99d28d7fa69e19fc2c66db3611ea6f6e26091e414017a87aca34b52fc55c0e82201c58f3c4ddd6eb20d4b937df0011c764c38180c77f7906345ffb1bc2481a9a71e95478efb068c0f729103295395fe4e520409d1e34bcc11047f4232109c4bf58e6cc8468729f933d61c4838c84f2e51d1874d888d25104fb8907dc662506badf3468df6815e29b8cf87471827046b12ff4b32d1e2f9554398d6fec64a80bf07c646ea392a01a9100ed91fd36ac1aff05f9411b0ffd7fbc405edf970f897e9ca2d50ec34c635997e90d19fb5d157720f64b53bc942d84c9ff7ecbf4cd362b36711bb239812135bb53fd734f4f49752579105e281f3c9bb3e179e5dc07878bbbdc0947cba7c2d7b3082ea3fc49a9d83006827b2850485ca538215902ce96c835c7331f6e7241df62e5cadd5b213d7214951a8583833cc814db2ad9d53a89852465de9e185310955c8b0ca70440022dbaaf57f94b311fd4ea6f804c0f3e09131aecca1ec0632e0d7f51afa28878254cd26fa53119347fcff91f21abee456623734fb7b5374aafd46a76cba87041ca4cd9a70117ad157a6f0d80b06f8abb937c1f4c407994c487be113a0b76516989dfea1c8960227c5ed2037001c4ae4a1255a37916b07c73f84ecb0774f9b1664c3097043d936b8f86e4e1169a69ed9642f3f42f0bd978f870b7a8b8a77363c935ddba62db8122aa89ca7a31c2e64116ac055835f260c9909ccea7a8e4b2b9b21b3bfb393ad84a1008b10eae75daa7082b6b1ca529317d83dec85e6d26e01dbac488ca60af61be855014be1a31602a3be743a619f27dec9be89d5d012273f40d8f5f24aa14eb0a052e06674e20a33cebdbc9f6d3fabef0a1457cfcc1934ea78acdc93b31b0ceeec14a8b82a778a2ff01373d5d798d8686634cad90995475f6b9516b652fd3d7ebf89461a18f239747010baa7ea9162fad6feb1a5a8ca8ab00b33d8f511948ec004b4f1d8a88119069968118906c9cb16947e6466cf02cbb67b3e5c1078a7a3013a2d4dbcce04f4f83184a56c53df2a9f6b13b18392cb35ab054251518756c7707ba7d122ab0e872c9658db3167434a413a3d1a0154e53b660a270ffd9c3680d854ecf41ed637366e188630a4a33d1f7f0ce528cde65b51e42375024e2892f5613c5c1648a3425e713a7fec772355deef1515d4b839152a69d2a04477456c8e32de38a7b365cd7cac98240f47b29605838a62911f3b0afe0219dfd85a1d4eb0919ee0e944e48edd913ede081c769ade7e003785916b6aa8392019300e9de3019f8360574c0b59373e8cc97ce8f8a9d4bcbfecfae97890e955a1d395f8866b69aa1fc4d762075aab9cc7f02de0cb39e26a3ce8de63bd86ac238a94b96ea625cb2abdad9adf1a1998b410690ac48f92462ee997d1dfd30717f07ef368d0ff7d0e76297a410477a502c56bb8d5dbc464cab8165a8b1f28c8403b89205db9611ab4632b8d36bf726522de64c074831ce24a46523cb9f425149f6adf19a9a8b90e1ae59726e19a9fccfa885c957f2d768d663e6bd6cb2a81a829fcb59c6b50dc1b3fb3854f4d4f5382e5ab7768f21e3cf9bf4d67aeece25e00a07c2f095508f75defdf8f02855916f1af2d10cb5c624e27349696a9dbee336380ec1def04174218493332fefa47bbdbefde0f84768c260620c209e6632d305e07fd8beacf69e737f100a242e92cb1dc362a41f60b814a006b5910da961f816b60c658d82c45b235bb6deb24335971fa7b05d5821cb3246568034f54241765f9207a7ae30ebdb9171b8b0aa750095552a0fdb34288a2a45e19b6722b8bd1b0d51b73a50e6a333ff67e66a36880eb2148296c032454eb1b04c023caacbaf215dc049c8ac96334e163d8487e8ad576dd2c19d9d067fd78181407e907e34e625b4a6911f437a3a2f714f4b12807c1e2ae876c45cdfb25bc3df7a89a0ad179906644c253f6ce3afcb0bdf8d60e9dfc40fdfe0604d71eec4c21aa9cfe769a57b2fa453a4c1dc0025d2006d4fa5c51694e5c68e601d0fe1bec94b566e70d33d24d9f2079ebaead15915d931c9f925b14a4b7cf96d2c15bb373f1469b8c82fc0d8244cf841ad262a8c2a83ede69738f136edc452bda82e4f20b64ff8b9015ed73c32193ff9041860e8543d5af18833b4672860d23eed8b25cad8ecceaba4237b7e5e01be2084caa9de9092c001a15463bb6354cc7c3d21f2849b24e4215b4c3f23f2c94d36568840605d6b0dd1dbf6c3aca47abd3d640290628f189192be94d5c1dd0bfaf445781c85da0509eb4b1937e4a1d0dc2a18f7c417bc2344d3e1a1d38d1fec462bb3f8eecd1cc6068b1be349f39d42f0c5938f823cd37651df324ac31ff604e021abddfa7a57ad445d01ad434f97b776d8d4ef460714bd2aff528a73795d3ce9fecda6d94c74b857544b84cc03a26eed59b1f2f0188a6d9b6e04c6a1b8683ab75acbade2facea552f14e8845d7395bf81c58bc324795527280fdb99796aa41d6bd92a82eee812f4a1aa8aecbc90c3a298e2749d1c7ed7ea68cbc54ede310093acaf30fa37a0add2983a94fe0e70539588240fba297ad1f2f2ef30fa1b3595aff6e586fe5d527d8d4036c8489b4741e90b94f0a41ea5c4209d120df43a98488a67ab9d3eed4206fca4878b206b43ec193f085ffdb3a0fb5d0fd04d44bc524260d99afd0be26569946aa76a1287d8e911a78d1f1c18cb2b81b7f264253b09a355f94e7e851a68e7c1cb1ada23137b309b295b6c51d99b638a5b5a6c988cbae0844b93594e1b5761adbef0234bbf4b094f6f802bbe217029ee65a6e0ae4119a955fe4174c4f34ffe723c6f31942fbbb0320d7bdf204ed34869c382219705d35b9019b0ce4c8b3bae72c56303a314cf497334f6eb6eebc449e7e95a50eab56439a626c81f106b2032a5a4e76fd1c455bda921712b4819a8827c4517a29106a83d1ec535b94097fbc80500d13aa873bb84bdde0d3e78ca01e88b7c43da42953675a3152434caf7b4fa7c10e20061ec3353809c45325076ca42fdd7885bcbf8a93aaf1f4a4042f7ae5d4304e4b690c237c89f86b38b1123661ff89df59c9cf143dc314a6137e2448293c8a5f388e0386476ed28a76048b8911101d17ff2d7038eb12b8214db73f2849516189039c26d2a928c0769b3ea0e6564e8acbd1318aa3d33534e6f6e2e22cf14bb4e00ef121f3ec95150ad0979fd120cf9cafd1435c8f5698f4e44eb5b0ccf823dd890e70eda7393bf45daa52f12ab7bc927f031f79a570889b6b3bc3c5985a3b132e70824f4df0eedf749176ea169f0541441315f7a749f88dd2c6ec87ebe728550d2905f909bd440cf032da45f6deda7a22c839b015a732cb21eba03b074316d278cff03bfae6e083d15a77632066fd65261600e443ea8815565f07161ff2380ab82c01fc9aa5a84b8015aeacf4e3e1d69314de932b7088ace8f579ef4ba389975d05677b5417f6d0394dbc5e4ea351dcff2e79e798faae0062b2400ac36a42f9f38153053a4e14154a741a05a0010fa46f9416ddea29133f014ac415c947c8a8bb602aec9b4d2a18e25a5a77271d34f5f9bce14316374101a57c25cf85a01e7ce4dfe1e4fe3193700595473c8e5a3da9c67faba5e9c9529c20560797f7142c529af7d329ed3f9ecae21816aa8a3073d371d9c315e789d26795f5c14805b28c5ececa85e044ed79955feb0a48f1f25a645e1636</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google评分卡💯及自评</title>
      <link href="/posts/grade/"/>
      <url>/posts/grade/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li>Google将技术能力划分为 0~11 的等级</li><li>自我评估技术，判断下一步需要作出的努力</li></ul></div><h2 id="↓-Self-Evaluation">↓ Self-Evaluation</h2><table><thead><tr><th style="text-align:left">↓ 基础要求</th><th style="text-align:center">grade</th></tr></thead><tbody><tr><td style="text-align:left">熟悉数据结构与算法</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">熟练使用 C++11</td><td style="text-align:center">3</td></tr><tr><td style="text-align:left">熟悉并掌握 C++高级特性 (14/17/20)</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟练使用 Python 等脚本语言</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">熟悉batch、Shell、Linux常见指令</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟悉MySQL等数据库的设计、优化</td><td style="text-align:center">0</td></tr><tr><td style="text-align:left">熟悉编译原理、编译优化</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟悉 vscode、sublime、vim 等IDE、Editor</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">熟悉 Jenkins、TeamCity 等 CI&amp;CD 平台</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">熟悉 ChatGPT、CodeMaker 等 AI工具</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟悉Linux内核，如进程管理、内存管理、文件系统等</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟悉网络协议和网络编程，熟悉websocket、HTTP、socket、TCP/IP等</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">↓ <strong>C/C++领域</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">内存管理、内存分配、ASan原理、内存错误及排查</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">模板、SFINAE、type traits、metaprogramming</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">并发、memory order、同步、互斥、boost::asio</td><td style="text-align:center">0</td></tr><tr><td style="text-align:left">编译优化、SIMD、ISPC、CPU性能分析</td><td style="text-align:center">0</td></tr><tr><td style="text-align:left">C++编码规范</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">↓ <strong>Python2/3领域</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Todo</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">↓ <strong>工具/pipline领域</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Jenkins 日常工作使用，无阻碍</td><td style="text-align:center">3</td></tr><tr><td style="text-align:left">VSCode 日常开发使用、多个插件开发经验</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Vim 熟练使用、vimrc配置</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">Git 基本的GUI、CMD操作</td><td style="text-align:center">2 ~ 3</td></tr><tr><td style="text-align:left">↓ <strong>加分项</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">具备内存优化经验、熟悉linux内存分配</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟悉GPU使用，或有底层基础库（CUDA，mkl、openblas等）优化经验</td><td style="text-align:center">0 ~ 1</td></tr><tr><td style="text-align:left">良好的系统设计能力，如 performance、reliability、availability 多维度考量程序</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">熟悉机器学习平台相关工具，比如k8s，kubeflow，mlflow，automl等</td><td style="text-align:center">0</td></tr><tr><td style="text-align:left">有视频解码和渲染开发经验者优先</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">有存储系统、分布式系统等底层开发经验</td><td style="text-align:center">0</td></tr></tbody></table><br>## ↓ Google-Standards<table><thead><tr><th style="text-align:center">等级</th><th style="text-align:left">标准</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:left">You are unfamiliar with the subject area</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">一窍不通</td></tr><tr><td style="text-align:center">1</td><td style="text-align:left">You can read/understand the most fundamental aspects of the subject area</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">理解基本概念</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">Ability to implement small changes,understand basic principles and able to figure out additional details with minimal help</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">能够实现一些小改动，在别人帮助下钻研更多细节</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">Basic proficiency in a subject area without relying on help</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">基本掌握和熟练使用</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">You are comfortable with the subject area and all routine work on it</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">足够精通，足够应对所有日常工作</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">An even lower degree of reliance on reference materials. Deeper skills in a field or specific technology in the subject area.</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">深耕某个细分领域</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">Ability to develop large programs and systems from scratch</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">独立开发大型系统</td></tr><tr><td style="text-align:center">7~10</td><td style="text-align:left">脚踏实地慢慢来吧…</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【网络】HTTP协议进阶</title>
      <link href="/posts/http/2/"/>
      <url>/posts/http/2/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE">专栏：透视HTTP协议</a> 墙裂推荐 ⭐</li><li><a href="/posts/http-1/">HTTP协议入门</a></li></ul></div><div class="markmap-container" style="height:500px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;HTTP数据编码&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#MIME-type\&quot;>MIME-type</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;&amp;quot;Accept&amp;quot;&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;&amp;quot;Content-Type&amp;quot;&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;HTTP大文件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;数据压缩&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;chunked传输&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;HTTP连接&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;短连接&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;长连接&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;<a href=\&quot;#队首阻塞\&quot;>队首阻塞</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie\&quot;>Cookie</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie原理\&quot;>Cookie原理</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie生命周期\&quot;>Cookie生命周期</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie作用域\&quot;>Cookie作用域</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Cookie应用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie应用：身份识别⭐\&quot;>身份识别</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie应用：广告追踪\&quot;>广告追踪</a>&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP代理\&quot;>HTTP代理</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;<a href=\&quot;#代理字段\&quot;>代理字段</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;<a href=\&quot;#代理协议\&quot;>代理协议</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;<a href=\&quot;#负载均衡\&quot;>负载均衡</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;Cache&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;<a href=\&quot;#Cache：浏览器\&quot;>浏览器cache</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;<a href=\&quot;#Cache：服务器\&quot;>服务器cache</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;<a href=\&quot;#Chrome调试\&quot;>Chrome调试</a>&quot;}],&quot;p&quot;:{}}"></svg></div><h2 id="HTTP数据编码">HTTP数据编码</h2><p><font color="#FF1E10"><strong>todo</strong></font></p><h3 id="MIME-type">MIME-type</h3><p>使用svn更新的时候有一栏会标注 <code>Mime type</code>，可以观察到除了常见代码文件外，都是以 <code>application/octet-stream</code> 格式传输，它代表未知的二进制数据。</p><p><img src="/images/svn-mime-type.png" alt=""></p><h2 id="HTTP大文件">HTTP大文件</h2><p><font color="#FF1E10"><strong>todo</strong></font></p><h2 id="HTTP连接">HTTP连接</h2><p><a href="/posts/http-1/#TCP">前面说过</a>，HTTP协议 是运行在 TCP/IP协议 之上，因此每一次新的HTTP连接，都需要经过TCP协议的 <strong>“3次握手 &amp; 4次挥手”</strong>，这无形中降低了HTTP协议连接的代价。</p><p>因为 TCP位于传输层，HTTP位于应用层，所以可以用如下的类比来理解连接的代价：</p><ul><li>开关机：TCP连接</li><li>使用电脑办公：HTTP连接</li></ul><p>每次使用电脑办公，都需要打开电脑，在使用完毕后又需要关闭电脑。这就好比 <strong>HTTP 短连接</strong>。而更常规地做法是，保持电脑的始终开启，这样利于随时使用，这就好比 <strong>HTTP 长连接</strong>。</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/assets/57b3d80234a1f1b8c538a376aa01d3b4.png" alt=""></p><h3 id="Connection字段">Connection字段</h3><p>当HTTP请求采取长连接时，在响应报文的 “Connection” 字段会标记为 <strong>keep-alive</strong>，此时服务器不会在短时间内断开连接，但是为了降低服务器的无效占用，Web-Server 往往会在一段时间内若没有任何数据收发，便会主动断开连接，断开后会收到 “Connection: close” 的字段。</p><h3 id="队首阻塞">队首阻塞</h3><p>因为 HTTP协议 采取 “一问一答” 的模式，即典型的 <strong>FIFO</strong> 结构，当队首的请求因为处理太慢而耽误时间，那么队列后面的所有请求也会相应地被阻塞，这就是 <a href="https://en.wikipedia.org/wiki/Head-of-line_blocking"><strong>Head-of-line blocking</strong></a>。</p><p>类比理解为：食堂排队打饭，每次刷卡是一次 Request，每次领到饭是一次 Response，每处理完一次成对的 Request-Response，队伍才能往前推进一步。只要前面打饭的慢了，后面所有人都会受影响。</p><p>解决方案是：并发连接，即增加打饭的窗口。这里不详细介绍。</p><h2 id="Cookie">Cookie</h2><p>前面说过 <strong>HTTP连接 是无状态的，即没有任何记忆</strong>。即使某个请求会让服务器出现500的错误，下次请求时服务器依然会 “热情招待”。这迫切得需要一种缓存的机制，Cookie应运而生。</p><blockquote><p>Cookie 是服务器委托浏览器存储的一些数据，让服务器有了“记忆能力”</p></blockquote><h3 id="Cookie原理">Cookie原理</h3><p>Response报文中，<strong>利用 <code>Set-Cookie</code>字段发送多个 “key=value” 形式的 cookie值</strong>，这些会由浏览器负责记录下来。当浏览器下次访问同样的地址时，Request报文会自动利用 <code>Cookie</code>字段将本地缓存的 cookie 发送给服务器，这样服务器就知道自己的身份了。</p><p>因为 Cookie 是与浏览器绑定的，如果你换个浏览器或者换台电脑，就会丢失之前的 Cookie记录，此时服务器也会重走一遍新的 <code>Set-Cookie</code> 流程。</p><h3 id="Cookie生命周期">Cookie生命周期</h3><p>Cookie拥有自己的生命周期，它通过 <code>Expires</code> 或 <code>Max-Age</code> 两个字段实现。当超过标记的有效期后，浏览器会自动在本地删除记录，不会再通过HTTP请求发送给服务器。</p><ul><li><code>Expires</code>：记录“过期时间”，如 <code>Fri, 07-Jun-23 20:00:00 GMT</code></li><li><code>Max-Age</code>：记录“保质期”，单秒是秒。将浏览器收到相应的时间加上 <code>Max-Age</code>，即得到 <code>Expires</code></li></ul><h3 id="Cookie作用域">Cookie作用域</h3><p>浏览器会存储大量的Cookies，因此需要标记其作用域，即发送给哪个服务器或者URL，常用字段是：（不清楚的推荐阅读 <a href="/posts/http-1/#URL">HTTP协议之URL</a>）</p><ul><li><code>Domain</code>：域名</li><li><code>Path</code>：路径</li></ul><h3 id="Cookie应用：身份识别⭐">Cookie应用：身份识别⭐</h3><p>登录taobao等电商网站时，浏览器会自动保存你的登录账户（或密码），就便是利用cookies实现的。它同时还会记录你的浏览记录和购物车。</p><p>大概格式为：<code>name=xxxxx....</code></p><h3 id="Cookie应用：广告追踪">Cookie应用：广告追踪</h3><p>当你浏览各种网站时，它们会根据你的访问喜好作行为分析，然后定向推荐一些图片广告给你，这就是利用cookies的原理。<br>这部分成为 “第三方Cookie”，属于搜集用户隐私的行为，浏览器经常会弹出确认框以请求权限。</p><h2 id="HTTP代理">HTTP代理</h2><p>传统的HTTP请求是 <code>Client-Server</code>，现在常常有“第三者插足”，即在中间会引入一个 <strong>代理服务器（Proxy Server）</strong>，它的角色是双面的：</p><ul><li>面对上游：充当客户端，发送请求</li><li>面对下游：充当服务端，响应请求</li></ul><div class="admonition note"><p class="admonition-title">类比：消费者（浏览器）—— 便利店（代理）—— 源服务器（批发市场）</p></div><div class="admonition note"><p class="admonition-title">定理：计算机领域的任何问题，都可以通过引入一个中间层来解决</p></div><p><img src="/images/proxy-server.png" alt=""></p><h3 id="代理字段">代理字段</h3><p><strong>代理服务器 通过字段 <code>Via</code> 标明代理的身份</strong>，在HTTP请求的链路中，每当报文经过一个代理节点，代理服务器就会将自身的信息追加到 <code>Via</code>字段的末尾。<br>另通过如下字段标明其他信息：</p><ul><li><code>X-Forwarded-For</code>：追加代理的域名</li><li><code>X-Real-IP</code>：客户端真实IP</li></ul><p><img src="/images/proxy-process.png" alt=""></p><h3 id="代理协议">代理协议</h3><p>针对代理的HTTP请求，<a href="https://www.haproxy.org/">HAProxy</a> 公司推出了专门的代理请求协议，The Proxy Protocol。<br>其基本格式为：开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。</p><pre><code>PROXY TCP4 1.15.115.4 110.42.228.178 32200 80\r\n</code></pre><h3 id="负载均衡">负载均衡</h3><p>当一个区域所有的消费者，都蜂拥而至一个批发市场购物，就会造成堵塞排场对的现象。<br>因此 “负载均衡” 的解决方案是，在每个居民集中地地区设置一个小商超，或者经销商，而自己只负责货物的批发和调配。消费者 择近择闲 选择小商超去购物即可。</p><p><strong>通过中间的代理服务器，将请求均匀合理地分散到多台源服务器</strong>，能够有效提高系统的响应速度和利用率，这就是 负载均衡 的基本原理。</p><p>而如何挑选转发的服务器，有如下的思路：</p><ul><li>哈希：如尾数单号的去A服，尾数双号的去B服</li><li>轮询：对于新请求，分配一个最空闲的Server去处理</li></ul><h2 id="Cache">Cache</h2><div class="admonition note"><p class="admonition-title">两句话讲清楚Cache</p><ul><li>浏览器Cache：消费者家里囤（上次买的）货</li><li>服务器Cache：小商超囤（上次卖的）货</li></ul></div><h3 id="Cache：浏览器">Cache：浏览器</h3><p>当浏览器频繁每秒请求同样的数据时，如果服务器不厌其烦的依次发送，会造成很大的性能和流量浪费。因此需要客户端（即浏览器）的缓存。</p><p><strong>一个带Cache的HTTP请求流程是：</strong></p><ul><li><p>浏览器检查cache，若有则直接读取，若无则发送新的HTTP请求；</p></li><li><p>服务器响应请求，并返回资源，同时标记资源的有限期；</p></li><li><p>浏览器接受请求，并缓存资源；</p></li></ul><p>而<strong>标记资源的有效期字段是 <code>max-age</code></strong>，即cache的生存时间（秒），过期则被浏览器自动销毁。<br>其他常见字段有：</p><ul><li><code>no_store</code>：不允许缓存，如一些高频的秒杀字段</li><li><code>no_cache</code>：使用缓存前，检查是否有最新版本</li><li><code>muster-revalidate</code>：不过期则直接使用缓存</li></ul><h3 id="Cache：服务器">Cache：服务器</h3><p><font color="#FF1E10"><strong>Todo</strong></font>，与HTTP协议关系不大，可以了解 Redis、Varnish 等缓存技术。</p><h2 id="Chrome调试">Chrome调试</h2><p>Chrome浏览器提供了丰富而强大的调试功能，按下 <code>F12</code> 或者右键点击“检查” 以进入调试页面。</p><img src="/images/chrome-http-debug.png" height="400">]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Computer Networking</title>
      <link href="/posts/network/"/>
      <url>/posts/network/</url>
      
        <content type="html"><![CDATA[<p>计算机网络大纲，HTTP/TCP/UDP…<span id="more"></span></p><div class="markmap-container" style="height:425px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Network Model&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;TCP/IP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;OSI&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Protocol&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;HTTP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;/posts/http-1/\&quot;>HTTP协议入门</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;/posts/http-2/\&quot;>HTTP协议进阶</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;TCP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;UDP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;KCP&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;Web Server&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Apache&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Nginx&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;Performance&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;RPS：每秒处理数&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;TPR：平均响应时间&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;Concurrency：并发量&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;Tools&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;Telnet&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;<a href=\&quot;#/posts/2G7VBZ2/#curl\&quot;>curl</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;wireshark&quot;}]}],&quot;p&quot;:{}}"></svg></div>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
          <category> Network </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【网络】HTTP协议入门</title>
      <link href="/posts/http/1/"/>
      <url>/posts/http/1/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE">专栏：透视HTTP协议</a> 墙裂推荐 ⭐</li></ul></div><div class="markmap-container" style="height:480px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;HTTP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#Hypertext\&quot;>Hypertext</a>（html）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;text&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;media&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;hyperlink&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#Transfer\&quot;>Transfer</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;client&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Chrome, Edge&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Telnet&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;server&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;<a href=\&quot;https://nginx.org/\&quot;>Nginx</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;<a href=\&quot;https://httpd.apache.org/\&quot;>Apache</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;CDN（内容分发）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\&quot;>负载均衡</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;加速访问&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;<a href=\&quot;#Protocol\&quot;>Protocol</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#TCP-IP\&quot;>TCP/IP</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;#IP\&quot;>IP</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;<a href=\&quot;#TCP\&quot;>TCP</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;<a href=\&quot;#DNS\&quot;>DNS</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;<a href=\&quot;#域名解析\&quot;>域名解析</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;<a href=\&quot;#DNS缓存\&quot;>DNS缓存</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;<a href=\&quot;#URL\&quot;>URL</a>（网址）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;<a href=\&quot;#URL\&quot;>示例⭐</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP抓包\&quot;>HTTP抓包</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;wireshark&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP报文\&quot;>HTTP报文⭐</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;start-line&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;headers&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;body&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP方法\&quot;>HTTP方法⭐</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;GET, HEAD&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;POST&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP状态码\&quot;>HTTP状态码</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP特点\&quot;>HTTP特点</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;.&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;.&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;可靠传输&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;明文传输&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;无状态&quot;}]}]}]}],&quot;p&quot;:{}}"></svg></div><h2 id="HTTP协议">HTTP协议</h2><p>HTTP 协议是 <a href="https://en.wikipedia.org/wiki/HTTP"><em><strong>HyperText Transfer Protocol</strong></em></a> 的缩写，它是一种用于超媒体信息传输的应用层协议，是互联网通信的基础。</p><p>如何通俗地理解 HTTP协议 呢？</p><div class="admonition todo"><p class="admonition-title">如何理解新概念?</p><ol><li>任何技术思想，在现实生活中都能找到映射</li><li>巧用 “类比” 的手段</li></ol></div><h3 id="Hypertext">Hypertext</h3><p>在互联网早期，传输的信息只有简单的字符文字，即 <code>Text</code>。随着信息爆炸式地增长，网络需要传输的信息被扩展为 图片、音频、视频等等，这些就是超文本。<br>超文本的核心是 <a href="https://en.wikipedia.org/wiki/Hyperlink">超链接 Hyperlink</a>，通过互相引用而形成复杂的网状信息结构。</p><h3 id="Transfer">Transfer</h3><p>HTTP 是一种 <code>Request-Response</code>协议，即将信息在 A、B 两个点之间双向传输，因此有两类参与方：</p><ul><li><code>client</code><br>http请求的发起方，通常指浏览器（如Chrome、Edge）</li><li><code>server</code><br>http请求的接收方，又称为 <code>Web Server</code>，如 <a href="https://nginx.org/">Nginx</a>、<a href="https://httpd.apache.org/">Apache</a> 都是常见的服务器框架</li><li><code>CDN</code><br>client和server之间通常不会直连，而是经过 <code>CDN</code>(<a href="https://en.wikipedia.org/wiki/Content_delivery_network">Content Delivery Network</a>) 这个中间商。它能够实现安全防护、负载均衡等常见功能。</li></ul><h3 id="Protocol">Protocol</h3><p>HTTP 是众多网络协议中的一个，先理解什么是协议?<br>以毕业生签署的“三方协议”为例，参与对象是多元的（自己、学校、企业），同时协议还会规定各方需履行的义务，以及该做什么和不该做什么。因此协议的核心要素是：</p><ul><li><p>多方参与<br>client、server、中转者…</p></li><li><p>通信规范<br>如规定 <code>Get</code>、<code>Post</code> 的请求报文格式，如请求的错误处理等等</p></li></ul><p>在 HTTP 的发展历程中，也经历过很多大版本的迭代，如 <code>HTTP/0.9</code>、<code>HTTP/1.0</code>、<code>HTTP/2</code>、<code>HTTP/3</code>等等。</p><h2 id="TCP-IP">TCP/IP</h2><p><a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">TCP/IP协议</a> 是整个互联网的标准通信协议，它实际上是一系列协议的统称，其中最核心的是 TCP 和 IP，这里篇幅有限只作简单介绍。</p><h3 id="IP">IP</h3><p><strong>IP协议（<a href="https://en.wikipedia.org/wiki/Internet_Protocol">Internet Protocol</a>）主要解决寻址和路由问题</strong>，它提出 <strong>IP地址</strong> 的概念来定位互联网上的每一台计算机。因此可以将其类比为电话号码，而整个运营商的拨号系统就是一个 IP协议。</p><p>IP协议又分为 IPv4 和 IPv6，大部分仍在使用前者，即IP地址是4个用冒号分割的数字，例如 <code>1.15.115.4</code>。之所以出现 IPv6，是因为v4分配的地址已经捉襟见肘，不够整个互联网的使用。</p><h3 id="TCP">TCP</h3><p><strong>TCP协议（<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol</a>）是一种 传输控制协议</strong>，它基于 IP协议 之上，提供可靠的、字节流形式的通信，也是HTTP协议得以实现的基础。</p><p>之所以了解TCP/IP协议，是因为HTTP运行在前者上，因此又称为 <code>HTTP over TCP/IP</code>。</p><h2 id="DNS">DNS</h2><p>在TCP/IP协议中，通常使用纯数字的 IP地址 来标记计算机，这非常不利于用于的使用和记忆。<br>因此 <strong>DNS（<a href="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System</a>）域名系统</strong> 应运而生，它使用具有实际含义的名称来替代IP地址（即英文+数字的组合，也可以是汉字），例如：<code>95.211.80.227</code>是IP地址，<code>nginx.org</code>是其域名，两者指向的是同一个web服务器。</p><h3 id="域名解析">域名解析</h3><p>以 <code>www.apple.com</code> 这个域名为例，当用户尝试访问该域名时，会经过至少3次的DNS域名解析服务器：</p><ul><li><em>Root DNS Server</em>：管理 <code>com</code>, <code>cn</code>, <code>net</code>等顶级域名的IP地址。</li><li><em>Top-level DNS Server</em>：管理 <code>apple.com</code> 的IP地址。</li><li><em>Authoritative DNS Server</em>：管理 <code>www.apple.com</code>的IP地址。</li></ul><h3 id="DNS缓存">DNS缓存</h3><p>目前全世界有 13组 <code>Root-DNS-Server</code> 提供顶级域名的解析服务，但因为全世界的网民都在请求，会造成系统的拥挤并降低访问速度，优化手段之一就是利用 <em>DNS缓存</em>。</p><p>当你已经访问过 <code>www.apple.com</code>，操作系统就会在某个文件（如下↓）<strong>缓存解析后的IP地址</strong>，这样下次访问时，就不再需要经过 DNF解析服务器了。</p><ul><li>linux: <code>/etc/hosts</code></li><li>windows: <code>C:\WINDOWS\system32\drivers\etc\hosts</code></li></ul><h2 id="URL">URL</h2><p>通过 TCP/IP协议 加上 DNS 的组合，我们实现了访问互联网中任意一台机器，但是每台机器上的资源仍然有很多，如何对他们加以区分呢？</p><p><strong>URL（<a href="https://en.wikipedia.org/wiki/URL">Uniform Resource Locator</a>）含义是 统一资源定位符，即俗称的网址</strong>，如下是其组成格式：</p><p><img src="/images/URI.svg" alt=""></p><ul><li><code>scheme</code>：指定http、https、ftp等协议<ul><li><code>file</code>：本地文件</li><li><code>ftp</code>：文件传输</li><li><code>ssh</code>：加密登录</li></ul></li><li><code>://</code>：约定俗成的分隔符</li><li><code>user:passwd@</code>：明文身份信息，已被弃用</li><li><code>host:port</code>：省略端口会用默认值，如 HTTP 80，HTTPS 443</li><li><code>path</code>：资源的在主机的路径，也可能是服务路径</li><li><code>?query</code>：查询参数</li><li><code>#fragment</code>：仅浏览器使用，用于锚点跳转</li></ul><h2 id="HTTP抓包">HTTP抓包</h2><p>“纸上得来终觉浅”，我们通过在windows下快速搭建一个最小化的HTTP模拟环境，借助抓包工具 wireshark 来对 HTTP 的细节一探究竟。</p><blockquote><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/07%20%20%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%8C%E6%90%AD%E5%BB%BAHTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.md">搭建http本地实验环境</a></li><li><a href="https://zhuanlan.zhihu.com/p/82498482">知乎: Wireshark抓包指南</a></li></ul></blockquote><p>在启动本地web服务器后，尝试在浏览器输入 <code>127.0.0.1</code> 访问该server，然后按下回车，wireshark抓包（限制<code>http/tcp port 80</code>）抓包的结果如下：</p><ul><li>前三个包：TCP协议的 “三次握手”</li><li>中间四个包：HTTP协议发送了一个 <code>GET /HTTP/1.1</code> 的请求报文，Server回复OK</li><li>后四个包：HTTP协议发送了请求 <code>/favicon.io</code> 的请求报文，Server回复404</li></ul><p>通过http抓包，基本清楚了http协议的工作流程，<strong>核心是 “Requst-Response”，即 “一问一答”的模式</strong>。</p><p><img src="/images/wireshark-http.png" alt=""></p><h2 id="HTTP报文">HTTP报文</h2><p>通过wireshark也可以清楚看到http请求发送的报文内容，其全部由 ASCII文本 组成，非常容易肉眼阅读。</p><p>HTTP协议的 requet报文 和 response报文 的组成机构基本相同，由三个部分组成，每个部分由一个空行 “CRLF（0x0D0A）” 隔开:</p><ul><li>请求报文</li></ul><div class="markmap-container" style="height:220px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Request-line&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;Method&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;URI&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;http-version&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Request-header&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Key-Value&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;eg. Host: 127.0.0.1&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;eg. Connection: keep-alive&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;eg. User-Agent: xxxxxx&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Request-body（空）&quot;}],&quot;p&quot;:{}}"></svg></div><ul><li>回复报文</li></ul><div class="markmap-container" style="height:180px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Response-line&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;http-version&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Status-code&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;200：成功&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;404：查找失败&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Reason（描述原因）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;Response-header（同上）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Response-body&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;eg. name=luhao&amp;amp;password=1234&quot;}]}],&quot;p&quot;:{}}"></svg></div><ul><li>报文示例<br><img src="/images/http-request.png" alt=""></li></ul><h2 id="HTTP状态码">HTTP状态码</h2><p>既然 HTTP协议 采用 “一问一答” 的模式，那么响应报文内应该包含请求的结果信息，即状态码（Status Code）。<br>目前 RFC标准 规定状态码是三位数，即取值范围是 000 到 999，其从设计之初也有具体的含义区分：</p><ul><li>1xx：提示信息</li><li>2xx：成功<ul><li>200 OK</li></ul></li><li>3xx：重定向</li><li>4xx：客户端请求报文错误<ul><li>400 Bad Request</li><li>403 Forbidden</li><li>404 Not Found</li><li>408 Request Timeout</li></ul></li><li>5xx：服务端内部错误<ul><li>500 Internal Server Error</li><li>502 Bad Gateway</li></ul></li></ul><h2 id="HTTP特点">HTTP特点</h2><p>作为本篇的收尾总结，HTTP协议可以概括为三大特点：</p><ul><li><p>可靠传输<br>注意，“可靠”只是确保 Request方 的必定传输，由于一些网络原因未必能确保 Response方 的成功接收。</p></li><li><p>明文传输<br>HTTP报文的所有信息都回暴露在 “光天化日之下”，HTTPS协议实现了加密版本的HTTP传输。</p></li><li><p>无状态<br>区分于 TCP协议 的状态，HTTPS协议 是没有状态的，即 “没有记忆能力”。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【GAMES101】Shading</title>
      <link href="/posts/shading/"/>
      <url>/posts/shading/</url>
      
        <content type="html"><![CDATA[<p>Lambertian、Blinn-phong、shading-tech<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101 Shading</a></li><li><a href="https://www.cs.ucr.edu/~shinar/courses/cs130-spring-2012/schedule.html">CS130 Shading</a></li><li><a href="https://www.cs.toronto.edu/~jacobson/phong-demo/">WebGL demo</a></li></ul></div><div class="markmap-container" style="height:300px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Factors&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2],&quot;f&quot;:true},&quot;v&quot;:&quot;光源&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3],&quot;f&quot;:true},&quot;v&quot;:&quot;平行光&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4],&quot;f&quot;:true},&quot;v&quot;:&quot;点光&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5],&quot;f&quot;:true},&quot;v&quot;:&quot;聚光灯&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6],&quot;f&quot;:true},&quot;v&quot;:&quot;相对位置&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7],&quot;f&quot;:true},&quot;v&quot;:&quot;距离衰减&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8],&quot;f&quot;:true},&quot;v&quot;:&quot;角度（Lambert’s cosine law）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9],&quot;f&quot;:true},&quot;v&quot;:&quot;材质&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10],&quot;f&quot;:true},&quot;v&quot;:&quot;Ambient&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11],&quot;f&quot;:true},&quot;v&quot;:&quot;Diffuse&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12],&quot;f&quot;:true},&quot;v&quot;:&quot;Specular&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Shading-Reflection⭐&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#font-color-750000-Lambertian-Reflection-⭐-font\&quot;>Lambertian</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#font-color-750000-Blinn-Phong-Reflection-⭐-font\&quot;>Blinn-Phong</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Shading-Tech&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[16,17],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#1-Flat-Shading\&quot;>Flat</a>（poly）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#2-Gouraud-Shading\&quot;>Gouraund</a>（vertex）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#3-Phong-Shading\&quot;>Phong</a>（pixel）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;Shading-Normal&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#1-顶点法线\&quot;>Vertex-normal</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[21,22],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#2-像素法线\&quot;>Pixel-normal</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="Shading">Shading</h2><p><a href="https://en.wikipedia.org/wiki/Shading">Wikipedia: Shading</a><br>维基百科对于 shading 的定义非常清楚，即对3维场景中模型 <strong>着色</strong> 的过程，且着色的效果取决于如下几个因素：</p><h3 id="1-光源">1.光源</h3><p>推荐阅读：<a href="https://learnopengl.com/Lighting/Multiple-lights">LearnOpenGL</a>，<a href="https://www.cs.ucr.edu/~shinar/courses/cs130-spring-2012/content/Lecture12.pdf">CS130-Lecture12</a></p><ul><li><p>Ambient lighting<br>环境光照，即使在最黑暗的情况下，存在一些微弱的光亮使得物体呈现出一些颜色。</p></li><li><p>Directional lighting<br>平行光，也称作天光，在固定的光源方向上无任何衰减。</p></li><li><p>Point lighing<br>点光，向四周照射，随距离衰减。</p></li><li><p>Spotlighting<br>聚光灯，呈一个锥形范围照射，随距离衰减。</p></li></ul><h3 id="2-相对位置">2.相对位置</h3><ul><li><p>距离关系<br>光照强度一般随 <strong>距离的平方</strong> 衰减，$ ~ I / r^{2}$</p></li><li><p>角度关系<br>根据 <a href="https://en.wikipedia.org/wiki/Lambert%27s_cosine_law">Lambert’s cosine law</a>，$\vec {n} * \vec {l}$ （结合后面的 Lambertian Reflection 理解）</p></li></ul><h3 id="3-材质">3.材质</h3><ul><li><p>Roughness<br>粗糙度越高，镜面反射能力越强，典型代表如镜子。</p></li><li><p>Metallic<br>金属度越高，漫反射越弱。</p></li><li><p>Translucent<br>具有透光属性，如典型的 <a href="https://en.wikipedia.org/wiki/Subsurface_scattering">SSS</a>。</p></li></ul><h2 id="Local-Shading">Local Shading</h2><p>现实中的光照，需要考虑各种直接光、间接光的反射、吸收效果，想要在图形引擎中模拟它们非常不现实。因此一些大佬提出局部的着色算法，以模拟 <strong>一个独立点的shading计算</strong>，这里统称为 local-shading。<br>我们需要了解 <code>Lambertian Reflection</code> 和 <code>Blinn-Phong Reflection</code>。</p><h3 id="font-color-750000-Lambertian-Reflection-⭐-font"><font color="#750000">Lambertian Reflection ⭐</font></h3><p><strong>Lambertian模型</strong> 一般用来模拟 diffuse光，核心影响分别是：距离、角度。<br>距离基本的衰减关系，前面讲过了。角度根据 <a href="https://en.wikipedia.org/wiki/Lambert%27s_cosine_law">Lambert’s cosine law</a> 计算得一个光照强度的系数，其中 $max(0, n \cdot l)$ 表示任何大于90度的夹角，光照强度都为0。</p><p><img src="/images/lambert-shading.png" alt=""></p><hr><h3 id="font-color-750000-Blinn-Phong-Reflection-⭐-font"><font color="#750000">Blinn-Phong Reflection ⭐</font></h3><p><strong>Blinn-Phong模型</strong> 在前者的基础上引入了 <strong>Ambient 环境光</strong> 和 <strong>Specular高光</strong>，它是一个叫<code>Blinn</code>的教授拓展了<code>Phong</code>的光照模型，其计算方式分别为：</p><ul><li><strong>Specular</strong></li></ul><blockquote><p>$L_{s} = K_{s}(I/r^{2}) max(0, n \cdot h)^{p}$<br>引入一个 <strong>半程向量 $h (=\frac{v+l}{|v+l|})$</strong>，实际含义为入射角和观察角的二分之一夹角。此时衡量 $h$ 和 $n$ 的接近程度，即点乘 $n \cdot h$（<code>Phong</code>模型选取的是 $cos(\alpha)$，$\alpha$是夹角）， $n, h$ 越接近 则点乘值越大，则高光越强烈。<br><br>其中的 p 衡量 <strong>高光随夹角的衰减速度</strong>，p值越大，则呈现高光的范围越小（如下图）。</p><ul><li>p = 5 … 10：塑料</li><li>p = 100 … 200：金属<br><img src="/images/blinn-phong-demo-all.png" alt=""></li></ul></blockquote><ul><li><strong>Diffuse</strong></li></ul><blockquote><p>同 Lambertian模型</p></blockquote><ul><li><strong>Ambient</strong></li></ul><blockquote><p>$L_{a} = k_{a}I_{a}$<br>环境光假设任何点来自环境的 <strong>光照强度是一致的</strong>，即 $I_{a}$，它与实际光照方向无关。<br>笔者粗暴地理解为自发光、固有色。</p></blockquote><p><img src="/images/blinn-phong.png" alt=""><br><br></p><h2 id="Shading-Tech">Shading Tech</h2><p>推荐阅读：<a href="https://en.wikipedia.org/wiki/Shading">Wikipedia</a>，<a href="https://www.cs.ucr.edu/~shinar/courses/cs130-spring-2012/content/Lecture14.pdf">CS130-Lecture14</a></p><p>前面讨论光照模型的计算，但是忽略了一个重点：<strong>以什么对象（或粒度）进行Shading?</strong><br>基于前面的知识得到，任何 mesh 都是由顶点和三角形（或Poly）组成，因此自然想到如下几种方案：</p><ul><li>Tri（Poly）：基于三角面的 Flat Shading</li><li>Vertex：基于顶点的 Gouraud Shading</li><li>Pixel：基于像素的 Phong Shading</li></ul><p><img src="/images/shading-tech.png" alt=""></p><h3 id="1-Flat-Shading">1. Flat Shading</h3><p>对<strong>每个三角形（或Poly）</strong> 计算出一个法线，可以通过叉乘得到，并基于法线作光照计算。此时三角形内的Shading结果是一样的。可以理解为 <code>Low-Poly</code> 的渲染风格。</p><h3 id="2-Gouraud-Shading">2. Gouraud Shading</h3><p>对<strong>每个顶点</strong>作计算（假设顶点没有自己法线，可以根据周围几个三角面的法线求均值）。可以理解为 <code>Vertex-Shader</code>。</p><p><img src="/images/gouraud-shading.png" alt=""></p><h3 id="3-Phong-Shading">3. Phong Shading</h3><p>对<strong>每个像素</strong>插值出单独的法线，基于此作光照计算。因为是全像素的，所以性能开销高。可以理解为 <code>Pixel-Shader</code></p><h3 id="三种方案对比">三种方案对比</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Flat</th><th style="text-align:center">Gouraud</th><th style="text-align:center">Phong</th></tr></thead><tbody><tr><td style="text-align:center">光照粒度</td><td style="text-align:center">poly</td><td style="text-align:center">Vertex</td><td style="text-align:center">pixel</td></tr><tr><td style="text-align:center">表现</td><td style="text-align:center">劣</td><td style="text-align:center">中</td><td style="text-align:center">优</td></tr><tr><td style="text-align:center">性能需求</td><td style="text-align:center">低</td><td style="text-align:center">中</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">需要顶点法线</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><h2 id="Normal">Normal</h2><p>Shading的着色计算非常依赖 <strong>法线</strong>，下面介绍两种常见的法线计算方式：</p><h3 id="1-顶点法线">1. 顶点法线</h3><ul><li><p>模型自带，例如 <code>obj</code> 格式可以指定逐顶点的法线</p></li><li><p>计算顶点周围 <code>Poly</code> 的法线均值</p></li></ul><p><img src="/images/vertex-normal.png" alt=""></p><h3 id="2-像素法线">2. 像素法线</h3><ul><li>通过两个顶点的法线插值，记得归一化！</li></ul><p><img src="/images/pixel-vertex.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSAPP】Virtual Memory</title>
      <link href="/posts/virtual-memory/"/>
      <url>/posts/virtual-memory/</url>
      
        <content type="html"><![CDATA[<p>虚拟内存、cache、内存分配、内存泄漏…<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="http://1.15.115.4/CSAPP-3rd.pdf">CSAPP 第9章：Virtual Memory</a>（已读完，通俗 &amp; 受益匪浅）</li><li><a href="/posts/3RBTN4W/">汇编（一）：计算机架构入门</a>（站内文章，硬件基础知识）</li><li><a href="https://fengmuzi2003.gitbook.io/csapp3e/dixzhang-xu-ni-nei-cun">CSAPP重点解读：虚拟内存</a></li><li><a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf">What Every Programmer Should Know About Memory</a>（114页pdf）</li><li><a href="https://en.cppreference.com/w/c/memory">cppreference: Dynamic memory management</a></li><li><a href="https://www.usna.edu/Users/cs/roche/courses/s19ic221/lab05.html">IC221 Lab 05: Memory Leaks</a></li></ul></div><div class="markmap-container" style="height:450px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;What，Why&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;physics-memory 及弊端&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;virtual-memory&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;virtual page&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#PTE\&quot;>页表 PTE</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Cache&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#page-hits-✔\&quot;>页命中</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<a href=\&quot;#page-faults-❌\&quot;>缺页</a>&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;<a href=\&quot;#locality\&quot;>Locality</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;时间局部性&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;空间局部性&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;<a href=\&quot;#memory-allocator\&quot;>memory allocator</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;<a href=\&quot;#衡量标准\&quot;>衡量标准</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;1. 分配&amp;amp;释放速率&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;2. 内存利用率&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Explicit allocator&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#u-class-black-mallco-free-u\&quot;>malloc &amp;amp; free</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;new &amp;amp; delete&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;Implicit allocator&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;<a href=\&quot;#垃圾回收\&quot;>垃圾回收</a>&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;<a href=\&quot;#memory-leaks\&quot;>memory leaks</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;<a href=\&quot;#Valgrind\&quot;>Valgrind</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;<a href=\&quot;#ASan\&quot;>ASan</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;<a href=\&quot;#memory-bugs\&quot;>memory bugs</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;<a href=\&quot;#引用坏指针❌\&quot;>引用坏指针</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;<a href=\&quot;#未初始化的堆内存❌\&quot;>未初始化的堆内存</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;<a href=\&quot;#缓冲区溢出❌\&quot;>缓冲区溢出</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="virtual-memory">virtual memory</h2><p>物理内存有什么问题？1. 内存空间不够，2. 产生内存碎片，3. 没有内存保护。从这个角度看，<strong>虚拟内存是一个中间层，本质是到物理内存的一层映射关系</strong>。<br>并非所有系统都会使用虚拟内存，一些古老or简单的系统就会直接使用物理内存。</p><p>物理地址和虚拟地址的对比如下：</p><ul><li><p><strong>Physical-Address</strong>：物理地址，从0开始每个byte递增1<br>物理地址可以直观反应内存大小，且是连续的，例如 <code>0x0000 ~ 0xFFFF</code> 表示 <code>64KB</code> 的内存。</p></li><li><p><strong>Virtual-Address</strong>：虚拟地址，是一种到物理地址的映射（<a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>）<br>使用虚拟地址，可以节省地址总线的位数，且利于cache实现。</p></li></ul><p><img src="/images/virtual-memory.png" alt=""></p><h2 id="cache">cache</h2><p><strong>存储器</strong> 是计算机用来存储数据的器件，即通常所说的磁盘。其根据读写特性又可以分为两类：</p><ul><li><p><strong>ROM（Read-Only-Memory）</strong><br>只读，一般是显卡、网卡上的默认系统，如<code>BIOS</code></p></li><li><p><strong>RAM（Random-Access-Memory）</strong><br>可读可写，显卡上的RAM又成为显存</p></li></ul><p>为了提高CPU读写数据的速度，现代计算机在 CPU和RAM之间又增加了 <strong>速度更快、内存更小、造价更高的</strong> <em><strong>L1, L2, L3 Cache</strong></em>，这部分称为 SRAM（Static）。<br>作为对比，DRAM（Dynamic） 一般用作虚拟内存的cache。<font color="#FF1E10"><strong>（???）</strong></font></p><p>至于为什么 SRAM 速度要比 DRAM 快很多？这需要从硬件制造上理解，参考阅读：<a href="https://rf.eefocus.com/article/id-336795">存储技术SRAM详解</a></p><h2 id="page">page</h2><p>计算机内存会被划分为固定大小的 <strong>页（page）</strong>，划分页是为了实现缓存的功能。</p><p>对于虚拟内存而言，任何一个 <strong>虚拟页（virtual page, VP）</strong> 中的内存只能处于如下三种状态：</p><ul><li>unallocated：未分配内存（即不在物理内存中）</li><li>cached：已缓存（但在物理内存中）</li><li>uncached：未缓存（但在物理内存中）</li></ul><h3 id="PTE">PTE</h3><p>为了描述 虚拟页 和 DRAM 之间的缓存关系，操作系统引入 <strong>页表 PTE（Page Table Entry）</strong> 的概念。通常情况下，它有一个有效位和一个n位地址 组成：</p><ul><li><strong>有效位</strong>：对应的虚拟页是否 cached</li><li><strong>地址位</strong>：若cached，则对应 DRAM 的物理地址</li><li>其他许可位：如可读、可写、可在内核运行等</li></ul><p>配合下图理解，一段虚拟内存被分为 8个虚拟页，对应着左侧的 8个PTE，其中的虚拟页1、2、4、7已经在物理内存中被缓存，同时在PTE中存储了对应地址。</p><p><img src="/images/virtual-page.png" alt=""></p><div class="admonition note"><p class="admonition-title">虚拟内存访问页的两种情形</p><ul><li>已缓存，即 page hits</li><li>未缓存，即 page faults</li></ul></div><h3 id="page-hits-✔">page hits ✔</h3><p>页命中，即虚拟页已经在DRAM中被缓存，读取时只需根据 PTE 找到对应的物理地址。</p><h3 id="page-faults-❌">page faults ❌</h3><p>页缺失，即虚拟页 <code>cache miss</code>，这是它在 PTE 中的有效位是0，即代表其在 DRAM 中未缓存。<br>此时内核会选择一个已经被缓存的 “无辜儿” 去替换成该页，这个无辜儿又称为 <strong>牺牲页（victim page）</strong>，同时进行如下两个操作：</p><ol><li>（物理内存中）用 查找页 替换 牺牲页</li><li>（页表PTE中）交换 查找页和牺牲页 的 cache有效位</li></ol><p>注意这里的 <a href="https://forum.huawei.com/enterprise/en/thread/667215004455288832?page=1">替换策略</a> 很重要，主要有如下两种（实际应用会更复杂）：</p><ul><li>write-through：直写，发生改变时更新cache和内存</li><li>write-back：回写，发生改变时只更新cache</li></ul><p>DRAM 为了性能考虑，采取的是 <code>write-back</code> 方案。</p><h2 id="locality">locality</h2><p>虚拟内存、分页之所以能达到非常好的cache优化，是因为程序的局部性原理 <a href="https://en.wikipedia.org/wiki/Locality_of_reference">Locality of reference</a></p><ul><li><p><strong>时间局部性</strong>：一个刚刚被访问的内存地址，在未来有更大概率被再次访问</p></li><li><p><strong>空间局部性</strong>：被访问的内存地址，其周围的内存更容易被访问</p></li></ul><h2 id="memory-allocator">memory allocator</h2><p>实际开发中，当需要申请一段内存时，其大小往往不是固定的（与runtime有关），此时有如下两种内存分配到方式：</p><ul><li><code>int arr[10000];</code> 静态定义偏 <code>hard-code</code>，浪费较多内存</li><li><code>int* arr;</code> <strong>需要时动态分配内存⭐，本章重点介绍</strong></li></ul><p>C++ 提供一种在 <strong>堆(heap)</strong> 上动态分配内存的方法，一个 <code>runtime</code> 程序的内存划分如下：<br><img src="/images/section.png" alt=""></p><p>C++ 的动态内存分配器有两种类型，区别在于<strong>如何释放内存</strong>：</p><ul><li><p><font color="#ef6d3b"><strong>Explicit allocator</strong></font><br>显示分配器，要求程序自己去释放掉申请的内存，C-Style的方法是 <code>malloc/free</code>，Cpp-Style的方法是 <code>new/delete</code>；<br>当程序没有正确或及时地释放内存，就会造成 <em><strong>Memory Leaks</strong></em>。</p></li><li><p><font color="#ef6d3b"><strong>Implicit allocator</strong></font><br>隐式分配器，它会自动检测未被释放的内存块，并主动去释放掉，它有一个通俗的名称叫 <strong>Garbage Collector（垃圾回收）</strong>；<br>诸如 Java、Python 等拥有自己的垃圾回收（这部分不作讨论）。</p></li></ul><h3 id="u-class-black-mallco-free-u"><u class="black">mallco &amp; free</u></h3><ul><li>阅读文档：<a href="https://en.cppreference.com/w/c/memory">cppreference: Dynamic memory management</a></li><li>使用的时候多查阅文档，注意 <code>malloc</code> 使用时要判断 <code>NULL</code> 避免内存分配失败</li></ul><pre><code class="language-c++">#include &lt;unistd.h&gt;void *malloc(size_t size);void *calloc( size_t num, size_t size );void *realloc( void *ptr, size_t new_size );</code></pre><ul><li>分配过程：↓</li><li>需要考虑字节对齐，注意被释放后的内存也可能重复利用，这也解释了为什么野指针的 <code>undefined behavior</code></li></ul><p><img src="/images/malloc-demo.png" alt=""></p><h3 id="衡量标准">衡量标准</h3><p>动态内存分配器的实现有很多种（<code>malloc</code>是非常普遍的一种），一个优秀的分配器应该兼顾如下两种性质：</p><ul><li><p><strong>分配&amp;释放的速率</strong><br>即每秒可以进行多少次的内存分配 和 释放操作，又称为吞吐率。</p></li><li><p><strong>内存利用率</strong><br>即内存的实际利用率，受牵制与内存中的小碎片。</p></li></ul><h2 id="垃圾回收">垃圾回收</h2><p>垃圾回收（Garbage Collection）是现代高级语言的常见特性，它最早可追溯于 1960s Lisp语言，如今也已经发展为 Java、Python 等语言的重要部分。</p><h3 id="What-is-Garbage">What is Garbage?</h3><p>正所谓知己知彼方能百战百胜，欲消灭“垃圾”，先搞清楚“垃圾”的定义。<br>阅读下段代码，其中的指针<code>p</code>在函数<code>garbage</code>内部没有被释放掉，因此函数调用返回后，这就是一段内存垃圾，也称为<strong>内存泄漏</strong>。</p><blockquote><p>因此垃圾回收，就是自动释放 泄漏的内存</p></blockquote><pre><code class="language-c++">void garbage(){    int *p = (int *)Malloc(15213);    return; /* Array p is garbage at this point */}</code></pre><ul><li>实际的垃圾做法比较复杂，这里简要提一下其实现原理。</li></ul><p>垃圾回收器 会维护一个内存块的有向图，其中 <code>Reachable</code>节点就是有指针指向的，可以被手动释放；而 <code>Unreachable</code>节点就是无内存泄漏的节点，垃圾回收就是去释放它们。</p><p><img src="/images/memory-garbage.png" alt=""></p><h2 id="memory-leaks">memory leaks</h2><p>关于内存泄漏的定义，<a href="#What-is-Garbage">上面有提到</a>。这里重点介绍两种检测内存泄漏的工具。推荐阅读这篇材料: <a href="https://www.usna.edu/Users/cs/roche/courses/s19ic221/lab05.html">IC221 Lab 05: Memory Leaks</a></p><h3 id="Valgrind">Valgrind</h3><ul><li><code>valgrind ./a.out</code>：跟踪内存泄漏</li><li><code>valgrind --leak-check=full ./a.out</code>：查看更详细的内存泄漏信息</li><li><code>LEAK SUMMARY</code>：该标签，就是潜在的泄漏部分</li></ul><pre><code class="language-c++">==2392771== HEAP SUMMARY:==2392771==     in use at exit: 0 bytes in 0 blocks==2392771==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated</code></pre><h3 id="ASan">ASan</h3><p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizer"><strong>AddressSanitizer</strong></a> 已集成到 gcc、clang 等编译器，添加 <code>-fsanitize=address</code> 的编译选项 并运行即可。</p><ul><li><code>g++ -fsanitize=address -g main.cp</code></li></ul><pre><code class="language-c++">===================================================================2392472==ERROR: LeakSanitizer: detected memory leaksDirect leak of 5 byte(s) in 1 object(s) allocated from:</code></pre><h2 id="memory-bugs">memory bugs</h2><p>内存bug 相对于其他类型的bug，往往更难以定义和排查。这篇文章 <a href="/posts/2F2QH5R/#Bug%E4%BA%A7%E7%94%9F%E5%8E%9F%E7%90%86">调试理论与实践</a> 指出：<strong>程序代码错（Bug）到 可观测错（Failure）之间的跨度距离，决定一个bug排查的难易程度</strong>，而内存bug的跨度尤长。</p><blockquote><p>换言之，不论是时间还是空间上，内存的错误 往往距离错误源有较长一段距离。</p></blockquote><h3 id="引用坏指针❌">引用坏指针❌</h3><p>错误表现是 <code>segmentation fault</code>，错误原因有：</p><ul><li>访问非法内存地址，如读取 <code>0x0000001</code> 地址的值；</li><li>对 “只读内存” 进行写操作，如 <code>scanf("%d", val)</code></li></ul><div class="admonition warning"><p class="admonition-title">WARNING</p><ul><li><code>scanf("%d", val)</code> 会将 <code>val</code> 的值解释为一个地址</li><li>如果该地址只读，会出现 <code>segmentation fault</code></li><li>如果该地址可写，程序会覆盖这段内存，造成无法预测的后果...</li></ul></div><h3 id="未初始化的堆内存❌">未初始化的堆内存❌</h3><p>对于 <code>.bss</code> 的静态内存，加载器会将其初始化为0，但是堆内存的值是无法预测的。</p><p>如下 <code>y</code> 数组的值不一定都为0，请手动为其赋值。<br><code>int *y = (int *)malloc(5 * sizeof(int))</code></p><h3 id="缓冲区溢出-❌">缓冲区溢出 ❌</h3><p>这类bug使用中文有点别扭，实际是 <code>Stack (Buffer) Overflows</code>，即写内存时超出原本的大小限制。如下当输入超过 64 bits 就会出现 <code>segmentation fault</code>：</p><pre><code class="language-c++">char buf[64];scanf("%s", &amp;buf);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSAPP】CMU 15-213</title>
      <link href="/posts/csapp/"/>
      <url>/posts/csapp/</url>
      
        <content type="html"><![CDATA[<p>CS网课中的 “圣经”<span id="more"></span></p><style type="text/css">blockquote{    line-height: 30px;    padding: 4px 16px;}</style><blockquote><ul><li><a href="https://www.cs.cmu.edu/~213/">课程主页</a> | <a href="https://www.bilibili.com/video/BV1iW411d7hd/">B站视频（中字）</a> | <a href="https://www.cs.cmu.edu/~213/lectures/">课程ppt</a></li><li><a href="http://1.15.115.4/CSAPP-3rd.pdf">CSAPP pdf 英文版</a></li><li><a href="https://github.com/Maecenas/ICS-15213-CSAPP3e-CMU">Labs Github</a></li><li><a href="https://fengmuzi2003.gitbook.io/csapp3e/">CSAPP重点解读</a></li><li><a href="https://wdxtub.com/work/">读薄/读厚 CSAPP</a></li></ul></blockquote><h2 id="CSAPP">CSAPP</h2><p>CSAPP 是 《Computer Systems: A Programmer’s Perspective》 这本书的缩写，它作为CMU大学的ICS课教材，被誉为计算机系列课程的圣经，其内容涉及：计算机组成原理、操作系统、编译优化、网络和并发等。</p><p>“万丈高楼平地起，勿以浮沙筑高台”，学习计算机的底层原理，是在修炼内功、在夯实基础，这比修一个bug或者读几段代码更加实在。</p><h3 id="站内文章">站内文章</h3><ul><li><a href="/posts/24H1CZ3/">2. Information Storage</a></li><li><a href="/posts/1X3A6C1/">9. Virtual Memory</a></li></ul><h2 id="关于-labs">关于 labs</h2><p>首先 <code>CSAPP</code> 的整个学习过程：以 <code>labs</code> 为主，视频和ppt 为辅。在github上找到一份疑似官方一致的repo，自己fork了一份用于开发：<a href="https://github.com/593413198/ICS-15213-CSAPP3e-CMU">🔥<em><strong>Github Repo</strong></em></a></p><p>整个 labs 的设计非常精巧，还囊括了测试、评分的用例，后者是用 python2 脚本编写。以 lab-0 为例稍微介绍其整体的架构设计：</p><ul><li><code>RAEDME</code>：实验说明</li><li><code>Makefile</code>：通过 <code>make</code> 完成实验的编译、运行与测试</li><li><code>*.c, *.h</code>：lab源码 ⭐</li><li><code>qtest</code>：脚本驱动的测试框架，值得一读 ⭐</li></ul><p>其中 <code>console.c</code> 实现了一个精巧的可交互命令行，并集成一些用于 lab 的指令。<code>qtest</code> 集成了前者和一些测试用例，它将评判你的代码是否通过多少case、以及获得多少得分。</p><p><strong>通过实验，读懂实验框架代码，这两件事都很重要！</strong></p><h2 id="Lab0-c-programing">Lab0 - c programing</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cpp】Constructors</title>
      <link href="/posts/17P7469/"/>
      <url>/posts/17P7469/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">提要</p><ul><li><a href="https://hackingcpp.com/cpp/lang/destructors.html">hackingcpp: destructors</a></li><li>面向一些基础使用，因此所涉比较浅</li></ul></div><h2 id="基础">基础</h2><p><code>cpp</code> 有 3 种特殊的成员函数，本文所有的内容都围绕它们展开：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">what</th><th style="text-align:center">when</th></tr></thead><tbody><tr><td style="text-align:left"><code>T::T()</code></td><td style="text-align:center">默认<u class="green">构造</u>函数</td><td style="text-align:center"><code>T</code>创建时</td></tr><tr><td style="text-align:left"><code>T::~T()</code></td><td style="text-align:center">默认<u class="green">析构</u>函数</td><td style="text-align:center"><code>T</code>销毁时</td></tr><tr><td style="text-align:left"><code>T::T(param…)</code></td><td style="text-align:center">特殊<u class="green">构造</u>函数</td><td style="text-align:center"><code>T</code>带参数创建时</td></tr></tbody></table><p>即使用户不去声明 构造 和 析构 函数，编译器也会<strong>自行创建者两者</strong>。</p><p>构造函数的调用时机很容易理解，但<strong>析构函数的调用时机</strong>很特殊。</p><ul><li><p>显式地销毁对象</p></li><li><p>隐式地被销毁，如局部变量的作用域结束</p></li></ul><pre><code class="language-c++">if (...) {    T x;  // constructor}  // destructor</code></pre><h2 id="Constructor">Constructor</h2><p>构造函数根据构造的类型，又分为如下几类：</p><pre><code class="language-c++">class Test{public:    Test(int a);  // 构造函数    Test(const Test&amp;);  // 拷贝构造函数    Test&amp; operator=(const Test&amp;);  // 拷贝赋值operator    Test();   // 构造函数    ~Test();  // 析构函数}</code></pre><p>考虑如下两个初始化的用法，才能看出调用构造函数的区别：</p><ul><li><code>Test t1(88);</code>：普通构造函数</li><li><code>Test t1 = t2;</code>：拷贝构造函数</li><li><code>Test t1; t1 = t2;</code>：拷贝赋值operator</li></ul><div class="admonition warning"><p class="admonition-title">C++11 delete</p><ul><li>申明为 <code>Test(const Test&amp;) = delete;</code> 可以禁止用户使用拷贝构造函数</li><li>此时如果调用，会有编译报错：<u class="error"><code>error: use of deleted function ‘Test::Test(const Test&amp;)’</code></u></li></ul></div><h2 id="Destructor">Destructor</h2><p>析构函数的调用顺序是编译器严格限制的，即<strong>析构顺序与声明顺序相反</strong>。</p><p>对于如下的结构体 <code>Test</code>，当对象发生销毁时，执行析构的顺序依次是：</p><ul><li><code>Test -&gt; t3 -&gt; t2 -&gt; t1</code></li></ul><pre><code class="language-c++">class Test {    T1 t1;    T2 t2;    T3 t3;public:    Test();    ~Test();}</code></pre><h2 id="RAII">RAII</h2><blockquote><p><em>Resource Acquisition Is Initialization</em></p></blockquote><p>这条 <a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii">stackoverflow</a> 认为<code>RAII</code>应该称作<code>Scope-Bound Resouce Managerment</code>，这样更容易理解，笔者深表赞同，因此下面也围绕这个理解展开。</p><p><strong>Resource</strong></p><p>首先理解什么是 <code>Resource</code>? 可以理解为任何需要被合理控制的c++对象</p><ul><li><em>file handles</em></li><li><em>thread</em></li><li><em>lock</em></li><li>…</li></ul><p>对于任何一个resouce，它的生命周期会经历 <u class="black"><strong>创建 -&gt; 使用 -&gt; 销毁</strong></u> 三个阶段。而销毁往往最容易被忽视，这会引起内存泄漏等问题。</p><p><strong>Scope-Bound</strong></p><p><code>Scope</code>是指一个resource的作用域，当其离开作用域时，应该自动调用其析构函数以使其销毁。</p><div class="admonition note"><p class="admonition-title">总结</p><ul><li><code>RAII</code> 是一种防止内存泄漏而进行自动析构的cpp特性</li></ul></div><h3 id="RAII应用">RAII应用</h3><p>一些 C Library 总是会成对出现一些功能性的函数，例如：</p><ul><li><code>gpulib_init</code>, <code>gpulib_finalize</code></li></ul><p>如果只调用了init函数，而忘记调用负责析构的后者，就会出现内存泄漏、资源hung-up等bug。<br>因此我们可以在cpp层通过 RAII 的理念将它们封装一层：</p><pre><code class="language-c++">#include &lt;gpulib.h&gt;class GPUContext {  int gpuid_;public:  explicit  GPUContext (int gpuid = 0): gpuid_{gpuid} {    gpulib_init(gpuid_);  }  ~GPUContext () {    gpulib_finalize(gpuid_);  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023下半年规划</title>
      <link href="/posts/2023b/"/>
      <url>/posts/2023b/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0113e7eca44a13e446f0c67f5a0c83b9eb26aae79f0cb84bdeb4c786b5cdd62b">b3dc07a81f6459d120ce338ccca5504603780459e0306826441972681af56d627d2064135f70cb5bd2c200b9fa7e4da72155358871900a56565a0ca03e1ca0b2209e5b1092c6186a7b1819d438a12ca9bb18367e9ad80c87a7b8a1c70e817b59deea3abc794afb18b2fb4eb087ba547c9f7fb4264345913dd3318920907316dcea5179bd9ca5e01d1b8786e2a88b1aa4eae0deca44e46bdfdb7be567042d398cbcac6d7d4df07086cf83206bcaf121e4d589d7d0565d82253148efa244de06c29cd4d5e829781744043d93fe2dfc1f62af75b32f34e5f41a40e68bb8691e1520eb3736e007b060d41d8d91ee413128b5226f44d3215acf8b789e6ff0975e3e62f79ee70db266502c8b50ca520cc702d46caf3d7c67da8d8386b133122b85fade61a3bed6e260bc1ae72c038cad6fe0bbf99e31f534ef254436b63749e680c4e714f46885ede1e073036490eecefa8faeb383029a35954e938b9816811f4896c0a795a541390a4b697770100161e92b851e407d5d0512c4848dd59808dacff0fdcb90e1aef6ad65390e7a1ce003b7870d40971ba9c0cfa574d7b7c6bdb744e78bc81188952f0a40625fb1e809c5486608c65409ce55d9c5a93ff8f7360da7c8a7aec3748e27818e16ab4b42813d31134dad3e4b7dd40842675e0931679d5cb30edff2a7a8a4f47e08764a2a9e88f0d8d5f9f369f758ba26ffdb57e2a635e847b606868589b55703b449bf1904dd24a712acd1eb7daf4c8a49f9f5089197ddeb320c3d4901cae1f9a9c724e434fbc748e86503e796facd6dd3fcdba3730cce1cf117830acf018aa9b1741ab5322d0c90aab334e5a95b348b202ca54c5db116fcde85868ef3c9aebdceccdc079b2b39def29ed898a15769e0f04418ff78634d8c15a0ad4243912831b607532f827f8f162085533a2b78b0c6c41ed79aa206f07167aaff6a835000527fca2beba8192ec947dad5be709af5eab40e59f9d9b50e5d78c9a36d56e14005be186ceebfb9a5f5b67a1576316dc25724cef3cfd3918db0048e54fc02629bc21fd6aa6cfeab7235511cbb0ab02967161aaa5215d0c94c16a4452cef8a3b4b63d6d567093255ae382af063bfc522ef48a0e817153353677bd624d2489e2db3174d86da9df96aa43e6eb95a6cb3292f22c2420c5574263288f2112f6b19d4d906aa4ac4215c92512864754025522f7f6a677c5338a549be7ee39c27b6f847a0689d6c85ba82a3342833d2126955cb091037f0500420e932b6e8f2273d532e589fa76627b9a1586ade5e5bdeab52a75c94cb8c7840d13242764c3315e9766c683f736748e303606f16ff783dd541254ce5aee7960e5406d8c93d7264965c4aad2ca95ce82758e5f471c384ad432b8391e535198ffae940355cead6b531e875139853d739c65f158e6813fb2563a8895d06fc55676041f331f5261a1af5b6ae9c2a28de51b4541e9f75e1c408d379060b0db18cdb1bbc30466eebb546965c3df3499d79c8cc82b84775a01db56c7536417d542050316f9e10860b74fa3ad6991c884f18b5228a89c48ac97585c88776c3919b9978cf1ee1cd3438afa27a75db4e2601be958c8a153c688a3884fa99b8e850de02afc99793bbfa333acdb018cda2db870bcae335e6f08f648a7f70f997b2cad84b5c1cb8aadb9a7b713ed645895622a4de770b7e0cd5faf32382c0f0dbf8f9d0a9dea7ad4219c37aee3edec37ecd4bf89073584d488343927931cd39cd8383087ce9115d33a5dbed7da484cbfb75bacd28c7e7cbdd306109bfbd7ab89502c77ab1a83624a2f0c3583cddb4b2e3bea5ea1999d9e288394264d6aee918a17f744974041fa574173fe389442fd2d6dd5f0b8df797519d2a4cfe611da63189675122be6655529dfa93ab96fc17347dfd73ca5a5a18526c8628b6f7de1f23846ad476b490b09eb3f34269ed3c35e190733b375b8608a8980b214b9b495eaa6eafe7de3c48d576918989fbda4cfec6fa6ea08c53bb267c092a9df327f34dee0f3aab47618b5a30deb7bdff885f0c2d9159377070a3985b9cccb3b178778a25045628254511c037c5d09a694a9d385e2599ac2cd0afefdca85b759961239aac2e0e8dfb1394b9e08c649728c3d78d5a707ec9569173a04430ca7cab9945c3504de158be47f63f06c64a51d4eba302cb38b24802e930e9c21bfaf6f83c47de5770cf82059e97ef64c9a5b26dcfad0cad3d7048649509d1742089aaae0afc8a58bbf26f80a2c52c58ef2d4e530652cf3051e453c5335f99c3a6f4ca8a6507f797d2f4abb1fe4d1750bc0c10c79939ce7a3ae5eb0f509a35ce5bcbfc0798599f026ee28b83dad9c0b5dea2eda10deefefb65102150300d50e2299839d645f94320446d46b057a7eb89419b266a2a7431c9307a00ca4b4310239114d8f49129e2fbdd29fd92aa47e4a024c9258c1e13eace88ced8c13f892b0ffbfb1962c247ba0c70ca8c97b717561137dee9092be7156444e3fc275d9a6eff1a5cce3092bc63bc734cad52504d00d760b7f0e285ff910a50f5e04ebbd42beca35efb64276e4c88f1a61dbf1d82acd1b3b3f6d40836e481b5749a0768f9855834200bde2e612a3cbc365a1aff8bb100e51434e32b644f433fd6859f63b7cb8131cbbbc01113a369abe053f86aa4bea9c34e6005106a637f6b12ff574eaa75c63c397e7781d9215b6e348db066a0c83bb95deea48059d70d5bb0fd6142085bba31cb28a5e6d6ca28ed75b412770cd22d222bb0a4fdcd35bdd159c1b686d03090b1a8e6f6db7fd8f750bfdb4bb8b866c8acf091c7e6719301fe75f2b6502d84ee1fc0251c25bd328c7d592715a580ea6cf793666cb91f217d23b03f46d494faf291b2e567e37f09dfa1808d6795dea74b15869d57e22b0908a7cc6a5a3cb0e731d90e9e28c05ebbc2e84e4227f895fecfad5239c50ddfdd62001b13e6a26b8bc933e573da54d672498fad7702cde70837ac84d3a548ff6d4f536df755a7d45a253004519deb589d03a65415abca08c9a45a6cb55aeb810dbdefdd28877a6acecf17e4a911deee4f0d62da8e165ec1b152343ba69c9dd5624c4fd7b3920d5d0e06fcdfd1ad23ee416d97ddc063a59f6b5b7cd9712fd63021b74d96599f2f15e96df4e14063eb65ffa7d0604c36a64b4e2bbaeb0255ed383b20e5e2fd16c681b1dce4402051dad2194a505c34c75f60870f7fe2b2e8aab589e0444182d013c1fe57abd369e3398bf16b49a19c7cc07c6ec149d03f586838c52f17809a1fc51a5daa231ad18b3b9565c1b345017aee1bd32bacab3e360334b1c7bac3af2a10e5ff4cd75b3a0f3618ddabca82bc4e4b9126e3590ddcb05e798884e4122dd7aba443d3c2da8f0077b9357d8b05d6322facdc8eef99f475e61bb753960b9c90a0f4af3ac8692a7c6b75cb996a372f51554faf04cc8150c0d49a46a7a02e2a1828861308c80fa4d207f46cf00d4dc5a015fb6b1991f3357b957736b729056e144b8c86f8addd661d2cd3d0ec35e8c6a9245bbcd061e4f9dc94b4dfd39d349f9044f2ad9aff16eb33dd404337b15ab13346d3762c114771dffd96346e133b0ff4bb48c6612f57e6eb2c79022bc9f281abed145b54ea9abf4881d21ae6539bf88adabe0fa3774bf7a45606b246b823b5d316c66b7db204571540250edddfe56c0a51350e8dc422c1bca19b09ab3b2184a4260284dfbf89fa9b2a2a97a6d803646a2c0c11814712dacf4c4d3d96058f7aee8fa6ee134eb13d77531f151228f5ca12c8203bc4e875bff7a54771eb60a31dd2d1d9ab67ea40f339dcba7392727c00b624778f2f609edd3b8fd19edad6e18bd4729e66c49b7b504fe4222462df6a01c3d3b2d5edcc73c19a9997a7f37d6592b00c3442672633492e8bb0c2c06f94096d92fd38c2811f1ca968cc33a1e3354c23ebacee7244ed4df70b3bb55094ced26839f03fda78618aa0fd061d11b7da716759dccbc2ef9aa6c2e2e534180b091efb1018cf0bf0bcbdcbaf41a7d297109464a54b31e02b57f5d90391db4bb2a49762b328ce1e37c301620432b83470597f905e6cdda33a5d1145c1ae975f9d68786edcb58e3bf90a11f2babd25da33c77ee2eda6346a483645f7f5e06ab4d91fb4582365d97db6c3fc478aa7efbb64cabb5a5a7c79fc7501e03267063028350bf4f0db1917500bab4d37ca8068240f6182323875168be46c44f1fbcbbc99fbe49bfbabaaacda2d3845ac67f33750550611c643e44372f46a8fee5f51cedb083298d2a408e9cd571e77cfeb31133357db36aeb3c589c99e832d5a84ee88048ec90ccaf4a1fc6043390e1c5b40ec66a64843a961fba5b0e36f42814d8b50287337d4e94c76493af184185c28a6507bee35900d01d8a0d394cd6e004cfeae094cbf01f3b4c921bd40fb1aa6a0d350762e8d3cf47de352831cbf87da349a7a10425a32e112e071b0768dab8fa5b4e57dd1a5ec1ebed54eddc65353ce42a48fb3a8dea673f233a706cb35786312ab8877cb3240ce06672564f0ac3c095547b0858a93d44ac309f0296098a985db70cab6c25fd82ba99c3e51b1992e3128873ee829ef6b346c2881c5415024035d81a5f1fe722d874e30e5b68e5aa31c20a4811518cfd6657655521479ed6b7298677a00313d3b62e4eb91874bcb3753c752e0676da5130fdc57017acecd9019b2eff4b3e0c8a5c7bf0600fe836acb159e315bf633226e590a07d50ce424c0c5fb5ac1ff0b0220d18f3e3fbec5edca589675b335d0c29326b6509515915cf806ee25f2df83413ba9eca2c4b82a81fcd968e2d315b6edb02bc9e1e9b1828a552c011fb16837c4846b08e3f22259ccd6e5e9084008d6e2dd17add713cdd8be6e22bf8b7d814e08a4924ff4f0470b2a28c03d8f312acaf1ebabf66c00707b635ea7509ddc1f97ec13340ad6ba4660bfeaa99c607117eeaa97aa77d6ecd2a28332fe4bb969d1c34c4d5456746ce0b7bfdc660e8ddd5f9464a0a154bc2dce340152b908d9377f79162b6ba50ed7b45c8632eb403ef6ead07a5846a461de7e08cebaad8383b991f688fbadc13d197a1a88b2dbc1dbf5c4881fe9a1f9514241c27159ed19bfc20900f822af94060cdffd279d50a2aae8211ca1dccb1300e3aa29207d64d3b449cfe9dca40a5f56714180e56376fc8b5062c6f8ad7c31ca02a896f485dee54b07c44c3e76eecdd9ea20df5a73cbcd85da973be017e1694a3766ccd8a909b8333a67dfb24e90d8491dff0e8a98e6cf6216f5481f8672abced8a4fcd72605e5fc0285872e056704bc81612612fb54c80818f2a685503130fd057e1b6e1606d16508b0116c2f43dacaea7f1c675519014d2143c12d4503c7ce063b5e0b2ded0872db79b2027a9f05ff1bf4f1cc9ca2fa8c6fa3a31667fbc3d41a5512e50f4fe29bc4e473e95ef24fddb69b842483987f029444bd70b6bd2cc458b2bed75399dbb81f4ddcd69c3ba721462afa47246d5ad5a6a9a5af0281a7cf95f62093a5fc29cf4c0ad05eb7d4140812c3c12c773863c9a8a40c888110d3559bc9ecc25e2a88ba06c497cd8954f3389f416cd591b12e88a9ab59e9cde5dcc39d16ea23d1d3b5492da3bd5ca53b4312ec2a0a152039eb77fb54b67a4cc11f878e0c5ece85aed42bf07caf3c5d7a9918aff38388faa7f85945460f908755e79054f927205013e5929c6b1b34ded26ada80037d4f35b8be325f7b3514ca8eaf986ea64b77b2aff4c7f5ec317553cd7b1621285d3dac7a369261c1f3bc4635f20b886fe98a36c4c47e2f6a3e857682ba34628cd2f6dbefb738f91c57788f39521727772901fc0440127d6f3f9101f345889f90efd93ae65cc0ac231d8fab066ed2036381c669afc9bf75a4ff12e777f752e24166d0ef2b123680a587b7cca405c2bed163dd7e430c95212ca2aaaf6ac81a814b59bcf3070ea5a4e19f9cfb62307d5c6014311b4c63a5b0e67eccb53c63d8bbec4126d66d14eba550f83b64cbb9569d707473c8495791515659d1f74f51b1408ef51937651ac4b987ba4cc01f4bea19193431ffc690e795e22d9a7ced5ef27cb030a6971988c34b27fae4c829c6c780b72dc5ef88434cab46d3d0e02086609df638be981cb4b93aaeca55cc800ab8e0664be4b74b607554f5d8b184c469727bb590d14a2764001d6e37798e38fd1456a61791449c2e15e1a22f11020bfd144ebb78388c35196b4d88a0a8742e613b40c3490d1717379ce70d73de0848e91cec45dbefba1458618630816ed83819ceac99449d5a27f29504c5ad2cfdc73e9d5c73d42d49e03be0eca26b72f88f2c0f7525c89680a8aaa92c1b471e628109530ee91d0b5e62c0fbd39fe1abde4235a72573a5d91e2804b4dd1005dfba78b2cf2c1b0eec0809e4e3900adfad6d7910f333d219fabcb6646ae0515a6e5abd7ef55f0b33b6c370348de30dc0276608c5cf6f8ac709d1face93669babecd7248d38500ad7d6130c118b292624a3fa9cac96c32cf3e889405782949c3412baec90ba545a090dd43b834ab4135a4f05ca7114ed591c6d2ad24078dc1fff0f43500fc595b18e7ddf7bae4f6202c9b4bc68e3071accca23a17a6db2091e09f754418dd7eb19167f5f30d12b38d96d221e1973120586f601b47ebb0dd3c3f8e851d0c26ddee16f21f088154fa97bf55827a2d6b73c3db2a6084d2e11eda942b65a2b269d7fbefeeea1def50efc0228e374997c5558b14e2571fa0e7cad6d96131ec7f22758113dae057d421be238c6f00cb0288c1a054c188cf738b06e694217144105220deb84614ef3765258900e6d77f7eb816910429e86faf87785919f5cb238baa5cf38c53ec3096863ff47094d366812495ca0ccccb5f678839115e1e43a236811057c12f3bc000dc7970aee2afe656c4a86af951aca37dffab69638f7812144ea9683f6ecccc89a447df5304ca5623054d6ee44275834b2cf17baf589ece1f398371cbde6e1ae46898a6397eb9239567a967321927cc1f20448265d4a3b38edfc68475d8c65ed98238ee3391fbb6b80b94a0746f4644d623c4924a49a84dde95f91345fa72efeb186b6c00a94b99f3abbe65367e61aa61e4f8a4900f20f29270485d2492c763e8249318d6fd928d7848d83d185dffd7e291ec4f37d4466d80958cb19d4872f96e8ce836caee00aaf8fa8276fc653526dc033fc1d61e7353df0fcc34ddd4b505d44e7b642344fa61e60f6613e81a9e11149fb9ebebecca8c9231920a782a1b82e69a545c7cdaa7f136192cfc86d6fc38febfa0202e4574b061b2997341a840ef616fd6f66819a72bb9a4ec222cdf8206eed66a41dc4ff9ee81a1339784780b8ffc4610a5add7a468f2995a8ad35dec217994999283f4a513ad509a919fc305c4f4d01a017fa6276f891fb53858ed36bfe5e362761e7858b605cfdfac56f83951458ed133feab54c66eefe6fa460e8db1eb4dddea51229e42e5663ac024042df8684d1724d268b5c391c348dfa8c8331f8a6ea9b7e4101c25699a49cb2002e1f5009b9336f40d10bac3124df9389cedadbdcdd40e5944ad3a2f347f769046205bfbc886a5aebacc15028d7a801f0658aa5b0edd1629294ed2bdbcb0fe3c194ad1880d155c915cccfe949c53a13f75a0f486e3380ab6a1e4cd813b29eeebfe41b647d4e1d1b420f8f1763f3137cea5fadddfad27015a4472dbfed1ebef363b92e683315b41e51e3b2ef2226e2d89e2a1de09b9974e8a58fafa5f401303644d2aa9cd977c6dbda5ec972e3d7b2271954d51f2a6fcd248727cf00d37139765c05af4a1e06e6c96c73743f2164fc0100e1404f4d665846863d4360163ed60a5e6cbcf6007aa7a0ee3ec5c8cd1d773477c26e76e1ea24ededb4412b5e895e50d02d1064f826ed922d06d2e87fcf34185d0aa07d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【vscode】如何配置断点调试</title>
      <link href="/posts/1RVNF84/"/>
      <url>/posts/1RVNF84/</url>
      
        <content type="html"><![CDATA[<p>包含<code>python、cpp、ts/js</code>等调试<span id="more"></span></p><div class="admonition note"><p class="admonition-title">概要</p><ul><li><a href="https://code.visualstudio.com/docs/editor/debugging">vscode debug 官方文档</a></li><li>附一张日常开发调试用的 vscode调试面板 截图<img src="/images/vscode-debug.png" alt=""></li></ul></div><h2 id="环境配置">环境配置</h2><p>vscode 虽然是一款轻量级编辑器（相比于Visual Studio、pycharm），但只要搭配正确的插件使用，依然可以轻松拥有 <code>IDE</code> 的断点debug功能。</p><h3 id="launch-json">launch.json</h3><p>vscode 的调试配置都写在 <code>launch.json</code> 文件中，它的位置是在 <code>.vscode</code> 目录下。如下是一个最简单的 python debug 配置：</p><pre><code class="language-xml">{    "version": "0.2.0",    "configurations": [        {            "type": "python",            "request": "launch",            "name": "Python: debug",        }    ]}</code></pre><p>常见字段的含义和配置方法如下：</p><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">作用</th><th style="text-align:center">必选</th></tr></thead><tbody><tr><td style="text-align:left">type</td><td style="text-align:left">调试语言，需要安装对应的<code>debug extension</code></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left">request</td><td style="text-align:left">支持 <code>launch</code> 和 <code>attach</code> 两种模式</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left">name</td><td style="text-align:left">调试选项中展示的名称</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left">program</td><td style="text-align:left">调试的目标文件，如 <code>main.py</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">args</td><td style="text-align:left">参数，格式为 <code>["1", "2"]</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">env</td><td style="text-align:left">环境变量</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">cwd</td><td style="text-align:left">设置工作目录</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">port</td><td style="text-align:left">attach模式指定端口</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">console</td><td style="text-align:left">使用哪种终端: <br><code>internalConsole</code>, <code>integratedTerminal</code>, <code>externalTerminal</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">preLaunchTask</td><td style="text-align:left">debug之前运行指定Task</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">postDebugTask</td><td style="text-align:left">debug之后运行指定Task</td><td style="text-align:center"></td></tr></tbody></table><p>一些常用的环境变量：</p><ul><li><code>${file}</code>：表示正在打开的文件</li><li><code>${workspaceFolder}</code>：表示 <code>workspace</code> 的根目录</li></ul><h2 id="python">python</h2><p>python一般选择调试当前文件，要注意工作目录是否正确。</p><pre><code>{    "name": "Python: 调试当前文件",    "type": "python",    "request": "launch",    "program": "${file}",}</code></pre><div class="admonition warning"><p class="admonition-title">python2调试</p><ul><li>新版的 <code>python extension</code> 往往不支持 python2 断点调试，需要回退到<code>2021</code>年左右的版本</li></ul></div><h2 id="cpp">cpp</h2><p><a href="https://code.visualstudio.com/docs/cpp/cpp-debug">官方文档: Debug C++ in VSCode</a></p><p>C/C++ 的断点调试略微复杂，需要分为两个步骤：</p><ul><li>使用 <code>gcc/g++</code> 将源码编译为 可执行文件（默认为<code>a.out</code>）</li><li>使用 <code>gdb</code> 调试 可执行文件</li></ul><h3 id="1-编译">1. 编译</h3><p>首先借助 vscode tasks 将cpp源码编译为可执行文件，配置如下：<br>详细可以阅读 <a href="https://code.visualstudio.com/docs/editor/tasks">官方文档：VSCode Tasks</a></p><pre><code class="language-xml">{    "tasks": [        {            "type": "cppbuild",            "label": "C/C++: gcc build",            "command": "/usr/bin/g++",            "args": [                "-g",                "${file}", // 编译的cpp文件                "-o",                "${workspaceFolder}/a.out" // 生成的可执行文件            ],            "options": {                "cwd": "${workspaceFolder}"            },            "problemMatcher": [                "$gcc"            ],        }    ],}</code></pre><p>配置 <code>tasks.json</code> 完毕后，可以通过 <code>ctrl+p</code> 输入 <code>Run Task</code> 并选中 <code>C/C++: gcc build</code>，可以将当前cpp源码编译为指定的 <code>a.out</code> 可执行文件。<br>后面的调试需要用到这个task。</p><h3 id="2-调试">2. 调试</h3><p>接下来配置 <code>launch.json</code> 以实现对上一步生成的 <code>a.out</code> 调试，配置如下：</p><pre><code class="language-xml">{    "name": "gcc/g++ debug",    "type": "cppdbg",    "request": "launch",    "program": "${workspaceFolder}/a.out", // 需要调试的二进制文件    "args": [],    "stopAtEntry": false,    "cwd": "${workspaceFolder}",    "environment": [],    "externalConsole": false,    "MIMode": "gdb",    "setupCommands": [        {            "description": "Enable pretty-printing for gdb",            "text": "-enable-pretty-printing",            "ignoreFailures": true        }    ],    "preLaunchTask": "C/C++: gcc build",    "miDebuggerPath": "/usr/bin/gdb"}</code></pre><p>其中的 <code>preLaunchTask</code> 会在按下 <code>f5</code> 调试按钮后，先行运行指定的Task，即编译指定的cpp源码文件，然后调用 linux下的 <code>/usr/bin/gdb</code> 对可执行文件进行调试。</p><h2 id="Node-js">Node.js</h2><p>vscode 对于 <code>js/ts</code> 的开发生态支持度非常高（毕竟vscode插件都是基于<code>typescript</code>所开发的）</p><pre><code class="language-xml">{    "type": "node",    "request": "launch",    "name": "JS/TS debug",    "skipFiles": [        "&lt;node_internals&gt;/**"    ],    "program": "${file}"}</code></pre><h2 id="others">others</h2><div class="admonition warning"><p class="admonition-title">其他语言用到时再补充</p></div>]]></content>
      
      
      <categories>
          
          <category> VSCode </category>
          
          <category> VSCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【cpp】pointers</title>
      <link href="/posts/pointer/"/>
      <url>/posts/pointer/</url>
      
        <content type="html"><![CDATA[<p>cpp指针、地址、引用相关<span id="more"></span></p><div class="admonition note"><p class="admonition-title">概要</p><ul><li>指针是C++学习中绕不过去的难题，需要对计算机内存有深入的理解。</li><li><a href="https://hackingcpp.com/cpp/lang/pointers.html">hacking C++ Pointers</a></li><li><a href="http://alumni.cs.ucr.edu/~pdiloren/C++_Pointers/">Learning C++ Pointers for REAL Dummies</a></li><li><font color="#FF1E10"><strong>todo: unique_ptr, shared_ptr ...</strong></font></li></ul></div><h2 id="When">When</h2><p>任何一门技术（或者概念），都是服务于具体的需求，或者在特定的需求场景下，才会诞生。<br>C++的指针也不例外，它的出现是为了满足如下三个常见的场景：</p><ul><li><p><strong>持有（任意的）对象</strong><br>在避免 copy 的情况下持有对象，这是 cpp 最重要的语言特性之一，通过指针可以实现对象的引用。</p></li><li><p><strong>访问动态内存</strong><br>这块暂时没理解，todo…</p></li><li><p><strong>创建某些动态的数据结构</strong><br>如 vector，链表，树等结构。</p></li></ul><h2 id="What">What</h2><blockquote><p>Pointer to Object of type <code>T</code>，which stores a memory address.</p></blockquote><p>指针<strong>永远指向一个具体的对象</strong>（任意类型<code>T</code>），也可以是空对象（<code>nullptr</code>）。<br>指针的<strong>本质是一个内存地址</strong>，这个地址在 x64 的机器上占 64 Bits，即 <code>usigned int64</code>。<br>指针的生命周期，和它所指向对象的生命周期，两者是相互独立的。</p><div class="admonition todo"><p class="admonition-title">TODO: 通常说的 “指针” 是指c++默认指针，不包括如下（有空补充）</p><ul><li><code>std::unique_pointer</code></li><li><code>std::shared_pointer</code></li><li><code>std::weak_pointer</code></li></ul></div><h2 id="Operators">Operators</h2><p>C++有三个操作符与指针相关，分别是 <code>&amp;</code>、<code>*</code>、<code>-&gt;</code>，需要区分其不同的使用场景和含义。</p><h3 id="Address"><code>&amp;</code>: Address</h3><p><code>&amp;</code> 的含义是<strong>取地址</strong>，<code>&amp;a</code> 会<strong>返回对象a的地址</strong>。</p><p><img src="/images/cpp-address.png" alt=""></p><h3 id="Dereference"><code>*</code>: Dereference</h3><p><code>*</code> 的含义是<strong>解引用</strong>，该操作符后面会跟随一个地址，<code>*p</code>会<strong>返回地址p上的值</strong>。</p><p><img src="/images/cpp-pointer.png" alt=""></p><h3 id="Member-Access"><code>-&gt;</code>: Member Access</h3><p><code>-&gt;</code> 的作用是<strong>访问类成员</strong>，准确说是访问一段地址上的某个成员属性，经常会和 <code>.</code> 使用混淆。</p><ul><li>对于指针类型，使用 <code>-&gt;</code></li><li>对于具体的对象，使用 <code>.</code></li></ul><p><img src="/images/cpp-access.png" alt=""></p><h3 id="和-的区别"><code>&amp;</code> 和 <code>*</code> 的区别</h3><p>作为不同的操作数有不同用法，区别如下：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>*</code></th><th style="text-align:center"><code>&amp;</code></th></tr></thead><tbody><tr><td style="text-align:center">声明符</td><td style="text-align:center">定义指针: <code>int *p = nullptr</code></td><td style="text-align:center">定义引用: <code>int &amp;a = b</code></td></tr><tr><td style="text-align:center">一元操作符</td><td style="text-align:center">解引用: <code>char a = *p</code></td><td style="text-align:center">取地址: <code>auto p = &amp;a</code></td></tr><tr><td style="text-align:center">二元操作符</td><td style="text-align:center">乘法运算: <code>a * b</code></td><td style="text-align:center">与运算: <code>a &amp; b</code></td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">不要在单行申明多个指针</p><ul><li><u class="error"><code>int *a, b</code></u>：容易产生歧义，建议多行申明</li></ul></div><h3 id="pointer-to-pointer-⭐"><code>**</code>: pointer to pointer ⭐</h3><pre><code class="language-c++">int   v = 5;int*  p = &amp;v;  // 指向intint** pp = &amp;p  // 指向int*</code></pre><h2 id="nullptr-C-11">nullptr (C++11)</h2><blockquote><p>nullptr is a special pointer value</p></blockquote><p><code>NULL</code> 完全等同于0，<code>nullptr</code> 本质是一个空指针对象，注意两者的区别！<br>作为规范，<code>nullptr</code> 通常代表 <strong>无法访问的变量</strong>（value not available）</p><div class="admonition note"><p class="admonition-title">nullptr 编码规范</p><ul><li>指针初始化时，赋值为nullptr：<code>int *p = nullptr</code></li><li>解引用时，检查该指针是否为nullptr：<code>if (p != nullptr) { *p = 8; }</code></li></ul></div><h2 id="const-pointer">const pointer</h2><blockquote><p>Read-only and preventing pointer redirection.</p></blockquote><p><code>const</code> 搭配指针会产生奇妙的化学反应，一共有如下四种情形：<br>牢记口诀：<strong><code>const</code> 左边的永远是不可变的。</strong></p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">指向的对象 可修改?</th><th style="text-align:center">指针自身 可修改?</th></tr></thead><tbody><tr><td style="text-align:left"><code>int *</code></td><td style="text-align:center">✔</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left"><code>int const *</code></td><td style="text-align:center">❌</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left"><code>int * const</code></td><td style="text-align:center">✔</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:left"><code>int const * const</code></td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr></tbody></table><p>下面看一段代码示例：</p><pre><code class="language-c++">int i = 5;int j = 8;int const* cp = &amp;i;*cp = 8;   //  ❌ COMPILER ERROR: pointed-to value is constcp = &amp;j;   //  ✔int *const pc = &amp;i;*pc = 8;   //  ✔pc = &amp;j;   //  ❌ COMPILER ERROR: pointer itself is constint const*const cpc = &amp;i;*cpc = 8;  //  ❌ COMPILER ERROR: pointed-to value is constcpc = &amp;j;  //  ❌ COMPILER ERROR: pointer itself is const</code></pre><h2 id="this-pointer">this pointer</h2><p><code>this</code> 仅在类内部使用，<strong>本质是一个指针</strong>。</p><ul><li><p><code>this</code> 返回类对象的地址</p></li><li><p><code>*this</code> 访问类自身</p></li><li><p><code>this-&gt;</code> 用来访问内部的成员</p></li></ul><h2 id="Memory">Memory</h2><p>接下来从 <strong>内存分配</strong> 的视角，理解指针在计算机内的存储，以及指针运算符做了什么。</p><ul><li><p>根据内存对齐，<code>char</code> 和 <code>short</code> 在内存中都占据 4 bytes</p></li><li><p>指针的本质，就是第一个byte的16位地址（因此 <code>sizeof(p) = 2</code>）</p></li></ul><p><img src="/images/pointer-memory.png" alt=""></p><ul><li><p>下图演示指针的<code>++</code>，会根据指向对象的内存大小而进行偏移</p></li><li><p><code>pointer += 2</code> 或者 <code>pointer --</code> 也是同样道理</p></li><li><p><code>pointer[3]</code> 等价于 <code>pointer += 3</code> 后的取值</p></li></ul><p><img src="/images/pointer-memory-add.png" alt=""></p><h2 id="⚠️-Warning">⚠️ Warning</h2><p>指针使用经常会出现如下几种错误：</p><h3 id="1-dangling-pointer">1. dangling pointer</h3><blockquote><p><em><strong>dangling</strong></em>： pointer points to an invalid/inaccessible memory address</p></blockquote><p>永远确保 <strong>指针指向的对象是合理的</strong>，否则出现 悬空指针（迷途指针）。</p><ul><li>error 1：访问 未初始化的对象</li></ul><pre><code class="language-c++">int *p; // p not initialized!*p = 7; // ❌</code></pre><ul><li>error 2：访问 nullptr</li></ul><pre><code class="language-c++">int *p = nullptr;*p = 7; // ❌</code></pre><ul><li>error 3：指向 无法访问的内存<br><code>p = 0x0000001</code>，这是运行程序无法访问的内存段，运行时会报错。</li></ul><h3 id="2-pointer-argument-passing">2. pointer argument passing</h3><p>当函数的参数定义为指针时，注意传入的参数，不能是一个非法的指针。</p><pre><code class="language-c++">void swap_values (int* a, int* b) {  int t = *a;  *a = *b;  *b = t;}int x = 3, y = 4;swap_values(&amp;x, &amp;y)        // ✔swap_values(&amp;x, 0);        // ❌ UNDEFINED BEHAVIORswap_values(&amp;x, nullptr);  // ❌ UNDEFINED BEHAVIOR</code></pre><h3 id="3-hard-code">3. hard code</h3><p>通过合理的编码，区分 <code>*</code> 的频繁使用，尤其是乘法和指针混合使用的场景。</p><p><code>*p = *p * *p + (2 * *p + 1);   // SO MANY STARS!</code></p><h2 id="指针习题">指针习题</h2><p>当你以为入门了cpp指针，尝试解答下面的题目，常看常新：</p><ul><li>已知如下的地址和取值，问如下输出</li></ul><pre><code class="language-c++">cout &lt;&lt; v;cout &lt;&lt; p;cout &lt;&lt; pp;cout &lt;&lt; &amp;v;cout &lt;&lt; &amp;p;cout &lt;&lt; &amp;pp;cout &lt;&lt; *v;cout &lt;&lt; *p;cout &lt;&lt; **pp;</code></pre><p><img src="/images/pointer-question.png" alt=""></p><h3 id="解析如下："><strong>解析如下：</strong></h3><ul><li><p><code>cout &lt;&lt; v</code>：5</p></li><li><p><code>cout &lt;&lt; p</code>：0x44</p></li><li><p><code>cout &lt;&lt; pp</code>：0x48</p></li><li><p><code>cout &lt;&lt; &amp;v</code>：0x40 (=p)</p></li><li><p><code>cout &lt;&lt; &amp;p</code>：0x44 (=pp)</p></li><li><p><code>cout &lt;&lt; &amp;pp</code>：0x48</p></li><li><p><code>cout &lt;&lt; *p</code>：5</p></li><li><p><code>cout &lt;&lt; *pp</code>：0x40 (=p)</p></li><li><p><code>cout &lt;&lt; **pp</code>：5</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hackingcpp.com</title>
      <link href="/posts/1GTNS16/"/>
      <url>/posts/1GTNS16/</url>
      
        <content type="html"><![CDATA[<p><code>hackingcpp</code> 网站的学习记录<span id="more"></span></p><div class="admonition note"><p class="admonition-title">背景</p><ul><li><a href="https://hackingcpp.com/"><em><strong>hackingcpp</strong></em></a> 是一个偶然发现的优秀C++学习网站，开这篇记录学习过程。</li><li><a href="/posts/142JHJQ/">pointers</a></li><li><a href="/posts/10R6MRC/">constructors &amp; destructors</a></li></ul></div><h2 id="Environment">Environment</h2><h3 id="ISO-Standard-C">ISO Standard C++</h3><p>C++语言标准，前后经历如下几个大的版本。大学教程所传授的C++基本是围绕 98 展开，工作中使用的 “现代C++特性” 基本也不出 11。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">时间</th><th style="text-align:left">特性</th></tr></thead><tbody><tr><td style="text-align:center"><em>C++98</em></td><td style="text-align:center">1998</td><td style="text-align:left">the original standard</td></tr><tr><td style="text-align:center"><em>C++11</em></td><td style="text-align:center">2011</td><td style="text-align:left">almost a new language</td></tr><tr><td style="text-align:center"><em>C++14</em></td><td style="text-align:center">2014</td><td style="text-align:left">some improvements</td></tr><tr><td style="text-align:center"><em>C++17</em></td><td style="text-align:center">2017</td><td style="text-align:left">new features &amp; library extensions</td></tr><tr><td style="text-align:center"><em>C++20</em></td><td style="text-align:center">2020</td><td style="text-align:left">game-changing new features &amp; libraries</td></tr></tbody></table><h3 id="Compiler">Compiler</h3><p>主要有 gcc, clang, MSVC 三种主流的C编译器，其跨平台、兼容性、代码生成和优化都有所差异。不过 99% 的开发场景不需要考虑到 这三种编译器 之间的差异性。</p><p>看到一些资料，都会说 <strong>clang 的性能和内存都要优于 gcc</strong>，这里不了解所以不作为何描述。</p><ul><li><p><font color="#1A9BFF"><strong>gcc/g++</strong></font><br>GNU C++ 编译器，使用最为广泛。</p></li><li><p><font color="#1A9BFF"><strong>clang/clang++</strong></font><br>又称 LLVM，一般作为 Mac 默认的编译器，因为其同时支持 C、C++、Objective-C。<br>关于 gcc和clang的对比，推荐阅读该材料：<a href="https://opensource.apple.com/source/clang/clang-23/clang/tools/clang/www/comparison.html#:~:text=Clang%20is%20much%20faster%20and,does%20not%20support%20expressive%20diagnostics">Clang vs GCC</a></p></li><li><p><font color="#1A9BFF"><strong>MSVC</strong></font><br>Microsoft Visual C++ 是由微软开发的C++编译器及相关环境，只使用于 Windows。简单来说，这是 windows C++ 开发的 <s>唯一</s> 最好选择。</p></li></ul><h3 id="Running">Running</h3><p><code>g++ hello.cpp -o sayhello &amp;&amp; ./sayhello</code></p><p>C++是一门编译型的静态语言，（区别于 Python）其源代码是无法直接运行的，而是需要通过前面说的编译器 转换成二进制的机器代码。因此一个 <code>.cpp</code> 文件的执行需要经过如下几个步骤：</p><p><img src="/images/cpp-running.png" alt=""></p><h3 id="Compiler-Flags">Compiler Flags</h3><p><code>g++ -std=c++20 -Wall -Wextra -Wpedantic -Wshadow input.cpp -o output</code></p><p>需要掌握基本的 <a href="https://caiorss.github.io/C-Cpp-Notes/compiler-flags-options.html">C++编译选项</a>，如 Warnings、编译标准、优化等级 等。</p><table><thead><tr><th style="text-align:center">编译选项</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>-std=c++20</code></td><td style="text-align:left">使用 <em>C++20</em> 标准编译</td></tr><tr><td style="text-align:center"><code>-Wall</code></td><td style="text-align:left">打开一系列的编译警告</td></tr><tr><td style="text-align:center"><code>-O0 </code></td><td style="text-align:left">优化选项，代表关闭所有优化</td></tr></tbody></table><p>当你在 windows  MSVC 开发时，借助 Visual Studio 可以在 “属性页” 查看和编辑所有的优化选项。它实际上是提供了一个可配置的GUI框。</p><h2 id="Variables">Variables</h2><p>最基本的变量申明方式有两种：</p><ul><li><code>type var = value</code>: 通用写法</li><li><code>type var {value}</code>: <em>C++11</em> 标准</li></ul><div class="admonition warning"><p class="admonition-title">undefined behavior</p><ul><li>时刻牢记初始化变量，这样能避免很多类似Bug</li></ul></div><p>注意 <code>a++</code> 和 <code>++a</code> 的区别，在合适的场景使用两者：</p><ul><li><code>a++</code>：返回旧值</li><li><code>++a</code>：返回新值</li></ul><h3 id="Type-Narrowing">Type Narrowing</h3><ul><li>低精度 向 高精度 转换：OK</li><li>高精度 向 低精度 转换：NARROWING，有信息丢失</li></ul><h3 id="Control-flows">Control flows</h3><div class="admonition note"><p class="admonition-title">if (statement; condition) {...}</p><ul><li><code>C++17</code> 允许这样的写法: <code>if ( int x = 5; x &gt; 0) { ... }</code></li><li><code>switch</code> 同理</li></ul></div><h3 id="using">using</h3><p>使用 <code>using</code> 代替 <code>typedef</code>，用来作类型的赋值，例如：</p><ul><li><p><code>using real = double</code></p></li><li><p><code>usning int_vector = std::vector&lt;int&gt;</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【日志】2023年6月</title>
      <link href="/posts/2023/6/"/>
      <url>/posts/2023/6/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="57315dc35c6a9822422a46384cc2e8e6074031f23a2214e52d6bdf3d2abaf09f">b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475de0b1305a637ea913974dff7410a14ed4dbbb40a5278eb14bbac34e59e12a284c7a294ab69a495d47e11e78ad50feb107058e3275f75d936a554eb95bedbf96a7783a11b9f4096cfe1861725619e5a531746d668c7ddc527dd363ab656ea7f69ac2f25b2c496b27abbc3824127870eca0d8a2f8c80addbf39e2b1e80923c0a03fdb5696fde6983b2df072a7b0cda199e20f9fb9c7d770945c6cf667caf0962029a3b039c88bb6c1058092bcdc12419b3ddcf5845ecf891615201024a124bb8479b53886fd25f57cab26c014b23a8f02610784d4555664647631777f5564e260a383be4a83a05ada80e4aa10419916daa8c7ee3856d3f201cd7b910752eb07e88f6435fbea5a36ec4e90944ec768efa1f2e1a5014bcb16bf85702108e5592d7768437de280aa71a0b02bbb043cc44b1f748932a83a7e7994fc6dfff56125db4462b4b7af4d08cc5ca557b0ec57ea956d6b52068f1485d3095beaafd7eec7605af22706f9f5653981a57a9a2ae3751b52c3f310bfa704407c9efcb3e3fe59069aef388cd7b7c99e15a9cf1208b4d91ec742f425851a3ea9b8eb6576162bafe3868b36b322d2ea63f8cb1121b4fb5e8c5e1fdf05419cff11bba2faf692e9a6a936d60afa311b74e218ea590a6bc74a73b69f73559441f99b6889382bea7809cb13db5b09520b8590f4c43dcc3f37db86297cf84b8294e16c40ee91a0937e04de074ad77f504a0132e4f6f7cda0e01e545ce0aa381ea714f26ce0964ec9794113aaf2a1b7f848301ae08219a52326de2b0568df66fb6ecb20d8ab1101d37bd2fca650174996af5c32239ac9374077a98cfdaae53ad0809a9a4bce4ee804e6c94ced7216b791206d2f52adb59a30a472b3a372d592b29ede861aed6acb5c68959ab473cdd7cb5893433942c203da710f083cc6a94625fa29b8e394cdab8382c4ad03e6f9b348315c68873d88705119658cb5ffbf12e2cb9a2befba2ad3720df6c5fc1e3cb01d0d899b84530644d8484bf64f652ae473f9055027a3e2c2620c67906224ca9e01bd3f3bbb0fe1bd534347bf410ca5b00e4f90be13d6cfb4c9bcd5bcb531d0e93e7ace5ecf16b406029724a1a542fad5c39aeb1ce70a55d7d4ee9ac93f58a453b20575bf008cc94fbb711e44ef9d2bab9379c281d375347fd80feb18eec6dfd304d43ed1a3afd5828277544ab5d787f0cb01222db79f50d3c0a91d4a6f13be8c328dc8dee48a4abeaf0b8edd1be22f653601c441b3fc4d0f2d629b50bc51e8a9bc34272a5b831fbf6bf774b7e1e7b98bfec246e770366db1da3da7c4bdd16ff15390034f020bcce032facfaeabe68438bc7554fa951944b3de9d28ae887b61f48c6fa8cdc7923210f011949bb1b62566d0c2d3f8c5644ff0d01d1344a586f83b80b7b6a4c051e670bbeaaba29a70ea111a9b5e52a1d7e77b35fef01a1cc1517e1b4acf7bbf8d952464b2469e7595281c6aa8f8cbee95d7993b3810764a430aba9b205ed73271d4f8b926de93a18209a5654e3c80da19c4c7e4548645f77bbec651aed9076abdc51105923df8039b26e4832ce7c5f81ce1bd4843a0c94e140186b67674b0eb52f57d489e5bc154c287fcc287f49ec3d367f01ba60f58a96644bda1c66b09d0110832b37474f9dd15d5fd2c8af876db36d5fc8391494f06e539f8d5169e26564abb1d4794a7ea77f09f006e1320d8c9a6a470ae779b03611c49f4294073df9edd3692851cc2c0b5d817a7582c29a28fc7e27e02a0aadd76ffb519aa54b6a14b2e3e6b6ba6c60082855eea2f3cad85b1683c6846fd80abbcf1c4eced92d2de564a8a1a9b9e6bd858224336bdc00bd95d96d1e41bbb351dc600b6b0a206bcd2937a32e42d201724cb875db7806cc1a53173ebf8426a7519ff15f5a5992514278c3cf42fed8000e11d4a8b16d6475a0d85ec724d81b53869f4220349a051e215b4dbdb5bf1988039fd8473fe82afb5d1acfeff22d067c91a8c30692eeab6249683e96611937a27c735ea4da30f12953d6065b2b376bd8ccca9a954257cce36b096b31cdaf4a94c303f99d5b73c6504109db78e3848b6a60d85d919c081f4f643b7b9c91e14feadf5b5392378e52dfc34ebb2f6a9f304fa9a48a34d89974ec9a2491241076bfe6a7420bdd0fb3562fb6ca3d1ddbb6a374452f4e4d4441ddc3f5c485d74aac69598ded35ec84fb939a551715f06daab7a55b8dc2d8ce8aba3f545b9b15c8d32413bdb1ab92cd0fb0c77c6e757b98371cd37f6593e1d9afbcbc19894fc4e3d09e9d8a1ce9eaa25459d894e61ae91cb6b57705b2fed7558c3f999c6003dd2cf7aceacceed80886209ef311296b38836443e25181912cc6c213c1fe722d48f735bf84bd67162b19369efce628cab41d149c98e1215d32b01cedacc4cdb2c0bb2a556285ef1cc853a626684e6f548ddb87595cfd0e70ed17259eb33c8847d6af6d5154f610faf112744e4b9f9c6fdb6e002e8779bdbd37c345f82d3b6fa501c40863b09d0d91a4caa334800a6fcb52c596f7eee8dd6d6c370c9687966d74d0b30f8a9f4309b9644422cb52b87b99647f071194e07e9349a69e3d4981608a5f5a5abd477a4abe2c62841091885c550f11ca9bb12dcae10dd3c076c17a9d69dd68dc2f76e7c66471e41d261a270125c89082a206df131658dbaa1e8362d214c3ab22a36e8de23c09ec1da3f6301db6407fc856e4906543be9e59377c74abeea7b0f7bcb505fdd3336eae0bc9261a2b87ee660d7e370f7092036b4d20f1c7296afcce17fdd4eb826954e0630971ab7d2cdb991d43535bf60a329803ce7cd921890cc4773c8ca4e4bd754c442bb9c09b0462bef054a233e029b7184c103ffe13612c5f04d8b9c592ab23e766b5095907973f61d362b4f659593143fefeadd77f43e280863f4030ce558d6a1fe2baa4460729edea3d181f39f10e4d85a0fcec852d0ad14d0dcb1caf34f36d77b9fb0465dc2e3956909009793b7b0ec17575dbccffd8ac872c4a04a11d32341a94a8356f28661784122b49bc986cdf26daea8d118f5c9f6a877a18f7dd866db79ed8382ee9820877e6aaa78dc5805bb08cb9cba6599ac3b2a68dc6048e110cd8ff25598d03883f9fc62e397a94249873f0f90261b3d82993117f30e3c33470cbbee0818296934c209c7b33204d0b10784f0d890118e1c50d57843214d556b67a2ae0aaa17991eaa1e361a34b06636bc5d12ce136fd6b2434334f22b1c0dbf3ee6d70970cf5a1f687d960b3e0b8d1451ee0b4f5b53dbeaca467048977e2f459b50574bfcc051898e857ebd2e9dad17b9f5c61ae2a12c7eb07ce4c9fdd33a53fe5dd7bbc69ee1df207f2f2227face54176b0c86d1835a68e9eeaf8ccf07f480d2a20f95b54f48c7f9ad522469ab094e64304f4eeaa72ae2d7ce1452a7b192938a095a139fd7d64f4d6c87627612adf687b454ed34beef741d0d83561898e6972f96943c756640d4885542019b4a3493655eb94e48219dcc1012a8e2ac5a5e59b9085294b910372861c7ca511fef2131126ec9d6aa4cd8b6c17a19763625de9c1866b15518e3c17cecbda85120b71bb62ebf86fd988d53533785348c6af17f98110d40b02c3e9b873898be3e384b685d447833bb8b1817ac67627bf7cfe769cc7f580856e88c20a2d8091fecd66e4981ea48d7a0f17bd38c470569e2ea574af532b36f476480024afc7f562340f7b68d6e51bc4bb15953183baab5b946ff251c181aae25fd8f7aa46df977cb14dc9bec4b234244e19bd9905536667e2d5d1e3623655c0bee13d09438a2a11f5c7d59b00ddd6ddd411e97f778689f03280e7163c4225ff5c3be3c09dee7907e5b602e873e57c8e17c427d6bad4ae8689a7e2e0f273a4592f519e94f638e991eaae06eb3ecc69ca4ae2e1f299c4fb8d6c740771ee321c27f12965f07d0d1a9f235cf9500f17367cfa9c352c69f7add537eaca3dfa5365505583a7fda66782a91270974c56f9116feed37329ddef413fc2af8afd1690f7b14b240544197486df99933f7352e675bfaec667790c670d7d03468ef4fa1093f1b68a642374b6029bdd6362c2eb743bbdebc52a3ee5928535022bc031d38c835475f282c811dc04e46a25426c263ab9687ba29c7764339c3037087d16ffe1df24d5a7d49acadcb68c166e618c46409080da6bd0b29d28d0713f9a18e74dc5e0d632f1843aad5522814475655f99e4d0d03c2b1ae9f21fb9e1fe52e72596b6589cdc1c529c3029e116b0be145fc683714b0224478c1c21fc6a3b6dc46fc7f90ceb0f7b43dda1beb159e4095e2cbe8e4dad649f4089bbcc6ce24ad8702bebce5d2114671de9a80a01c0a16c2f4d88785c123fa1d0062e99ddb3c292a2dd2def8a2f256292cd40da272c707386d364fb9cf11c3756c41d0cf6fdf99092ce4a2f8924c25bdd3c35e4bd90ed35b0a01f2b845f524f5b985971532da5ad8a254a0454f25bea4bd49f4089e0b4f7141d7f6db838ef3216fd3fcdd1673dd09c587ec394abc16b16ca5f20d65c111f3fed2a89611f07d7347cd6bd08a457db5202bbc41c5b8e7c9d050d7f56d834f05971444c2bd3b46558c7bee0496a3898c5d6102d6ac64be43775ddc4b4519651a0298d49b1dab9b367b28658cad4ce8c779761e722bbaa5c22acfade7b9a69242d0c49f55210e4eedb0b4aed05be3c089916febaeeda1c821d2a2680da84f2332f407bfd23d8e447258e672a77b0fb4381cf18a40f34b809ad176a6b808b9023453a4cedbbb2ac6bcdc5aec4f8145aeaf6704816c3d8e696996d198119476470f3b6bfe161bdaf18b324c1bd8310ac2daf193561e098efde5978922a9c031a15594b5c758ac44ddefe651961fc9e6395aeb00f030b27914e350fa82ee1ca8322abebc2457aeb49fd3f8d387a77729bcceeea8da2ed4b00c6c84f6c0ce633671c490b685e55c8d95d8b297455a78ab813481b706f5e6194d5074b5542685feb1b67f032c04b01a6141b25972d0b48c187aabe49c3d0499413c98f20aaf1651fe203df8709cf3af744e794b334e068a26f6c4a5b1625078b3a2ffa2682e44ae62cf599e6ad9d9d8d0c666cc58b59536b71ecb30ddc3cf3498cb59bc741949915c6cea51b12a14d8997e2c7642812329e5242c1c48dcad787a8abadfe9e02cba4d77eb9155b8177f900eed30913cf82709c2e3b1d5b737c027cad1fc4ff434823f0bcdcae9fea1d8600c28e785281c4c6861a9af55fd8494c4e30c7418e35e727bc5cd77af791330f78533c210cf4199ac9efb4f764a28271b77f6dbb6b6b3e37b035a91e909049a577e1c9399f2539012e91252ca79ed4bc80fba91b1f16b4f55f09e7f163df4fe27a9b71067476985bbd95a46be713a3609c824d2dc534d7dddd894d9e7c7a152936a2178bbc3a8c3d7cd19d4db103e76fbd2700733781c68491bda41a928f578b09b2dfb4dc9324925ce5d7f96adc948924a592afb391ffddce9c81d06db9f893862cc2164b9d983aff675e6b0fecaff02ea9300f5429c74228399f581312a0f7da1d9152e94d457a4ee3d2c1981b0413577d57a3cbd8d3f5bbfa627747d83ac5de877480efd73b149d3d5453204ae4e51c49d3e4a9da268b5dd682cd42e8ab278fe583ad04c7ef606befcb531e9ca5332c8ac8c462044938bf4614e3688c83d8e7b6b33fde3393590ce424ccd518f00a1d4b6632a2d62c1319aa986b1757eeff6bd7fc8bf532abf6bdf0c17cab5523268d4b1945dd086e2132cbf40936020d1a0c9941f562cf9ae9ad4a49bf53a12f2f2fbd8f26ea50bfe1a9437ae8709415f83dab6d3a75d50e24a17de437545c500a349fdc7710cb1833f9f982aea0e0a1c19deb2511a7811118031ab99217e65f0dedfc3cacd8b29df1768bc9a751b71ab38b191ff66e8929b46afe50218c231112d20f479b33f76cd4a2483da6147096314b710fa074499e5592fc7f7c9f5537f574a6e7acf18b857142356aa084844fb0ec730f7fd9bd364ff6b67cc098435242e58112fefea3e0e9fe058960a1b9db35e8241b1b12200f8f30fde740d72241176e4b970c2d5188a9fe563eee26793fb423ca43c55bd5ee5b2e474dfa1cbfd1dec77655fda211da764d16a2abb40aa6f87015e3280e7c247a6ee484dd1eaea4a30131e9c4071aa3a732944365de4df7796bebd83255aa9ddb7318e5584fd9ccd54d94a8eb148b5b2b117fe73d8e41a610b86910de8c99c5c93468085f28a8b56ff2e198d1be9102a0a0d785f84a9cf1840b2fcfb65d4f092726b22cc78e261a874c9e80293f5aba84a4d5a95addd8c1fd6e39d401635f7400e7c6dbf665c0968ced393c84358c22c10bbb6d4ad3f7c6c4002215a921b0a07f0e815d30c7407eede3da2b3df02f4e4325e17680acd8de01ed9df9deda0b845271d5184d3fb3391bb69031dee5a936ad05aadbabb28a5a71c9a2427a6d2d2de014d71fb7d4bb1e9d66ee17f61a0ee36b48ef01c04d9a8cce147a7f3db081cbb9ba2b6df2ee90aeebd5a9dfc05c8a71f9bae26b054a78b27153660c4f5e0366259c970b41cbc939c17396858ee0b02d5fcf1747d2d85d819ef0501be3defdc075512d98e8a40f0508b3c8b800ff657574f9663239877e0e61dcdce5ced9f9d22241c6593c8473366b5bf301805c62ed726a30c9c66b7b448e2b1821a1a4d5bfdb5d8e53171074a14300ec8888e6a5bbe70e3e532f32c19fc46ae15c5928cde94515e83ecdc90a08feb375f506350ea458a2b0ec77432aac460dc2f026fe26a13f9b74fc20d8ab1392a638c50650a02851e1075a4df699242e04d502564bfe0f1360bcd8870c52a7b2a26080fbdb7119cde74c87467392db93380d34a0e9e3324f6157d7e119deeba2e02b40c0e7f5cd884afbe0cda251b5e97841d7ee93c555240a1aec41b03c34d4731d0e001aff06994b662fd9c6bc8663e76b940db9d943558b7a349d6aafd7dc431ffaeef3b3051d30ce30412bb9d31779bf2fd33569c61fd5f1e29d49b032897d71a7eafa6a63e1ac6e326b1478934b050c448dba33251fe40a59e18835905a5a1be08288b022455bafa5e40007ec87d7cad53269d8cb4ba3e3eae7d3f40c8eb26b4e4e731b74f353e8ebf54cf833dc9702e11b68af5a3759ecc63173dedc0e290e4c68eaae8914e96812ecc784c363b188f5e6e0df614a6b49b70b11594302ca8a01e4290a899d7d883421b1644be04783a62a21e31dbc956faaee6d80fa6f944dc84e76c8f62d9fdbc20e0f9226cc24c6b007efd145186d7d21378f1b515e1dd4217085de5b3325d47e3c25f62ba79874712459e86c9a9754d53de03afd702f2a706ab039a7900dd089e48b0bc1f1351c6b8ce9228fae5fbbcccce0b6fe4053aacfd7f61623ba0195a21f91761e33752175e8f054d61b93740a6beee986575bb5bd55bdc445cd179cf507102ecaf404a5ee4d43f4a0d3ce4967b77e6a1e3694f680ed10f3a72b68b9100c9fb2b082fcb2fe14857ae46297185b37b34b7501ec5da1dd188b7a9513c9636185186e1835372a4b754be0d6fdf443dea5d79f21d074fc72e6c606f25fd95de9605878b347aa301032535b46213470b119d9fd2a4fc6665dd9036a06904c5212516d32b2cf80e473234fc7fa2b2df3d37123270a98142d40301053d33d8a633b9f7956ed8bb628fc5cd9cb3e88e7d6b87e2464ca9bf80b281615f4295e97632acea9e52f210dfcdf9510c120c39d7ce147cdf87ba7219f91fcec739ef4359222d1c6dec8564b611e0e9d55b264da8ad862db4c80d9518a8265a233dcd7d2bb3979f0eb0db5c78933a4ca8b479696e9875594b5bb245719e61734600162e473a285eba7858fd48d800ba0e5cfeb010a9e1b5d9c6e80e805d6953adf7ddba9cb217926d55ac921da456ed608ae3e6713885916ae9da6325e5cb1ee852eb928eb45339e767cfdacf80942f9343974d3e57ee8945816afa6c5966f574efa7fab0eb3de811e07427213c855c75faf27d5d5cbb159e5a5aa22ee1ac701550d7e2cc4fcb0dd14a7b29cd5bd27107c70e8df2923b27e505a698548e46f83c32402d4b32c2502d786075becb40b9e8b0461a7b6d1aebcfbfb3b6dd94058b6cccf51330793ff681ae175094edd8b0c14d49ba393a79d3f774ee1848f1c38af2320f1fd3dc5a684298096d216c6c5d191123658dcfeb8cc4f43317eee25d2051130ce88463d6591e040cd6316751a91fd94b74978685c50f408ed7e67adc01aae5343323b56fa88398773aea9eae0eb613357511075de894dba631c21241b8c582c231ec14bddf6fa6bf5fc84f1f8111b267c0691266f0a20454aeac8019fcb471be797e054cc3a94538db5847ca9bd9c1f931479a8ba3240554b9bc589c23ef30c1ba2abac1906bc0152c7b40d2222291a9f2fef971aeddc49e88250d1d23b340eb5ee2d0761ab12c6f385b43c8e9c1966f833dcc2e94c86d5b1f8a3f26acc1f1215fc46961e07a2ca0c520f0f776b9e50106b1a03f31fbfbbf82720b5960994a73f71aff8d8621fe40c09e7f41b33eee7a5dc63a10b4d281a766e141895eb45a359ef4e93d2bc278c9f5650a15a6a5c25c83c9ee0ed04d8dd03050a45e4f9de5dd23ce764576f84c7fad98634918021413483b18f74e7ee18f543f99ef37561a9f9f197d0415adf1fe63b5004e4fb51c8562eccc7b363767c535581541f5e058e64fc4e7220f57558bd0f1bda479e64d468be95e9511dbffb11ebe3eef31532759ef89004906ccb9ed3d474755a517659208696706ecdd28941db3c0b230a2d232b6a04c908e25a6290205b4126e95565592c0fa5edf9758b4e8aaa0c0d83a5f0b27c5a14fa4e07a3f057401adca77d320624562677020ccbdb14f46f16748c78a51c08b6bfa74abcdfd8a4320876079620fa3130c5d42585c630644ab370602ecbe12d547818bab8e7c653969600f3db9995d6f60b9e7fa12e6e06d93bca89801591f18cb6ed119e01f6db64103279faa6a66d3a8d1457214db62f0c78b7e0533078b35950eca3d9eaf62ca8883f53053d2a1415093d74f432dfb67680d9a18be3822c143991ba52849376640b9a9fe600ad6a9d918e3b27888160dd6a33aaa6b4f8d56a1305d7085cd49bddc08b4e343ff19b978bdf852f6cc702a14a585083d5642a95eca1ea1d6798f79d77e3948e4e17cf762c7351573f7286ffec26a2e037561c7d65289b5580bb5e56a10769c5c0f1b22d6c0487329681934608742dd717a427cc62747eb033209c323def4ae34ab0865fd4fa945e43fe1fd3e4e44fa382dcc8ce70aecfed3299a7c7b5c5b3ab030c8cadd3b6162209b9bc90540529fae5a54c492120f66d1fc2bf9be93d7b2d6956c09eb223b46fdca51489848983b5a755a8e1b9bb66460f6e36ad303397c1cc7d6755b296c9b493c114c456e10632713d4eb2b61b1a8a079044160da399770682f90f5dcea6fb152632ee99cf42af3e35047cdd6c8ec24e0f685701a47de1d1995325f480c33a9f93d1ce8b8791a364c9c05ffc7b81375cad1ab0680a904dbd3af0f20a8283635fb3bdbfb9f9b994a036cb6a10ecb32def3872435a9a6cec57c0c955841ee460f4931f7ed2f79c3ebfbdb3e3943f0633df0c670f225e185b25d74c7960f438a3e1ed7d0d851a1b96dc9c316271754dbe83f1906814506e7d1d7522f5684f66c1fbc23c7c5451538d10933a32a7ac915acfabab9f58875db16e2c66fda0243aefb722600d5695aec05e4a75f88c99a168d77d64e80c67cb76affd217bb758e4888b58cd5a9f6afe4c0728b5f1fb8cd96d852c50cdb48af7dbc6bd8ce682c78d162690890273ea13f852e6b7e8459d201716d7d4e619f07ab5651880ef898ec291a666186e636d5d87490e6a4a49cd11be7c6b2ae0769f75c3ad40ccbfe86d3d5af0b9eaed9d02bffd640c98f879976bc7dd211cd857c60379f732b236c9150c9094bc7d3a5ee0d419e0ebaebea69816520fd79a758969a8daee7aac46ddd34ef24a855947a7923c63f581a7dcaea7946d511149963cbcb7ea55b9315c45cfc6fcd89b98aa333c78503cd96e1329ce4a530c5002a743dc4d0528c85396022714a8dc3bad55966e3a15bd733e29ca9d9a539e127d6eb86e977209d87f7c096ad6e4301b33980835041b3022267a09b707238554399ec6b9d6532b74ab3f9c057dbcb15efc79c36fcd890552ee06ff15e2d2f6de98afd386fe8e61f5cfd57fff740540fd3e0782fd96fb83aa10eba2a0a30320018842d108ffffd474ad73379892d5b589b1c41d7ae4938ba18005d367996cada6f3842a04c6d51c7af0bc171a7adb1abff800553be05e7583934698418563bf96137d21e446f81e300e292aeaaa0e8d82fccadb36c04b9454c2b0be2b1698c574da65347ca5edd9290276cc45c84d1a4b340e6dbc63a9e94d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【selenium】自动秒杀脚本</title>
      <link href="/posts/3R1HHH2/"/>
      <url>/posts/3R1HHH2/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><ul><li>借助 <code>Python + Selenium</code> 实现 <code>taobao</code> 购物车自动秒杀</li></ul></div><div class="admonition error"><p class="admonition-title">TODO</p><ul><li>增加定时秒杀的功能</li><li><code>time.sleep</code>的时间把控（短则逻辑错误，长则秒杀失败...）</li><li>实测，实战</li></ul></div><h3 id="环境">环境</h3><p>下面以 windows 环境为例，因为高度依赖 chrome ui 界面操作，linux 暂且按下不表</p><ul><li><p><code>pip3 install selenium</code>，直接下载最新的 <code>selenium</code> 库</p></li><li><p><code>chrome://version/</code>，在 <code>chrome</code> 浏览器输入 以查看当前版本</p></li><li><p><a href="https://registry.npmmirror.com/binary.html?path=chromedriver/"><code>mirrors/chromedriver/</code></a>，下载对应版本的 <code>chromedriver.exe</code></p></li></ul><h3 id="访问网页">访问网页</h3><p>只需要掌握 <code>webdriver</code> 的几个核心接口：<code>Chrome</code>、<code>ChromeOptions</code>、<code>find_element</code></p><ul><li><code>options = webdriver.ChromeOptions()</code><br>创建一个 chrome 的配置项，实际用途是避开反爬虫的js检测。<br>具体代码如下，复制粘贴即可：</li></ul><pre><code class="language-python">options.add_experimental_option('excludeSwitches', ['enable-automation'])options.add_argument("--disable-blink-features=AutomationControlled")</code></pre><ul><li><p><code>driver = webdriver.Chrome(executable_path='./chromedriver.exe', options=options)</code><br>创建一个 chrome 的自动化示例，它会唤起一个谷歌浏览器，但是又不同于正常打开的 <code>chrome.exe</code>。<br>注意，需要传入对应版本的 <code>chromedriver.exe</code> 的路径。</p></li><li><p><code>driver.get('https://cart.taobao.com/cart.htm')</code><br>利用 chrome 访问指定的网页</p></li><li><p><code>driver.find_element('id', 'xxx')</code><br>根据html、css规则，查找指定的对象。<br>可选的参数有 <code>id</code>、<code>xpath</code>、<code>name</code>…<br>注意，旧版的方法是 <code>find_element_by_id</code>…</p></li></ul><h3 id="自动登录">自动登录</h3><p>前面访问的网页是 <a href="https://cart.taobao.com/cart.htm">cart.taobao.com/cart.htm</a>，如果浏览器没有对应的缓存，则会自动跳转到登录界面。<br>这时候需要借助 <code>find_element</code> 实现自动登录与跳转。</p><table><thead><tr><th style="text-align:center">find_element</th><th style="text-align:center">Arg1</th><th style="text-align:center">Arg2</th></tr></thead><tbody><tr><td style="text-align:center">用户名</td><td style="text-align:center">name</td><td style="text-align:center">fm-login-id</td></tr><tr><td style="text-align:center">密码</td><td style="text-align:center">name</td><td style="text-align:center">fm-login-password</td></tr></tbody></table><p>代码示例为：</p><pre><code class="language-python"># 用户名input = driver.find_element('name', 'fm-login-id')input.clear() # 清空# time.sleep(0.2) # 防止过快input.send_keys('*******') # 输入您的用户名# 密码input = driver.find_element('name', 'fm-login-password')input.clear() # 清空# time.sleep(0.2) # 防止过快input.send_keys('*******') # 输入您的密码# 跳转driver.find_element("xpath", "//*[@id='login-form']/div[4]/button").click()</code></pre><h3 id="自动下单">自动下单</h3><div class="admonition note"><p class="admonition-title">某宝下单成功有三个步骤</p><ul><li>1.购物车中 “勾选商品”</li><li>2.点击 “结算” 按钮 （选中商品后，按钮才是可点击态）</li><li>3.点击 “提交订单” 按钮 （选择收货地址）</li></ul></div><table><thead><tr><th style="text-align:right">步骤</th><th style="text-align:right">Arg1</th><th style="text-align:right">Arg2</th></tr></thead><tbody><tr><td style="text-align:right">1. 勾选商品</td><td style="text-align:right"><code>id</code></td><td style="text-align:right"><code>J_SelectAll1</code></td></tr><tr><td style="text-align:right">2. 点击结算</td><td style="text-align:right"><code>id</code></td><td style="text-align:right"><code>J_Go</code></td></tr><tr><td style="text-align:right">3. 提交订单</td><td style="text-align:right"><code>link text</code></td><td style="text-align:right"><code>提交订单</code></td></tr></tbody></table><ul><li>勾选商品</li></ul><p>下面简化为购物车内的商品全选。</p><pre><code class="language-python">while 1:    try:        select_all = driver.find_element("id", 'J_SelectAll1')        if select_all:            select_all.click()            break    except:        print ('Retry: 全选商品')</code></pre><ul><li>点击结算</li></ul><pre><code class="language-python">while 1:    try:        buy = driver.find_element("id", 'J_Go')        if buy:            buy.click()            break    except:        print ('Retry: 点击结算')</code></pre><ul><li>提交订单</li></ul><pre><code class="language-python">while 1:    try:        a = driver.find_element("link text", "提交订单")        if a:            a.click()            break    except:        print ('Retry: 提交订单')</code></pre><h3 id="代码示例">代码示例</h3><pre><code class="language-python"># coding: utf-8import timefrom selenium import webdriverusername = ''password = ''TB_LOGIN_URL = 'https://cart.taobao.com/cart.htm'options = webdriver.ChromeOptions()options.add_experimental_option('excludeSwitches', ['enable-automation'])options.add_argument("--disable-blink-features=AutomationControlled")# exe path for chromedriver.exeexe_path = r'E:\chromedriver.exe'driver = webdriver.Chrome(executable_path=exe_path, options=options)driver.get(TB_LOGIN_URL)input = driver.find_element('name', 'fm-login-id')input.clear()driver.implicitly_wait(0.5)print ("Username:", username)input.send_keys(username)input = driver.find_element('name', 'fm-login-password')input.clear()driver.implicitly_wait(0.5)print ("password:", password)input.send_keys(password)driver.find_element("xpath", "//*[@id='login-form']/div[4]/button").click()time.sleep(0.2)# while 1:#     try:#         select_all = driver.find_element("id", 'J_SelectAll1')#         if select_all:#             select_all.click()#             break#     except:#         print ('Retry: 全选商品')# time.sleep(0.2)# while 1:#     try:#         buy = driver.find_element("id", 'J_Go')#         if buy:#             buy.click()#             break#     except:#         print ('Retry: 点击结算')# time.sleep(0.2)# while 1:#     try:#         a = driver.find_element("link text", "提交订单")#         if a:#             a.click()#             break#     except:#         print ('Retry: 提交订单')    assert(0)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【GAMES101】Anti-Aliasing</title>
      <link href="/posts/3P0T9MZ/"/>
      <url>/posts/3P0T9MZ/</url>
      
        <content type="html"><![CDATA[<p>信号处理、抗锯齿<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">LearnOpenGL: Anti Aliasing</a></li><li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_06.pdf">GAMES101: Rasterization and Anti Aliasing</a></li><li><a href="https://www.zhihu.com/question/19714540/answer/1119070975">知乎：如何理解傅里叶变换公式？</a></li><li><a href="https://www.zhihu.com/question/264302905">知乎：如何理解图像经傅里叶变换后所得频谱图意义？</a></li></ul></div><div class="markmap-container" style="height:400px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;信号处理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;时域&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;频域&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;空域&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#傅里叶变换（Fourier-Transform）\&quot;>傅里叶变换</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;走样&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#什么是走样（Aliasing）\&quot;>What</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Jaggies&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Moiré&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Wheel-effect&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;<a href=\&quot;#为什么产生走样\&quot;>Why</a>（从信号处理角度）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;How&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;<a href=\&quot;#Blurring\&quot;>Blurring</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;#High-Pass-Filter\&quot;>Filter</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;<a href=\&quot;#Convolution\&quot;>Convolution</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;实际应用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#MSAA\&quot;>MSAA</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;#FXAA\&quot;>FXAA</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;<a href=\&quot;#TAA\&quot;>TAA</a>&quot;}]}]}],&quot;p&quot;:{}}"></svg></div><h2 id="信号处理">信号处理</h2><p>了解反走样与抗锯齿之前，需要学习一些基础的信号处理相关知识，其中最重要的就是 时域、频域 及两者的相互转化关系。</p><h3 id="1-时域-Time-domain">1. 时域 (Time-domain)</h3><blockquote><p>时域 是描述一个数学函数（或物理信号）对于时间的关系（函数）</p></blockquote><p>电脑上的音频文件（例如mp3、wmv…）就是一个时域信号的典型例子，其本质是音频（波形图）在时间上的分布，如下所示：</p><ul><li>横轴：时间 t</li><li>纵轴：声音的振幅<br><img src="/images/signal-mp3.png" alt=""></li></ul><p>声音信号是由 高音、中音、低音 三个部分组成，如果我们想加强低音部分，仅仅通过时域信号是没法修改的。因为高中低音在时域中是混合在一起的，没法通过逆变换将他们抽离开来。<br>因此引申出 频域 的概念 ↓</p><!-- **因此 [傅里叶变换](https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2) 的出现，就是为了将信号在时域和频域之间相互转化。** --><h3 id="2-频域-Frequence-domain">2. 频域 (Frequence-domain)</h3><blockquote><p>频域 是描述频率分布的关系</p></blockquote><p>频域的理解有点困难，需要结合时域一起看（如下图）。时域上的信号可以看做不同频率的信号的叠加，因此频域就是展示这些不同频率信号的分布。</p><ul><li>横轴：频率</li><li>纵轴：该频率的振幅（&gt;0）</li></ul><p><img src="/images/frequence-vs-time.png" alt=""></p><div class="admonition note"><p class="admonition-title">空域 (Spatial-domain)</p><ul><li>又称为空间域、图像空间（image space），可以理解为像素在屏幕空间（x，y）的分布。</li></ul></div><h3 id="时域与频域">时域与频域</h3><blockquote><p>时域与频域 表示的是同一个信息，只不过呈现的方式不同。</p></blockquote><p>下面以标准正弦函数 $sin(x)$ 为例，展现时域和频域的不同表示：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">函数</th><th style="text-align:center">示意图</th></tr></thead><tbody><tr><td style="text-align:center">时域</td><td style="text-align:center">$y = sin(t)$</td><td style="text-align:center"><img src="/images/time-domain-demo.gif" alt=""></td></tr><tr><td style="text-align:center">频域</td><td style="text-align:center">$f = \frac{1}{2π}$</td><td style="text-align:center"><img src="/images/frequence-domain-demo.png" alt=""></td></tr></tbody></table><h3 id="傅里叶变换（Fourier-Transform）">傅里叶变换（Fourier Transform）</h3><div class="admonition warning"><p class="admonition-title">关于傅里叶变换</p><ul><li>这部分浅尝辄止，理解基本概念和用法即可</li></ul></div><ul><li><p>任何函数都可以表示为 $sin$、 $cos$ 函数的组合</p></li><li><p>将时域转化到频域（傅里叶变换）</p></li><li><p>将频域转化到时域（逆变换）</p></li></ul><h2 id="什么是走样（Aliasing）">什么是走样（Aliasing）?</h2><p>如下概括了三种常见的走样的导致的 Artifacts：</p><table><thead><tr><th style="text-align:center">Artifacts</th><th style="text-align:center">原因</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Jaggies">Jaggies</a></td><td style="text-align:center">空域采样频率不足</td><td style="text-align:left"><img src="/images/raster-jaggies.png" alt=""></td></tr><tr><td style="text-align:center">Moiré Patterns</td><td style="text-align:center">空域采样频率不足</td><td style="text-align:left"><img src="/images/raster-moire.png" alt=""></td></tr><tr><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Wagon-wheel_effect">Wagon wheel effect</a></td><td style="text-align:center">时域采样频率不足 <a href="https://michaelbach.de/ot/mot-wagonWheel/">demo</a></td><td style="text-align:left"><img src="/images/raster-wheel.gif" alt=""></td></tr></tbody></table><h2 id="为什么产生走样">为什么产生走样?</h2><h3 id="从信号处理角度理解">从信号处理角度理解</h3><blockquote><p><em>Signals are <font color="#1AAD19">changing too fast (high frequency)</font>, <font color="#FF1E10">but sampled too slowly</font>.</em>  —— GAMES101</p></blockquote><p>将图像信息看做空域信号，根据傅里叶变换得出，可以表示为任何正弦信号的叠加，因此光栅化的过程可以理解为：<strong>以某个频率对原始信号进行采样的过程。</strong><br>由于造物主的超然存在，自然界的所有采样频率可以当做无穷的（时间是连续的、世界是无穷多个像素点…），而妄图用有限的频率去描述、去采样现实世界，即用有穷描述无穷，必然会带来信号和信息的损失。<br>以下图为例，采样频率固定时，当原始信号的频率越低，采样产生的误差也就越小；当原始信号的频率越高，采样产生的误差越大。</p><p><img src="/images/antialisaing-why.png" alt=""></p><p>上面3种常见的 <strong>采样导致的Artifacts</strong>，都是因为采样的频率较低（低于原图像的变化频率）。</p><p>原始图像的信号不是随着时间而变换（时域变换），而是随着空间中x、y的值而变化（空域变换）。信号的变化频率高是指：像素之间的RGB颜色是否发生骤变（如白色255变成黑色0）。<br>从这个角度理解走样的原因：</p><div class="admonition note"><p class="admonition-title">为什么锯齿都在图形的边缘?</p><ul><li>因为内部的信号变化慢，低频采样没什么影响；而边缘的信号变换频率会骤增。</li></ul></div><h2 id="如何进行反走样（Anti-Aliasing）？">如何进行反走样（Anti-Aliasing）？</h2><p>Anti-Aliasing，又称为反走样、抗锯齿，提高采样频率是最直接的反走样方案，如增加分辨率。<br>下面介绍一些常见的AA理论。</p><h3 id="Blurring">Blurring</h3><p>模糊化是反走样的一个基本操作，即在光栅化之前对原始图像做一个模糊的操作。</p><p><img src="/images/aa-blurring.png" alt=""></p><h3 id="High-Pass-Filter">High-Pass Filter</h3><p>高通滤波，即高频的信号可以通过，过滤掉低频的信号</p><h3 id="Low-Pass-Filter">Low-Pass Filter</h3><p>低通滤波，即低频的信号可以通过，过滤掉高频的信号</p><h3 id="Convolution">Convolution</h3><p>前面的滤波技术，本质不是丢弃某些特定频率的信号，而是把它们变成一个新的信号。即$m*n$的信号通过滤波之后，得到的仍然是 $m*n$ 的信号。它的本质就是 <strong>将信号在时域上卷积</strong>，即求平均值。</p><ul><li><strong>滤波器</strong>：一个固定大小的信号，如 $1*3$，且每个信号都对应一个数值（系数），如下所示：<ul><li><img src="/images/aa-filters.png" alt=""></li><li>对于每个像素，根据滑动窗口计算 经滤波器后 的取值。</li><li>示例，对应为 $5$ 的像素，滤波后的结果是 $3*1/4 + 5*1/2 + 3*1/4 = 4$</li></ul></li></ul><p>下图是一个 1/9 的滤波器，它起到了图像模糊化的作用，其本质也是一个低通滤波器（模糊的本质，是去掉高频变换的边缘区域）</p><p><img src="/images/low-filter.png" alt=""></p><div class="admonition warning"><p class="admonition-title">理解困难</p><ul><li>如何理解：时域（空域）的乘积，本质是频域上的卷积</li></ul></div><h3 id="MSAA">MSAA</h3><p><a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">MSAA（Multi-Sampling AA）</a> 的本质是在更高倍分辨率下进行采样。<br>下图是一个 <em>4 x MSAA</em> 采样的示例，即对于每个像素，采样其中四个子像素，根据是否在三角形内的比例，得出其颜色的贡献值。</p><p><img src="/images/4xMSAA.png" alt=""></p><p><strong>MSAA的额外开销</strong></p><ul><li>n-MSAA，意味着 N 倍的采样量</li><li>可以尽可能的复用之前的采样值</li></ul><h3 id="FXAA">FXAA</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E8%BF%91%E4%BC%BC%E6%8A%97%E9%8B%B8%E9%BD%92">FXAA（Fast-Approximat AA）</a> 是在屏幕空间的快速近似抗锯齿，它是在后处理阶段进行的。<br>在有锯齿的图像上，找到其边界，并替换为无边界的图像，与采样无关。</p><h3 id="TAA">TAA</h3><p><a href="">TAA（Tempol AA）</a> 将采样从单帧扩展到多帧，尽可能地复用之前帧的结果。需要额外处理动态物体的情况。</p><div class="admonition warning"><p class="admonition-title">写在最后</p><ul><li>MSAA，FXAA，TAA等抗锯齿方案需要更深入的学习和实践，这里只是浅尝辄止</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【GAMES101】Rasterization</title>
      <link href="/posts/M5TXVE/"/>
      <url>/posts/M5TXVE/</url>
      
        <content type="html"><![CDATA[<p>光栅化与硬件基础<span id="more"></span></p><div class="admonition note"><p class="admonition-title">前集提要</p><ul><li><a href="/posts/30P8RVY/">GAMEASA101-Transformation</a>描述了基础的线性变化，以及MVP变换的过程</li><li>本文讨论的是在MVP变换后，如何将一个正交的 $(0, 1)^{3}$ 坐标映射到屏幕坐标上</li></ul></div><h2 id="显示设备">显示设备</h2><h3 id="CRT-阴极射线管">CRT 阴极射线管</h3><p><a href="https://zh.wikipedia.org/wiki/%E9%98%B4%E6%9E%81%E5%B0%84%E7%BA%BF%E7%AE%A1">阴极射线管</a>（英语：Cathode ray tube，缩写 CRT），是较早的显示仪器，曾广泛的应用于示波器、电视机和显示器上。<br>其原理是利用阴极电子枪发射电子，在阳极高压的作用下，射向荧光屏，使荧光屏上的荧光粉发光。<br>同时电子束能够在偏转磁场的作用下，作上下左右的移动来达到扫描显示的目的。（高中物理的磁场计算题…）<br>早期的CRT仅能显示光线的强弱，因此是黑白画面；直到1941年，CRT才支持红绿蓝三种颜色的电子束，这告别着彩色电视机技术的问世。</p><p>因为采用电子束的技术，CRT显示器具有亮度高、伤眼睛的特点。因此早期小朋友看彩电时，经常被家长督促离得远一些。<br>同时 CRT显示器 的分辨率做不高、屏幕做不到，导致2000年后逐渐被LCD、LED取代。<br><a href="https://www.zhihu.com/question/57752884">知乎：为什么 CRT 画质这么好也被淘汰，液晶反而发展的很好？</a><br><img src="/images/CRT.png" alt=""></p><h3 id="隔行扫描技术">隔行扫描技术</h3><p>通常的显示器在成像时，会从上到下地扫描每帧图像。这个过程消耗的时间很长、占用带宽也很高。<br>因此CRT显示器采用一种 “隔行扫描” 的技术，即每次只传输和显示一半的图像，一场只包含奇数行或者偶数行。由于人眼具有视觉暂留效应，所以仍然会看到完整的一帧画面。</p><div class="admonition note"><p class="admonition-title">视觉暂留效应</p><ul><li>光对视网膜所产生的视觉，在光消失后，<strong>仍然会保留一段时间（约1/16秒）</strong></li><li>例如日常使用的日光灯每秒大约熄灭100次，但不会感觉到灯光的闪动</li></ul></div><h3 id="LCD-LED">LCD &amp; LED</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">LCD</th><th style="text-align:left">LED</th></tr></thead><tbody><tr><td style="text-align:center">功耗</td><td style="text-align:left">❌ 功耗高10倍</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">寿命</td><td style="text-align:left"></td><td style="text-align:left">✔ 寿命更长</td></tr><tr><td style="text-align:center">视角</td><td style="text-align:left">❌ 视角较小</td><td style="text-align:left">✔ 视角宽达160°</td></tr></tbody></table><p><a href="https://zh.wikipedia.org/wiki/%E6%B6%B2%E6%99%B6%E6%98%BE%E7%A4%BA%E5%99%A8">LCD液晶显示器</a> 和 <a href="https://zh.wikipedia.org/wiki/%E7%99%BC%E5%85%89%E4%BA%8C%E6%A5%B5%E7%AE%A1">LED发光二极管</a> 涉及较多的物理和光学专业知识，这里不详细展开，就对比两者的优劣和差异。</p><h3 id="E-Ink-电子墨水屏">E Ink 电子墨水屏</h3><p><a href="https://zh.wikipedia.org/zh-hans/%E9%9B%BB%E5%AD%90%E5%A2%A8%E6%B0%B4">电子墨水技术</a>是由 <em>E Ink Corporation</em> 公司提出，常被用于制作电子显示器，例如大名鼎鼎的 <em>Amazon Kindle</em><br>它的表面由大量包含正负电子的微胶囊组成，当设置电场为正时，白粒子向微胶囊的顶部移动，所以呈现白色；反之电场为负时，呈现黑色。</p><p>电子墨水的一大缺点时，即重置屏幕时具有延迟，因为要通过改变电场使粒子发生移动，例如Kindle阅读翻页时有明显等待。</p><p><img src="/images/kindle-tech.png" alt=""></p><h2 id="光栅化">光栅化</h2><h3 id="Pixels">Pixels</h3><p>首先如何从计算机的角度定义一个屏幕?</p><ul><li>颜色：（<font color="#FF1E10"><strong>R</strong></font>，<font color="#1AAD19"><strong>G</strong></font>，<font color="#1A9BFF"><strong>B</strong></font>）</li><li>坐标：由分辨率决定的二维数组<ul><li>左下角：$(0,0)$，右上角: $(width-1, height-1)$</li><li>像素实际坐标：$(x+0.5, y+0.5)$</li></ul></li></ul><p><img src="/images/pixels.png" alt=""></p><p>要解决的实际问题：<br>将$[-1, 1]^{2}$ 映射到 $[0, width] \times [0, height]$</p><p>先经线性变化（先从屏幕左下角平移到屏幕中间，再经过缩放操作）：</p><p><img src="/images/viewport_matrix.png" alt=""></p><h3 id="Triangles">Triangles</h3><ul><li>为什么用 <strong>三角形</strong> 表示几何物体?<ul><li>顶点数<strong>最少</strong>的平面几何（再少一个点就是线段了）</li><li>任何多边形都可以<strong>由三角形组成</strong>（三生万物）</li><li>利于做差值、判断内外等运算</li></ul></li></ul><p>一些常见的三维模型格式，例如obj、fbx，其内部都是用三角形（或者Poly 即两个三角形）表示模型的。<br>可以看这篇文章：<a href="/posts/2WF6HFQ/">Model and Mesh</a></p><h3 id="问题建模">问题建模</h3><p>光栅化实际要解决的问题如下:<br>对于每个三角形，逐个像素判断是否在三角形内，是则着色，不是则跳过。</p><div class="admonition note"><p class="admonition-title">判断三角形内</p><ul><li>通过三次叉乘实现</li><li>参考这篇文章：<a href="/posts/30P8RVY/">【GAMES101】Transformation</a></li></ul></div><p><img src="/images/raster-demo.png" alt=""></p><pre><code class="language-python">for tri in tris: # 所有三角形    for (x, y) in pixels: # 所有像素        output[tri, x, y] = inside(tri, x, y)</code></pre><p><strong>观察如上算法，是一个 $O(N^{3})$ 的遍历算法，是否有优化的方法呢？</strong></p><h3 id="加速：AABB">加速：AABB</h3><p>利用三角形的包围盒来加速。<br>实际绘制中，不可能每个三角形都填充满整个屏幕，因此可以通过AABB剔除掉在包围盒外的像素点。</p><h3 id="加速：Incremental-Triangle-Traversal">加速：<a href="http://15462.courses.cs.cmu.edu/fall2019/lecture/drawingatriangle/slide_068">Incremental Triangle Traversal</a></h3><p>可以理解为更精细的AABB。<br>从三角形每排的最左侧到最右侧执行光栅化，基本不会多遍历一个像素点。</p>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSAPP】Information Storage</title>
      <link href="/posts/24H1CZ3/"/>
      <url>/posts/24H1CZ3/</url>
      
        <content type="html"><![CDATA[<p>原码、反码、补码、Integer、Float…<span id="more"></span></p><div class="admonition note"><p class="admonition-title">材料</p><ul><li><a href="https://www.cs.sfu.ca/~ashriram/Courses/CS295/assets/books/CSAPP_2016.pdf">CSAPP chapter 2</a></li><li><a href="https://fengmuzi2003.gitbook.io/csapp3e/di-er-zhang-zhong-dian-jie-du">CSAPP 重点解读</a></li><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86">IC S解读</a></li><li><a href="https://0.30000000000000004.com/">0.30000000000000004.com</a></li><li><a href="http://graphics.stanford.edu/~seander/bithacks.html">Bit Hacks</a>（位运算的奇技淫巧）</li></ul></div><div class="markmap-container" style="height:250px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;字节序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#大端（Big-Endian）\&quot;>大端</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;<a href=\&quot;#小端（Little-Endian）\&quot;>小端</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;编码&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#原码\&quot;>原码</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#反码\&quot;>反码</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#补码\&quot;>补码</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;浮点数&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;<a href=\&quot;#小数的二进制\&quot;>小数的二进制</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;<a href=\&quot;#IEEE-754\&quot;>IEEE-754</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="导读">导读</h2><p>CSAPP花费较多篇幅介绍计算机的二进制系统，以及“1字节=8比特”的设计。既然人类已经习惯使用十进制计数法，为什么计算机要改用二进制呢？</p><ul><li>二进制 对应电路中的高低电平，容易区分</li><li>二进制 利于物理存储，磁极、凹凸、光照等</li></ul><blockquote><p>推荐阅读如下前置知识：</p><ul><li><a href="/posts/3RBTN4W/">计算机架构入门：CPU、存储器</a></li><li><a href="/posts/1X3A6C1/">Virtual Memory</a></li></ul></blockquote><h2 id="大端小端">大端小端</h2><p>先看什么是大端、什么是小端，这些统称为字节序（Endianess）</p><p>假设 <code>int a = 0x01234567</code>，地址为 <code>0x100</code>，因为int类型占4个字节，所以写入 <code>0x100 0x101 0x102 0x103</code> 这四个字节的内存地址：</p><h3 id="大端（Big-Endian）">大端（Big-Endian）</h3><p>将 数据的低字节 放在 内存的高位，符合人类的阅读习惯，又称为 <em>network byte order</em><br><img src="/images/big-endian.png" alt=""></p><h3 id="小端（Little-Endian）">小端（Little-Endian）</h3><p>将 数据的低字节 放在 内存的低位，与人类的阅读习惯相反，又称为 <em>host byte order</em><br><img src="/images/little-endian.png" alt=""></p><p><strong>大小端利弊</strong></p><p>为什么没有厂商一统江湖，选择 “利于阅读” 的大端呢？<br>原因是两种存储方式各有利弊，谁也无法说服谁…<br><a href="https://www.zhihu.com/question/25311159">知乎: 大小端字节序存在的意义，为什么不用一个标准</a></p><ul><li><ol><li>因为 “符号位” 存储在第一个字节（后文讲到），此时大端能快速判读大小、正负</li></ol></li><li><ol start="2"><li>执行加法运算时，高位往往需要添加额外的数据，此时小端效率更高，大端要额外移动</li></ol></li></ul><p><strong>常见字节序</strong></p><p>大端：IBM，JPEG …<br>小端：Intel，BMP …</p><h3 id="观察字节序">观察字节序</h3><pre><code class="language-c++">// Demo_2:观察字节序的一个简单例子typedef unsigned char *pointer;void show_bytes(pointer start, size_t len){    size_t i;    for (i = 0; i &lt; len; i++)    printf("%p\t0x%.2x\n",start+i, start[i]);    printf("\n");}int main(){    int a = 0x01234567;    show_bytes((pointer) &amp;a, sizeof(int));}// 输出结果(Linux x86-64)Demo$ gcc -o chp2 chp2.c ; ./chp20x7ffc837a0b3c0x670x7ffc837a0b3d0x450x7ffc837a0b3e0x230x7ffc837a0b3f0x01</code></pre><h3 id="记录一个未区分大小端导致的Bug">记录一个未区分大小端导致的Bug</h3><p>如下定义了一个 <code>struct</code> 类型，大小是 32位，占 4字节。<br>假设 <code>idx</code> 存储的数据是 <code>0x1234</code><br>当在shader中解析 <code>idx</code> 的取值时，因为存储在贴图的通道中，所以只能逐字节decode。<br>由于默认 <code>0x12</code> 在 低位，所以解码为 <code>L + H &lt;&lt; 8</code>，但是对于小端存储的机器（如Intel CPU），这个取值就是错的，因为实际算出来是 <code>0x34 + 0x12 &lt;&lt; 8</code></p><pre><code class="language-C++">struct DataDesc{    uint16_t idx;    uint8_t  count1;    uint8_t  count2;}</code></pre><ul><li>修复方法</li></ul><p>利用 <code>htons</code> 将小端统一转化为大端存储，<a href="https://linux.die.net/man/3/htons">htons(3) - Linux man page</a><br>注意头文件，Linux下是 <code>#include &lt;arpa/inet.h&gt;</code>，windows下是 <code>#include &lt;winsock.h&gt;</code></p><h2 id="原码">原码</h2><blockquote><p>最高位表示符号位，其他位存放数值</p></blockquote><p>数据的存储只能是 0 和 1 两种状态，如果想区分一个数值的正负，先人提出用 “最高位” 的 0 和 1 来表示：</p><ul><li>1：负数</li><li>0：正数</li></ul><div class="admonition warning"><p class="admonition-title">思考一下为什么用1表示负数，而不是0呢？</p></div><p>假设用 3 bits 表示一个整数，则 1个符号位 加上 2个数值位，可以表示的范围是 <code>-3 ~ +3</code>，如下表：</p><table><thead><tr><th style="text-align:center">二进制</th><th style="text-align:center">符号位</th><th style="text-align:center">真值</th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">+</td><td style="text-align:center"><font color="#FF1E10"><strong>+0</strong></font></td></tr><tr><td style="text-align:center">001</td><td style="text-align:center">+</td><td style="text-align:center">+1</td></tr><tr><td style="text-align:center">010</td><td style="text-align:center">+</td><td style="text-align:center">+2</td></tr><tr><td style="text-align:center">011</td><td style="text-align:center">+</td><td style="text-align:center">+3</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">-</td><td style="text-align:center"><font color="#FF1E10"><strong>-0</strong></font></td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">-</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">110</td><td style="text-align:center">-</td><td style="text-align:center">-2</td></tr><tr><td style="text-align:center">111</td><td style="text-align:center">-</td><td style="text-align:center">-3</td></tr></tbody></table><h3 id="原码的缺陷">原码的缺陷</h3><ol><li><p>原码中存在两个0，即正零和负零，意味着判断是否要0要两个时钟运算…</p></li><li><p>原码作运算时，如果符号位不同，会导致计算结果错误（需要硬件额外处理）：<br><code>001 + 101 = 110</code>，表示 <code>1 + (-1) = -2</code></p></li></ol><h2 id="反码">反码</h2><blockquote><p>正数的反码是原码，负数的反码是符号位除外、其他按位取反</p></blockquote><p>反码的出现是为了解决原码的弊端，即 “相反数之和不为0”。这里干脆从结果反推，为了使和为0，不如用一个整数的“按位取反” 来表示负数。</p><p>例如，<code>001</code>表示+1，则-1的反码是<code>110</code>，此时相加为 <code>001 + 110 = 111 = 0</code></p><table><thead><tr><th style="text-align:center">原码</th><th style="text-align:center">反码</th><th style="text-align:center">真值</th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">000</td><td style="text-align:center">+0</td></tr><tr><td style="text-align:center">001</td><td style="text-align:center">001</td><td style="text-align:center">+1</td></tr><tr><td style="text-align:center">010</td><td style="text-align:center">010</td><td style="text-align:center">+2</td></tr><tr><td style="text-align:center">011</td><td style="text-align:center">011</td><td style="text-align:center">+3</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">111</td><td style="text-align:center">-0</td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">110</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">110</td><td style="text-align:center">101</td><td style="text-align:center">-2</td></tr><tr><td style="text-align:center">111</td><td style="text-align:center">100</td><td style="text-align:center">-3</td></tr></tbody></table><h3 id="反码的缺陷">反码的缺陷</h3><ol><li><p>仍然有两个0</p></li><li><p>表示有点反人类，不够直观</p></li></ol><h2 id="补码">补码</h2><blockquote><p>正数和0的补码是原码，负数的补码是反码 +1</p></blockquote><ul><li>如何根据补码求真值?<br>牢记口诀，正数照求，负数将数值部分按位取反 +1</li></ul><p>如下表，<code>3 bit</code> 补码的真值范围是 <code>-4 ~ 3</code>，比原码、反码多出一个值，是因为去掉了重复的正负零。</p><table><thead><tr><th style="text-align:center">补码（正数略）</th><th style="text-align:center">真值</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">-4</td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">-3</td></tr><tr><td style="text-align:center">110</td><td style="text-align:center">-2</td></tr><tr><td style="text-align:center">111</td><td style="text-align:center">-1</td></tr></tbody></table><p>因为补码是现代计算机硬件应用最广泛的编码方式，顺便提一下补码的运算规则：</p><ol><li><p>加法<br>不论正负数，直接对补码相加即可：<br><code>3 + (-2) = 011 + 110 = 001 = 1</code></p></li><li><p>减法<br>补码的减法，实际就是加一个负数，道理和加法是相同的：<br><code>3 - 2 = 3 + (-2) ...</code></p></li></ol><h2 id="浮点数">浮点数</h2><p>C++中计算浮点数加法时，经常会出现 <code>0.1 + 0.2 = 0.30000000000000004</code> 的类似现象，导致浮点数判相等很困难，这也是源于 <code>IEEE 754</code> 的存储方式。<br>首先，不论是0.1 还是0.2，在十进制这是一个有限的小数，但是在计算机二进制的表示中，他们是无限不循环的，这就造成了运算的精度误差。</p><h3 id="小数的二进制">小数的二进制</h3><div class="admonition note"><p class="admonition-title">如何理解小数二进制</p><ul><li>核心是科学计数法，十进制的 $0.525 = 5 * 10^{-1} + 2 * 10^{-2} + 5 * 10^{-3}$</li><li>对应二进制为：$0.525 = 1 * 2^{-1} + 1 * 2^{-2}$</li><li>口诀是：<strong>乘2取整，顺序排列</strong></li></ul></div><p><strong>有限不循环的十进制，在二进制下 可能无限不循环</strong>，而数据存储的bits是有限的，这就是浮点数误差的根本原因。</p><p>以小数 0.2 转成二进制为例，按照上面的算法得出如下的计算过程：</p><table><thead><tr><th style="text-align:center">依次乘2</th><th style="text-align:center">取整数</th><th style="text-align:center">二进制</th></tr></thead><tbody><tr><td style="text-align:center">0.2 * 2 = 0.4</td><td style="text-align:center">0</td><td style="text-align:center">0.0</td></tr><tr><td style="text-align:center">0.4 * 2 = 0.8</td><td style="text-align:center">0</td><td style="text-align:center">0.00</td></tr><tr><td style="text-align:center">0.8 * 2 = 1.6</td><td style="text-align:center">1</td><td style="text-align:center">0.001</td></tr><tr><td style="text-align:center">0.6 * 2 = 1.2</td><td style="text-align:center">1</td><td style="text-align:center">0.0011</td></tr><tr><td style="text-align:center">0.2 * 2 = 0.4</td><td style="text-align:center">0</td><td style="text-align:center">0.00110</td></tr><tr><td style="text-align:center">…循环</td><td style="text-align:center"></td><td style="text-align:center">0.00110011…</td></tr></tbody></table><h3 id="IEEE-754">IEEE 754</h3><p>通用的浮点数标准是 <code>IEEE 754</code>，在1985年提出并沿用至今。</p><p>下面以浮点数 <code>178.125</code> 为例，描述二进制的计算过程：</p><ul><li>整数部分：178，二进制为 <code>10110010</code></li><li>小数部分：0.125，二进制为 <code>001</code></li><li>合起来二进制为 <code>10110010.001</code></li><li>转换成二进制的科学计数法，为 <code>1.0110010001 * 2 ^ 7</code>，7用二进制表示为<code>111</code></li></ul><p>接着对照下面的公式，代入三个部分的取值：</p><ul><li>符号位 S = 0</li><li>尾数 M = 0110010001</li><li>指数 E = 111，结合偏移值得到 10000110</li><li>因此 <code>178.125</code> 的单精度浮点数是 <code>0x43322000</code></li></ul><p><img src="/images/float-demo.png" alt=""></p><h3 id="32位浮点数-转换公式">32位浮点数 转换公式</h3><blockquote><p>$V = (-1)^{S} \times M \times R^{E}$<br>S：符号位，0为正、1为负<br>M：尾数（float），对于 $2.18 \times 10^{-2}$ 中的 2.18<br>E：指数（int），对于 $2.18 \times 10^{-2}$ 中的 -2<br>R：基数，十进制为10，二进制位2</p></blockquote><p><img src="/images/32bit-float.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graphics </tag>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】UnitTest单元测试</title>
      <link href="/posts/A20MTJ/"/>
      <url>/posts/A20MTJ/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><ul><li>工作中经常遇到一些阻碍开发流程的提交，希望通过 <code>UnitTest</code> 避免类似的commit</li><li>todo: Python unittest，关于自动化测试的方法，测试理论等</li><li>plan: 预期这周内完成，伴随一些工作的脚本开发</li></ul></div><hr><p>TODO: 尝试学习 <code>pytest</code><br><a href="https://mp.weixin.qq.com/s/y9a1E7BW4e1Mki7oxAbiOQ">pytest, 一个神奇的Python库</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDCA 闭环思维</title>
      <link href="/posts/120QJ0A/"/>
      <url>/posts/120QJ0A/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">提要</p><ul><li>阅读材料来源：<a href="https://www.zhihu.com/question/421674339/answer/2863380386">知乎：有什么行为习惯昭示着你是个编程**？</a></li><li>本文都从工作的角度讨论，不涉及个人生活作息</li></ul></div><h2 id="为什么讲闭环">为什么讲闭环</h2><p>闭环思维，决定你是否能把一件事做到完美，决定你是否能成为一个靠谱的人。</p><p>通俗理解闭环思维，就是无论做什么事情，都要有始有终，能够形成一个完整的闭环。</p><h2 id="五个核心">五个核心</h2><p>通俗地理解，闭环思维有五个核心，须牢记于心：</p><ul><li><p>凡事有计划</p></li><li><p>约定必落实</p></li><li><p>问题早只会</p></li><li><p>及时报进程</p></li><li><p>事后须反馈</p></li></ul><h2 id="PDCA循环-⭐">PDCA循环 ⭐</h2><p>闭环思维的理论依据是“PDCA循环”，由美国管理专家 休哈特博士 提出，将每件事分为四个阶段：</p><ul><li>Plan：计划</li><li>Do：落地</li><li>Check：检讨/检查</li><li><s>Action</s> Improve：改善/改进</li></ul><p>如下图所示，一个需求可能需要多个回合的改善才能完成，即代表多个“PDCA循环”：<br><img src="/images/pdca.png" alt=""></p><p>这个模型完全可以应用于程序的日常开发，过去自己往往只关注 <code>Do</code> 的部分，而忽略了其他三个环节。<br>后面的改进：</p><ul><li>需求提出初期，明确 <code>Plan</code> 环节</li><li>推动落地期间，逐步记录 <code>Do</code> 的过程</li><li>需求开发完毕，主动 <code>Check</code> 完成度、潜在的bug、回归范围</li><li>提出待改善项，即 <code>Improve</code></li></ul><p>针对目前的工作流程，如下是一个 <code>PDCA</code> 的示例：</p><table><thead><tr><th style="text-align:center"><code>PDCA</code></th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>Plan</code></td><td style="text-align:left">∘ 3月5日完成功能A<br> ∘ 3月7日完成功能B</td></tr><tr><td style="text-align:center"><code>Do</code></td><td style="text-align:left">∘ 3月5日：完成A，同时优化了xxx<br> ∘ 3月8日：完成B，同时修复了xxx</td></tr><tr><td style="text-align:center"><code>Check</code></td><td style="text-align:left">∘ A的性能存在问题<br> ∘ B的code review有两处comments</td></tr><tr><td style="text-align:center"><code>Improve</code></td><td style="text-align:left">∘ 计划4月通过xxx优化方案解决A的性能问题<br> ∘ code review问题已修复<br> ∘ B完成延期一天，原因是xxx</td></tr></tbody></table><h3 id="5W2H分析法">5W2H分析法</h3><ul><li>What：先阐述清楚要做的事情是什么，确保合作职能可以理解</li><li>Why：为什么要做这件事？</li><li>Who：参与协作的职能</li><li>When：交付时间</li><li><s>Where</s></li><li>How：准备怎么做</li><li>How much：做到什么程度</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【GAMES101】Transformation</title>
      <link href="/posts/30P8RVY/"/>
      <url>/posts/30P8RVY/</url>
      
        <content type="html"><![CDATA[<p>向量与线代、空间变换、投影<span id="more"></span></p><div class="markmap-container" style="height:350px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;空间向量&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#点乘\&quot;>点乘</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;<a href=\&quot;#叉乘\&quot;>叉乘</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;线性变换&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#缩放\&quot;>缩放</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#旋转\&quot;>旋转</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#平移\&quot;>平移</a>&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<a href=\&quot;#齐次坐标系-Homogeneous-coord\&quot;>齐次坐标</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;What：<code>(x, y, z, w)</code>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Why：解决平移&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;几何意义&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;w=0：向量&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;w≠0：点&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;#欧拉角\&quot;>欧拉角</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;MVP变换&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;<a href=\&quot;#小数的二进制\&quot;>Model</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#IEEE-754\&quot;>View</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;#IEEE-754\&quot;>Projection</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;正交投影&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;透视投影&quot;}]}]}],&quot;p&quot;:{}}"></svg></div><h2 id="点乘">点乘</h2><ul><li><p>$\vec {a} \cdot \vec {b} = |\vec {a}| |\vec {b}| cos \theta$</p></li><li><p>几何意义：$\vec {a}$ 在 $\vec {b}$ 方向上的投影与 $\vec {b}$ 的乘积</p></li><li><p><img src="/images/dot.png" alt=""></p></li><li><p><strong>图形学应用</strong></p><ul><li>衡量两个向量是否接近：值越大越相近</li><li>判定两个向量是否同向：正值同向、0为垂直、负值反向</li></ul></li></ul><h2 id="叉乘">叉乘</h2><ul><li><p>几何意义：$\vec {a}$ 和 $\vec {b}$ 围成平行四边形的面积</p></li><li><p>$\vec {a} \times \vec {b}$ 垂直于两个向量所在的平面</p></li><li><p>方向：右手螺旋定理</p><ul><li>四个手指顺着 $\vec {a}$ 指向 $\vec {b}$ 的方向，则大拇指表示 $\vec {a} \times \vec {b}$ 的方向</li></ul></li><li><p><img src="/images/product.png" alt=""></p></li><li><p><strong>图形学应用</strong></p><ul><li>判定左右：$\vec {a} \times \vec {b}$ 叉乘为正，说明 $\vec {a}$ 在 $\vec {b}$ 的右侧</li><li>判定内外：<ul><li>需要三次左右判定，如可以通过 $\vec {AP} \times \vec {AB}$ 得到 $P$ 在 $\vec {AB}$ 的左侧</li><li><img src="/images/product-tri.png" alt=""></li></ul></li></ul></li></ul><h2 id="正交左手（右手）系">正交左手（右手）系</h2><p>可以通过 “叉乘” 定义一个正交坐标系</p><ul><li><p>$|\vec {x}| = |\vec {y}| = |\vec {z}| = 1$</p></li><li><p>$\vec {x} \cdot \vec {y} = \vec {x} \cdot \vec {z} = \vec {y} \cdot \vec {z} = 0$</p></li><li><p>$\vec {y} = \vec {z} \times \vec {x}$ （左手系 or 右手系）</p></li></ul><p><img src="/images/left-hand-axis.png" alt=""></p><h2 id="矩阵">矩阵</h2><ul><li>$(M \times N)$: 表示 $M$ 行 $N$ 列的矩阵</li></ul><p>$(M \times N) (N \times P) = (M \times P)$</p><p><img src="/images/matrix-multiply.png" alt=""></p><h2 id="线性变换">线性变换</h2><h3 id="缩放">缩放</h3><p>以 $x$,$y$ 分别缩放 $a$,$b$ 为例：</p><ul><li>$x’ = ax$</li><li>$y’ = by$</li></ul><p>$<br>\left[\begin{matrix}<br>x’\\y’<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>a &amp; 0\\0 &amp; b<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>x\\y<br>\end{matrix}\right]<br>$</p><h3 id="反射">反射</h3><p>以绕y轴反射为例：</p><ul><li>$x’ = -x$</li><li>$y’ = y$</li></ul><p>$<br>\left[\begin{matrix}<br>x’\\y’<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>-1 &amp; 0\\0 &amp; 1<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>x\\y<br>\end{matrix}\right]<br>$</p><h3 id="旋转">旋转</h3><p>以绕坐标原点旋转 $\theta$ 角为例：</p><p>$<br>\left[\begin{matrix}<br>x’\\y’<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>cos\theta &amp; -sin\theta\\sin\theta &amp; cos\theta<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>x\\y<br>\end{matrix}\right]<br>$</p><h3 id="平移">平移</h3><p>尝试了一波，发现没法用一个 $2\times2$ 的矩阵表示二维的平移变换？<br>（后续为了解决此问题，引入了第三维度 $w$）</p><h2 id="齐次坐标系-Homogeneous-coord">齐次坐标系 (<em>Homogeneous coord.</em>)</h2><div class="admonition warning"><p class="admonition-title">为什么引入 齐次坐标系?</p><ul><li>考虑用 $M_{2 \times 2}$ 叠加平移变换</li><li>$x' = x + p$</li><li>$y' = y + q$</li><li>二维变换下，$x' = M_{2 \times 2} \quad x$ 无法作常量的平移变换</li><li>只能写成 ： $\left[\begin{matrix}x'\\y'\end{matrix}\right] =\left[\begin{matrix}a &amp; b\\c &amp; d\end{matrix}\right]\left[\begin{matrix}x\\y\end{matrix}\right] +\left[\begin{matrix}p\\q\end{matrix}\right]$</li></ul></div><h3 id="平移变换">平移变换</h3><ul><li>$<br>\left[\begin{matrix}<br>x’\\<br>y’\\<br>w’<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>1 &amp; 0 &amp; p\\<br>0 &amp; 1 &amp; q\\<br>0 &amp; 0 &amp; 1<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>x\\<br>y\\<br>1<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>x+p\\<br>y+q\\<br>1<br>\end{matrix}\right]<br>$</li></ul><h3 id="w-维度">$w$ 维度</h3><ul><li><p>区分 点 和 向量</p><ul><li>点：$(x, y, 1)^{T}$</li><li>向量：$(x, y, 0)^{T}$</li></ul></li><li><p>区分 二维运算</p><ul><li>向量 +/- 向量：$w$ 维度为0，得到向量</li><li>点 - 点：$w$ 维度为0，得到向量</li><li>点 + 向量：$w$ 维度为1，得到点</li><li>点 + 点：$w$ 维度为0，得到点</li></ul></li></ul><h3 id="x-y-w-T-几何意义">$(x, y, w)^{T}$几何意义</h3><ul><li>$w = 0$：表示向量</li><li>$w ≠ 0$：表示点 $(\frac{x}{w}, \frac{y}{w}, 1)$</li></ul><h3 id="总结">总结</h3><p>此时可以表示 Scale、Rotation、Translation 三种线性变换：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Matrix</th></tr></thead><tbody><tr><td style="text-align:center">Scale</td><td style="text-align:center">$\left[\begin{matrix}s_{x} &amp; 0 &amp; 0\\0 &amp; s_{y} &amp; 0\\0 &amp; 0 &amp; 1\end{matrix}\right]$</td></tr><tr><td style="text-align:center">Rotation</td><td style="text-align:center">$\left[\begin{matrix}cos\theta &amp; -sin\theta &amp; 0\\sin\theta &amp; cos\theta &amp; 0\\0 &amp; 0 &amp; 1\end{matrix}\right]$</td></tr><tr><td style="text-align:center">Translation</td><td style="text-align:center">$\left[\begin{matrix}1 &amp; 0 &amp; t_{x}\\0 &amp; 1 &amp; t_{y}\\0 &amp; 0 &amp; 1\end{matrix}\right]$</td></tr></tbody></table><p>另外，可以用 $M^{-1}$ 表示逆变换（反向操作，逆函数）</p><h3 id="欧拉角">欧拉角</h3><ul><li><a href="https://www.zhihu.com/question/47736315/answer/236284413">知乎: 如何通俗地解释欧拉角？</a></li><li><a href="https://en.wikipedia.org/wiki/Euler_angles">Wikipedia: Eular angles</a></li></ul><p>欧拉角使用三个角度来描述刚体在 $xyz$ 坐标系中的旋转，这三个角度分别表示绕 “三个轴” 旋转的角度，不同顺序会产生不同的结果</p><p>也可以用 roll, pitch, yaw 来表示欧拉角，如图所示<br><img src="/images/roll-pitch-yaw.png" alt=""></p><ul><li>旋转所绕的轴有两种划分<ul><li>世界坐标系（静止）：$xyz$</li><li>局部坐标系（动态）：$XYZ$</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">TODO</p><ul><li>万向节死锁这部分没完全弄懂</li><li><a href="https://en.wikipedia.org/wiki/Gimbal_lock">万向节死锁</a></li></ul></div><h2 id="MVP变换">MVP变换</h2><ul><li>首先前面提到过 $(x, y, z, w)^{T}$ 表示三维的信息<ul><li>$w = 0$: 表示向量 $(x, y, z)$</li><li>$w ≠ 0$：表示点 $(\frac{x}{w}, \frac{y}{w}, \frac{z}{w})$</li></ul></li></ul><p>三维空间的点，最终展现到二维屏幕上，需要经过一些列的空间变换，可以概括为 <font color="#ef6d3b"><strong>“MVP”</strong></font></p><p>MVP 变换可以想象为一个拍照的过程：</p><h3 id="Model-变换">Model 变换</h3><blockquote><p>“将人群和景色放到一个合适的位置”</p></blockquote><p>将所有模型移动到统一的世界坐标下（world space）</p><p>局部坐标 -&gt; 世界坐标</p><h3 id="View-变换">View 变换</h3><blockquote><p>“找一个合适的相机角度”</p></blockquote><ul><li>如何描述相机的信息?<ul><li>坐标：$\vec e = (x_{e}, y_{e}, z_{e})$</li><li>相机朝向 Look-at：$g$</li><li>相机上方向 Up：$t$</li></ul></li></ul><p>通过一个 View矩阵 $M_{view}$ 将所有模型转换到 view空间，只需要 平移变换 + 旋转变换：<br>即 $M_{view} = R_{view} T_{view}$</p><p><strong>先平移 $T_{view}$</strong></p><p>平移变换是为了将相机移到中心原点，因此矩阵很好得到：</p><p>$<br>\left[\begin{matrix}<br>x’\\y’\\z’\\w’<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>1 &amp; 0 &amp; 0 &amp; -x_{e}\\0 &amp; 1 &amp; 0 &amp; -y_{e}\\0 &amp; 0 &amp; 1 &amp; -z_{e}\\0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>x\\y\\z\\w<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>x - x_{e}w\\y - y_{e}w\\z - z_{e}w\\w<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>x - x_{e}\\y - y_{e}\\z - z_{e}\\1<br>\end{matrix}\right]<br>$</p><p><strong>后旋转 $R_{view}$</strong></p><p>拆解开来，需要作如下三个轴的旋转：</p><ul><li>$g$ 旋转到 $- \vec Z$</li><li>$t$ 旋转到 $\vec Y$</li><li>$g \times t$ 旋转到 $\vec X$</li></ul><p>将 “局部轴旋转到$XYZ$轴” 很困难，因此可以求逆变换：“将$XYZ$轴旋转到局部轴”</p><ul><li>将 $\vec X (1, 0, 0)$ 变换到 $(x_{g \times t}, y_{g \times t}, z_{g \times t})$</li><li>将 $\vec Y (0, 1, 0)$ 变换到 $(x_{t}, y_{t}, z_{t})$</li><li>将 $\vec Z (0, 0, 1)$ 变换到 $(x_{-g}, y_{-g}, z_{-g})$</li></ul><p>将这三个特殊值代入，可以解出 $R_{view}^{-1}$ 矩阵为：</p><p>$<br>R_{view}^{-1}=<br>\left[\begin{matrix}<br>x_{g \times t} &amp; x_{t} &amp; x_{-g} &amp; 0\\<br>y_{g \times t} &amp; y_{t} &amp; y_{-g} &amp; 0\\<br>z_{g \times t} &amp; z_{t} &amp; z_{-g} &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{matrix}\right]<br>$</p><p>根据转置矩阵得到 $R_{view}$：</p><p>$<br>R_{view}=<br>\left[\begin{matrix}<br>x_{g \times t} &amp; y_{g \times t} &amp; z_{g \times t} &amp; 0\\<br>x_{t} &amp; y_{t} &amp; z_{t} &amp; 0\\<br>x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{matrix}\right]<br>$</p><div class="admonition note"><p class="admonition-title">逆向思维</p><ul><li>“求逆” 是线性代数解决问题的常见思路</li></ul></div><h3 id="Projection-变换">Projection 变换</h3><blockquote><p>“按下快门！拍照”</p></blockquote><p>投影变换是最重要的部分，因为它塑造了 “立体感”，它分为两种：</p><ul><li>Perspective Projection: 近大远小，符合人眼</li><li>Orthographic Projection：远近一致</li><li><img src="/images/transformation.png" alt=""></li></ul><p><strong>正交投影</strong></p><div class="admonition warning"><p class="admonition-title">疑问?</p><ul><li>正交投影 为什么把任何立方体投影到一个(-1, 1)的正方体?</li></ul></div><p><strong>透视投影</strong></p><div class="admonition todo"><p class="admonition-title">TODO</p><ul><li>这部分有点复杂，教程中利用 “相似三角形” 和 “特殊值法” 求出了矩阵，有空补一下</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【C99】setjmp.h</title>
      <link href="/posts/3CKYSDZ/"/>
      <url>/posts/3CKYSDZ/</url>
      
        <content type="html"><![CDATA[<p>学习<code>setjmp</code>C标准库, 实现轻量级协程<span id="more"></span></p><div class="admonition note"><p class="admonition-title">写在最前面</p><p><em><strong><code>setjmp</code></strong></em> 是C99的一个标准库, 其实现了 <em><strong><code>non-local jumps</code></strong></em>, 本次学习路线是:</p><ul><li>阅读手册、文档 ✔: <a href="https://man7.org/linux/man-pages/man3/longjmp.3.html">man(3)</a>, <a href="https://en.wikipedia.org/wiki/Setjmp.h">wikipedia</a></li><li>阅读代码示例 ✔: <a href="https://en.wikipedia.org/wiki/Setjmp.h#Example_usage">wikipedia: Example usage</a></li><li>coding: <a href="http://jyywiki.cn/OS/2022/labs/M2">M2: 协程库 (libco)</a></li><li>可选: 阅读 <code>setjmp.h</code> 的源码</li></ul></div><h2 id="man-setjmp">man setjmp</h2><h3 id="what">what</h3><p>准确说是 <code>man 3 setjmp</code>, <code>3</code> 的含义是 <em><code>Linux Programmer's Manual</code></em>.<br>先看其基本的定义:</p><blockquote><p><em>setjmp, sigsetjmp, longjmp, siglongjmp  - performing a nonlocal goto</em></p></blockquote><p>也就是说, <code>setjmp</code>的作用是执行一个 nonlocal goto;<br>为什么说 nonlocal?<br>举个例子, 看下面的 C 代码, main函数 中尝试借助goto跳转到 func函数内部, 编译会报错<br><font color="#ef6d3b">因为 goto 只能实现函数堆栈内部的跳转，即 local jump!</font></p><pre><code class="language-c">void func() {outer:    printf("into func...");}int main() {inner:    // ...     goto outer; // error: label "outer" used but not defined    goto inner; // ok    // ...}</code></pre><h3 id="how">how</h3><p>继续阅读 Description 部分:</p><blockquote><p><em>The setjmp() function dynamically establishes the target to which control will later be transferred, and longjmp() performs the transfer of execution</em></p></blockquote><p>直译过来就是说，<code>setjmp()</code> 扮演的是定义 label 作用，<code>longjmp</code> 扮演的是goto跳转作用</p><p>继续看这两个函数体的定义:</p><pre><code class="language-c">int setjmp(jmp_buf env);void longjmp(jmp_buf env, int val);</code></pre><p><code>setjmp</code> 接收一个 <code>jmp_buf env</code> 的参数, 看看手册是如何解释 env 的:</p><blockquote><p><em>The setjmp() function saves various information about the calling environment (typically, the stack pointer, the instruction pointer, possibly the values of other registers and the signal mask) in the buffer env for later use by longjmp()</em></p></blockquote><p>写的很直白了， <code>env</code> 保存了调用处的局部环境，例如 栈指针、pc指针…<br>（这块如果看不懂，需要恶补汇编知识，建议阅读：<a href="/posts/1QNHHCN/">汇编（三）：基础AT&amp;T汇编</a>）<br><code>setjmp</code> 负责写入env，<code>longjmp</code> 会读取env并恢复调用时的环境，这样就达到了 <code>nonlocal goto</code> 的作用</p><p>ok基本看明白了，但是还有一个 <code>int val</code> 的参数，作用是什么？</p><ul><li>这里我觉得 man手册 没说清楚，自己总结下吧<ul><li>如果是 <code>setjmp</code> 的直接调用：返回 0</li><li>如果是 <code>longjmp</code> 的跳转调用：返回 一个非0 的 参数</li></ul></li></ul><div class="admonition note"><p class="admonition-title">setjmp的两次返回值</p><ul><li>这里很抽象，需要结合代码理解</li><li><a href="https://stackoverflow.com/questions/1692814/exception-handling-in-c-what-is-the-use-of-setjmp-returning-0">StackOverflow: What is the use of setjmp() returning 0?</a></li></ul></div><h3 id="注意点">注意点</h3><p>阅读 man手册 的 Caveats 部分，有两点注意事项:</p><ul><li>如果 调用 <code>setjmp</code> 的函数 在 <code>longjmp</code> 调用之前返回，那么行为不确定.</li><li>如果 在多线程 中使用 <code>nonlocal env</code>，那么行为不确定.</li></ul><p>这两点在实际开发中暂时不会遇到，先列在这里吧</p><h2 id="code-example">code example</h2><p>talk is cheap, show me the code：这部分开始讨论代码</p><p>下面的代码展示了 <code>setjmp / longjmp</code> 的基本使用:</p><p>核心：记住 <code>setjmp</code> 处会被call两次</p><ul><li>第一次是用户自己调用的</li><li>第二次是 <code>longjmp call</code> 回来的</li></ul><pre><code class="language-c++">// https://en.wikipedia.org/wiki/Setjmp.h#include &lt;stdio.h&gt;#include &lt;setjmp.h&gt;jmp_buf env;int longjmp_ret = 8;         // paramater pass to longjmpvoid second() {    printf("second 1\n");    // √    longjmp(env, longjmp_ret);    printf("second 2\n");    // ×}void first() {    printf("first 1\n");     // √    second();    printf("first 2\n");     // ×}int main() {    int val = setjmp(env);    if (!val) {        printf("setjmp return: %d\n", val);        first();               // when setjmp executed, setjmp returns 0    }    else {                     // when longjmp returns, setjmp returns 1        printf("setjmp return: %d\n", val);        printf("main :: else\n");     }    return 0;}// setjmp return: 0// first 1// second 1// setjmp return: 8// main :: else</code></pre><h2 id="setjmp-实现协程"><code>setjmp</code> 实现协程</h2><h3 id="实验要求">实验要求</h3><p>看到这里觉得自己很牛逼了，觉得都会了，是骡子是马，上实验遛遛：<br>这里 NJU 操作系统的实验，利用 setjmp 实现一个轻量级的协程: <a href="http://jyywiki.cn/OS/2022/labs/M2">M2: 协程库 (libco)</a></p><p>首先你要理解什么是 <a href="https://en.wikipedia.org/wiki/Coroutine">协程</a> （Python Generator 就是一种协程）</p><p>其次实现实验里给出的 api:</p><ul><li><code>co_start</code>: 创建一个新的协程，并返回一个指向struct co的指针（类似于 pthread_create）</li><li><code>co_wait(co)</code>: 表示当前协程需要等待，直到co协程的返回才能继续执行（类似于 pthread_join）</li><li><code>co_yield()</code>: 将当前协程“切换”出去，随机选择下一个线程执行</li></ul><pre><code class="language-c++">// co.hstruct co* co_start(const char *name, void (*func)(void *), void *arg);void co_yield();void co_wait(struct co *co);</code></pre><p><strong>如下是一个使用的例子：</strong></p><pre><code class="language-c++">#include &lt;stdio.h&gt;#include "co.h"int count = 1; // 协程之间共享void entry(void *arg) {  for (int i = 0; i &lt; 5; i++) {    printf("%s[%d] ", (const char *)arg, count++);    co_yield();  }}int main() {  struct co *co1 = co_start("co1", entry, "a");  struct co *co2 = co_start("co2", entry, "b");  co_wait(co1);  co_wait(co2);  printf("Done\n");}</code></pre><div class="admonition error"><p class="admonition-title">TODO</p><ul><li>为什么这里 <code>count++</code> 不会有线程安全问题?</li></ul></div><p>其中co1和co2这两个协程共享 <code>count</code> 变量，因此输出是：<br><code>b[1] a[2] b[3] b[4] a[5] b[6] b[7] a[8] a[9] a[10] Done</code></p><p><strong>一个小小的调试技巧:</strong></p><p>当你不希望某些调试用的输出，出现在正式环境，可以借助宏重写 printf:<br>（其中 <a href="https://learn.microsoft.com/en-us/cpp/preprocessor/variadic-macros?view=msvc-170"><code>__VA_ARGS__</code></a> 用来表示不定数量的参数）</p><pre><code class="language-c++">#ifdef DEBUG_MODE  #define debug(...) printf(__VA_ARGS__)#else  #define debug(...)#endif</code></pre><p>编译时增加 <code>-DDEBUG_MODE</code> 的编译选项，即可打开 <code>DEBUG_MODE</code> 宏，即实现了输出控制</p><p><strong>VSCode 调试 C++:</strong></p><p>因为一直 <code>VSCode Remote-SSH</code> 在服务器上写代码，不适合用 VS、Clion 等现代IDE调试，gdb这种又贼难用，所以配了一下VSCode调试的环境，看 <a href="/posts/3HCBFZ8/">这篇博客</a>；</p><p>限制还是有的：1. 只适合小型的 c/c++ 项目，2. 依赖太多三方库等文件时，<code>launch.json</code>不太好写</p><h2 id="实现">实现</h2><p>首先将协程的状态分为几类:</p><pre><code class="language-c++">enum co_status {  CO_NEW     = 1, // 新创建  CO_RUNNING = 2, // 已经执行  CO_WAITING = 3, // 在 co_wait 上等待  CO_DEAD    = 4, // 已经结束};</code></pre><p>状态的划分很重要，因为 <code>co_yield</code> 会选取下一个幸运儿进行调度执行，选择标准就是协程的状态；<br>理想情况下，选取一个 <code>CO_WAITING</code> 状态的协程继续执行，正在执行的协程状态是 <code>CO_RUNNING</code>，且同时有且只能有一个 <code>CO_RUNNING</code>…</p><p>那么选取下一个协程时，有两种情形要处理：</p><ul><li>有 <code>CO_WAITING</code>：直接切换</li><li>无 <code>CO_WAITING</code>：怎么办?<ul><li>继续执行？显然违背了 <code>yield</code> 的原理</li><li>正确做法是切回到 <code>main</code>（可以将 <code>main</code> 理解为一个主协程）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OS】多线程之互斥算法</title>
      <link href="/posts/14ZY2JK/"/>
      <url>/posts/14ZY2JK/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li>Mutex (<em>Mutal Exclusion</em>): 即相互排斥, 即多个线程不能执行同一段代码（指令）</li><li>PPT: <a href="http://jyywiki.cn/OS/2022/slides/4.slides#/">理解并发程序执行</a> | B站: <a href="https://www.bilibili.com/video/BV15T4y1Q76V">理解并发程序执行 (Peterson算法、模型检验与软件自动化工具)</a></li><li>之前的多线程用C++实现, <strong>这篇改用Python实现</strong>, 因为重点是算法思想而非语言</li><li><font color="#FF1E10"><strong>Todo</strong></font> 互斥算法的正确性证明: 画状态机, 暴力穷举, Model checking</li><li><font color="#FF1E10"><strong>Todo</strong></font> C++, Python: 多线程, 锁等相关</li></ul></div><div class="markmap-container" style="height:225px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;一个经典并发bug&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;atomic&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;critical section&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;互斥原理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Mutex&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Progress&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;Bounded Waiting&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;互斥算法&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;LockOne&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;LockTwo&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;Peterson&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="问题背景">问题背景</h2><p><a href="https://stackoverflow.com/questions/15058925/why-using-multiple-threading-to-get-the-sum-is-correct">StackOverflow: Why using multiple threading to get the sum is incorrect?</a></p><p>先看一个经典的 <strong>Python多线程求和</strong>, 经典面试题目, 经典并发Bug:</p><pre><code class="language-python">import threadingN = 1000000x = 0def add():    global x    for _ in range(N):        x += 1t1 = threading.Thread(target=add)t2 = threading.Thread(target=add)t1.start(); t2.start()t1.join(); t2.join()print(x)</code></pre><div class="admonition error"><p class="admonition-title">什么N取值较小（如1000）, 结果却是正确的?</p><ul><li>todo</li></ul></div><p>输出结果分布在 <code>&lt; 200w</code> 之间, 通过前面的学习已经知道, <code>x ++</code> 这个操作是 <strong>非线程安全的</strong></p><p>查看 Python汇编得到 <code>foo</code> 函数的汇编, 看到 <code>x ++</code> 被拆分为 3条汇编指令</p><ul><li><code>LOAD_GLOBAL</code>: 读取x取值</li><li><code>INPLACE_ADD</code>: 执行加1</li><li><code>STORE_GLOBAL</code>: 写入x取值</li></ul><pre><code class="language-asm">    12 LOAD_GLOBAL              1 (x)    14 LOAD_CONST               2 (1)    16 INPLACE_ADD    18 STORE_GLOBAL             1 (x)    20 JUMP_ABSOLUTE            8-&gt;  22 LOAD_CONST               0 (None)    24 RETURN_VALUE</code></pre><p><strong>下面证明为什么被拆成3条cpu指令, 就会导致非线程安全:</strong><br>如下表, 线程A和B分别有三条指令, 汇合在一起就是实现 <code>x ++</code> 的功能</p><table><thead><tr><th style="text-align:center">No.</th><th style="text-align:center">Thread-A</th><th style="text-align:center">Thread-B</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">load(A)</td><td style="text-align:center">load(B)</td><td style="text-align:center">读 x</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">add(A)</td><td style="text-align:center">add(B)</td><td style="text-align:center">x ++</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">store(A)</td><td style="text-align:center">store(B)</td><td style="text-align:center">写 x</td></tr></tbody></table><p>首先明确执行的顺序规则, 同一线程内的指令一定是有序的, 但不同线程间的指令无法确保顺序</p><ul><li><p>一种正确的情形 ✔:<br><code>load(A) -&gt; add(A) -&gt; store(A) -&gt; load(B) -&gt; add(B) -&gt; store(B)</code><br>输入 <code>x=0</code>, 输出 <code>x=2</code>, 这是最理想的情况</p></li><li><p>一种错误的情形 ❌:<br><code>load(A) -&gt; add(A) -&gt; load(B) -&gt; add(B) -&gt; store(A) -&gt; store(B)</code><br>输入 <code>x=0</code>, 输出 <code>x=1</code>, 显然出错了<br>问题在于线程A、B依次load的时候, x取值为0, 相当于都对0做了 <code>+1</code> 的操作, 所以结果少加了一次</p></li></ul><p><strong>如何避免这样的问题?</strong><br>只要保证 <code>x ++</code> 同时只有一个线程在执行, 这样的代码段称为 <font color="#ef6d3b"><strong>Critical Section</strong></font><br>我们只需要确保 Critical Section 部分的代码, 不被多个线程同时执行, 即为它加上一把互斥锁</p><div class="admonition note"><p class="admonition-title">Critical Section</p><ul><li><em>Critical Section is the part of a program which tries to access shared resources.</em><br></li><li>即尝试访问共享内存（或资源）的程序段,</li></ul></div><h2 id="一次失败的尝试">一次失败的尝试</h2><p><strong>现在实现一个多线程互斥算法:</strong><br>脑袋里最直观的想法是, 维护一个全局变量（即锁）, 每当有线程访问 Critical Section 时, 就上锁, 以达到防止别的线程同时访问的目的, 退出访问后不要忘记解锁;</p><pre><code class="language-python">lock = ''x = 0def add():    global x, lock    for _ in range(N):        while lock == '🔒':            pass        lock = '🔒' # add lock        x += 1      # critical section        lock = ''   # release lock</code></pre><p>这段代码很简单很low, 但是你秉承着大道至简的信念, 略有自信的运行了它…<br>Wrong Answer! …</p><p><strong>继续看出错的原因在哪里?</strong><br>第6行 <code>while lock == '🔒'</code> 和 第8行 <code>lock = '🔒'</code>, 这里分别代表 <code>load/store</code> 操作, 其实已经违背了线程安全的原理<br>举个粒子, 线程A/B依次进入while的判断, 都以为现在是无锁的状态, 而实际的加锁都没走到…</p><h2 id="互斥问题的类比">互斥问题的类比</h2><p><strong>当你无法理解一个抽象问题, 尝试将其类比为熟悉或者具体 的概念</strong> <a href="/posts/3819NVV/">💡《直击本质》书摘</a></p><ul><li><p>先假设一些前提：</p><ul><li>每个人是独立的线程</li><li>大脑内的思想是局部的（<code>private</code>）</li><li>自然界的信息是所有线程共享的 （<code>public</code>, <code>shared memory</code>）</li></ul></li><li><p><strong>通过 <code>抢厕所</code> 解释 非线程安全:</strong></p><ul><li>早上10:05（带薪蹲坑的好时候）, A 和 B 同时看到 仅剩的一个厕所（<code>Load</code>）</li><li>他们激动难耐, 都同时冲了过去… （<code>try to store</code>）</li><li>此时产生两个人抢夺一个厕所的情况… （<code>2 threads -&gt; critical section</code>）</li></ul></li><li><p><strong>解决思路一: 叫号</strong></p><ul><li>由一个全局的公告牌决定 轮到谁上, 但是如果叫到A, 但是A不在或者临时有事了…</li><li>缺点: 违背 “空闲必进” 的原则</li></ul></li><li><p><strong>解决思路二: 协商</strong></p><ul><li>让A/B自己讨论放谁进去, 如果碰到两位仇家, 是不是谁也不让最后僵持不下?</li><li>缺点: 陷入死锁</li></ul></li></ul><p>通过这些 <s>牵强</s> 的类比, 大概对互斥算法设计的好坏、标准有了一些认识：</p><div class="admonition note"><p class="admonition-title">互斥算法的三条标准</p><ul><li>Mutex: 互斥的正确性</li><li>Progress: 有线程进入<code>critical section</code></li><li>Bounded Waiting: 有限等待, 无死锁</li></ul></div><h2 id="LockOne算法">LockOne算法</h2><p>顾名思义, 引入一个bit的 <code>turn</code>, 即允许执行的线程id<br>假设 <code>turn==0</code>, 此时线程1想要执行, 只能干等…<br><strong>违背了 “空闲必进” 的原则</strong></p><p><img src="/images/mutex-lockone.png" alt=""></p><h2 id="LockTwo算法">LockTwo算法</h2><p>顾名思义, 引入 2 bits的 <code>flag</code>, 标记第n个线程是否要执行（因为是双线程互斥，2个bit就足够）<br>假线程0、1同时标记了自身的flag, 它们就可以分别卡在等待中, 即死锁.<br><strong>违背了 “有限等待” 的原则</strong></p><p><font color="#FF1E10"><strong>WARNING 纠错:</strong></font> 下图的 <code>flag[i]=true</code> 应该在 <code>while (flag[i])</code> 判断的上方</p><p><img src="/images/mutex-locktwo.png" alt=""></p><h2 id="Peterson算法">Peterson算法</h2><p>既然 1bit的turn 与 2bit的flag都无法完美解决互斥, Peterson算法干脆说：“我全都要！”</p><ul><li><p>它的优点是, 保证了双线程互斥正确性的同时，</p><ul><li>既确保了 <code>LockOne</code> 的 空闲必进 原则</li><li>又防止了 <code>LockTwo</code> 的 陷入死锁 问题</li></ul></li><li><p>尝试阅读如下材料, 以对Peterson算法又更直观的理解:</p><ul><li><a href="https://en.wikipedia.org/wiki/Peterson%27s_algorithm">Wikipedia: Peterson’s algorithm</a></li><li><a href="https://jamesrwilcox.com/SharedMem.html">A Proof of Peterson’s Algorithm</a></li></ul></li></ul><h2 id="写在最后">写在最后</h2><ol><li><p>本文讨论的, 全部基于 双线程互斥, 不适用于 <code>n &gt;= 3</code> 的情形;</p></li><li><p>正确的互斥算法, <strong>其内部的状态转移一定存在环</strong></p><ul><li>直观理解就是, 一个线程进入 <code>critical section</code> 后, 另一个线程不断的轮询等待 (<code>陷入while</code>)</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【硬件】GPU架构</title>
      <link href="/posts/3Z9MX8B/"/>
      <url>/posts/3Z9MX8B/</url>
      
        <content type="html"><![CDATA[<h2 id="GPU-与-显卡-的关系">GPU 与 显卡 的关系</h2><p>GPU 是 显卡最核心的部件, 除了GPU, 显卡还有散热器、通讯元件等电子设备</p><p>目前的 GPU 厂家主要有两个：</p><ul><li><code>NVIDIA</code>: 英伟达, 主要是GTX, RTX系列, 俗称<code>N卡</code></li><li><code>AMD</code>: 主要是Radeon系列, 俗称<code>A卡</code></li></ul><h2 id="摩尔定律">摩尔定律</h2><p><a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B">Moore’s Law</a> 是由 Intel 的创始人摩尔提出:<br><strong>CPU的性能每隔 18个月 就会提升一倍（同时成本也会相应地降低一倍）</strong></p><p>但是 GPU 的性能发展历史打破了这一定律, 下图是 CPU/GPU 的性能提升对比图:</p><p><img src="/images/cpu-gpu.png" alt=""><br><br></p><h2 id="CPU-和-GPU-的主要区别">CPU 和 GPU 的主要区别</h2><ul><li><p>参考阅读:</p><ul><li><a href="https://www.cherryservers.com/blog/gpu-vs-cpu-what-are-the-key-differences">GPU vs CPU: What Are The Key Differences?</a></li><li><a href="https://www.cnblogs.com/biglucky/p/4223565.html">CPU 和 GPU 的设计区别</a></li><li><a href="https://www.eet-china.com/mp/a180440.html">深入GPU硬件架构及运行机制</a></li></ul></li><li><p>一个通俗的比喻:</p><ul><li>CPU是几个大学教授, 单打独斗能力强</li><li>GPU是成千个小学生, 擅长大规模并发计算</li></ul></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">CPU</th><th style="text-align:center">GPU</th></tr></thead><tbody><tr><td style="text-align:center">Short for</td><td style="text-align:center"><em>Central Processing Unit</em></td><td style="text-align:center"><em>Graphics Processing Unit</em></td></tr><tr><td style="text-align:center">Cores</td><td style="text-align:center">6大核 (i5 10600kf)</td><td style="text-align:center">4864小核 (RTX 3060Ti)</td></tr><tr><td style="text-align:center">Memory</td><td style="text-align:center">Performance, Capacity</td><td style="text-align:center">Bandwidth</td></tr><tr><td style="text-align:center">Arch.</td><td style="text-align:center">SIMD</td><td style="text-align:center">SIMT</td></tr><tr><td style="text-align:center">Application</td><td style="text-align:center">Operation System</td><td style="text-align:center">Graphcis, AI</td></tr></tbody></table><h2 id="GPU-架构发展历史">GPU 架构发展历史</h2><h3 id="0-Tesla-架构"><a href="https://en.wikipedia.org/wiki/Tesla_(microarchitecture)">0. Tesla 架构</a></h3><div class="admonition note"><p class="admonition-title">Tesla 虽然是 GPU最简单的架构, 但是写这文章时, 大概只理解了不到两成（很多概念太抽象了）, 希望伴随职业生涯的学习能不断加深对硬件的理解</p></div><p>Tesla 是第一个面市的 GPU 架构, 但是经典永不过时<br>这篇知乎写的很好, 作者把GPU比作一个外包公司: <a href="https://zhuanlan.zhihu.com/p/403354366">【GPU】Tesla架构（一）：初识GPU架构</a></p><p><img src="/images/gpu-tesla.png" alt=""></p><p>通过几个核心器件来分析:</p><ul><li><p><strong>Host interface</strong><br>GPU 所有工作的包工头, 负责派发任务</p></li><li><p><strong>Input assembler</strong><br>将 CPU 传递的顶点数据组装后, 传给 Vertex work distribution</p></li><li><p><strong>Vertex、Pixel、Compute work distribution</strong><br>分别负责 顶点、片元、shader的三大任务</p></li><li><p><strong>TPC</strong> （<em><strong>T</strong>exture <strong>P</strong>rocessing <strong>C</strong>lusters</em>）<br>包含一个纹理单元 和 两个负责计算的SM（<em><strong>S</strong>treaming <strong>M</strong>ultiprocessor</em>）</p></li></ul><p><font color="#ef6d3b"><strong>理解核心的 TPC ⭐</strong></font>（架构如下图）</p><p>将 GPU 看作一家大的外包企业, 那么 TPC 就是其一个个小的子公司, 它的核心部门如下:</p><ul><li><p><strong>SMC</strong> （<em><strong>SM</strong> <strong>C</strong>ontroller</em>）<br>SMC 是负责将总部的各种任务拆分打包成 Warp, 并交给下面的小部门（SM）处理。可以看做该部门的负责人, 既要对接外界资源, 又要管理内部的任务分配, 需要实现负载均衡</p></li><li><p><strong>Texture Unit</strong><br>todo</p></li><li><p><strong>SM</strong>（<em><strong>S</strong>treaming <strong>M</strong>ultiprocessor</em>）<br>SM 是真正负责干活的小部门, 内部划分如下:</p><ul><li><strong>I cache</strong>: 指令cache, 将 SMC 传递来的指令缓存下来再分批执行</li><li><strong>C cache</strong>: 常量cache与共享内存</li><li><strong>MT Issue</strong>: 多线程主管, 负责内部进程的调度, 是GPU高并行的关键</li><li><strong>SP</strong>（<em><strong>S</strong>treaming <strong>P</strong>rocessor</em>）:负责执行基本的浮点、整型计算</li><li><strong>SFU</strong>（<em><strong>S</strong>pecial <strong>F</strong>unction <strong>U</strong>nit</em>）: 执行更复杂的计算, 如超越函数、插值Lerp等.</li></ul></li></ul><p><img src="/images/gpu-tpc.png" alt=""></p><p><strong>接下来尝试理解GPU的高度并行 ⭐</strong></p><p>当 SMC 拿到 多条二进制GPU指令后, 会以 32个线程为单位 分发给手下的 SM, 它们就称为一个 Warp, 这就是 **SIMT（Single-Instruction, MultipleThread）**架构</p><p>真正的并行单位是 Warp.</p><p>理想情况下, 每个线程执行相同的指令（想象所有 pixel走的分支L逻辑一致）, 这时候几乎是 100% 并行的（取决于指令数 和 core数量）</p><p>但是实际 shader 运算中, 会出现 <code>if</code> 等分支语句, 导致不同线程的执行分支也不同, 如图展示了一个 Warp 中不同线程进入不同分支情况:</p><p><img src="/images/gpu-ifelse.png" alt=""></p><h3 id="1-Fermi-架构"><a href="https://en.wikipedia.org/wiki/Fermi_(microarchitecture)">1. Fermi 架构</a></h3><p>Fermi架构 相对于 Tesla架构 的优化主要在如下几点:</p><ul><li><ol><li>晶体管硬件的发展, 可以堆更对的 SM 和运算单元</li></ol></li><li><ol start="2"><li>固定管线的一些列操作（视口、裁减、光栅化、剔除等）逐步在硬件上细化</li></ol></li></ul><p>推荐阅读 知乎: <a href="https://zhuanlan.zhihu.com/p/451179968">【GPU】Fermi架构（二）: 三角形的异世界之旅</a>, 它以三角形的视角描述了 cpu -&gt; gpu -&gt; 各种着色器经历的计算过程</p><img src="/images/gpu-fermi.png" width="370"><h3 id="2-Kepler-架构"><a href="">2. Kepler 架构</a></h3><p>Kepler架构的核心是低功耗, 因为物理器件温度过高时, 会导致降频促使性能下降（尤其是移动端）</p><h3 id="其他架构">其他架构</h3><p>Maxwell, Pascal, Turing这三个架构先不介绍了, 超出理解能力了…</p><h2 id="移动端架构">移动端架构</h2><p>区别于桌面端的架构, 移动端GPU受限于电池的短板, 需要避免高带宽导致的高电耗</p><p>当前主流的移动端 GPU架构（如PowerVR, Adreno, Mali…）, 都是基于块的渲染 <strong>（Tile Based Rendering, TBR）</strong>; 作为对比, 桌面端的GPU架构都是 <strong>（Immediate Mode Renderers, IMR）</strong></p><p>什么是一个 Tile? 假设一个屏幕分辨率是 2k（2560 x 1440）, 它将每 16x16 划分为一个 Tile, 每个Tile内有自己的缓存, 绘制时也是逐 Tile绘制</p><h2 id="写在最后">写在最后</h2><p>开这篇文章是为了普及一些GPU硬件的知识, 因为学习软件汇编时必然也会接触 CPU硬件架构.<br>但是GPU硬件很多概念根本看不懂, 很抽象, 权当科普吧…<br>过一段时间再回来头, 希望会好点</p>]]></content>
      
      
      <categories>
          
          <category> 3D Engine </category>
          
          <category> 3D Engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【引擎】渲染系统</title>
      <link href="/posts/36E2965/"/>
      <url>/posts/36E2965/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="daae7c8582868c8fa9fe052bb312c1a7d6fc98545f9e186ef30170b3552a6786">b3dc07a81f6459d120ce338ccca55046d81ca386354419b6b77d6b55182b8ed33140f2401a25c01a514a43101d339e09a1b2e92127965f9324a394488623f13567a42631fecb5042eb8052206cc0ab8768157a03a512d041b85e73b5ad01100c1fa62983540997e855ef137f75a3520d73b6e836afc1e03b244e0efd0b1f6659d84c1feb5f526eef882a052f38bc4d4f54c3b21f7ac35d22a6c7416b81d076e287d11d62c3b5acbc6ae09295d3d7b1272ba11d47a0078530d26b6167f5812214e6a06520ea990373c5131a13525c023f10aa6883f875e56eab9ee5b3a126d6bd289ba09c5d42273d5591d7e3600e926b52797fcd4634ea7e293dbeeecbc31e56415dbedc1c3e3509782ae8969064bf59e44532faef8d76fe16ff8a0cbf01fef3f37b65d5c97e98bb26cfc366a93c4b7d3320906ec8fcb19ecc09dab2ac6085682a4fd0f9b505cdac92091626de5a1e3f9f85ab4ab30ee4d8e8708c785c323ac26a29373c25ea6d70c2a175e5b34fc4100eabe70c375a9e735e462459fe8b5f28e3ecad7aa96d7b86db29953efac9973b0f8aa580bde40c9dbb368e2a691100aff1d77a886ce30df1e4d8de59456f31893bdf557bb11235120d8b98742991d76fb4862b973603cdbb4796bfa472f462456582b6488b101043431424649698a0f3c0c7b6661acd69df55a6a7028da6f6341f418f581b12bc922a4db384e85a031bdc3c716291dcd159730e3d708c102a5785b58186e6aafecf69b09ad841d82a17a53cc71c89dc518535bb8b25623715d35d9b3dc55777ec39572bc6aa1f7f243442686982b172cf41870dd48af9ce70d706731d8d9cf2884c75cb38e3a31cfb3f33906f66e57ccc29f7326116c69782b13bf6d04a91c7524f2081610f88588101c4c3c96020d0fa69749e328a8a5ac71d1c676a843a7ac125a3b561b17955fa3c2b774010aeec09c6f7e991381ef507d028a263c5f6809c70ed8f63f969fe439d1788b676f0168f0638fe2f7f9135b81b878eb1bf73cb732112c5dc64284bfdf7e764db90ce741a2a24cc5e41a9bbd5b9dd4a72f997e492b642f8f489d6f607dfd5be929710cf457350d7068d72584b9075bf45f3149f2a23e2e548360189bc8cb1965e7127041b5ec244a4286c1ac59878609b0facf2bb043eeb9814af93c75f8301a82d4ccd53930a62a888019fff22648897dc0df05c31580ed10f4e6c6a3993f462afc77165ce5afab45472b218d3347a5f20be6991cdcfba1a92a4c51eb3bd8f2cb5a1b44de5c5852baf98fbbe0bbeb7dbe5385a0ac07fd66a70a0d4070fc0f2a5bb25f431a9dc978bbebdcf9fd679ca147d788939bd6d009ddac8ddde3b5cb6b8f9cb0ab7996ceec5557b0a5e0e1f795f8ca4f10a626b2dbe9eece30b029b463de848b1906b5521811692fb082b5769737763807ee0325a7e7747cf46d711323621a47133107ed8d2f47421494d82d0886eaf307199f0f90cfb0a1ada6a09b8fde3a4dbc801e3cb492a129dde62ea2da11600831caedac3f4cd34aa499be6372068718da25e56cfe3df8452a599eeead7dee0464707548eebf99bb889efc716d1df4570c75e6091c3ce6184f0d86d6daa9ca3acc3a68f117003db2608193a5d934e3a69b9dbb0fb25eae3035d46227e2d99a1065dfe791ee901ccf13a3877a090a88e3a2852bb2f6748caa9d61d431759cd56ca123cef02ce434192873d9e24d36b90a926ffe58d699dc40d56d657a4ed210e12a9ef2c111a2b2a280ec20ba73a0e67fec2638962b3a2b5979f0baa47e700aaa171e064bc3ec8429d8ba52a8fded50c0acf30bda1a254249a6b44e86824c183d5df35b7197d3c1661fe6b0bd0ba7f9619b6bff75134d1b7db818ee222ed7e0be33ecf0d922e3e126ff9e15e660f1b0f279bc5736d6e4c630f64ed0ea65e38ad400081a50478cbfe606954db147ccae56a8b8da4ae954598953573137cdc779531faf9720ee47cc72e79a30c015b567da9ddd1b3b6f5047e5f2ffca7df6415867d9c6a87bdcceeb973263c6e382e88909817745b80cc2fd7972ecb826f953da3451fb67e34c1dbcc02df32852b7b85fa11de6dea20f6cb88d687bc5637585025bd23190698758239c8a81d210ad3965e49599e885575e72f6a5bf9f21f9d5cb466199144a00c057f2331d888ae729dc46e6163f4e5060b9e6a7fe6895680be21050b87f502e07014fe0349cad9130be7f6e4519def1a50571e6545d9fdf742f9344ae0715d700252c7da089b2cfd5f49b9010021c26ab1db6d7de4274128ad4d82a58ad776828e720e300f29056c8090b6f8e8fb6c20a103264f7020673648457d1666f16a7ac8690f4f36238e9ac81dc0c27625170dd8e25edeb82ebe881771e564c09cf2a603d50980975affc43e2db38398f05d034a3d83755447445833c61cf97701c5ef95770271a7b5ac8e6f9f4cb66b7548c9a583489f62641f0e3f3913b2003f62bcfe39eabb36d8987946a84ddf81f11460f28a8f5a9ed9733c635bf5c1b4b50a19727583cd826fc2e1aa15f7d5d194c8c83e6ee05a1a33c90f482cfc64712f29b6ac37b288969a25ffa414854c2b55fea1927eb6e5ffff6a8809a65cffa905f5060e3c70e79b8171b5ebb27cd96ab3585f37969256978caca4924fe49d13a39d3842e857e67f3df0f1ffbfaf88596bfb5197f607ee985f8cc96de53d60638281d150c39e6b0b557605c012f36cf9807943252326481bed87124b332502b189c01d99e19d358d9345e812a02dc571ca78bb904ef80f06800510bb529add3cd74638772daa7e747e7299519b6a29ba265d90b03b66c880de0f03415e34c9237b57d299808601a389801e81402f56286a8486c1e8176692f8f06e5b536d75fe14276bf2322ca3671cb9d8446f667ef615ed039cca31a4a76d690aae7fb357260d4b23ea1dd47e32b3f12bb529184c67b67e46c99dbdd742325afb3c0b123837e4a7f1c4ef67d68d5fd523ff3c1c5da4c102a7fea874b7431bde61a94d6fbd9ade44604b09a857f709fb0303e0096a110c0d2a5924971c1eeca291f692d2ea1b0ee1908acb76d32c639e7a926d30dd0dd4d36715a59ce078958f695f3ae356d2c8f9469abaa78380b588c7ddb9fb5dd02f86acbff35faeee0ce736110d5d034150c4afb47562a693b2abbc0d20ecb83e90e1c256c2ae2efdd44c777cc598c8c937eaf32e6773db326ac0afbc31e08b1105760e9ac24181841f900ea1468c9f2ea11f51d0e24d337dae2966a0ca697f9c43f2ab0e696f43c807f89922a70fb6684a2926dd729918eee6f27334507194e8dab192ed99fcd1feccc54816b9f4abca4cdd0ee8b31748800738425cd7b388bcdd5cd42b41391bdfcf17c4eb89ec3f1aa3a8c0f3fb27d220662680c387e8b2a0ea2424d0b21055f10631cd17a1e2e88810d0c381401637cae045600a93e12f11530627052eeb0525e1a3afe416766c37f8094cda3d806f9b6f6728af6a67058df6a1085cb70c614fcf2eb7bffca49e0146dd9f727c7c2671acd47814f33f343e983eaaa3f83bd377527d1bf8e42faa0f22ff205e4c79d20058386e8e870a343505fa026edd5bd9c54a5326ebce24186b452c04595b9576e440f228e991b8a5becc7fa9469d70c030f8476f983112c26198bbafbf65a06a2726eb990dc3a97b4ce4ed678ff39eb00ca821cc5e15af83e2be80fe18145007aaf2d2ef49ddfba7bf571972bab57c13d5bedfdb409207a77d91f79c24cccabbba779cbf781b143349f7284e0ab6e7e0e7e6457b1ad0a5ee86e3eba2dccc311fb1416c7e4d0457b7e0e04b11aaf453422ffd026b30c02100f6baee40dbfb4b55a1af00bf9051881b7888e11ae1fac464e6ba51901b4aeb1fdd7ca05cb1ab1b06052a518c52f63777e592a3f03b81ff507bb5a2e6ed828e1b705ab9c54af9bddac51ce97499871dd417e531c7ef12f2e00f514fca3306731fbce16afd2e95c9f9f216eb9a939909199a9a90b997b63228c25249379e4a0a67efbce19ae986a32b50592e1613c591d24fe0b529208055bbe962f221ce6c6fb36a043385b74508d40c28e592c6a87cd5c293cb9bbf7981f27a8cca06ba6486f9c962ca02fb505d52826da150ade739e31f88bc551f94f688603fe9459d20a4db401f7191e945deea96f95c0fb32b1137ca9827b77d00b4d5eda52bac4396a13999f4641eee8b8097f2cd883fb7923f2430d81e348f9a1455c02982a02dee67263bb5a6c9b20b198ed0d2a02a8dc4512e41324522b98c7e2fb38bd333df7c7ed77ed30baa491c12b643843e3e635178c9d5a383f4f69479e6d40d5923fe7a4b5ee6944d1a71236b7d007b1ac0d1d003894d91a1973bb24baf1819a5c86ac8bbfe1c6e02bc5fed57af474e893ced79276ac856f2a18ae88b067fe8e5c2a5464bdbb86c3f573fc9e53e9f233bd8b5e50e787c9bd54c1feb761f076dcff8fd23e08da9ee727c7af0ef4bc584f357e7853c35e7cd893c3fd6d0f72e338492620d6542bcb6435a3abfdf471e592b29bc06808b7d36b4f8dcd02f65dcf5b2213e1597629f4e7db48e563abd6edc9f5915dbbd8bd7fd637e97da895ee179aa94953f8dd7355cd0df6e17a98b9fc61a8b0d0dc997b15abce092e95f70d5f1cde992694b1fe46e939cf689129c2f1e2b24da5d20ac4cf3276f2eb442a44f333c0e5c11cf0c0329c904a2fa9524578fdac112cf273a856aef7de162df177e6e0ebae1c2e0bac5b2241f37a6034d1382258870b41599290830ded264a6a6f913f76332bf412a3a905b7cd4c4a13160158ba065035ddd368591f201be66d44e0853d81c2f33225debe5bf2979cb27914ffeeac385433a29401b7a4b0749d3ee258608bc5609318f853d89027621c857cb2c38a9f3a07c03996e317f078400b4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 3D Engine </category>
          
          <category> 3D Engine </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Python】编码之encoding</title>
      <link href="/posts/3RHEW9J/"/>
      <url>/posts/3RHEW9J/</url>
      
        <content type="html"><![CDATA[<p><code>ASCII, gb2312, unicode, utf-8</code><span id="more"></span></p><div class="admonition note"><p class="admonition-title">Human use text. Computer speak bytes</p><p>不论什么字符, 在计算机中都是按照bytes存储. <br>区别仅在于 <strong>encoding</strong> 和  <strong>decoding</strong> 的规则.</p><ul><li>encoding: text -&gt; bytes</li><li>decoding: bytes -&gt; text</li></ul></div><h2 id="ASCII">ASCII</h2><p><em><strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange</em>  （since 1963） /ˈæski/</p><p>ASCII 使用 <em><strong>7 bits</strong></em> 来表示计算机键盘上的所有字符.<br>一共定义了 128 个字符, 描述范围是 0 ~ 127.</p><ul><li>95 x printable ch. : a-z, A-Z, 0-9…</li><li>33 x control ch. : EOF, LF</li></ul><div class="admonition warning"><p class="admonition-title">为什么 ascii 是 7bit 而不是 8bit?</p><ul><li>第8个bit</li><li>要么用于校验位: <a href="https://zh.wikipedia.org/wiki/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D">Parity bit 奇偶检验位</a><br></li><li>要么用于扩展 ascii 到 256个: <a href="https://en.wikipedia.org/wiki/Extended_ASCII">Extended ASCII</a></li></ul></div><blockquote><p>ANSI: 泛指最早每种国家语言各自实现的 ascii 扩展编码方式，各个编码互相之间不兼容</p></blockquote><h2 id="GB2312">GB2312</h2><p><em><strong>G</strong>uo <strong>B</strong>iao <strong>2312</strong> 号标准</em> （since 1981）</p><p>由于 1个byte 的ascii不能表示中文, <strong>GB2312将编码拓展到 2个byte.</strong><br>但是 GB2312 只收录了 7000多个 中文汉字, 不包含 生僻字、繁体字和日韩文字, 后来推广到 <strong>GBK</strong>（Guo Biao Kuozhan） 得以收录完毕.</p><h2 id="Unicode">Unicode</h2><p>GB2312 是显示中文的编码, 不同国际不同语言都维护了这样的编码, 管理起来就很混乱 （如 <code>\ux8\ue2</code>在中文和俄文编码中的含义就不同）.<br>Unicode 通过构建一个全世界通用的字符集解决了此问题.</p><p>具体的Unicode编码需要查表: <a href="http://www.metools.info/code/utf8235.html">Unicode, UTF-8, ASCII 在线转码的网站</a></p><h2 id="UTF-8-⭐">UTF-8 ⭐</h2><p><em><strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat-<strong>8</strong>.</em></p><p>UTF-8 是 Unicode 的一种编码方案, 它是不定长的（1~4字节）, 可以显示 ascii、中文、繁体及其他文字.</p><p><strong>encoding 规则如下:</strong></p><ul><li>单字节符号 (ascii): 第一个bit 为0, 后7位即 ascii码, 这与 Unicode/GB2312 都是兼容的.</li><li>n字节符号 (如 汉字): 第一个byte 的 前n个bit 为1, 第 n+1个bit 为0, 后面byte的前两位一律为10, 剩下的都是Unicode编码.</li></ul><p><strong>decoding 规则如下:</strong></p><ul><li>若第一个bit是0, 则为单字节的ascii.</li><li>若第一个bit是1, 则连续多少个1, 就表示占用多少个字节.</li></ul><p><strong>根据Unicode范围决定字节数:</strong></p><pre><code>1 byte: 0000 ~ 007F: 0*******2 byte: 0080 ~ 07FF: 110***** 10******3 byte: 0800 ~ FFFF: 1110**** 10****** 10******4 byte: 0001 0000 ~ 0010 FFFF: 11110*** 10****** 10****** 10******</code></pre><p><strong>以汉字 “鲁” 为例, 解释 UTF-7的编码规则:</strong></p><p>“鲁”的unicode编码是 <code>0x9C81</code>, 二进制为 <code>1001 1100 1000 0001</code>.<br>首先查上表得知占用 3字节, 因此选择 <code>1110**** 10****** 10******</code>.<br>从后往前依次填入 Unicode, 不足的补0:<br>得到: <code>11101001 10110010 10000001</code>，十进制为 <code>0xE9B281</code></p><div class="admonition note"><p class="admonition-title">Python编码问题</p><ul><li>为什么首行添加 <code># -*- coding: utf-8 -*-</code>?</li><li>因为Python默认编码是 ascii, 如果文件中包含如中文, 会报错: <code>SyntaxError: Non-ASCII character '\xa3' in file ...</code>, 即 超过 127的ascii范围导致解码失败</li></ul></div><h2 id="BOM头">BOM头</h2><p><em><strong>B</strong>yte-<strong>O</strong>rder <strong>M</strong>ark</em></p><p>文本文件如何确定自己的编码方式?</p><p>通过开头几个字节即BOM来辨别, 同时包含大小端信息</p><ul><li><code>FE FF</code>: 大端</li><li><code>FF FE</code>: 小端</li><li><code>EF BB BF</code>: UTF-8</li><li>…</li></ul><p>下面这段 python2 程序:</p><pre><code class="language-python">a = u'El Niño'a.encoding('utf-16')# '\xff\xfeE\x00l\x00 \x00N\x00i\x00\xf1\x00o\x00'# fffe 即代表 小端存储</code></pre><h2 id="Escape">Escape</h2><p>Escape通常用来打印彩色输出等.</p><ul><li><p><a href="https://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6">wikipedia: Escape Character</a></p></li><li><p><a href="/posts/1MJH73F/">站内博客: Python之优雅输出</a></p></li></ul><h2 id="Python与编码">Python与编码</h2><p>传送门: <a href="https://docs.python.org/3/library/json.html">json Python3.11</a></p><ul><li>与编码打交道最多的是 <code>json</code>库<ul><li>Python2 中允许传一个参数为 <code>encoding</code></li><li>Python3 干掉了这个参数, 需要手动编码</li></ul></li></ul><p>有一个 <code>ensure_ascii</code>参数, 默认是True, 它允许对 ascii 不进行额外的编码.</p><p>工作中遇到过一个小bug, request请求得到的unicode编码为: <code>\\u6789...</code>, 问题出在多了一个斜杠, 原因是重复的<code>json.dumps</code>, 需要避免</p><h2 id="资料">资料</h2><ul><li><p><a href="http://www.metools.info/code/utf8235.html">Unicode, UTF-8, ASCII 在线转码的网站</a></p></li><li><p><a href="https://stackoverflow.com/questions/19212306/whats-the-difference-between-ascii-and-unicode">Stackoverflow: What’s the difference between ASCII and Unicode?</a></p></li><li><p><a href="https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">阮一峰: 字符编码笔记 ASCII，Unicode 和 UTF-8</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【日志】2023年5月</title>
      <link href="/posts/2023/5/"/>
      <url>/posts/2023/5/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c61a51a85f84168e3832e0377bc6a98dca95fb12ef3c4ba7ce2c51e96121683a">b3dc07a81f6459d120ce338ccca55046116de9af7135eccfa9c61a82756948fc387d14cd325776592b49d3f1481915c7af940bfd801627f44561689b79cae0dc10d51e8b38f6abff19d282ea8f2ce4a1a7b21476ff60f0802fae4d4cf990cfa67f839215902bc1fd50e5aac32fc2f2c2501b22d895d776f73872ff39db9d4f0336d04723fffacce349547dbbfbc9bb3aea7a10e6685fc3aec57a4155b3009c0e109261f3ea9bd9ab466dd4c12bc32b47e77c0dc457085e5a6efaa6c9b8c236e377017b6c2b20bce3aeb1f710c5761130afbf733859958cfcf1bde5fbf0c13fb8cb206af3a3d0dd204f780e217c1fedd66c4227b6aac9b918474e0e3a0ac3df383d6a7f727c8a22b4c1f66c9298a02b34b44eb90c7473dc9243ca8cd8fe6f2abe429eed206e886a403067d8815ccd0a3a52dd5c2013b00b33453658ab181c7f90f99246d3311605b748704be75865fe09706269709e8fde2bcc3eae83d48869bc8fa8d6155ca00b8efdbeb22fff1bcbcaa5acdc5c34b1dc3fa4db78fdb663d62811aac50072a07ed19c8d785b9b7c560e83ca857443e4634b445dc999e6608b6ed048516050ab25255dd2f932d6695fdeb5b0fe0ef588553ca601bd4ca13037039f55b14cf80b2f53a9cdc8a945e045148acf1c14116299553df9b1d2c70e7339ffc0bc53a3d0c89bef9c77b897d7073812a94d21d434c4e4508a3b5bb5250a99ecc194614da541edfdb5d35e6c7a0150a4183e3595ec62f2a86d26e3906bd2226b9e12d240d7161dd8e86ba8a4c90688873b6526ea74cad40c2eb81bc2a7ec319f9d1f7d1ecff15e01a2edddcee4eaad12012058d55c68d75520057847766e5439a92b5ca5e0e9df4ffd8ac091735a9c75ebcd755849ed32c5a3e537dd6ccc69a74cb9e57971ff1b0bf326b171cf1b73c75e8681a47a38be4932dda31c80240e7fa5a1dbb68093f40741d794ea9b171df98b34945c567230f76070836e025a0a00334fc61ce3bf194d9dda4ef9d494e9c73bda899050ec5901e4c62a33b85e6461be8548ccd0ab0fe9f19662f936f5bb725a5fb1ed973fbcbb7d4dabf09f5ec0533979bf203ca9606581a3ed38a6989f176cde8a9a16f4b5173fd1e221e3e69861d221c307d021c1f3f78fe6ff05ce248c31dbdddd33d2d5619525d521abe18109ec7a1e5930329efc36e6267574bde629b0a080c9cb3a45a0f83f36b7b599c36c3bae734f2b711c29c16fa95bfe62936c2d3d5039655e9077b351b039a8e33527b6ed48d074450bdd1a9609d2a07bd87332ed66899c294ac44d22d946f71a2c148f4b5096ad8a37b8203b6a11b1a430f4932ee7c4362118ba3456aa5a670f62331ff2c755c8dc5932712d73fd45bf89d4a9e97420b04c55c55f5384fe13dde1f9f5fecc73a9dfedbbbf7dc1406b66747fd43a52d0b7efcb717d8d39890f3bfe809b75c90edd83bd81529fc1e62d1bb96ba287bacab0a91775df61ca59f5077ac81eb642796507855a6a47a26a205c60250630ceef5986ed3b27e14fbd8fbbf6298c049e7d2680adcc2c1cbf9d580c2948ca7a57ceb9c16d4e3a5ab063bcbefc7f2bd0911ffcd854dbcc17b32a21d382821ad48d8795c20b7abd62a52e545f216f48d1e0bff63da7aa2fa813617a1416d4fe5d1f0d6d3245518633ac00ea2c61722f085af79adbdeca87675200a505816b2825ed07a2d4d42a7f9966f6e569bac85eb16d6ae483459a179b558288067008e899a9c7ac02f6ca3a0fbadf3c52f1857dde68186a26120e510b813e8af4daea3b6b0e16c4f4d2c3196580cca97cf30e872fb8fd1a664033c1676c0bbf63a0aa02b0ab16e5522aa314a3b08496f6e5c3c2ec617eaa0763f9f8f850d0c6490f3f64612545a5400dad40797b4962c8bc2fd3c0a821f56c37dcd940caf323ea42c4c75fea51e83b9336d3932a3fb895e5e2f12d78ad910bdff50d233c187768cf0827eabf7a7f7eb551ca293ee788fec75eb37f60cc3d8829662fed9d03cd93a1f5cde87bb78333ca1182c60e17ac6c98f0c6888aaaaee952be6cf1027160e0626a2e027531dac6d3cabebb688cca80cb425186679305f211ed6e93403d466e9905d31b08f27c09e44df25405402c279bfabc28ee3a2d6ffa28023c7fb20a24fdcf74e24652002d487eebb237b8602d77a4d42fd85a05eca18b22482c12939f09743c4a0d9d83d0d1796e6ab6ca85c9d705073c24d197d63743d1f5cb5211e8dfb4a91345b62a5b2e5349f9759b534a757e2a00c11f8188f4a385ba18c74f79c2982c9c658c722037591ea9c606f9eed0d60fd6ca21073a53c4dba47d211093d43cb3cb024e4566c8e56c0f71d7c6066cf95855c5d36f5fe3c5407391fbdf9c5f166e2e80c9c6341eabcd498d31fe1349380b09f46acfe2908e5d602f1a0f3aab9176d2d256050417647e7def66ba0bd0e52873ebe838bea753d136c14fc952088fd2725db7d42db185d735876df2f099516b469f3e3dab80a4383aa91e5fc1d33bd4ebb2d19fcf6e01b45216e4d9e7d7fa2736a7bc3607882675117aa6b3309d69fbb8c90d5861b1044fffc516d150618523121322d51715a85a23ed606732fa5504afda287e0001ff8196be950cc7ec0fc63fa67d1690b443d0e241cce8dab60ac74b81418bdad07a0f776a27fc2679837b3676ee517b1fb53f49f35ab0c2db40c2ce3541db1c782830663a4d95fc16a7d49e7fb55a2d1bfd4b663efbedddc0923cab5a2da56fd3f158ca683744563ce8063c221eee1f47e597b20e55d150f28ea06d21d40cb0a4d08c4dec7d14eca9aa83931b5bfcbacf08b44bd108e24130a45b9ac1430fb3eb1415d2b35886ed66085b0919253d9a23cbca8067444ae6cf8f1125143fb589eede24d40e33a1bf685fb1cd90285d9a95e01e0edb5653abca4d63a31a78138481ae7788011885fea28073e164c79e9ff5d2c800ed4c5cb383cbf7204805ace01717f8c2372f72e75b18536d0fa84c99f8021be13b526518f189e17ae376e3b041b92797e428bba8ccd261168c5d42a98f04f81c237ed7b11ddbf3b47bcddf6cd4a573a877d38271dc0d24491df738912b40f3d0f23346f7fbdd271558b3429381c20c6c542c84b484c86acab5675f7ee7f78fa549f3a3adc1c0be44bcc07c8837731c50c5986517690821c509f6658f642e405366ec245b9308cd08a9218163a0297fda672c2846a49fa31446f87d806b457a360c9b3956dde2086f04003e5a62fa81901fb96ac85d4abdac89e4b761b54520238457966a6fa5852683ce182b79718d3ee9d7e77e435dd5b8b9bf8673a488e1846ee473c9a6aece281a95aebe74d77f04d0ad5f05780734e7293d09aacbae2c5a99a49316d88b67d0501aeb4f79064764f20b32c5a001bca3fc0f2d583b139cc1dbf9ffbe0acfeedd55f85f79cc03c31b351ec92f54cd9e5e2878087bac0521e00d19e4d14b37b5386a03188b690a5a1ce759ee417ebdbdd482d611efdfbd102782c487b1738f9aeccfde623c0bd511b138704a5986c5d914a402703e9e9604e4cf767a5e2c99d6b204d4d0ce2d6c9b4686a065893885f6f3657307863f57b0aad1cf7e3dedd8370dc13f2616aa46bd4050f1c5070b619d56ed75bc3f14faea904ebe399b00ca923c53795c36cedcadd5b4eaa0888beeb89da5fc9209e7bf716f79eb8615d5353feff27b35be050bc97ad666e70e991b16308f5143afffc39a5d878f771d9c7e4f0124cfb9a5b68479531d783827e91720d08f427c7a13178b0d32caf20fe6a0f17f9a59b04cbbfb937c1ac0d059b6bb013de86972fcbf4cbe85b82ff97dbce3692bc4b8ff6f66176332282d47eaef10db48c14e5d04ec3c6577a209868d4b2deea139ba312c40dc8fba8eb5bba9250e529d158dfc61c66004ae0a11a8ca6df5ddf98ae4e90570b755c9044420863f1f69607905dd917a6b20310c6a42ef87035e1dd453413ab40d183034afed3fce92f46d5d1e1af7136e2a2730125cb238daca79b36b36d7e28412a17e2607bea153955cf4ddebb58a6684d454f392141be1633da15410bf9c8117a0619befa13eb21447d51a60ecedbd6fc15b7ef2623afe8e3661024e9b25af88263c77475f338a412a0ff608aab216d51d79a2aecf40c3c25f273e09d7f6a405393d0c67608a75e40895b2657a2c02681d842c8888ee09ca3edcb74ce0f474f55aca7325b043ae4144a5bd5ddcd3473035be6df26d21ea7ec23a451155a622a841fa47bb136f951f06983024d46120fbcb0a121a7341fdd7298f2b223c6b4e4b15b14d6c499f01ed0892424ff097d564fecef94edfecb6d0559443139dea475209125b1e4ae0554cad8c47c6c97dc8cd7ec629ccb14d10a47b7aac1f784a338f18ad4d132d80b796e7d023953a579c8c8c1014d3b6fa35c89af7aa86f87f2a928d5b965fbcecc6aaa9468db1751ece62fcfb938ab049564fa7cdae2540c41ebf930025a9a342dd8731b01b5c431cd50ed130f5def04d18b7ce6e4ac58530c22a5a356c7bd87295103a4175028cae3da360b9fc8599e7cc85c96ee63ed4f8e9458212432bce8f0caf6973ecea91e130e889acc30ec2b77d0f34a6fa56ff236b85fbefe98ab6baa36a1408fcae4e443ead45d8308a3855c876cc08954dc8f7f579aa429b057d35ed1846626b98675accd106b76dcc865c95cc58d8e40b8ee1df1bde165c068c19da8ffae4b8ed6d73d83d3c839739e48e95014ff4bb05af38c2e4b67428a067dc29242d488594a5996ec1bb284f7e6708242f86fe3cf13eed62d01e109bda51c8c429377ea54e4515f0e56719ae0395b520fa9f49c3f66b44dfe24d016177df73d1378e7f778e70e658b0112de762cd1fb01c8fe07cea37ea13057dc75ec8a453535cd00dea731db058243e65edc325d7d70af364d24ee9dba5b32a35c0128ed406b4e4798755ee242e45480dd51f2d64f5532c2cbda90f431b852c7af54a56d63ab43bce0c11bcd363974e5228307430c28db64a9aa2d6eca73f0608e9c9f6b1102256e3ffba4f6febb0c803a3b386dd8a64b5b896dcf53e411b9ef61d363a7586a68e82936fee9b76410b8582e792e897dea12ac5469e4f284a7c0f9605ed4ecea756344a4a199f935904368c219e4a581c0a2a7ba6304eb5c2b43485d03c0bc2102c263d57dad0011f9a4a41db42297bdaa0bf0dd4c0cbca41f134657d27feb8df1dd7f7d3ed54d8509949e619367291e16bb4761aa8bb82003b61416004bbe8257840cb94c82edcbaf09bda9035a94396cf012f1e778cf12a5325b8d3e7f9628a732e070c10c5a075564f82bc7665167f9a7d0f87d0402779771f272ef3de3c647a7bac08626e91f7046efe6b3fbe89218e4b74362b3434f37129c513889234773cf22efba855251f270259247c6995e2a509861b462521a91eb2256c8b0a06895171d6c0cbedc34c76740e9e09031c90106cb97360fcb42f4ae4f3cab5fcf7d723f0b1011720986ff1e5105d139ccac0207c12a84d4783c871a8602835edfdd6bb97d9c66fe0cc001154aecd14ebb4f603f613f277425a43509806b91c48336ce15dbee4cc0286d3871250e0c0f65d52e2119b5a7ee9d77a7f9458361e933b30ef553ede51b5cb2e13a594b8700d4dae0d38282c5c88fdc7d9249e41c6c4c3605b2fa7b5f82006ac1436c9204138d4ab3c91f97e2e4b6c4c5b13b71e1a4742511742c9ebac165abd9cd13d7b7c03a713c79afc70a884f3470d0a39e4b4c771caf212f71e00b23044940a0b7c7a42932944b74abe80e088d53fb4ef24ab591f0eee9f80d300f09a6c515b9f7606602c42f90b2922347762427230d0ae7c2271b24346d15a5b3b7594edfb40104f0849eeda0b6563cdedb05f0e6dcae3b90cf0fb242e8c922ee03449966fefe3d63abd8c2b358d570ef579a22ab410aca029c3c04655a204458bf44d1528b8873e676a56ba65fc18d1dfe02bb523bc854deac1cf5aa32f4a92e92ce980599ded7336d42912d321fbf0dd381f64b1f952eca7992db3980df0d3aa31fad8833840b61d52ffff4cbe5d7dcbfcef4f4a40125e7be753476cdc690875f418d0de5fd1f50ff847c0c2650fbdab39aea9ffc731c31e9db61101d22641d2378c532d9201e31c33675cce5cbbcf5902b438c70492c30c4adff9c634ecbd8da97c836b273285eee757b785611817374ab42cfd691f8d9575e33339c1fb4519779be16d38a039bbc049061bf2470de0923f2bd0b9170313f1890ed5c81ab74d8802c4f28d9bd3ffe6d6f7a5f4b835ddd6556edf967a6e4a724366271697cb79bddc0a9df380ac304d91f11ab489f6c866bb017275b718f3d9e9bb98e30c22a0489b002ee55d2f062078e361ce1ed51b3bea2985c1f7a9b006e647705d970b08bbed3c730c3f39c94281868d3c9795575694c5dd05fdc7493947d73fd5331d6d3cc11ab4c7b9adc6d14f54817b9fd7dea83dfb2aaf2f69241c1a6edb591ac718b262acd5122806ee11c9a619d25a1e8cbafdd75d9953f88dc5a193c00509f58185adb7166d514e9abe0e2bcc87c15fa0d1b2864ae6e320d154ee17d50df4291b271e1cb42869e5c1d396091af829eff8ae349ddf4c49648d767a4286bb51f9aeaad5c5c47085b35406ff4d45b1d646f1b8f1e4641f44ffcdcb8f79267e94e145522acd730c59d9a6eef459e456a1377e4f3292ab586d047d28a51370f38cd2dcb57c5ef15cf9241b0b7d1c50f9f9e2a827b49bd084525dd530a440ab53810d8794e1bfcac4830f2fa9d28b45ce50b4d471a650ec5ced240bdca5ff17fb23a0011cade29b4749135788f39f2f90cc41ecf24ac39a9e57f91fb9709cb9139b266fecf8846f3342f3491859ab0542a5748f09b73cef07c31f88f8353ce7da017f7dd40508b9dbb1b26245d9ab461f78ee5542974ecd4a369a847620654588e6b3c9e60a05632f2a7e63bff05aad09465300abc60d4b378542db9c195359f93c727c8fadd71ff254dec98b9f257055900b8439d4b20345bf0474588efad9d2a8796e4349985fd1e1791f0fc75a25d47185dd9063b594975c725ec67c497a7efb036e1f17c0a42a194742e1fb6d062b42ca6bae088f756325fe2caf12b2101bf1b4d58e05d52d8b3592893a054c24d63a0322e20141a231dc3581419347ca6f1c97b7efd197c11bbeace06c3620d8a1e72216fb6c19ecac5dd4ec6c3527ad72360c9dc2c3b3bfcb1d702a0643e1fe90fda934037735d832ee36a404f21977630daf23ede143eae5cca722c5f01273a246e59d1bdf92749d0ee182e68ee0426e8489bfd5adfa1e2820bddc10c9d4cc4dfcc0db397ac01ed820063ddcf53c25a28fff37a548b7e61627ba0f6208c26eb6814d707b0b30b2e86f442dcc77ae0b4c03c742feba4191c0f6fe3b94538ee6b0db09e325eaad9ec378ac45c57d12117284c19fd8f3263e55db49deb5a1766d369034c618e4a4c6f58c1685e08f418c33f03375967ed2a7f34d5ac2f26b209d9fbe657c8c400c2a7834a0771a36bcaa66a06fb9632e94147b71f0746090685aae17bd149f5e3ce229216c923a757673c03e6bd11d572fa3f6d72ed49cfe111e1226910ad1694c7e6ab7905ac050d42917613f97a1876a88d7034ce49d384202d41bb22d42490ef8e4fb16a4ff8cecb27578028c114e53da70653bbad7eafa48a3c6fa68f3f7087345b5777e9c1f6986e646c0f701ff570c01d7115d12b8181b72783fd8b92cf460cc2b0faa6d92626f40047a23b737b4c0c8fd6b3b2d0eeb2038ba51bc5ff0ed27a6e85fc2f4f84faaa166be0f5a6e50feebea542eeb4937e25a4400cc3c796aeabbddb9bbac1730e5e6e5ae70a75233196f5ba7fce2fa1fe485d4d93fc09cdc2f560637aba9a7bda0c1b46231cb46392d2c02f745b1fcd09cd011e5c9c02a064b8f584ab7e09bdff439589ffea0e1b9c1fd35cf828819c485ac6d9c24e7377358bfc368b0a7b6e787a6b96db52756dd8a03dd8499d17d55d4e571d6764adf56e46d7dcc142e8581191e089b35810a5fc21938787605b9125e5feafd0702e48cb669e8176aa66c0b4cc587f3cdb51ecae939026b16c4c1ce1686eb75d141f51e08a9bd1a7d8328215f47105aab8fe16d315ee0433807a2911bb1b5c20085cc2cad0267830519f06fe73a1265c7a04c9a75d9e3a9b44cc0239a81ca81edebbf987df1628d238097ce5b289f4c64a7f1ce84d4abb554132d66d8a8425dd7c8011a8239563505d08601c100dda54d36860e38ec9a7163bf6ada16fbefaf3474940d0f78d8bc695e57aba37c34a8b68740234067ea135de11f7af41db7b9f773fabf3ff9c64be10e78ee9588d83fb376048c43f3778bd1adbcb5e63bd18dacb523e3dbd275d397a04a8dfa6b876bbabb94351164f43a36a73d086f247ff5b7e7a40f4557bc562149a6e9d8a15f673e1cd3c2b7e096c95b24be38ce89aa32948eb6ecc69d51fc7dab4750795343d6e4ebd8d3b89f153b3282122986a55573f54ca5559a6a4a3893d980e23ad1acc372eae6601b91396df91f96fe04a8bbd5f48d7b6afc5089ebb637fa5789da351c1bffdaa89bbbe4299c774be2a64c411d37fb98b3b987834e7bdef9827f768afed83375f4303d6abdffcc18170aa4840f140e8ac61fe524b26e8fa9383c9c10d77a93ba1249581cb380a9d263b6f10df5e88a773ec7dbb3c0c9a251b3f2d2d54cb0776833bac28ad2f1db95526f61aea66a576be06268ab241d25bdef338629897dc96c9e770d85d3d83d25b7e2f9c542ab8b86480efc7d017612f4e4c7ac6389046e9df86a97733c5bf96a0efdc8c9489663d6c4e6ff4fc8be0b96d8d0f71841a06541731b13da94bb1fa3272ff43a386d2f41e1a489362fd264b88588145abad341c7b8972a72bab5daad65148e916839c658e1b7092afde6897d50682a0ce7b5c30f7c19c170d21f7d7e2eb15f41c71a806db5a43343c35ef124bb17b1fb0de3e74e209b54e4bef72c89e5aab9e5a71904aaa793e9ba315faaee6d4e652fc4cd2f5a8db703fbc598b87b59968c8705719f97df552636e5dcfc96470ebd39f1b79b7b02fead29373f93ffa544f117dbc3568d57c91c2f0fd6afe5829ecc49e505f39507b8b0062b9bec28844a5b8566caee9ad8589445eba20e238ffb2cf5ed488638f2e69b330fd1fa32cea40b6eb85364b75fae13f04b4c098269011f173a987883affa3c44c4b366e45ae04fe3890e82bcd88559a7f396341ab631722f8980e587904029785c8449219d63b6e45b2d01c4f2c8346976c0adbaef3f21be46273c6bd496ce64952c5f429c900275e30d3b89defc342bf1ab9472bf05223dab95901b6ebe84e57118a826bb28b2edf7d1abd3ffe691b0619d25a3a41816bcc7e840f954de65572c5a64b40525f92a78da0cd6755a7fb3be25be7cb4a08ca626698314e37bc1e47eb86165e3011dce51dc6272172616b40c87862e511dc79f9ead6257af568398f9e8535276299eaaccdd7c4036858c3f8f68508d8ef843a8c2cc691ff567828bf5c3492ab80f4cc86a8e7f9253b0faf4d6ea68f6b6f5ca519055c9849d7a4ee2318ebc74ea81facb5baa1f902863ba0fd7feb0e77807604c798ac1dca05b9a7900d5f989329882020ee701056613755b724223df5f7351bf193bcd5a2efe0db994c51689ba3c1da6a11ac8b60ccf2a86666f942a228dcc62483da3b93666685c24d436f97a386365d3f699da11459af0c9050a0372b5acafbed04dfe4695b6a9d597dedbc03044fed4c1ae4848822c2c3ffb5cd31abe1da62cfa1764cdf065118d386617664eb97484e7a70c252af3c85345629229428b38f3bc511ea177169d46519451536e14a2dbc9ddc0d1c7497f9174</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023上半年总结（写在五一）</title>
      <link href="/posts/2023a/"/>
      <url>/posts/2023a/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="62d5dca4adf091f06849bcb470fe1d2d174cd7a397f93dfff5a2bf4079a6615b">b3dc07a81f6459d120ce338ccca55046116de9af7135eccfa9c61a82756948fc17f3721d690036660e1ca319b1de7ea5abee2b21d3b2ea15225dc942382fb2c6a01d15f403303ea35415a8b95d29bb66ef379a601361db61ad440174f24415743f6c6f9156bfeeaf0e6657aec44167f87bf27d9768494353a067b87b00a8c76676a1351ebacf5d195df6fa9b57ce808c501fa2aa03b645d2393067c862c33671b06654a4787ea1d45a0123005205bec8cea6476970d45126eb65e8e41c2204755ee61b772cfc80df1938c72d56dd1171efe1683b3a3e8225dfdcf8e999ab2bc72d9c078c46414a2a1ec88978f9207b13046bbb4152fa7c5c912771ac4081deffca6235bfed3cfcccd86776aeb2e247975da6d8d8c5f97217c495d5f55645b82fda52bc29b6114c3c612e47d09f6f7bd6df69366238caddb4f2e0f75a06adfda300037feef6a9e6426651f58b448bea63e6c19e5de7941243ebbf477fd0fdff187250aea12f29fb37bed75737c26615effd83715a69856556d0d7caa8ace3af0b697e5756c306654f2f3c2fa5569ffb2857ad59ff567047f989d51bbfbcf7ec6873fefb563576bb875354666c54ff7dc85524e5fbb3d0f89ceecb3cdb74abfcd2388266307d1caa091555781377025fe5b22396aa85d41793338e3db1fe30eb6a993e70ef79933ca100cee264aabdb13a7170a4565c364d12d0599160d5b4899fd4be011688b95398d2400b6330dc25b4e33d754a9ca8c27ad29a0fb8637129b6a8c85cf3d64aae7a79da926e99f7850a9b3d601f7c8cb0da06a14560e17c19eb45ed171f9e8ee924f4e1e49e06b9355e9233faf5aff88c09da9542b9b90d86c95e29fd0e9f85444a4b1ca681504d28dd142e7cff06cd226adcb6ccf12bd3d3ebb38acfc9059ba34ff82478f4e21a148982f2ffbb0b1d02674b850fb02cc1c92e1ef9d05347f15f4f64033f0dded2725d0d44a668e508a7c774eed0bfa85f8583a3a4a5e838db20c7ab8f2853ed080d789cc9d4f85be2b5b69552fc104069cf4f2e1ccbbb81cde2a09dd18dfca376ca1bb0794c9fb2ec71c11a1fcaaa8176255d9077fb86e66e08ae8bab5ff4fa1dd3bf874298c6e18887bad76d2649968d114ce2c3cd5a3c7be7b4abf5273e1085a1bccc567d8a37370c9afeb0a64bbbf9022a48db59365068675bce2de12b96100c4e11adb4071ff9a102dce16f2fbd48eba54c64298ae4ddf256c9e3b62a8392a8ae4b74df9a463ccf0bf5a2fe005ba508a520f5c6ab641800e34482eec8f13abc390d39e715dff34268e04a8dbf484816f755a578d502cabd819b27f40a4c59fd3ccdef61d045ef3059653482fa47318d385d0500904d924f175c1977dc337a854ef864eb24ed831ecd2678a99245de31475720585c390e5a7ed145b33c36d69027c7f7e1ae9ed74d1c4a0776d9e7d5aaa7339734835ec2d1b45692308a7e91f03170a586d86a8d68f785cb7f862e7345b121042a8fdfa42c32c999e7b14cc4f78cf433f818331d14b9edefd8ee81467e20972c5feeb7655100861d9e75bfacc02c24800bce75e824071f6ba480696afdc9be8a95a9d37344f74c9d2f20683ee1dfedb0ccbe2c871e7f35ecef96de4c674fdfb7dbe2af9678e45177c20f6fb3eec48d11ff50998a251978e816dae9307d28beeb9718ba6c11f94b1891613324224d36a5a0c4bdf0d8248ec2c6425a4c32712d6f34966800b283b127ff4f3c65414bfff3a187ad7a4cd6156d599992a0cd24041d258777b2a1db4660171a8137c071ae53025d28c8c2892250876516418433431dcd099cd87c339b90e7b4beb8db8385be58f49403820c3dc07110e581a7db180c174fa35020afc38a66b8f16c1aa7ede367eb98c619d831fba5bf94ddd6ff9941f90abbcb969aaad58622c9d2cd179c2dbaee78ea0f9f642f41c3a137f5f8ce59714c66acac56ca80948194ffe566d4c2d612cd2c7b9ec3ee2f1231e3620459b2eb79dd7b543cecb1f9d67673b4abdd22242e02f79451dd60f057b125fe420618ef3338a82c42b9196043be45ef43369da4887b0ddab80edcef2242b94ad9b0bccb50a745841b07175cde913ca4de6df1e31e2763e172a14e2c88fb29bef3398ce153a851f475706209307f0786e45562128f58ed2fee5b4a78330442ceeeecc51d78736696a3a2e00faf613eb3dac0bee0a5b7f256de770db74d3fabc06a9a7ba2417820df126eb0fa17ef4eaf1335ebd53686246b8c5255d5bc35c5b5beeeed19a840bf962abb10e74175b7c49d7a169ef72c2ff405f22ed09d518e78adb90f709be4c5914c0dd9df2f8cfdf03d132401308c41df6c85671f19f76720ef328bc5b1e1402b293898d2c1f46dc958433abfd2441ec9f5208e62643a6d5a4228b70973e81506fbc1f213c66703983a3fd7a35e72df84f010bedef9f95b54970c6122477c1c905300f290f0317515434350f9d749f60b55c06215d0b6f8a53f11579d3503990fab5eb95f779153ef32906d745ad6d5ad6fb498a9048bd33bf3292f0cc53b6537c7985cd72e071960d7c572561bdfcbf2b95011351a237dd9ca4d65771e5ff8bd91ee4ba1b71951d6ab211b6f5b10c15ab9e2970c87e5b0b852343d29fca6c0e3d54732bc9f2c7a971e7cd6586fcc719b104a206748dd2b2ff4ad6163ca121a1e62ba80aa91acc29763f4b164bfa9b52a392ee175435283bdced0b2210235074ebfa0a52b2b2389c8d90f3fe13fbd1b44e6534a2de358efae5eeb51d935325026c964209fa5e918c6f2c158ab412ff0342d1d7319b230c5ac880fc6bc53328d42f0fde9057180c7f3aa55990dc19a25a057f1afe05d31396e2d60dd72baa7044b758732f5b466bd7243d51e71cb3801c3fc6a4084be623cc36329ef25b4be7f2374423beb3fb48a7c35fd2d0961546dc605f25a260c50e791c25291c8191ce55b16965b7caf2b43ea2cd69fff7d71a17e713d1fc7df0f5ab55b503085cb30b0edb5c7d14bc48cdc31772706357ec2648b374790333497f7f2798cbf951c8e2f42c497d472c85b141f859800d210d655f2acf1a6fd8d259f0662be33000f22fcb8d6300cd41400ebbabbf0d42ea457213f548e6a71312d62f5aeb5ca2bc1b6fc11690f17be8ee0f872cbcc7323c8b7765134ab70ca8a72ebad4d9e5db12e207aee53e43d9a42e5fb21461e221f7986435e1f0f2b75edd6c89488dffd055fa8f7e2bf86e5906dc7b5f19e1ba6bbc22ba3983504d03e1c0889649b3bfbde88d8eb148eeb783a4cbb8b199ef58965f1f3a31f0559507640211d8c62de1020142456500e0aaa4f3da82f36daae0288597fca7b48dca12c2b2f6d54e654c70c83fb5bf999e27da7af4a98f80911652854b1fde14a7390761d4a873ab53396b0d34ef21a36035954664465e8c52c7172edc0ea305fa7344d57d3a51ff801a8c7afd86952a108982101aeb737a29111534a31c5989be365ccf5d8f9f1de8a7c106d582572241db3e8eed380c2e2819660f651d9fe082d5a4eb79a59a60cf62b15f435d241050cbaec0f0ba1c029ca5565a98a48a19de1db963a46101747e3919978ccf6f945f9c7fb383a0398643e3cbe88e34db77407a1c008534b2e5f14f4579bc22bb082d5786695d81e67b2ce9f6aa9cb445812a3b2a0e01ca47ac385640b88e18fa9cfe760ba6328253c781cb963a8cd8434fbd51abb8798a9299966941d31c08445b23ad9e8dff95c54e6c8791cb3e85b2733cefa62e41bf17e22fb7148811b196088f7f00e9aa404a539386809df25ebefca1eb52d0de4d48da335e2625bd6456034a384a454b32e07db056557e4b4bbbcf55efc0802e65fbd86fc70281d3fcd03cbbd14c93e3f8f77cba91668235ed98c5a141ccad4d0b5aad84f18f12f07aaafdc65f5d70f8c8be3021eb60c2c82d23ca3aff1a2ffb0bf86a75e698063776c7bd848ad9e819aa61a25813a214e7bda5aadf182ab983732af3af07597ec92c48ebc5e72c84bd8b0115228d1db868e5adb209371943bd41d1cf5caa839db2ab5273ea558a924a4c185539a0df2f8e900f526145934dd794c0ea31a476ba74b7bdb4b457bd2fc1a3501c6267fd9070640ce635848fa9c0848f3c006eba0d6e54af1c9da67bfe494bb33fb726f379d5396ebf68d826e609e15f56807adb72c170c993ee8f336a9453e7b8c622ea7e64b351f7494cf1bb1f68751e05ef9bfb6a7eff9ddf96e253626e030ed56aed15e15886be150af573f833efaf3b41fe281f8e8f599e2dec7df8dcfbb6d408e3358415d46ce7420ca658a1dcb7361e289043e27f05839af88ce810cea8ee19989da86a10584b70eb46330cd5292d89eeb8fc11ff5aa32a0f98a481aec10f580b8f0a972bd6e5e1f71d9a199feb23fab9aed6f9da39150cc77098d7a38344f286de76db18ba11bf0c3d467640a870a8f4477b1c177aecfa812a92fb020f6e969be9638033bc4e054234abab4211dd063a9d53c7b12a009880338ea6cacf4068ce4021e63123bb469239f1178255e8e195d97f241a9dbd9243a25690b817a02e0edd7e4512a235332850b836e64fa92e2aadd51296231bd7f9b10510952acefa6e27fa411da0466add8fb92c5ec48a1f436e1e3b8effbaf6b5efcc038e419c2300fd9d07013d804a869029001dfa50513a1e1dd2d57fdca2213f3ff92740ddd5bd37422a7eb64a75700c37c9e1176</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【引擎】基础架构</title>
      <link href="/posts/2TKCV1V/"/>
      <url>/posts/2TKCV1V/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">提要</p><ul><li>很多技术点只是埋了个坑, 等以后学到了再回头补充</li></ul></div><h2 id="游戏引擎">游戏引擎</h2><table><thead><tr><th style="text-align:left">Engine</th><th style="text-align:left">Types</th><th style="text-align:left">Games</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.unrealengine.com/en-US/unreal-engine-5">UE ⭐</a></td><td style="text-align:left">商业引擎</td><td style="text-align:left">PUBG</td></tr><tr><td style="text-align:left"><a href="https://unity.com/">Unity3D ⭐</a></td><td style="text-align:left">商业引擎</td><td style="text-align:left">原神</td></tr><tr><td style="text-align:left"><a href="https://www.cryengine.com/">CryEngine</a></td><td style="text-align:left">商业引擎</td><td style="text-align:left">孤岛危机</td></tr><tr><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Rockstar_Advanced_Game_Engine">RAGE</a></td><td style="text-align:left">自研引擎（R星）</td><td style="text-align:left">GTA5<br>荒野大镖客</td></tr><tr><td style="text-align:left">NeoX<br>Messiah</td><td style="text-align:left">自研引擎（网易）</td><td style="text-align:left">阴阳师<br>明日之后</td></tr><tr><td style="text-align:left"><a href="https://www.ogre3d.org/">Orge</a></td><td style="text-align:left">开源引擎</td><td style="text-align:left">天龙八部</td></tr><tr><td style="text-align:left"><a href="https://godotengine.org/">Godot</a></td><td style="text-align:left">开源引擎</td><td style="text-align:left">…</td></tr><tr><td style="text-align:left"><a href="https://www.cocos.com/en">Cocos2D</a></td><td style="text-align:left">2D开源引擎</td><td style="text-align:left">…</td></tr><tr><td style="text-align:left">…</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h2 id="核心难题">核心难题</h2><h4 id="1-Complexity">1. Complexity</h4><p>游戏引擎设计的计算机技术非常广泛, 涉及模块不限于如下:</p><ul><li>渲染</li><li>物理、动画</li><li>Gameplay</li><li>网络</li><li>…</li></ul><p>图形与物理依赖于数学, 跨平台依赖操作系统的兼容性, 在线游戏又依赖于网络同步, 实时运算要求高效的cpu/gpu优化…<br>游戏引擎的开发, 可以说是计算机技术中的地域级难度</p><h4 id="2-Realtime">2. Realtime</h4><p>区别于电影行业的离线渲染（off-time rendering）, 游戏要求在30ms内完成多个模块的运算；<br>对于某些要求高的FPS/动作类游戏，甚至要求16ms（即60帧）</p><h4 id="3-Collaborate">3. Collaborate</h4><p>一个3A游戏至少上百人的工作团队, 难题在于多职能间的协同合作.<br>涉及的职能不限于如下：</p><ul><li>程序</li><li>美术 （模型，动作，特效，场编…）</li><li>策划 （数值，关卡，运营，战斗…）</li><li>…</li></ul><h2 id="引擎架构-⭐">引擎架构 ⭐</h2><h4 id="1-Tool-Layer">1. Tool Layer</h4><ul><li><p>工具层；</p></li><li><p>接触任何引擎的第一印象, 都来源于 编辑器</p></li></ul><h4 id="2-Function-Layer">2. Function Layer</h4><ul><li><p>功能层</p></li><li><p>让整个游戏的功能丰富起来, 如角色控制、如物理碰撞、如特效渲染等</p></li></ul><pre><code class="language-c">tickLogic();  // 逻辑ticktickRender(); // 渲染tick</code></pre><ul><li>单线程 -&gt; 多线程 ⭐<ul><li>Fixed Thread: <code>MainThread</code>, <code>RenderThread</code>, <code>LogicThread</code>…</li><li>MainStream: <code>fork</code>, <code>join</code></li><li>Job System: …?</li></ul></li></ul><h4 id="2-Resource-Layer">2. Resource Layer</h4><ul><li><p>资源层；</p></li><li><p>Assets: 将外部的资源导入为 游戏中的场景，模型，动画，声音…</p></li><li><p>Composite Assets: 索引其他资源（xml）, 如场景索引模型、模型索引贴图…</p></li><li><p>(Assets) Manager: 运行时资源管理很重要！</p><ul><li>频繁的加载与释放</li><li>垃圾回收</li><li>延迟加载</li></ul></li></ul><h4 id="3-Core-Layer">3. Core Layer</h4><ul><li><p>核心层</p></li><li><p>Math Library: <a href="https://betterexplained.com/articles/understanding-quakes-fast-inverse-square-root/">Quake’s Fast Inverse Square Root</a></p></li><li><p>Data Structure: 如八叉树管理场景</p></li><li><p>Memory Managerment: 内存管理, 减少cache miss, 处理垃圾回收</p></li></ul><h4 id="4-Platform-Layer">4. Platform Layer</h4><ul><li><p>平台层</p></li><li><p>需要兼容PC, Xbox, IOS, Android等多个操作系统</p></li></ul><h2 id="游戏对象">游戏对象</h2><p><strong>Everything is a Game Object</strong><br>游戏中一切对象都是一个 GO, 根据是否改变/运动可分为:</p><ul><li>Dynamic GO</li><li>Static GO</li></ul><p>如何描述一个 GameObject?</p><ul><li>Property: 位置, 大小, 其他属性…</li><li>Behaviors: 移动, 攻击…</li></ul><pre><code class="language-C++">class Character: public GameObjectBase{public:    // Property    Vector3 position;    float health;    // Behavior    void move();    void die();}</code></pre><h4 id="Component-⭐">Component ⭐</h4><p><strong>Every GameObject could be described in a Component</strong><br>将游戏对象的所有功能拆分为 Component, 例如:</p><ul><li>transform_comp: 移动的组件</li><li>ai_comp: AI的组件</li><li>…</li></ul><p>UE, Unity等主流商业引擎基本采用如下的设计：</p><pre><code class="language-C++">class ComponentBase{    virtual void tick() = 0;}class TransformComp: public ComponentBase{    Vector3 position;    ...    void tick();}class GameObjectbase{    vector&lt;ComponentBase*&gt; comps;    virtual void tick();    //...}</code></pre><h4 id="Tick-⭐">Tick ⭐</h4><p>游戏世界将所有 GameObject 的 Component 全部 tick一遍, 即模拟整个游戏世界的运行</p><p><strong>Object-Based tick</strong>: 按照对象tick ❌</p><ul><li>Simple and easy to debug.</li></ul><p><strong>Component-Based Tick</strong>: 按照系统tick ✔</p><ul><li>Parallelized processing.</li><li>Reduce cache miss.</li></ul><h4 id="Events">Events</h4><p><strong>GameObject interact with each other via events</strong></p><p>todo</p><h4 id="Scene-Management">Scene Management</h4><p><strong>GameObject are managed in a scene with efficient ways</strong></p><p>多个GameObject如何管理?</p><ul><li>Uid</li><li>Position</li></ul><p>当地图上的一个角色开枪, 是否要遍历所有的GameObject以查询伤害情况?</p><ul><li>二维 xz 划分: Quadtree 四叉树</li><li>三维 xyz 划分: Octree 八叉树</li></ul><div class="admonition error"><p class="admonition-title">TODO</p><p>Bounding Volume Hierarchies? 搞懂 BVH 的原理 <br></p><ul><li><a href="https://www.zhihu.com/question/48905832">知乎: BVH相比八叉树有什么优劣？</a></li><li><a href="https://en.wikipedia.org/wiki/Bounding_volume_hierarchy">Wiki: Bounding volume hierarchy</a></li></ul></div><h2 id="学习参考">学习参考</h2><ul><li><p><a href="https://games104.boomingtech.com/sc/course-list/">GAMES104-现代游戏引擎</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/List_of_game_engines">Wikipedia: List of game engines</a></p></li><li><p><a href="https://blog.csdn.net/CNHK1225/article/details/50748058">CSDN 2016: 游戏行业内部主要几款游戏引擎的技术对比</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3D Engine </category>
          
          <category> 3D Engine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初读 周易八卦</title>
      <link href="/posts/3GXTS7K/"/>
      <url>/posts/3GXTS7K/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">先说为什么叫 周易?</p><ul><li>据传 "周的易经", 系周文王所创</li><li>昭示 周期性的<strong>规律</strong>, 世间万物的推演和<strong>变化</strong></li></ul></div><hr><p>理解周易, 核心是理解下面这段话:<br><strong>道生一，一生二，二生三，三生万物</strong></p><h2 id="道生一">道生一</h2><p>“一” 是世界上划分物质、时间的基本单位.<br>一壶酒、一竿纶… 物质的划分是简单而具体的，但如何划分时间呢?<br>古人通过观察时间的变化规律：</p><ul><li>根据日出日落划分为 “一日”</li><li>根据月亮阴晴圆缺划分为 “一月”</li><li>根据太阳位置变化的周期 划分为 “一年”.</li></ul><p>这就是 “道生一” 中的 ，一，而它是根据自然界的运转规律得来的，因此称为 “道生一”.</p><h2 id="一生二">一生二</h2><p>古人观察到一年中总有两天很特别:</p><ul><li>一天白天最长 （夏至）——&gt; 阳</li><li>一天白天最短 （冬至）——&gt; 阴</li></ul><p>这就是阴阳两极的由来，即 “一生二” 中二的含义<br>古人继续观察发现，世间的任何东西都可以通过阴阳来划分:</p><ul><li>日为阳、月为阴</li><li>男阳女阴</li><li>上为阳为阴，外为阳内为阴…</li></ul><p>为了方便记录，古人创建 爻（yao二声）来代表阴阳：<br><strong>即 <code>——</code> 表示 阳爻，<code>- -</code> 表示 阴爻</strong></p><p><img src="/images/yinyang-yao.png" alt=""></p><div class="admonition note"><p class="admonition-title">阴阳爻与二进制</p><p>阴阳即二进制中的 <code>0</code> 和 <code>1</code></p><p>古人认为阴阳是组成所有物质世界的基础，这与计算机的组成原理是一致的</p></div><hr><p><strong>阴阳转换</strong></p><p>古人观察发现，夏至和冬至间，白天长度一直在发生变化<br>这代表阴阳两极之间也会相互转变<br>它在当时对农业生产起到极大的推动意义<br><img src="/images/yinyang-change.png" alt=""></p><p>这就是八卦的由来：</p><p><img src="/images/yinyang.png" alt=""></p><hr><p><strong>阴阳拓展</strong></p><p>由于阴阳，夏至冬至的划分不足以满足 农耕农时的要求（理解为计算机中的精度不足）；<br>古人提出了 春分秋分 的概念</p><p>那么怎么表示呢?<br>聪明的古人将 “一爻” 推广到了 “二爻” （即计算机中<code>1bit</code>到<code>2bit</code>）<br>这样就能表示4种组合：春分、夏至、秋分、冬至</p><p><img src="/images/yinyang-season.png" alt=""></p><div class="admonition note"><p class="admonition-title">二进制的理解</p><p>对于上图用二进制表示，阳为<code>1</code>，阴为<code>0</code></p><p>即 春（10），夏（11），秋（01），冬（00）</p></div><h2 id="二生三">二生三</h2><p>古人将 阴阳爻 扩展到 三爻，即创造了8种的排列组合，这就是 <a href="https://www.nationsonline.org/oneworld/Chinese_Customs/bagua.htm">八卦</a> 的由来!</p><p><img src="/images/yinyang-8gua.png" alt=""></p><h2 id="三生万物">三生万物</h2><p>古人的 <code>两仪（阴阳）</code>、 <code>四象（春夏秋冬）</code>、 <code>八卦（天地水火山雷风泽）</code>，就是自然世界的基本组成，它的确可以表示任何物质.</p><p>用现代计算机的解释就是，<strong><code>3 bit</code>的组合可以推演出任何可能</strong>.</p><p><strong>六十四卦</strong></p><p>古人将 3bit 的八卦，衍生到 6bit，再拿去占卜算命，就是所谓的 “64卦”</p><h2 id="解64卦">解64卦</h2><p>以下图的 “否卦”（乾上坤下）为例：<br><img src="/images/yinyang-pi.png" alt=""></p><p>俗话说 “否极泰来”，显然否卦是不好的卦象，但是 “乾上坤下” 又很符合自然界的规律，这如何解释呢？</p><div class="admonition warning"><p class="admonition-title">为什么 “否卦” 是不好的？</p><p>易经的核心是 “易”，即万事万物是寻求变化的</p><p>因此 “乾上坤下” 这种与自然界一致的卦象，属于 “不易”，毫无变化内部无限熵增，最终会乱作一团</p></div><hr><p><strong>卦象赏析</strong></p><table><thead><tr><th style="text-align:center">64卦</th><th style="text-align:center"></th><th style="text-align:center">吉凶</th><th style="text-align:center">释</th><th style="text-align:center">象</th></tr></thead><tbody><tr><td style="text-align:center">乾，乾为天</td><td style="text-align:center">乾上乾下</td><td style="text-align:center">大吉</td><td style="text-align:center">诸事顺利，名利双收</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">坤，坤为地</td><td style="text-align:center">坤上坤下</td><td style="text-align:center">吉</td><td style="text-align:center">精守安顺，妄动招损</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">屯，水雷屯</td><td style="text-align:center">坎上震下</td><td style="text-align:center">吉</td><td style="text-align:center">宜守不宜进，蛰伏</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">蒙，山水蒙</td><td style="text-align:center">艮上坎下</td><td style="text-align:center">凶</td><td style="text-align:center">蒙昧忧愁，缺乏果断</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">需，水天需</td><td style="text-align:center">坎上乾下</td><td style="text-align:center">大吉</td><td style="text-align:center">等待时机，收成在后</td><td style="text-align:center">云团等待下雨</td></tr><tr><td style="text-align:center">讼，天水讼</td><td style="text-align:center">乾上坎下</td><td style="text-align:center">凶</td><td style="text-align:center">诸事不顺，避免树敌</td><td style="text-align:center">天水相隔，事物相背</td></tr><tr><td style="text-align:center">师，地水师</td><td style="text-align:center">坤上坎下</td><td style="text-align:center">中</td><td style="text-align:center">包容别人</td><td style="text-align:center">容纳江河的大地</td></tr><tr><td style="text-align:center">比，水地比</td><td style="text-align:center">坎上坤下</td><td style="text-align:center">吉</td><td style="text-align:center">求助聚力，方能谋事</td><td style="text-align:center">水依附大地</td></tr><tr><td style="text-align:center">小畜，风天小畜</td><td style="text-align:center">巽上乾下</td><td style="text-align:center">中</td><td style="text-align:center">受人牵制，蓄养实力</td><td style="text-align:center">风云积蓄但雨不曾落下</td></tr><tr><td style="text-align:center">履，天泽履</td><td style="text-align:center">乾上兑下</td><td style="text-align:center">中</td><td style="text-align:center">谦虚自重，不可攀缘</td><td style="text-align:center">上天下泽尊卑先别</td></tr><tr><td style="text-align:center">泰，地天泰</td><td style="text-align:center">坤上乾下</td><td style="text-align:center">大吉</td><td style="text-align:center">万事诸顺</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">否，天地否</td><td style="text-align:center">乾上坤下</td><td style="text-align:center">大凶</td><td style="text-align:center">诸事不顺，凡事忍耐</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">同人，天火同人</td><td style="text-align:center">乾上离下</td><td style="text-align:center">吉</td><td style="text-align:center">与人共事，谋事有成</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">大有，火天大有</td><td style="text-align:center">离上乾下</td><td style="text-align:center">大吉</td><td style="text-align:center">事事亨通，大有收获</td><td style="text-align:center">火在天上明烛四方</td></tr><tr><td style="text-align:center">谦，地山谦</td><td style="text-align:center">坤上艮下</td><td style="text-align:center">吉</td><td style="text-align:center">谦虚忍让，步步高升</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">豫，雷地豫</td><td style="text-align:center">震上坤下</td><td style="text-align:center">吉</td><td style="text-align:center">诸事吉祥，可得长辈助</td><td style="text-align:center">雷鸣催发大地万物</td></tr><tr><td style="text-align:center">随，泽雷随</td><td style="text-align:center">兑上震下</td><td style="text-align:center">吉</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">–</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">20. 观，风地观</td><td style="text-align:center">巽上坤下</td><td style="text-align:center">中</td><td style="text-align:center">处于变化中，观机行事</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">34. 大壮，雷天大壮</td><td style="text-align:center">震上乾下</td><td style="text-align:center">吉</td><td style="text-align:center">强盛壮大，切忌骄傲</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">55. 丰，雷火丰</td><td style="text-align:center">震上离下</td><td style="text-align:center">中</td><td style="text-align:center">如日中天，谨防盛衰无常</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">63. 既济，水火既济</td><td style="text-align:center">坎上离下</td><td style="text-align:center">事情已成，谨防变故</td><td style="text-align:center">水浇火熄</td><td style="text-align:center"></td></tr></tbody></table><h2 id="参考">参考</h2><ul><li><a href="https://www.bilibili.com/video/BV1Fc411n7cR/?spm_id_from=333.788&amp;vd_source=db26a19e4b4372574c8ebde86f9333bd">B站: 一个视频就能讲明白的《周易》底层原理</a></li><li><a href="https://www.bilibili.com/video/BV1Ne4y1r7r6/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=db26a19e4b4372574c8ebde86f9333bd">B站: 如何解读周易64卦</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【C++11】lambda</title>
      <link href="/posts/87V2YJ/"/>
      <url>/posts/87V2YJ/</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda">Lambda</h2><p>lambda 表达式是C++11最重要的特性.</p><p>中文可以翻译为 匿名函数, 在此之前 <code>C#</code> 和 <code>Python</code> 都已经引入了 类似lambda 的概念:</p><ul><li><p>C#<br><code>Func&lt;int, int&gt; square = x =&gt; x * x;</code></p></li><li><p>Python<br><code>square = lambda x: x * x</code></p></li></ul><p>经常使用Python的同学应该能体会到lambda的好处, 避免了繁琐的函数定义, 提高可读性（避免跳转阅读）…</p><p>参考Python的语法, C++的 lambda语法基本一致, 只是多了其特有的 值传递 和 引用传递:</p><pre><code class="language-C++">auto func = [captures] (parameters) { /* func body */ };</code></pre><p>一个计算求和的简单Lambda函数:</p><pre><code class="language-C++">auto sum = [](int a, int b) {    return a + b;}</code></pre><h2 id="Parameters">Parameters</h2><p>这部分就是普通的参数定义, 不赘述;<br>重点提一下 <code>auto lambda</code>（C++14）, 即模板传参, 写起来非常方便</p><p><code>auto lambda = [](auto node) {};</code></p><h2 id="Captures">Captures</h2><p>与局部函数不同, lambda函数无法使用外部的变量, 因此需要通过 <font color="#ef6d3b"><strong>捕获（Caputres）</strong></font> 来获取外部变量.<br>同时捕获也分为 值捕获 和 引用捕获 两种:</p><ul><li><p><font color="#ef6d3b"><strong>Value capture</strong></font><br>等同于参数中的值传递, 会伴随一次拷贝, 无法修改原变量的值</p></li><li><p><font color="#ef6d3b"><strong>Reference capture</strong></font><br>等同于参数中的引用传递, 避免拷贝, 能够修改元变量的值</p></li><li><p><strong>Implicit capture</strong><br>隐式捕获, 主要如下几种写法:</p><ul><li><code>[]</code>: 无捕获</li><li><code>[&amp;]</code>: 都引用捕获</li><li><code>[=]</code>: 都拷贝捕获</li><li><code>[=v1, &amp;v2]</code>: v1拷贝, v2引用</li></ul></li></ul><div class="admonition error"><p class="admonition-title">关于捕获</p><ul><li><code>[=]</code> <code>[&amp;]</code> 不是捕获所有 <code>local</code> 里的变量, 而是 "对lambda内所有使用的变量, 采用 <code>值/引用捕获</code>"</li><li>避免对 很大的结构体 使用拷贝捕获, 例如 <code>vector&lt;int&gt; m_huge(10000)</code></li></ul></div><h2 id="Examples">Examples</h2><p>看了一圈发现微软的文档示例（<a href="https://learn.microsoft.com/en-us/cpp/cpp/examples-of-lambda-expressions?view=msvc-170">Examples of Lambda Expressions</a>）, 写的最好, 以后多读读微软的文档…</p><p>这是微软对 lamda 的介绍: <a href="https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">Lambda expressions in C++</a></p><h2 id="related">related:</h2><ul><li><a href="https://changkun.de/modern-cpp/en-us/03-runtime/#3-1-Lambda-Expression">Modern C++ Tutorial Ch.3: Lambda Expression</a></li><li><a href="http://c.biancheng.net/view/3741.html">中文 lambda代码示例</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fluent Python</title>
      <link href="/posts/3K47Y0N/"/>
      <url>/posts/3K47Y0N/</url>
      
        <content type="html"><![CDATA[<p>《fluent python》前部分阅读摘录<span id="more"></span></p><div class="admonition note"><p class="admonition-title">NOTE</p><ul><li>英文原版pdf链接: <a href="https://bibis.ir/science-books/programming/python/2022/Fluent%20Python%20Clear,%20Concise,%20and%20Effective%20Programming,%202nd%20Edition%20by%20Luciano%20Ramalho_bibis.ir.pdf"><em><strong>Fluent Python (2nd Edition)</strong></em></a></li><li>上书随时可以拿来翻一翻，很多地方一目十行带过了</li></ul></div><h2 id="前景">前景</h2><p><strong>精通Python?</strong></p><p>Python作为一门脚本语言, 上手门槛很低, 但是自以为 “精通Python后”,  往往导致自己再难跳出舒适区, 不会花费时间去学习跟高效、更科学的特性；4月25日晚, 花了半小时初读第一章 <code>Data Structure</code> 的部分内容, 收货非常多!</p><p><strong>阅读计划</strong></p><ul><li>个人以为该书充当两个重要的作用:<ul><li><font color="#ef6d3b">随时查阅的手册 （Manual）</font></li><li><font color="#ef6d3b">编程习惯的养成 （如何Pythonic）</font></li></ul></li></ul><p><strong>章节划分</strong></p><p>很多小节应该过得很快, 实际不需要1天的开销, 暂时先排到五一结束吧.<br>阅读这本书的收益还是很高的, 尽快读完~</p><table><thead><tr><th style="text-align:left">大节</th><th style="text-align:left">小节</th><th style="text-align:center">排期</th><th style="text-align:center">进度</th></tr></thead><tbody><tr><td style="text-align:left">Data Structure</td><td style="text-align:left">1. The Python Data Model ⭐</td><td style="text-align:center">4.26</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">2. An Array of Sequences ⭐</td><td style="text-align:center">4.28</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">3. Dictionaries and Sets</td><td style="text-align:center">4.29</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">4. Unicode Text Versus Bytes</td><td style="text-align:center">4.30</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">5. Data Class Builders</td><td style="text-align:center">5.1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">6. Object References, Mutability, and Recycling ⭐</td><td style="text-align:center">5.7</td><td style="text-align:center">✔</td></tr></tbody></table><h2 id="1-The-Python-Data-Model">1. The Python Data Model</h2><p>书中以实现52张的扑克牌为例（不包括大小王），讲述了若干Python的特性.<br>这段代码推荐反复阅读…</p><pre><code class="language-python">import collectionsCard = collections.namedtuple('Card', ['rank', 'suit'])class FrenchDeck(object):    ranks = [str(n) for n in range(2, 11)] + list('JQKA')    suits = 'spades diamonds clubs hearts'.split()    def __init__(self):        self._cards = [Card(rank, suit) for suit in self.suits                                        for rank in self.ranks]    def __len__(self):        return len(self._cards)    def __getitem__(self, position):        return self._cards[position]</code></pre><p><strong>涉及Python特性如下:</strong></p><ul><li><font color="#1A9BFF"><strong>namedtuple</strong></font></li></ul><p><code>collections.namedtuple('Card', ['rank', 'suit'])</code><br>它创建了一个 <code>Card</code> 对象, 拥有 <code>rank</code>, <code>suit</code> 两个属性.<br>namedtuple 可以替代 dict 和 class 的繁琐创建, 大幅提高代码的简洁度.</p><ul><li><font color="#1A9BFF"><strong>meta programming</strong></font></li></ul><p>重写各种 内置函数( <code>__len__</code> , <code>__getitem__</code> ), 合理搭配 <code>len</code>, <code>[]</code> 等特性使用.</p><ul><li><font color="#1A9BFF"><strong>list comprehension</strong></font></li></ul><p>列表推导式, 看第二节.</p><div class="admonition todo"><p class="admonition-title">TODO</p><p>找时间过一遍所有Python的内置函数<br>例如 <code>__getitem__</code>, <code>__dir__</code>...</p></div><h2 id="2-An-Array-of-Sequences">2. An Array of Sequences</h2><h4 id="Sequence">Sequence</h4><p>先看Python内置的容器</p><ul><li><p>根据存储的数据类型可分为:</p><ul><li><p><strong>Container sequences</strong><br>允许不同种类型的对象： <code>list</code>, <code>tuple</code>, <code>collections.deque</code></p></li><li><p><strong>Flat sequences</strong><br>仅允许同一种对象：<code>str</code>, <code>bytes</code>, <code>array.array</code></p></li></ul></li></ul><p>作为对比, Flat-seq 在内存上更为紧凑和节省, 因为 Container-seq 会存储 <code>ob_refcnt</code>、<code>ob_type</code>、<code>ob_val</code>等 C 对象, 这导致其内存占用也更大.</p><ul><li><p>根据是否可修改可分为:</p><ul><li><p><strong>Mutable sequences</strong><br>可修改类型：<code>list</code>, <code>bytearray</code>, <code>array.array</code></p></li><li><p><strong>Immutable sequences</strong><br>不可修改类型: <code>tuple</code>, <code>str</code>, <code>bytes</code></p></li></ul></li></ul><h4 id="Tuple">Tuple</h4><p>尽可能的使用<code>tuple</code>类型（在某些不可变对象的场景下）, 因为它有两个优点:</p><ul><li>防止数据被错误修改 （如误传引用）</li><li>比<code>list</code>节省内存</li></ul><p><code>tuple</code> 不可变, 是意味着被tuple直接引用的对象不可变.<br>以下图为例, tuple中嵌套一个list, 该list仍是可变的.</p><p><img src="/images/tuple-demo.png" alt=""></p><h4 id="List-comprehension">List comprehension</h4><p><code>[str(i) for i in range(10)]</code><br>这是一个最简单的 <strong>Python List Comprehension, 即列表推导式</strong>, 它可以替代简单的 for 循环.</p><p>性能上, 推导式 往往优于 for循环, 主要有两个原因:</p><ul><li>for循环中的 <code>append</code> 等操作很废.</li><li>推导式的 for 是C层面的 for, 它要快于Python写的for循环.</li></ul><div class="admonition warning"><p class="admonition-title">runtime 优化</p><p>当不需要一次性产生所有数据时, 使用<code>(str(i) for i in range(10))</code><br>它是一个generator, 每次迭代时才会从中取出数据<br></p><p><code>filter</code> 函数就是一个generator, 使用<code>list(filter(...))</code> 以将其转化为列表</p></div><h4 id="Unpack-and">Unpack and <code>*</code></h4><ul><li>使用unpack来赋值</li></ul><p><code>a, b = "1 2".split()</code></p><ul><li>使用<code>*</code>来存储溢出的数据</li></ul><p><code>a, *b = "1 2 3 4".split()</code>, 其中<code>b</code>是一个list</p><h2 id="3-Dictionaries-and-Sets">3. Dictionaries and Sets</h2><p>略</p><h2 id="4-Unicode-Text-Versus-Bytes">4. Unicode Text Versus Bytes</h2><p>写在这篇文章: <a href="/posts/3RHEW9J/">【Python】编码之encoding</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【问题求解】Hash Map</title>
      <link href="/posts/7BBSYB/"/>
      <url>/posts/7BBSYB/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><ul><li>《Introduction to Algorithms (4th)》: Hash Tables</li><li>Python dict的算法原理</li></ul></div><div class="markmap-container" style="height:300px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Hashing：key -&amp;gt; value&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#Hash-Collisions\&quot;>Hash Collision</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;1. Chaining&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;2. Double-hashing&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#Hash-Function\&quot;>Hash Function</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;1. Division Method&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;2. Multiplication Method&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Hash Application&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;<a href=\&quot;#font-color-1F618D-SHA-font\&quot;>SHA</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;<a href=\&quot;#font-color-1F618D-MD5-font\&quot;>MD5</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="Hashing">Hashing</h2><p><strong>A hash table, also known as hash map, is a data structure that maps keys to values.</strong><br>哈希表, 就是一种将 key 映射到 value 的数据结构</p><p>哈希表实则为列表的进阶应用, 那么为什么需要哈希表?<br>先看列表的增删查改开销:</p><ul><li>增删改: <code>O(1)</code></li><li>查: <code>O(n)</code></li></ul><p>因此遇到需要<strong>密集查询</strong>的场景 (如通讯录, 如飞机航班…), 列表就会遭遇查询的性能瓶颈 (数据量很大)…<br>此时 Hash Map 就是<strong>应对高效查询而提出的数据结构</strong><br><br></p><p><strong>Hashing 主要由三个部分组成:</strong></p><ul><li><em><strong>Key</strong></em> : 可以是任意的输入类型</li><li><em><strong>Hash Function</strong></em> : 将input 转化为Hash index的函数 ⭐</li><li><em><strong>Hash Table</strong></em> : 存储所有Key, Value的数据结构, 类似Python Dict</li></ul><p>Hashing的性能几乎完全由 Hash Function 的好坏决定, 因此本文将围绕 Hash Function 的选择展开论述.</p><h2 id="Hash-Collisions">Hash Collisions</h2><p>最朴素的Hash结构, 即用一个大的数组表示 （即直接地址法）, Key即Value.<br>缺点很明显, 随着数据量的上升, 该数据结构的内存开销很大, 且存在空隙的浪费</p><p><img src="/images/hash-direct-address.png" alt=""></p><p>这在实际应用中显然是不可能的, 任何一个Hash Table, 其大小肯定是小于数据量的大小.<br>因此根据抽屉原理, 总会存在两个Key 哈希到同一个Index的情况, 这就叫<font color="#ef6d3b"><strong>哈希冲突 (Hash Collisions)</strong></font>.<br>如下图所示:</p><p><img src="/images/hash-collisions.png" alt=""></p><div class="admonition warning"><p class="admonition-title">如何理解 哈希冲突?</p><p>班上出现两个同名学生, 老师第一次点名时, 根本无法识别到哪一位.</p><p>因此需要额外的特征（身高、衣服、别的外号等）才能识别</p></div><br><hr><p><strong>如何处理 Hash Collisions?</strong><br><a href="https://stackoverflow.com/questions/4980757/how-do-hashtables-deal-with-collisions">🏅 Stackoverflow: How do HashTables deal with collisions?</a></p><ul><li><font color="#1A9BFF"><strong>1. Chaining</strong></font></li></ul><p>算法导论书中的方法是, 在哈希冲突的槽位中, 引入一个链表（如下面所示）.<br>这也是 Java Hash-Map 中解决冲突的方式（jdk1.7）.</p><pre><code class="language-python">0  -&gt; 40 -&gt; 27 -&gt; 53  // Hash Collision1  -&gt; 88              // OK!2  -&gt; 16 -&gt; 42        // Hash Collision...</code></pre><ul><li><font color="#1A9BFF"><strong>2. Double hashing</strong></font></li></ul><p>第一次哈希冲突时, 使用另一个备用的哈希函数, 循环下去直到冲突不再产生.<br>缺点是哈希的计算时间复杂度变高.<br><br></p><p><strong>什么是 Load Factor (负载因子)</strong></p><p>负载因子 = 总样本数 / 哈希表容量</p><p>对于列表来说, 负载因子为1, 永远不会出现 哈希冲突的情况.<br>负载因子越大, 说明发生哈希冲突的概率越高.<br><br></p><h2 id="Hash-Function">Hash Function</h2><p>此时我们得到 <strong>衡量一个哈希函数好坏的标准:</strong></p><ul><li>运算 快</li><li>内存 小 (产生的index少)</li><li>哈希冲突 少 ⭐</li><li>负载因子 小<br><br></li></ul><p><strong>常用的哈希函数有如下几种:</strong></p><ul><li><font color="#1A9BFF"><strong>1. Division Method</strong></font></li></ul><p>$h(K) = k \space mod \space M$<br>最朴素的哈希函数, 取模. 其中k是Key, M是哈希表的大小.</p><p>示例如下:</p><pre><code class="language-c">k = 1278M = 11h(1276) = 1276 mod 11         = 2</code></pre><p>这里的关键是 M 的取值, 显然它不能是 2 的任何次幂.</p><div class="admonition todo"><p class="admonition-title">如何选 M 的取值?</p></div><br><ul><li><font color="#1A9BFF"><strong>2. Multiplication Method</strong></font></li></ul><p>$h(K) = floor(M \times (kA \space mod \space 1))$<br>乘法哈希, 其中k是Key, M是哈希表的大小, A是一个 $(0, 1)$之间的常数.</p><p>示例如下:</p><pre><code class="language-c">k = 12345A = 0.357840M = 100h(12345) = floor[ 100 (12345*0.357840 mod 1)]        = floor[ 100 (4417.5348 mod 1) ]        = floor[ 100 (0.5348) ]        = floor[ 53.48 ]        = 53</code></pre><h2 id="Application">Application</h2><p><strong>哈希如何用作加密?</strong></p><p>以SHA举例, 用户输入自己的密码后（比如长度为5~12的字符串），系统会利用SHA Hash将其映射为 一个256bit的 字符串，并存储在计算机本地.<br>当用户再次输入密码, 只需要对比生成的SHA Hash值是否前后一致即可.<br>同时, <strong>由于Hash的不可逆, 还能有效起到防盗的作用.</strong></p><hr><h3 id="font-color-1F618D-SHA-font"><font color="#1F618D">SHA</font></h3><p>SHA-256（Secure Hash Algorithm）是最广泛的加密哈希算法之一, 任何长度的信息都会被映射到一个256位（32字节）的字符串.<br>详细可以看这篇: <a href="https://zhuanlan.zhihu.com/p/278028577">知乎: SHA256算法详解及python实现</a></p><pre><code class="language-python">hash("hello") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824hash("hbllo") = 58756879c05c68dfac9866712fad6a93f8146f337a69afe7dd238f3364946366</code></pre><hr><h3 id="font-color-1F618D-MD5-font"><font color="#1F618D">MD5</font></h3><p>MD5（Message Digest 5) 是一种消息摘要算法, 同时也利用了哈希函数.<br>本质上, MD5就是把任意长度的数据生成一个128位的字符串.<br>详细可以看这篇: <a href="https://juejin.cn/post/6844903663454928909">稀土掘金: MD5算法的应用及原理</a></p><p><strong>游戏Patch经常会使用MD5哈希算法, 来做文件下载校验.</strong><br><strong>SVN检查本地哪些文件作了修改, 也使用了MD5.</strong></p><hr><div class="admonition warning"><p class="admonition-title">SHA-256, MD5等哈希算法是否可逆?</p><p>显然是不可逆的, 因为这些是摘要算法, 本质是 <strong>无穷信息 到 有穷信息 的一种映射</strong></p><p><a href="https://www.zhihu.com/question/22651987">知乎: 为什么说 MD5 是不可逆的？</a></p><p><a href="https://www.zhihu.com/question/19743262">王小云: 破解出一个高效的MD5哈希碰撞算法</a></p></div><h2 id="Paper">Paper</h2><ul><li><p><a href="https://en.wikipedia.org/wiki/Hash_table">Wiki: Hash table</a></p></li><li><p><a href="https://www.geeksforgeeks.org/introduction-to-hashing-data-structure-and-algorithm-tutorials/">Geeksforgeeks: What is Hashing</a></p></li><li><p><a href="https://runestone.academy/ns/books/published/pythonds/SortSearch/Hashing.html#:~:text=One%20method%20for%20resolving%20collisions,first%20slot%20that%20is%20empty.">Hashing</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】如何阅读man手册</title>
      <link href="/posts/man/"/>
      <url>/posts/man/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">NOTE</p><ul><li><a href="https://www.kernel.org/doc/man-pages/">man-pages for web</a></li><li>程序员工作生涯三年, 至今恍然醒悟, 发现自己特喵的甚至不会读文档...</li><li><strong>搜索能力、阅读能力、表达能力</strong>, 是容易忽视却重要的技能</li></ul><p><font color="#1A9BFF"><strong>TODO:</strong></font></p><ol><li>man如何在多个标题之间快速跳转?</li><li>man如何显示行号?</li></ol></div><h2 id="man">man</h2><p><em><code>man man</code></em>, 利用man查看man指令的手册.</p><p><strong>基本使用:</strong></p><p>man 是完全按照 vim 的操作方式, 推荐阅读站内博客: <a href="/posts/adff27ce/">【VIM】Vi Improved</a></p><p>比如: q键退出, hjkl翻动等</p><hr><p><strong>下面总结几个重要的概念:</strong></p><h3 id="sections">sections</h3><p>为了处理 linux 不同模块手册中重名问题, 利用section将其区分.</p><p><strong>通过 <code>man -f [cmd]</code> 可以查看对应的section.</strong></p><p>以 <code>passwd</code> 指令为例:</p><ul><li><code>man (1) passwd</code>: changed user password (可执行指令)</li><li><code>man (5) passwd</code>: the password file (文件格式)</li></ul><p>通常情况, <strong>使用 <code>man [cmd]</code> 已经足够满足需求.</strong></p><p>下面列出常用的section:</p><ol><li>可执行程序或 Shell 命令 ⭐</li><li>系统调用（内核提供的函数） ⭐</li><li>库调用 ⭐</li><li>特殊文件（通常位于 /dev 目录）</li><li>文件格式和约定（比如 /etc/passwd）</li><li>游戏</li><li>杂项（包和一些约定) ⭐</li><li>系统管理命令（通常是 root 用户执行的命令）</li><li>内核相关的文件</li></ol><h3 id="headings">headings</h3><p>man手册的输出, 一般有如下几个标题组成:</p><ul><li>Name: 指令名</li><li>Synopsis: 指令的格式概要</li><li>Configuration: Configuration details for a device.</li><li>Description: 指令的详细描述 ⭐</li><li>Options: 指令接收的参数 ⭐</li><li>Examples: 指令的使用样例</li><li>Commands: 指令内置的操作键, 如htop有一个简单的UI界面.</li><li>Defaults: The default functions of the command and how they can be overridden.</li><li>Exit Status: 指令的返回值.</li><li>Environment: 指令相关的环境变量.</li><li>Files: 指令使用到的文件.</li><li>Authors: 开发者和维护者.</li><li>History: 发布历史.</li></ul><h3 id="man-k">man -k</h3><p>但你不确定要搜索的指令/模块名称, <strong>使用 <code>man -k</code> 可搜索所有的手册全文.</strong></p><p><img src="/images/man-k.png" alt=""></p><h2 id="colored-man-pages">colored-man-pages</h2><p>原生的man输出, 没有彩色的样式区分, 可以利用 colored-man-pages 实现.</p><p>阅读站内博客: <a href="/posts/2N8EPP4/">【Shell】oh-my-zsh</a><br>k<br><img src="/images/zsh-man.png" alt=""></p><h2 id="Quote">Quote</h2><ul><li><p><a href="https://phoenixnap.com/kb/linux-man#:~:text=To%20do%20so%2C%20follow%20these%20steps%3A%201%201.,man%20page%20in%20a%20browser%20of%20your%20choice%3A">How to Use man in Linux</a></p></li><li><p><a href="https://unix.stackexchange.com/questions/3586/what-do-the-numbers-in-a-man-page-mean">What do the numbers in a man page mean?</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OS】多线程之pthread</title>
      <link href="/posts/XT9Q9N/"/>
      <url>/posts/XT9Q9N/</url>
      
        <content type="html"><![CDATA[<p>大学时期写了一篇 <a href="https://blog.csdn.net/luhao19980909/article/details/89403233?spm=1001.2014.3001.5502">CSDN: 进程和线程的深入理解</a><br>阅读量接近4w, 回头看很多概念理解比较肤浅…<br>这篇文章会更注重代码层面的理解</p><h2 id="pthread">pthread</h2><ul><li><strong>man pthreads</strong></li></ul><p><em>Linux c</em> 提供 <em>pthread</em> 库用于实现多线程, 可通过 <em><code>man pthreads</code></em> 查阅手册.<br>阅读一遍筛选部分有用信息:</p><ul><li><strong>Description</strong></li></ul><p><code>pthreads</code> 是 POSIX threads 的简写, 它维护了线程相关的若干接口.</p><p><strong>These  threads  share  the same global memory (data and heap segments), but each thread has its own stack (automatic variables).</strong><br>这句很关键, 线程之间共享内存(堆), 但不共享栈.<br>看到没有, linux man 已经给了详细的答案和描述.</p><p><strong>Threads share a range of other attributess:</strong><br>线程间还共享如下属性:</p><pre><code>-  process ID-  parent process ID-  controlling terminal-  open file descriptors-  signal dispositions-  ...</code></pre><ul><li><strong>Thread IDs</strong></li></ul><p><strong>Each  of  the  threads in a process has a unique thread identifier (stored in the type pthread_t).</strong><br><strong>This identifier is returned to the caller of pthread_create(3).</strong><br>这就是俗称的pid (可以通过top指令看到), 它的类型是 <font color="#ef6d3b"><strong>pthread_t</strong></font>.<br>pid是由 pthread_create 第一个参数给出的.</p><ul><li><strong>Thread-safe functions</strong></li></ul><p><strong>A thread-safe function</strong> is one that can be safely (i.e., <strong>it will deliver the same results regardless of whether it is</strong>) called  from multiple threads at the same time.<br>重点+1, 这句直接解释了何为线程安全, 这不比CSDN上的一堆废话来的清晰直接吗?<br>线程安全, 即多线程下随便怎么调用, 结果都是唯一和确定的</p><p>后面接着列出了非线程安全的C函数…</p><ul><li><strong>Compiling on Linux</strong></li></ul><p><strong>On Linux, programs that use the Pthreads API should be compiled using cc -pthread.</strong><br>在linux下使用该API, 需要加上 <code>cc -pthread</code> 的编译选项！<br>直接 <code>include &lt;pthread.h&gt;</code> 以为就万事大吉了? 所以还是得看文档呀~</p><ul><li><strong>LinuxThreads</strong></li></ul><p>这里逐渐将如何使用 linux 多线程, 总结几点如下:<br>1.使用 <code>pthread_create(3)</code> 创建额外的线程, 这里自觉 <code>man 3 pthread_create</code> 查阅手册.<br>2.剩下的实践中再补充吧</p><h2 id="pthread-API">pthread API</h2><p>下面尝试利用pthreads实现 c 的多线程</p><ul><li><font color="#1A9BFF"><strong>pthread_create</strong></font></li></ul><p>这是创建线程的接口, 查看man文档可知:</p><pre><code class="language-c">#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr,                    void *(*start_routine) (void *), void *arg);</code></pre><ul><li><p>args:</p><ul><li>thread: 即pid</li><li>attr: 创建线程的相关参数, 传NULL即使用默认</li><li>void*: 线程调用的函数</li><li>void&amp; arg: 函数的参数</li></ul></li><li><p>return values:<br><strong>On success, pthread_create() returns 0</strong>; on error, it returns an error number, and the contents of *thread are undefined.<br>即创建成功会返回一个0, 有点像http请求的返回值规则.</p></li><li><p>下面给出一个示例:</p></li></ul><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;void *entry(void *arg) {    char *ret;    printf("thread() entered with argument '%s'\n", arg);}void main() {    pthread_t pid;    if (pthread_create(&amp;pid, NULL, entry, "thread 1") != 0) {        printf("pthread_create() error");    }}</code></pre><p>通过 <code>gcc main.c -lpthread &amp;&amp; ./a.out</code> 编译运行, 发现没有任何输出…<br>这里得出猜测, pthread_create 创建的线程不会直接运行<br>查阅文档得知, pthread线程的运行时不确定的, 进一步查阅 <code>pthread_join</code> 相关手册.</p><ul><li><font color="#1A9BFF"><strong>pthread_join</strong></font></li></ul><p><code>int pthread_join(pthread_t thread, void **retval);</code></p><p>作用是等到一个线程运行结束, join函数才会返回.<br>对于上面的 C代码示例, 只需要加一行:</p><pre><code class="language-c">if (pthread_join(pid, NULL) != 0) {}</code></pre><p>然后编译运行, 就可以看到 <code>entry</code> 函数中的正常输出.</p><p>另外, <code>pthread_join</code> 的另一个参数 <code>retval</code>, 可以获取线程的返回值.</p><h2 id="pthread封装">pthread封装</h2><p>Linux pthreads接口不是很好用, 且缺少一个全局的thread管理器.<br>我们可以尝试封装一层: <a href="/code/thread.h">thread.h</a><br>此时我们只需关注 <code>create</code> <code>join</code>这两个函数.<br>后面的所有代码示例都将使用 <code>thread.h</code> 展开.</p><pre><code class="language-c">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdatomic.h&gt;#include &lt;assert.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#define NTHREAD 64enum { T_FREE = 0, T_LIVE, T_DEAD, };struct thread {  int id, status;  pthread_t thread;  void (*entry)(int);};struct thread tpool[NTHREAD], *tptr = tpool;void *wrapper(void *arg) {  struct thread *thread = (struct thread *)arg;  thread-&gt;entry(thread-&gt;id);  return NULL;}void create(void *fn) {  assert(tptr - tpool &lt; NTHREAD);  *tptr = (struct thread) {    .id = tptr - tpool + 1,    .status = T_LIVE,    .entry = fn,  };  pthread_create(&amp;(tptr-&gt;thread), NULL, wrapper, tptr);  ++tptr;}void join() {  for (int i = 0; i &lt; NTHREAD; i++) {    struct thread *t = &amp;tpool[i];    if (t-&gt;status == T_LIVE) {      pthread_join(t-&gt;thread, NULL);      t-&gt;status = T_DEAD;    }  }}__attribute__((destructor)) void cleanup() {  join();}</code></pre><h2 id="Shared-Memory">Shared Memory</h2><p><a href="https://www.csl.mtu.edu/cs4411.ck/www/NOTES/process/shm/what-is-shm.html">What is Shared Memory?</a></p><ul><li><p><strong>进程间存在共享内存</strong><br>这个很容易解释, 想象一下windows的任务管理器, 或者Linux的top指令等.<br>他们一定可以读取其他进程的若干内存信息 (?).</p></li><li><p><strong>线程间不共享内存(local), 但共享进程间内存(global)</strong><br>线程的局部变量, 是存在栈中的, 之前看pthread man手册, 明确指出线程之间的栈是相互独立的空间.</p></li></ul><div class="admonition warning"><p class="admonition-title">TODO</p><p>关于共享内存先埋个坑, 看到相关的再补充.</p></div><h2 id="Atomic">Atomic</h2><p>从一个经典的问题入手: <a href="/code/sum.c">sum.c</a><br>两个线程分别对一个全局变量++, 最后的结果是多少?</p><pre><code class="language-c">long sum = 0;void Tsum() {  for (int i = 0; i &lt; 1000000; i++) {    sum++;  }}int main() {  create(Tsum);  create(Tsum);  join();  printf("sum = %ld\n", sum);}</code></pre><div class="admonition todo"><p class="admonition-title">WHY?</p><p>基本介于100w~200w之间, 偶尔会出现小于100w的情况.</p><p>先给出结论: <code>sum++</code> 不是一个原子操作, 即非线程安全.</p></div><br><ul><li><strong>为什么<code>++</code>非线程安全?</strong></li></ul><p><a href="https://stackoverflow.com/questions/39393850/can-num-be-atomic-for-int-num">stackoverflow: Can num++ be atomic for ‘int num’?</a></p><p>看汇编代码, <code>num++</code> 实际会拆分为3句汇编指令:<br>这三条指令在多线程中其执行顺序是不确定的.<br>即线程1在read时, 线程2可能在write…</p><pre><code class="language-asm">mov   eax, [num]  // readinc   eax         // addmov   [num], eax  // write</code></pre><br><ul><li><strong>什么是原子操作?</strong></li></ul><p><a href="https://wiki.osdev.org/Atomic_operation">Atomic operation</a><br>即原子操作在执行期间, 没有其他指令同时能够读或写.<br>正因为<code>num++</code> 不是一个原子操作, 才会出现上面的多线程bug.</p><br><ul><li><strong>多线程引发的支付问题</strong></li></ul><p>下面是一段模拟支付宝 扣除100元 的多线程代码:<br>当时尝试运行它, 会发现账户中瞬间多出用不尽的money…<br>这里的问题有两个:</p><ul><li><code>blance -= amt</code>: 它不是一个原子操作</li><li><code>unsigned long</code>: 非整形导致的溢出</li></ul><pre><code class="language-c">#include "thread.h"unsigned long balance = 100;void Alipay_withdraw(int amt) {  if (balance &gt;= amt) {    usleep(1); // unexpected delays    balance -= amt;  }}void Talipay(int id) {  Alipay_withdraw(100);}int main() {  create(Talipay);  create(Talipay);  join();  printf("balance = %lu\n", balance);}</code></pre><h2 id="Paper">Paper</h2><ul><li><p><a href="/posts/2DVYR5A/">如何阅读man手册?</a></p></li><li><p><a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">pthreads(7) — Linux manual page</a></p></li><li><p><a href="https://learn.microsoft.com/en-gb/windows/win32/procthread/about-processes-and-threads?redirectedfrom=MSDN">Microsoft: About Processes and Threads</a></p></li><li><p><a href="https://web.mit.edu/6.005/www/fa14/classes/17-concurrency/">MIT: Concurrency</a></p></li><li><p><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/threads-intro.pdf">Three Easy Pieces: Concurrency and Threads</a></p></li><li><p><a href="https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread">Stackoverflow: What is the difference between a process and a thread?</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js</title>
      <link href="/posts/1T7TWH8/"/>
      <url>/posts/1T7TWH8/</url>
      
        <content type="html"><![CDATA[<p>涵盖Node.js, NPM, html, TS/JS…<span id="more"></span></p><div class="admonition note"><p class="admonition-title">NOTE</p><ul><li><p><strong>WHAT is Node.js?</strong><br><a href="https://nodejs.org/en">Node.js</a> is a JavaScript runtime built on Chrome's V8 JavaScript engine.</p></li><li><p><strong>WHAT is NPM?</strong><br><a href="https://www.npmjs.com/">NPM</a> is the standard package manager for Node.js.</p></li><li><p><strong>WHAT is TypeScript?</strong><br><a href="https://www.typescriptlang.org/">TypeScript</a> is Typed JavaScript at Any Scale.</p></li></ul></div><h3 id="Node-js">Node.js</h3><p><code>linux</code> 默认安装比较老旧的 <code>Node.js</code> 版本，需要如下操作以升级：</p><ul><li><code>sudo npm install -g n</code></li><li><code>sudo n stable</code></li></ul><h3 id="TypeScript">TypeScript</h3><p><code>TS</code>默认使用非常严格的静态语法检查，通过如下途径屏蔽它（不推荐）：</p><pre><code class="language-tw">单行忽略// @ts-ignore忽略全文// @ts-nocheck取消忽略全文// @ts-check</code></pre><h3 id="nvm">nvm</h3><p><a href="https://github.com/coreybutler/nvm-windows/">https://github.com/coreybutler/nvm-windows/</a></p><p>nvm 是一个管理多 Node.js 版本的工具, 就像python conda.</p><p>使用: <code>nvm -h</code></p><ul><li><code>nvm list</code>: 查看所有Node.js版本</li><li><code>nvm install xxx</code>: 安装指定版本 (win10需要管理员权限)</li><li><code>nvm use xxx</code>: 切换到指定版本</li></ul><p>install 遇到报错, 是因为无管理员权限<br><code>Error extracting from Node archive: open ...\node-v18.15.0-win-x64\corepack.cmd: Access is denied.</code></p><h3 id="Problems">Problems</h3><p><strong>1. npm如何打包发布到html?</strong></p><p>借助 <code>browserify</code>: <a href="https://cloud.tencent.com/developer/article/1974393">如何在浏览器使用npm包?</a></p><p><strong>2. html调用js方法总结</strong></p><p><a href="https://blog.csdn.net/weixin_45587319/article/details/104776488">CSDN: HTML如何调用JavaScript</a></p><p><strong>3. html中js的相对路径问题</strong></p><p>使用 <code>" {{ assets/extra.css | url }} "</code>, html会自动生成相对路径</p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VSCode插件】function decoration</title>
      <link href="/posts/AEKS3P/"/>
      <url>/posts/AEKS3P/</url>
      
        <content type="html"><![CDATA[<h3 id="🏠-vscode-function-decorations"><a href="https://github.com/593413198/vscode-function-decorations">🏠 <em><strong>vscode-function-decorations</strong></em></a></h3><h2 id="原始需求">原始需求</h2><p>某个项目需要通过全局的Env属性来控制函数的可见性, 如下：</p><ul><li><a href="http://Env.py">Env.py</a></li></ul><pre><code class="language-python"># Env.pyFeature_A = TrueFeature_B = FalseFeature_C = True# ...</code></pre><ul><li><a href="http://xxx.py">xxx.py</a></li></ul><pre><code class="language-python">if Env.Feature_A:    def f1():        passif Env.Feature_B:    def f2():        pass</code></pre><h2 id="痛点">痛点</h2><p>当python文件很大, 函数定义很多的时候, 你得往上翻文件并通过对齐来确定函数是属于哪个if的作用域, 这是非常痛苦的.<br>因此希望通过vscode插件解析其作用, 在不同的函数后面显示样式来区分, 如下:</p><p><img src="/images/vscode-decoration.png" alt=""></p><h3 id="python语法解析">python语法解析</h3><p>先借助 <a href="https://docs.python.org/3/library/ast.html">python ast</a> 解析整个语法树<br>只需关注<code>ast.If</code>节点, 将它的body中是<code>ast.FunctionDef</code>的子节点都拿到即可<br>注意, 为了匹配else 还需要拿到其<code>orelse</code>对象</p><p>整体实现思路很简单, 见 <a href="https://github.com/593413198/vscode-function-decorations/blob/main/src/pyast.py"><strong>pyast.py</strong></a></p><h3 id="VScode添加标注">VScode添加标注</h3><p><code>DecorationInstanceRenderOptions</code> 的 <code>after</code>属性, 可以改变尾部的值和样式<br>代码示例:</p><pre><code class="language-js">// 新建一个样式实例const myRenderOptions: DecorationInstanceRenderOptions = {    after: {        contentText: ` # Feature_A`,        fontWeight: 'bold',        color: '#FF00FF',    },}// 控制样式位置和范围dividerRanges.push({    range: ...,    renderOptions: myRenderOptions,})// setDecorations, 切换文件会失效editor?.setDecorations(    dividerDecoration,    dividerRanges,)</code></pre><h3 id="效果展示">效果展示</h3><p><img src="/images/vscode-decoration-demo.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> VSCode </category>
          
          <category> VSCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OS】实现指令pstree</title>
      <link href="/posts/3AGXVNM/"/>
      <url>/posts/3AGXVNM/</url>
      
        <content type="html"><![CDATA[<h2 id="提要">提要</h2><p>pstree 是os-2022的一个mini lab: <a href="http://jyywiki.cn/OS/2022/labs/M1">M1: 打印进程树 (pstree)</a><br>主要内容是模拟linux下的<code>pstree</code>的输出</p><pre><code class="language-shell">$ pstreesystemd─┬─YDLive─┬─YDService─┬─sh───13*[{sh}]        │        │           └─23*[{YDService}]        │        └─14*[{YDLive}]        ├─acpid        ├─2*[agetty]        ├─barad_agent─┬─barad_agent        │             └─barad_agent───2*[{barad_agent}]        |         ...</code></pre><h2 id="思路">思路</h2><p>先通过 <strong><code>strace pstree</code></strong> 查看其系统调用, 发现其通过读取linux下 <code>/proc/xxx</code> 的文件实现 (这源自linux <code>everthing is file</code>的思想)</p><pre><code class="language-shell">$ strace pstree# 这句调用pstree的脚本execve("/usr/bin/pstree", ["pstree"], 0x7ffe85396ce0 /* 40 vars */) = 0...# 这句读取了/proc下的文件openat(AT_FDCWD, "/proc", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3fstat(3, {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0...# 这句读取/proc/1/stat的文件openat(AT_FDCWD, "/proc/1/stat", O_RDONLY) = 4...</code></pre><p>所以该实验考察的核心内容是:</p><ul><li><code>strace</code> 系统调用</li><li><code>c</code> 读文件</li><li><code>树</code> 数据结构</li></ul><h2 id="代码">代码</h2><p>无脑写完的, 没有什么技巧, 等过完os-2022的课程再回头review一遍此代码, 看是否有提高吧<br>缩进不一, 应该是因为混用tab和space导致, 这个有空处理下Hexo的编码</p><pre><code class="language-c">#include &lt;stdio.h&gt;#include &lt;assert.h&gt;#include &lt;dirent.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;struct Proc{char name[255];unsigned int pid;unsigned int ppid;};struct Proc proc_list[255];int proc_count = 0;int isNumber(char *str){    return strlen(str) == strspn(str, "0123456789");}void walkTree(int ppid, int tabs){// printf("%d:%d", ppid, tabs);for (int i=0; i&lt;proc_count; i++){struct Proc tmp = proc_list[i];if (ppid == tmp.ppid){for (int i=0; i&lt;tabs; i++)printf("---------");printf("%s(%d) [%d]\n", tmp.name, tmp.pid, tmp.ppid);walkTree(tmp.pid, tabs+1);}}}void walkDir(){    DIR *d = opendir("/proc/");    struct dirent *dir;    FILE *fp;    while ((dir = readdir(d)) != NULL)    {        if (isNumber(dir-&gt;d_name) == 0)continue;char path[256] = "/proc/";strcat(path, dir-&gt;d_name);strcat(path, "/status");fp = fopen(path, "r");if (fp == NULL) continue;char buff[256];struct Proc proc;while (fgets(buff, 128, fp) != NULL){char *ptr = strtok(buff, ":");if (ptr){char *val = strtok(NULL, ":");if (strcmp(ptr, "Name") == 0){strncpy(proc.name, val, strlen(val)-1);} else if (strcmp(ptr, "Pid") == 0){proc.pid = atoi(val);} else if (strcmp(ptr, "PPid") == 0){proc.ppid = atoi(val);}}}proc_list[proc_count++] = proc;fclose(fp);    }    closedir(d);}int main(int argc, char *argv[]) {for (int i = 0; i &lt; argc; i++) {assert(argv[i]);printf("argv[%d] = %s\n", i, argv[i]);}assert(!argv[argc]);walkDir();walkTree(0, 1);//printf("%s: %d\n", "12.3", isNumber("12.3"));//printf("%s: %d\n", "123", isNumber("123"));return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【问题求解】Recursion</title>
      <link href="/posts/20ER2MC/"/>
      <url>/posts/20ER2MC/</url>
      
        <content type="html"><![CDATA[<div class="admonition todo"><p class="admonition-title">TODO</p><ol><li>理论: 英文教材 《Chapter 2 Recursion: The Mirrors》</li><li>Leetcode: <a href="https://leetcode.cn/tag/recursion/problemset/">递归专题</a> | <a href="https://leetcode.cn/circle/article/OqbWl5/">递归blog</a></li><li>Recursion | Devide-and-Conquer | DP</li></ol></div><h2 id="Recursion-Mirrors">Recursion = Mirrors</h2><ul><li><em><strong>Recursion breaks a problem into smaller identical problems.</strong></em></li></ul><p>想象两面镜子正对着放在一起, 其中会无限产生倒映, 并且越来越小以至于肉眼看不见.<br>递归的本质, 就是将问题逐渐拆分成更小规模的问题, 以至于能被简单解决.</p><h3 id="How-to-search-a-word">How to search a word</h3><p>书中以 “在英文字典查词 <code>vademecum</code>” 为例, 阐述了两种方法:</p><ul><li><p><strong>Sequential search</strong><br>从字典第一个单词开始, 按顺序逐个查询…</p></li><li><p><strong>Binary search</strong><br>翻到字典一半位置, 根据首字母确定在前半部还是后半部, 然后接着翻到一半位置, 循环下去…<br>直到翻到只剩一页, 就停止循环, 在此页查找</p></li></ul><p>这就是一个经典的递归思想.</p><h3 id="2-x-Features-⭐">2 x Features ⭐</h3><p>递归思想解决问题, 符合如下2个特征:</p><ul><li><strong><code>base-CASE</code></strong>: 递归会终止于一个简单的问题</li><li><strong><code>降维</code></strong>: 每次递归都会调用自身, 并解决一个规模更小的问题</li></ul><h2 id="Recursion-Problems">Recursion Problems</h2><h3 id="Factorial-N">Factorial N</h3><p>先以阶乘为例, 阐述上面的特征:</p><p>$factorial(n) = n \times (n-1) \times (n-2) \times … \times 1$</p><ul><li>$f(1) = 1$<ul><li>这是一个base case, 因为它是最小的正整数, 是终止条件</li></ul></li><li>$f(n) = f(n-1) \times n$<ul><li>每次通过调用自身缩小了问题规模</li></ul></li></ul><p>python程序如下:</p><pre><code class="language-python">def fact(n):    if n == 1:        return 1    return n * fact(n - 1)</code></pre><h3 id="String-Backward">String Backward</h3><p><strong>字符串倒置问题</strong>, 这是递归中稍难的问题, 因为没有返回值, 它不再像 Factorial那样直观<br>以此为例, 阐述解决递归问题的思路：</p><ul><li><strong>找到<code>base-CASE</code></strong>: 长度为1的字符串, 倒置即是本身</li><li><strong>找到降维方式</strong>:<ul><li>已知n-1字符的倒置, 如何求n字符的倒置?</li><li>即S[n] + S[1…N-1]</li></ul></li></ul><p>python程序如下:</p><pre><code class="language-python">def write_backward(s):    if len(s) == 1:        print s    else:        print s[-1]        write_backward(s[:-1])</code></pre><h3 id="Binary-Search">Binary Search</h3><p><strong>二分查找</strong>, 这是计算机最经典的问题, 生活中也经常用到这个类思想.<br>任何情境下的二分问题,只需要想清楚如下2点:</p><ul><li>什么是<code>base-CASE</code>? 它确保二分能停止</li><li>选左半边? 还是选右半边?</li></ul><p>例如对一个有序数组作二分查找:</p><ul><li><code>base-CASE</code>: array[i] == target 或者 left &gt;= right</li><li>选择: 根据大小关系很容易选</li></ul><p>python程序如下:</p><pre><code class="language-c">int binarySearch(const int&amp; Array[], int left, int right, int target) {    if (left &gt; right)        return -1; // not found    int mid = (left + right) / 2;    if (Array[mid] == target)        return mid; // find it    else if (Array[mid] &lt; target)        // find right        return binarySearch(Arrary, mid, right, target)    else        // find left        return binarySearch(Arrary, left, mid, target)}</code></pre><h3 id="Find-Largest">Find Largest</h3><p>二分查找每一半的最大值</p><pre><code class="language-python">def findLargest(arr):    if len(arr) == 1:        return arr[0]    mid = len(arr) / 2    return max(arr[:mid], arr[mid:])</code></pre><h3 id="Find-k-th-Largest">Find $k_{th}$ Largest</h3><h3 id="Combination-of-C-k-n">Combination of $C^{k}_{n}$</h3><h3 id="Hanoi-Tower-⭐">Hanoi Tower ⭐</h3><p>这有个 <a href="https://www.mathsisfun.com/games/towerofhanoi.html">网站演示demo</a></p><div class="admonition warning"><p class="admonition-title">WARNING</p><p>这些算法待实现, 存在一定难度, 尤其是汉诺塔</p></div><h2 id="Recursion-Complexity-⏳">Recursion Complexity ⏳</h2><p>递归算法的效率往往不高, 因为任何编程语言的函数调用开销都较大.<br>可以通过使用迭代避免, 以Faborial为例:</p><pre><code class="language-python">def fact(n):    ans = 1    for i in range(1, n+1):        ans * = i    return ans</code></pre><h2 id="Leetcode-递归专题">Leetcode <a href="https://leetcode.cn/tag/recursion/problemset/">递归专题</a></h2><p>这里选取了几个最经典的算法题:</p><ul><li>斐波那契</li><li>反转链表</li></ul><h3 id="509-Fibonacci-Number"><a href="https://leetcode.cn/problems/fibonacci-number/">509. Fibonacci Number</a></h3><blockquote><p>F(0) = 0, F(1) = 1<br>F(n) = F(n - 1) + F(n - 2), for n &gt; 1.<br>计算F(n), 0&lt;=n&lt;=30</p></blockquote><h4 id="递归">递归</h4><pre><code class="language-c++">int fib(int n) {    return n &lt; 2 ? n : fib(n - 1) + fib(n - 2);}</code></pre><p>尝试用主定理分析一波复杂度:<br>$T(n) = 2 T(n)$</p><p>等比数列求和得到复杂度: $O(2^n)$, 空间复杂度: $O(1)$</p><p>尝试优化一下:<br><code>fib(n-1)</code>和<code>fib(n-2)</code>中间有很多是重复的运算, 可以作一个存储</p><h4 id="递归-缓存">递归 -&gt; 缓存</h4><pre><code class="language-c++">int fib(int n) {    // n &lt;= 30    int cache[31] = {0, 1};    for (int i=2; i&lt;=n; i++)        cache[i] = cache[i-1] + cache[i-2];    return cache[n];}</code></pre><p>通过数组存储, 避免了重复计算, 这里复杂度很容易分析:<br>时间$O(n)$, 空间也是$O(n)$</p><h4 id="进一步优化">进一步优化</h4><p>那么是否有办法优化掉$O(n)$的空间呢?<br>尝试使用多个局部变量即可<br>即a, b, c, 三者分别代表$fib(n)$, $fib(n-1)$, $fib(n-2)$:</p><pre><code class="language-c++">int fib(int n) {    if (n &lt; 2) return n;    int a = 1,  b = 0;    int c = a + b;    for (int i=3; i&lt;=n; i++)    {        b = a;        a = c;        c = a + b;    }    return c;}</code></pre><p>他是复杂度为:<br>时间$O(n)$, 空间$O(1)$</p><h3 id="206-Reverse-Linked-List"><a href="https://leetcode.cn/problems/reverse-linked-list/">206. Reverse Linked List</a></h3><blockquote><p>反转链表, 并返回链表head</p></blockquote><h4 id="递归-2">递归</h4><p>先尝试递归的解法, 按照递归的两个特性尝试理解:</p><ul><li><code>base-CASE</code>: 链表长度为1, 此时反转即本身</li><li><code>降维</code>: 长度为n的链表, 反转为 $R_{n}$ + $R^{'}_{1 - (n-1)}$</li></ul><p>实现的技术细节不是很直观, 因为利用了递归中函数调用的栈特性<br>如下 <code>next_node</code> 其实会一直调用下去, 直到最后一个尾节点, 然后才会执行<code>head-&gt;next-&gt;next=head</code>那两行代码.<br>即真实执行的顺序, 是<strong>从尾部到头部</strong> !<br>这个leetcode题解有动画演示, <a href="https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/">跳转链接</a></p><pre><code class="language-c++">ListNode* reverseList(ListNode* head) {    if (head == nullptr || head-&gt;next == nullptr){        return head;    }    ListNode* next_node = reverseList(head-&gt;next);    head-&gt;next-&gt;next = head;    head-&gt;next = nullptr;    return next_node;}</code></pre><p>照例分析复杂度: 时间$O(n)$, 空间$O(1)$</p><h4 id="双指针">双指针</h4><p>其实是单指针的方法, 利用<code>head-&gt;next</code>来更新节点, <code>cur</code>当做指针移动:<br>这个leetcode题解有动画演示, <a href="https://leetcode.cn/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/">跳转链接</a></p><pre><code class="language-c++">ListNode* reverseList(ListNode* head) {    ListNode* cur = head;    while (head &amp;&amp; head-&gt;next)    {        ListNode* next_next = head-&gt;next-&gt;next;        head-&gt;next-&gt;next = cur;        cur = head-&gt;next;        head-&gt;next = next_next;    }    return cur;}</code></pre><p>复杂度和递归的方案一致</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问题求解与算法</title>
      <link href="/posts/3HZHSCW/"/>
      <url>/posts/3HZHSCW/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">理论书籍</p><ul><li><a href="https://dokumen.tips/documents/data-abstraction-problem-solving-with-c-walls-and-mirrors-6th-edition.html">《Data Abstraction &amp; Problem Solving with C++》</a></li></ul></div><h2 id="目录">目录</h2><table><thead><tr><th style="text-align:left">专题</th><th style="text-align:left">Blog</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:left">Sorting</td><td style="text-align:left"><a href="/posts/1CKQG3J/">【Algorithm】Sorting</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Recursion</td><td style="text-align:left"><a href="/posts/20ER2MC/">【问题求解】Recursion</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Hash</td><td style="text-align:left"><a href="/posts/7BBSAYB/">【问题求解】Hash Map</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">String-matching</td><td style="text-align:left"><a href="/posts/1RJC6HF/">【Algorithm】String matching</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Binary-tree</td><td style="text-align:left"><a href="/posts/1E2J1Y0/">【Algorithm】BinaryTree</a></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Graphs</td><td style="text-align:left"><a href="/posts/2W1G2XP/">【Algorithm】Graphs</a></td><td style="text-align:center"></td></tr></tbody></table><p><img src="/images/algorithms-all.png" alt=""></p><h2 id="时间复杂度分析">时间复杂度分析</h2><p>递归和分治法, 可以通过主定理计算:<br>假设每次递归, 拆分为 $a$ 个规模是 $\frac{n}{b}$ 的子问题, 额外计算量是$f(n)$<br>$$T(n) = aT(\frac{n}{b}) + f(n)$$<br>则时间复杂度为:<br><img src="/images/master_theorem.png" alt=""></p><p>参考链接:</p><ul><li><a href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)">wikipedia: Master theorem</a></li><li><a href="https://blog.csdn.net/caozhk/article/details/24734371">主定理的证明及应用举例</a></li></ul><h2 id="附录">附录</h2><ul><li><a href="https://programmercarl.com/">算法随想录</a></li><li><a href="https://leetcode.cn/circle/discuss/E3yavq/">leetcode刷题攻略</a></li><li><a href="http://www.btechsmartclass.com/data_structures/introduction-to-algorithms.html">Data-Structures</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【日志】2023年4月</title>
      <link href="/posts/2023/4/"/>
      <url>/posts/2023/4/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="76a2277ae896c6b5980267a2882d582b7e5efb5514a778ea0567f822f56a5dae">b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475de0b1305a637ea913974dff7410a14ed4dbbb40a5278eb14bbac34e59e12a284c7643238e28174e788020e96a39239fbb7a1c76b116f6e38dc468b0c7cac9c50048e68c3dccb238a37e6d426c67296e44e624d0263ecbb1ee2ce6233952e63f68c54518300883aa91a56cb1ceea99ee02984fbd13056cf47fe0fd747697d84c93d835cf6f85ae3fef03ffe45ee23440aa039585c6ec0cbf30f39b3a857ce58c38f217729c7ec0c60e9bf63b162f3949f75b4548da5a65844a0bc0ed6329c52beceed7c96d178b24d5f7e92f673c17dd2f65c345f37961af7dee00bd990c7fc8ca4d5c0e4652d6d0313ddddf539200625354abbc375769ce7c5b3cce5aea73d281f4550dec5fdaf522abd2ca7b8deb0d9ea6c597736e09c84d18612210d09dafc7bfa4c134291a742e7627455b4b9883f85834fc8b42aa8bd86a5267a5595e235f3a2d43d079ff3e2554eb2e5d45370b7d46bfee4b35b6a89bb4161cd3e682ab74d091edf5a91939934ea6828deb895afc4bfdf0af86b435a2880bd8135110dc0f005a511f6b287e132c5031c05e8914e9d26f844cb26829a7d5c3c9cc64db2c2297fc35a8276e6f707ea808e5d83188fe0b9b31217c5c40f96f2bc55ed958db73b80aa28bd914c9aabda4ae50bbd92b45fc282114327b82c2d63a8a091bb0e0c1355e167457ce0638af83ec60396f3b1e714bfbcfd5fbb0ea9d25177b9876fd43403bb03db84052ea8e3fe9d998d819e6acf7433e431fd011e6a16d73ea835affc3dfe57c325036b3a905daa71ae851ba00ff7d2ed45f0ff999d368748f4ab57b8c9cb42bdaadef682c49de8c76f08613583208effcd82af9e5bb3b8843d46d348c4eea23cf50e4cc77bcb213da0dbbf3c964f2b00c70b9a51bd6e379ce65052185f6ddf25e40ad78df75342d8d529c9e2a4dee16e76d5b6e767452792eea3a78eced48fa7aebe768469f554bb29d3a26b45e676b7f1802179126ba0b5eeaebf314bb15cb18ee3a38a5f22d7b830c3b6cd5bf6c7b88fc0ab34d0cde0bc8fd13ab0a30219268c64488a44cb6fc24a8c6da1e5a5258bea003cf27452fce7c8a278cdbcccafab0874f9fe1dd35df6a9c5c5c9791557a59597466ac3fdb206ac43967ed09f6e9d03cec82142acaefe9397284812d51eee079393a92379cca42da4d044a189fbbe79fdc8a71d20c4566da54434eaeb6b7b947ddeea09e4c6c3813121795978ac2e2a6ac37e6923cf523881f8107cb5c1f74b60ef1c64502b8ffa625334760436e0fb541c55603f0c8703001790ca62c21ad1ff78c3d9078857492f6208aeb9956c02e277693987d84dacfb12c1889fb210da092b7a625051b2145de42cf1f3ecabe516402eff729b97479c39d0b3863a181ee41504fdca415abbd13659cb26535b16f0f1a53ac9805fe942ee5bcfabc61bf26b9175d10d56a104bed007bfebea691fd232481f2c7924679923b705334b6022f17ea6c5ff72571cf89eeb095a6dbaf77c190989d2804d8a1f7204a83d4d5a15777e3f7ea699029b6f5dfc31762b1751a52a738929435689823408d077906b5732028cd7ccd55f835ced93a1e95505e0e8518c53f26230da7226290f1bfc4094bd0ca2e31f6fa8300bacc4cf782b7fb3c6b7b64d23ba610c2b7d41c0c4e62d4c25f0aa96d616c09e371480c732b511f565ae06541634ca2170ce0eac117fa286a38f4db2f82c5379dfd273ef048fbb6019a8feb7437072263cc7bffa397e2a9d487a861f9d47f84aa0c7a5c1c9b7ed48e99485914a41feb32c57256fd04541511c9744c95c10f8ff74e2107f8ee6050594743c7ddd8c4e637ac67e1d515c2588de0fb08eb09f627080cd6cc1a308bc0ba5eac653b412b9eecb81751abec1d8ff98ae9803876457f586b4237285c3722363ac856a4118c53fe2725109627b02e0cc5d9326b40cb329c6ab74a8b9e1e616a389a8b9aa26bab69af4e4c9b688ec03f27474c283c2720b157a5081d8db41c5e5e5688b1a210a23d2577d48634e0e30ce3ab3e6f72fd8572fcdec59a6ca7e7631c11b3bc71ee23ded0881338671f60d8bd96bee283d3daccb34c5243b04795ec06b52dba190c85df0b0a8b8f26f9cffd4bc6bbf9fac76d313a5dee8c692a440ce26064d098b9a61f9a9c083a79dbd94baf0b6349f3f189677001ffc117520362ffd7962689d95d09720cf749bfd684cc708819053d68b0c0e2bd086ce4fcb962ccbce8a4fe87c9b23f885006f50c81d78ee05eecf1827b499caac7c6c4716f166ff2d24f6cdb4f505491ac74ff57455419b28ed82cfd484466fd1e34664cf015599aadabaafac3f3ca60399c3e5201aa84f81404b60cee265125e49e2965c90131eaa9c516556de738c73c834e9416bc33f1817e89c5691cd16094ae32a4c8484b57bef9ec2dfcfa4958a80a3da810faae1f1e9e893d4939b5d50f15bc4467d225ebc4578e2130e6e80708f4c909731851fbc62f690ddb403798e067cd8fc75a4ffdbefcb440a97872c0a8b0003d2076cff5ed39349590c5df318e6303454dd82ac3651a618a8729c5f848f2aedfe2e033d11aa4dc1d77a720be95609b8ae17f269eafce6fcd2133fb95789638aa3ff296f49a89de7c90174dd362abbca8d77a428b8352f389bd8fea81346093117ce89150ee938ec353a34dc587f96e5a1282af23b52030f616d237ce4472739b43e09effa8f468a76ce91b9ba04f479ef8f5215e8241e20df89b4c4257899ae013571b6eac5c7580f09cc075881f3eb59666834df5c3fcfc5dfae926e8e0a6bcab8eb187f5583a1cbcbe61efe8e0df7cd0d21d5df22602951840faf054ccf71cc069479dcbc5e3655f686ae62f84283075ed674c73fd372b7ec33a8da0a7f8094dfdedfe3149e6f9e197080f67d67e19fa1bfad62693cdaf6f527b6af9a7f01d9d0a4a62cd4d4788f8d36c1e80427328beb621504c18df5f672ff82842deae4e0c55758fce30fcfc2a752f69e06f179d97089237a7e1e1bd8da7b92acd39118092f6084a1b9956047c4c861a8f5b31825316f644772fbf5d690485974a4beacdcad5fa942cf5e1663ec241091b2eab691e7917647c9b7a66488caa4ae535a008a1424cb7a78bba3940d97a4ca29cd6ef7f256ca904c02df6f1199e85827b2f27f8f304fd60891666758a60b58291f35642051df38b6667fb6b3ae7ff21c1a3c4c8fa7013523818706aaf56497bb5989b0a51e410db312c22fe7ed84abdc3becc750e0e66d117120b467ccd65ea98f724430ccaee0c934c03aa6c830aae34f95c8c7eab5b74eb6fe903df3a7b088dea8714c5a20206261b3a4d1c7d9bfe01b373eefec634d80a6fbc826a9932d54fe1097a273083a29bfa6214ca40d6247342c6efda5d1bedb62125fff1ab5ec69c6ab62af161f05114b8b918dcc7d4bd2071d3cd1f380fc950b2a01975d81ccf708ed207452bf714b720b60f2061bb8c0f1c2d9076d2e2da3949b2296ffe23fb247b1ec05113372d7633c9a31210281abd97826aee4a159bfb83ed34b6ae3fef5032c27390248b861a22ff8b83471a6783162a359568c20d55b5e131153690bdfc4b23b4f776d0f71f87b4d3bc21ff03f6c2e7bf1179056993ea2a237a1f3a5eba2c8c2548c1dbb53377cc050918af21398be6fc0fecfdebb351a1e5d4789cde897cc9cd53a430f745bfc3c698203868d8a6fbc6f9ca6bb2a28991093d3dec6be898668c76b6b711f54c96a7b04e0589b436baab99b889791115fbfe6a9a95a859e9f921b516eb604911fc927b05e8c8701bd4414418b11694bba30aa2557ae860d42257dcba5642e6fa54ba7eb06a1a44dced955a2dc742f45cdf82a0b76ff1d0ec855aaea0dd33234c6ce00b223224a5287c059b7c159a0de028ba0cd8eb181936f42b8fbc2061ee5597fb4d993b0f307f392d22a411ced9e5511480fb56fbb92bad0d3ffd5c71fe7aa49a51ccf1968b84de2928c150f8a0aec8d2f11540ffbcdd5e74ea0b3eb6b73635d2f207ac5cba0bcac647c76f2e0cd49502ebdb7fc13785515cad8e8c90f0ff38f156eed1ec0dddf0f7082c5154620a2c377cf518d66e411dd742fb764808bdce9d5586c2d397033a90461cc3fc3163024f4f2a1be40f908e87dbafa28903fdc34f93be04aa36baac7163d1bada1be7f369ddab76852c03c0b6a59dbd10333b0459f450c68a63c86f6de68d724e5fdc05db3638335e99c4ca39093412b6a4e8ae587fc202e2324ccdadc93057f295da94204ff515b1de712dddec26b330cd8c08b4494b3509cf9df7872ace352ad66892e4c3814a6d3648284f43a91984d9acd95f99c8a5e930c64e480a5236657e8fff59dc0bb3af779dcce1722116c5f7e7fce65d8b87f7f240b122a353626fb67e5904baa6fef53ab8a4494fea1ff0bd0a0c2523472f5a987e7d5d8232bd3c4f605d29f2705931d4c19b4e7baa7b3b3d3b583a517559c5dac895d2ffbcd29dc5f9c6767ffce08dfb047ad03cdd504dcfaf8d8f5befc27b5eb0d93b53a039e7edb950310f379d3d074a87444dea4960e08bf5c28de126d4c87d8ac04048013673a5c006c755af4da7a33d18ebb40d5aec6cb3f6362ad96abe340f233d6c7dccc2ae0ee0c2b7dff380fc340ccfd085d9cf78b701f3a6b45410911f3dc9e6e3fee195ad76fcc084b698a42528fb460998d51bd70b037f50d53ce86d49d9b5198bfe6ff49c442fef2ace9def4beb230fb5664214e08ff7e239e9805a691b06550cd4211331399fcc53669f642c16fe6f3ceae673ae0e60ba980db05edc42ab19d2f0198858969ebc6046d52c03a2cb041c2a6ee1f513336d08ca54ee8a1877cc40d98c406219f42a8f9142ba4ac9fca5adea13bfd23bd53f0742c74082c00bd66ffb4eb8b0acdda9ee02172d790d7129d86175ba8cf332d239e7a9e7314d53c0c290a753e39f76f6fd87442c7ca656acb4c5736e1d244d45ae30617bed99775e3ec4b2e054813f09a52d6f1c35bba138b9d9e2308096901e715696f9dd9e480cfe38b9a16f24c810a70a507863712d1bd94d2bbf348dc222c80517532f9e649dd263edf76bb8bbffeb863025de7e9dcacb61131d25d8c15b8a1fff13c3e89dbeb5881ab629a3df14a8ba1323ca672b6d3a2e7b6c2ac619ab122a7fc921a0cf1334fd8529ed74adbe491d0db65b2fecdbc5b1f04b54577f51593028da29ac61197b6635c24b217339346e723589c70c35d5ed24b7265f041908c60d2325d47efbc9b3f90272bd321a2b042c39898ac5e0b85a59d137dc7a376dbee5672884227252fda1dbdb4d7c3ec1d776905eccd13fe4ec251579fb4caacccf414078a9966b3414ded41c1e3b03b0e21573540641aff48a2399b0a0427ee25e5da11091bd90f9b86547eb32ebe3b3d6104ecdff9ee25bd9d7c27c9938cadfe75b0d02274f518a50bb68149df05b8877d1e8de43d915063a3d75018d40e6c7be894ef445b2eff9e3f771e962070898b821a089d317f3c1e4e1c2f65858bc7948b5ed9403ae5e5c08c3521b67f561bfbf433a4ab02a8ea2bba3d10f8b3639c15e6137adf2ec05c2ab4e6c5772f614c052e8f646f8533f3d2ea6ac3fc6797cb36e803bbc21eb1a946a3b08e9e22ac8b3a54ba463578bd4585f14308848d8880fc00337a42bfbe05def1cc95b1bdfaed29ac60a88f5220cb5b9edcaa1295573e99eec3e09ab794342f749967222f992cb7c75593adf43fb37696d807aa2befdead293cbff99dad2a719fd7d6229c3b50ad88be6f4d01349e9a79784748c7fefd4666fbf6792b4824761a9a9b8a1a23fdb1112c98890e60b8fdbc96e0e20c1ec29336194839837f0b403167c6e112e55f84d5a3ea819c77f3c0c3068dc8938064cc6ae43ffc7d51a8eb5cfa023a0e1ef6e6c663bfea7635c2c1814a9aff3b25cec087ebb647008f4f3a1bf04431a226aef836e410e4ef6ecd90ecf6d16e72e19511e708963cfb24acddd81cd3fd2524ba05b1bca042f24ddb2739cc06a5e10b96ee41f62a55196eb23a79b93675d903187ce23e59708a6390101ab3f27e900cbe296958e90abebdb9049c64ce83c32fd755e11aeed53b332cbddf91375475e83f874aec215c25d7669bfae30644fb91923e70f6be060df7722e4a4e36fa0e329c11b443d78114a03b9231a0b9864b2ff0937d3ab3e9360befe8c1dfd503dbe946353f101e00769d518ef37a03d7c834e4753cd41e457cd5fc8a3b4c5e125472660f18e6200f6a7913fd48b35097e04500a2196109f8f27f3d1b3820c12ef16a3136d745e97e984fa56ae74d7ab85cb737bc9670a907f9101c591a31b4b804af14736be2959a356a7a23bc103e4606e9bddb0bb95767821a7f64af230c0739963768ebb4b4eee750b37d92e5d4aad00114ca491a88e13d79ea834e45c06e7061fbd4bffb8ab7a575f418ea75762f7b22b88ad8e8b4acde203319629a22e8adfacb2449b19a2fa26978e3f9457939c06e7cddabc79b7d0c0717748a5aff007980f4ddedd0b1dc44442d4afef1f2e070f92f340b0a488fdd50f2df1be00e8ef792679fdc2c7171fdae57f36a012badc922e70972dae00dfd0044fb3a9fd41b55eae9e44c672c72a5ae3c0c6723385175b2b0efd71f712e7ffe4420bfd8bdc953cf61f7a351cf43e5a962247854a1e3790f1cc9fcb281a460e6c2e074dfa23d6f16d1d05cd6d077bfa869aaf9701063c4f2dd0a0d90b56b05893ce653f8953d05eed96d2036bbc802278757b9c0f2da7d38a934afb7c9221a716c30b849d5d352d408ea450e2199feae9158d4a0672181a05a60c210e079b9fb941b5017637587bacffb99a0ea69584f64084943b6f1c21cee89cc06070ca947c3f3312adc6cb5d264398def825ebfe65112a7c1b401a4fc69e20eb35c58ff8e7704452f5b96a7d72a92679d116847429fa3941b9f5bc5e9033ba551505728e308e9c91f042ed4d3e904332015e6f4ccb837455670f42ea5ac535b0c279bfdf34ab8ba8c660a3dbc4b723b14291e1872fbd444a1cdb4e69030712fa60187bb0b635ef8ae0b00b52e4b00e09653a0239847a11fd9bb93befcc68d466b4c92533d83d9e987bc24fd3a3ecc294e194c23c329bda099934ea695e316da492fdcf329979324405ba709080ed628e6b88aa9933e4d948c9d911b525d63d96db55c839df78368c07288e2653fe5a44f00b33069bdae3514c993488ffae7207147a833366bf1f1befa4804ffa7dc29b62d3732575af990809438d7109f8b3a4440f48399bba568fb24ef942aa8aa00bbbf15a1e6a850f85ad96ec9ea836bcc09298ce6c2106aec488c35724ddd18b4ac57dd1d16e7703e005dc03b2e8bb65afa483877b53b7680b0b0ed459d3fa80cd6532cfaffb4c3a6d61f6678077d4b1d258630c9ae183629494f08456c63975d2508f72546f071311f29d373e2d0856dfea4d7dc44bfec38ca6891cedee6145e23c46f42c218c34d83b0a4f8b295a8a9e01ab248720407d669dea3393025e71b4e52dff37d7ad3e03895e5662fa5cb074c6f0d8d4ab5f01dc40bb01252707fe7c86446ef0af605ef07cbd9394e62cbb0bb0ef4d8a9c81e0250d6940e2133c5e6ed57462384073938a9b4b210295c1c8e3fe8451280c01284ae8ded609e9f194c8d262f6a2bd3a057684418cc11e33508bcebb5b554eca0ffecf29f66be7203ddb5a524513f9cf6ee91117555b3e0b709e58a8d8171e5a02c064fea90a91a83742051e19c7c0ae361e5d976bed60cbc8866a07c2cfb19d5eafd9bb78bbdf9415174cfc1033b19aeb26a54960246860556e4e83a1d30a18308b8fe6a5b0d5c487dea481afc21a938f1f1269173cff27cfdf9a4836dedb4b66a3366c524cb5bedfdf98df797903623707a00f8ba7358294b2dda6ba48db91246d427d4e6f49c0c45750f3da027699d026100c02b76275d743f147d30dc978364c42d725837595c32dc95b7b44311bd58517c31f6ff78e66ebf475f574a304363b82a57640de9f233f9700634beafcc2c6628ece15126f779fc993a3b7c6ab21dd8adcd2e830e5214ce9cf5357eb6b4fb55f60ff0f3c7f02c64ca1ea8ee60a338c4f9610e304080e8fc763549f35071ce6cede3da0739d3a4f8001232c397d231e805a8c1dd1b111e9079209d21e5617942768616fee6a640b8d4d9f7bc3c52663e5ecfbfc97cb649e0cd075efae20ea8a7eb9a8ee1570bf788fc713785da5adf625092a813e7027ec9332d813017d2d5d6bd3fe8ea2786297e0082595fb3625419a38c221e2599ba3735d57730ca43c96fba84d0ed297b13fc7c7efe2daba31b1e78007085edff1aa3ddb107b3d867535e52bad508a636c932972972fa8fef45061cce581e967ec08b5d75de36784f92bfa99cfb5853898b530e60e44b2e29076bf85e6fd9d5ae78d4978f21a1e551264aadf2c59a8c71493e33757c667c3b9a1f8b5d8e8d9a1b96eaed61e3ed1872d6a1d9a52674c96863b095447983ee8fd0bf7031b155738def2ddb694de86b8f80323031639d72ffd954e3f42144d71641bbb50e3a22b6e1ca321d5ba095ccd397b9a2ad01d510c14ea2e64134e6b3c8073c585015397dcf17bf51407fbec2b68a2cca8676f470ba80153d32d7c3816bc922e4731e434eed4314c759df2fc7dcbc0ca88b61b426c032b19017cf663022042e5adbf8072652461381b82b9f47052df41aea42e29b2f7bb6d2cb3d09588904249768bbf3d7979ba265659cddee29a6841641a453032a2e29e1e44bd226c542488b9f5bfd513e213b72fbb3294ea8617c857810e4b0a938373139b6d580b28364dec3af722e09506ad70f75d80fe8600d8b6b33fd94aa57990f990d3e25e97a94a624fe1d541bcfd26a33ae2f9086d2f1522f173a51fa541b36c5c19f3c0a1edfb4682947a8f3de8cdc14438736dbef0a3f6f208b012afa01ed1d7990bcc40693b13fd8d4be5add25ecd38b9e262c335be3362db170c2912978b309632d7f706f035fa74167f2f2d6d7290b0eb6069dd803209789026a432d48d4675dbe2f9801c294d140bcac1d60fd4e6bfd79ba1fc5a970c874e0675aae884754d52c63a16ac5d5ef3baf96934090584541cf7afff2797e3e9225aee8f3612ac81c690a55248dba8f13c2a53d2b647bf405e5e24e627a4e527adbc1fb3d6c38a8d9eddefc196be0070b1f9955752a21af691434099ece2a5ebca0f50615b5b8a33e83214f32c9dc9f2a0f8e86aa91cfb138dff8dc77071463126178b9829b77cfe3c0e143f87701c45cb4c37386024ed34f717575f4577998491e3e3d0e6864085295378277b009f8f23a4a06d16ca179c4b7aa0d391fd2b71066a915a1e46ceedb6a4121abbffe2c622d06e96223d744ba3375c2892ddbbbc3e5110e1162ec20147a2533542f0cf40609a58c668c2a458b3b03abad45ae408e029dea44f74cabc4184c7d3b1fe91b3822be30987996480eb75e5d09632d6a158d78648b2a00e14ea4b655f581cec7660f6f42bf730e9e7af691ab79d8698e067b36fb0b5255034a4ee3339860a82080f60d4db4ece88fff29fc9f090e654329adfbc42ea1db64f72069a4f3b4f53b1bdf69e729357bf9d1fd14d92ac4ae408b92b1bdc047a7241e9c6c7036bd73665083d0dba830f9ab1156d906ba96eb35658db3f726ff15b611e078dfb0cd1b3d94250f4c8c6ff4192afc95316f196955bd492f2cc319499099ed32a92ebbaf786073d457e04f55a9994eb13be9e4d07125374e57aa22b73fe9149912e1f95278b32e9e2e3b2308ce3e79a20d762d27ec02fe0e243b7a5a34bd985d2fe459f9ac140efdd4c79d51fa19523854c210770bedb676dc3728eba8e8d952abaf327ec172991c601fcde6b724203d115c1824ad41138240b1b9ac3957b0a72290e6de97604cc03eb523798f22fc64d4b00b2d19a942e2839edd97a90f4ab7b6d7538e0d528d7d5a897131a3c5e9d84756276ebf4eae39f5145d433e0297fe9b046e54f7ee11679506300cc76f332095adb1f105a57c2bebf1c7e08afa504a5994a3e225ced61fbd7950860d668dba5045c41d4a6f12b2bad61b7fd5cbc397b991d4dd135fbef3b378e4a9e3ced7d3705fb8345afa708c79e24d4af77b5623202fd6b3d46ffc2ffb1d74d92fe45a47b29f70d25d62820bf8f44d47aa692b92c58e8e09e94a5db1d444ac540cc565c33e0513c5cb75bcf4ec3851f12142f87109f656cac8187ebb4b4427f5ca1ea79925f7717586c0087f76ffca6ff2eaa57c0f4ea319700ce2377f4ab5181718b03a59055dbe00a012a2a2c58d492b97ef0eea7149d25f346368c5152d6b0c3c77639a99ca1d6a17208f564f1650953d01a043b252d3ea8930b8e012175ea9e734e9e932bb803fc35bdde65180c1d7c1d9ace27e090934977d3031b51fe187e790d51306e20107c30a4b27bc98991a81192669371b4da9afe9fc06b6651421252fd914003ef76bb2cb8c98a49ae090461c5bb3d04fe7009abf1acb2b51b9f4762500c2da26ca95e002d9c06a80853c7c2ee241fb993693d2b51451d17aa8fb3f76cc69eedc5d426fff5e24252c1a39a7079379d007a63f17bf781352d3ae04d510d97ac3a22799f0c3bd7710b366fefe1473a61ee18836060bece1bb2da87536bdadb2f71cb795001d071ba27349f9eed726b0dc217d7992659128686b62332da0991f198f44c6540f1eb11f47088cbe44a2cd6da4747415edc8db2c39b2a55ced7c6dc33b0a267b03c535813b8d98f7928b5838d995cec9db82405fff68f2fdc603a1d8e4d428f57d79fa442beb82490c859ee86d108c4d7a091c8c945d92b655069e4908930db4e14d61a013f8b7614dfff39276c4f65fe826d1e2a62305e1fbbc8ae1d80493e3dca4a114fca6efac773aa311d1b6f7159cad0f8e49cca6f78139c8604fd371d373f98bc56dd9088f22d9deb0faa17ab9ac1cd4b7b6dd6757aaaf31aceaad55d38ef27d190be76775b6eac81ed8290facf367da39532cca453201e288bcd72fed12a863ec1b5fabe7abfa66504f9d42530a811a3bb66b36142b0b502fdcc87171330deba44cb179aee041fd95b19c0e2e93e248d5b7eb741efe4e25812382c26fe577ff813bed23869261d3f985141156fb1a2605f847af853d0c8dfc432c1c25c5</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态网页搜索引擎</title>
      <link href="/posts/2F3J6A9/"/>
      <url>/posts/2F3J6A9/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">背景提要</p><p>在使用 <a href="https://www.mkdocs.org/"><strong>python-mkdocs</strong></a> 生成内部文档时, 其内嵌的搜索非常难用, 奇卡无比且不支持中文</p><p>因此萌生了写一个简易静态搜索引擎的想法</p></div><h2 id="搜索方案">搜索方案</h2><h4 id="常见的搜索有两种实现">常见的搜索有两种实现:</h4><ul><li><ol><li>接入 <strong>Baidu, Google</strong> 等搜索引擎的爬取, 然后利用他们的搜索接口去搜</li></ol><ul><li>适用于ip公开的网页, 好处是搜索快且功能全</li><li>坏处是, 不太好做输入的实时预览?</li></ul></li><li><ol start="2"><li>静态搜索网页内容, 适用于个人博客、内部站点</li></ol><ul><li><strong>本文讨论的就是这种方案</strong></li></ul></li></ul><h4 id="实现步骤">实现步骤</h4><ol><li>解析markdown语法树</li><li>按照一定规则将解析结果写入Json</li><li>实时搜索时调用fast-fuzzy搜索</li><li>html前端展示搜索结果</li></ol><h3 id="markdown语法树解析">markdown语法树解析</h3><p>借助 <a href="https://pypi.org/project/commonmark/"><strong>python-commonmark</strong></a> 实现</p><pre><code class="language-python">import commonmark"""MdParser: 解析一个md, 返回所有正文"""parser = commonmark.Parser()class MdParser(object):    def __init__(self):        self.visited = set()        self.content = defaultdict(list)        self.all_content = []        self.head = ''        def entry(self, path):        with open(path, encoding='utf-8') as f:            string = f.read()            root = parser.parse(string)            self._walk(root)    def _parse_children(self, node):        if node in self.visited:            return        child = node.first_child        while child:            if child.literal and child.t != 'code_block':                self.content[self.head].append(child.literal)                self.all_content.append(child.literal)            child = child.nxt        self.visited.add(node)            def _walk(self, root):        for node in root.walker():            if node[1]:                node = node[0]                if node.t == 'heading':                    self.head = node                self._parse_children(node)        def dump(self):        content = '.'.join(self.all_content)        # fix special character        content = content.replace(' ', '').\                        replace('，', ',').\                        replace('!.!.!.', '').\                        replace('\t', ' ').\                        replace('img.', ' ')        return content</code></pre><h3 id="生成数据search-json">生成数据search.json</h3><table><thead><tr><th style="text-align:center">Key</th><th style="text-align:left">Value</th></tr></thead><tbody><tr><td style="text-align:center">title</td><td style="text-align:left">h1标题</td></tr><tr><td style="text-align:center">text</td><td style="text-align:left">正文</td></tr><tr><td style="text-align:center">link</td><td style="text-align:left">跳转链接</td></tr></tbody></table><ul><li>如下遍历一个目录下的所有md, 并将结果写入一个json, 供搜索用</li></ul><pre><code class="language-python">import osimport json"""MdWalker: 解析路径下所有md"""index_output_path = ''output_path = './search.json'class MdWalker(object):    def __init__(self):        self.output = {'all': []}    def entry(self, folder):        # read index        f = open(index_output_path, 'r', encoding='utf-8')        index_json = json.load(f)        f.close()        # walk *.md        for root, _, files in os.walk(folder):            for _file in files:                if not _file.endswith('.md'):                    continue                path = os.path.join(root, _file)                md = MdParser()                md.entry(path)                file_name = _file.split('.')[0]                index_info = index_json.get(file_name, {})                self.output['all'].append({                    'title': index_info.get('title', file_name),                    'text': md.dump(),                    'link': index_info.get('link', '.'),                })        # dump to output_path        self.dump()        def dump(self):        with open(output_path, 'w', encoding='utf-8') as f:            json.dump(self.output, f, ensure_ascii=False, indent=4)</code></pre><h3 id="fast-fuzzy模糊搜索">fast-fuzzy模糊搜索</h3><p>借助 <a href="https://www.npmjs.com/package/fast-fuzzy"><strong>Node.js: fast-fuzzy</strong></a> 实现<br>使用方法直接看文档</p><h3 id="html展示搜索结果">html展示搜索结果</h3><p>考虑复用mkdocs原有的前端框架, 或者找一个带滚动条的容器<br>采用这个html样式: <a href="https://www.shouce.ren/study/api/s/framework7--swipeout-overswipe.html">swipeout-overswipe</a></p><h3 id="其他问题">其他问题</h3><p>参考这篇: <a href="https://luhao.wiki/posts/1T7TWH8/">Node.js (站内文章)</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OS】调试理论与实践</title>
      <link href="/posts/2F2QH5R/"/>
      <url>/posts/2F2QH5R/</url>
      
        <content type="html"><![CDATA[<div class="admonition error"><p class="admonition-title">牢记两条定律</p><ul><li><p>机器永远是对的</p></li><li><p>未测代码永远是错的</p></li></ul></div><h3 id="Bug产生原理">Bug产生原理</h3><ul><li><p>代码错 <font color="#FF1E10"><strong>Bug</strong></font> -&gt; 程序状态错 <font color="#FF1E10"><strong>Error</strong></font>  -&gt; 可观测错 <font color="#FF1E10"><strong>Failure</strong></font></p><p><strong>代码错</strong>，通过阅读代码发现是比较困难的<br><strong>程序状态错</strong>，是可以通过状态机（断点调试）一步一步定位出来的<br><strong>可观测错</strong>，如Segmentation Fault、如Wrong Answer，是发掘Bug最主要的途径</p></li><li><p>因此debug最佳的方式，是 <strong>让Bug尽早暴露出来</strong></p><ul><li>二分</li><li>使用assert</li><li>使用print (注意是debug环境下…)</li></ul></li></ul><h3 id="gdb">gdb</h3><ul><li><p><a href="https://luhao.wiki/posts/3DJGDAE/">汇编（四）：gdb调试</a></p></li><li><p>为什么gdb可以暂停程序的运行?</p></li></ul><p>一般的debug都是利用 <strong>软中断</strong>，即将系统调用<code>INT 3</code> 注入汇编代码<br>明白此原理，可以自己实现一个gdb调试程序!</p><h3 id="vscode断点调试原理">vscode断点调试原理</h3><p>现代编辑器（&amp;IDE）为每款语言都实现了一套自己的debug工具<br>如 <a href="https://github.com/microsoft/ptvsd">ptvsd</a> 就是vscode对python的debug工具<br>如下<code>main.py</code>:</p><pre><code class="language-python">import timewhile 1:    time.sleep(1)</code></pre><p>运行时需要加入ptvsd选项，默认端口是5678<br><code>python -m ptvsd --host localhost .\main.py</code></p><p>对vscode的<code>launch.json</code>加入如下配置:</p><pre><code class="language-json">{    "version": "0.2.0",    "configurations": [        {            "name": "Client: Python Attach",            "type": "python",            "request": "attach",            "port": 5678,            "host": "127.0.0.1",        },    ]}</code></pre><p>此时启动vscode 的f5，就可以愉快的断点调试了!</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Shell】oh-my-zsh</title>
      <link href="/posts/2N8EPP4/"/>
      <url>/posts/2N8EPP4/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">NOTE</p><p><a href="https://ohmyz.sh/">oh-my-zsh</a> 是一款具有高亮和丰富插件的跨平台终端</p><p>已亲测在Linux、Win10、MacOs上使用</p></div><p><img src="/images/zsh.png" alt=""></p><h2 id="安装">安装</h2><p>需要先安装 zsh：<code>sudo apt-get install zsh</code></p><p>官方文档给的是:<br><code>sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</code><br>但是这个链接可能会被墙，因此使用国内代理:<br><code>sh -c "$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)"</code><br>接着执行<code>install.sh</code>，如果速度仍然很慢，修改其中内容:</p><pre><code class="language-bash"># 这是旧的配置REPO=${REPO:-ohmyzsh/ohmyzsh}REMOTE=${REMOTE:-https://github.com/${REPO}.git}</code></pre><p>更改为:</p><pre><code class="language-bash"># 这是新的配置REPO=${REPO:-mirrors/oh-my-zsh}REMOTE=${REMOTE:-https://gitee.com/${REPO}.git}</code></pre><hr><p>Linux的默认shell一般是<code>/bin/bash</code><br>可以通过<code>echo $SHELL</code>查看环境变量</p><p>设置zsh为默认shell, 重新打开shell后生效<br><code>sudo chsh -s /bin/zsh</code></p><h2 id="zsh插件">zsh插件</h2><p>zsh插件基本是通过<code>.sh</code>实现的, 通过编辑<code>~/.zshrc</code>修改:<br>通过<code>source ~/.zshrc</code>使其生效</p><pre><code class="language-python">plugins=(    git    zsh-autosuggestions    colored-man-pages    # ...)</code></pre><h4 id="zsh-git">zsh-git</h4><p>这个是默认配在plugins的, 会显示当前的git branch, 如图：</p><p><img src="/images/zsh-git.png" alt=""></p><h4 id="zsh-autosuggestions"><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></h4><ul><li><code>git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></li><li><code>source ~/.zshrc</code></li></ul><p>会自动根据历史、剪切板、推荐等补全shell输入，如图：<br>注意，右键是补全</p><p><img src="/images/zsh-auto.png" alt=""></p><h4 id="colored-man-pages"><a href="https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/colored-man-pages">colored-man-pages</a></h4><p>彩色显示<code>man</code>，查手册非常有效</p><p><img src="/images/zsh-man.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode</title>
      <link href="/posts/3HCBFZ8/"/>
      <url>/posts/3HCBFZ8/</url>
      
        <content type="html"><![CDATA[<p>涵盖vscode源码、插件、使用技巧…<span id="more"></span></p><div class="admonition note"><p class="admonition-title">其他站内文章</p><ul><li><a href="/posts/1RVNF84/">vscode 多种语言断点调试</a></li></ul></div><h2 id="源码">源码</h2><blockquote><p><a href="https://github.com/microsoft/vscode"><em>github: microsoft/vscode</em></a></p></blockquote><p><strong>Windows build</strong></p><p>限制node.js版本最好使用: <code>v16.19.0</code><br>安装yarn: <code>npm install -g yarn</code></p><ul><li><p><code>git clone git@github.com:microsoft/vscode.git</code></p></li><li><p><code>.\scripts\code.bat</code></p></li><li><p><code>yarn watch</code>: 任何源码修改会自动reload</p></li></ul><p><strong>Linux build</strong><br>还没成功, Linux谁用vscode…</p><h2 id="vscode-插件">vscode 插件</h2><p><strong>推荐插件只有如下几个:</strong></p><ul><li><p><strong>Remote-SSH</strong><br>远程连接服务器开发必备, 太爽了!<br>建议在其config中配置所有常用服务器的ip, 别名, 然后直接在<code>Remote-Explore</code>中快速连接</p></li><li><p><strong>Bookmarks</strong><br>快速在代码指定行添加标签, 方便跳转<br>推荐快捷键改为:</p><ul><li><code>ctrl + →</code>: 添加mark</li><li><code>ctrl + ←</code>: 取消mark</li><li><code>ctrl + ↑↓</code>: 跳转</li></ul></li><li><p><strong>Live Server</strong><br>网页开发必备, 快速其一个本地的server</p></li></ul><hr><p><strong>自研插件:</strong></p><ul><li><strong>vscode-function-decoration</strong> <a href="https://luhao.wiki/posts/AEKS3P/">博客</a> | <a href="https://github.com/593413198/vscode-function-decorations">Github</a></li></ul><p>为Python函数增加标识, 以区分是哪个if包围.</p><ul><li><strong>vscode-markdown-snippet</strong> <a href="https://luhao.wiki/posts/2167JH4/">博客</a> | <a href="https://github.com/593413198/VScode-Markdown-Snippet">Github</a></li></ul><p>提供markdown的常用样式插入</p><h2 id="使用技巧">使用技巧</h2><p><strong>0. Tasks</strong></p><p>自定义vscode执行任务<br>相当于快速执行某个bat/shell脚本</p><p><strong>1. 区分顶部窗口颜色</strong></p><p>当work-space项目较多, 可以在<code>setting.json</code>下作颜色区分.<br>active代表选中, inactive代表未选中的颜色</p><pre><code class="language-xml">"titleBar.activeBackground": "#583e63","titleBar.inactiveBackground": "#583e6399",</code></pre><p><strong>2. editor和terminal切换</strong><br>作为VSCode terminal的重度使用者, 经常需要在其与编辑器界面切换<br>推荐绑定<code>ctrl+</code>, 在<code>Keybord Shortcuts</code>配置如下快捷键即可:</p><pre><code class="language-xml">{     "key": "ctrl+j",     "command": "workbench.action.focusPanel"},{     "key": "ctrl+j",     "command": "workbench.action.focusActiveEditorGroup",     "when": "panelFocus"}</code></pre>]]></content>
      
      
      <categories>
          
          <category> VSCode </category>
          
          <category> VSCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【OS】程序与状态机</title>
      <link href="/posts/22MGG22/"/>
      <url>/posts/22MGG22/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">先理解两个概念:</p><ul><li><font color="#ef6d3b"><strong>程序是 状态机</strong></font></li><li><font color="#ef6d3b"><strong>程序 = 计算 + SYS_call</strong></font></li></ul></div><h3 id="如何模拟一个数字电路">如何模拟一个数字电路?</h3><p>假设有两个寄存器，X和Y，取值分别为0和1<br>每次执行下面的动作:</p><ul><li><code>X′= ¬X ∧ Y</code></li><li><code>Y′= ¬X ∧ ¬Y</code></li></ul><p>则对应下面三种状态的转移，每个转移对应cpu一个时钟周期：</p><ul><li><code>X=0 Y=0</code></li><li><code>X=0 Y=1</code></li><li><code>X=1 Y=0</code></li><li><code>循环...</code></li></ul><p>这就是一个简单程序的数字电路视角，下面是C代码的实现:<br><code>gcc -E main.c</code> 可以展开宏</p><pre><code class="language-c">#define REGS_FOREACH(_)  _(X) _(Y)#define RUN_LOGIC        X1 = !X &amp;&amp; Y; \                         Y1 = !X &amp;&amp; !Y;#define DEFINE(X)        static int X, X##1;#define UPDATE(X)        X = X##1;#define PRINT(X)         printf(#X " = %d; ", X);int main() {    REGS_FOREACH(DEFINE); // 展开: static int X, X1;    while (1) { // clock        RUN_LOGIC; // 展开: X1 = !X &amp;&amp; Y;        REGS_FOREACH(PRINT); // 展开: printf("X" "=%d;" X)        REGS_FOREACH(UPDATE); // 展开: X = X1;        putchar('\n'); sleep(1);    }    return 1;}</code></pre><p>示例代码:</p><ul><li><a href="/code/logisim.c">logisim.c</a></li><li><a href="/code/seven-seg.py">seven-seg.py</a></li></ul><h3 id="C程序的状态机">C程序的状态机</h3><ul><li>状态 = stack frame + 全局变量</li><li>初始状态 = main(argv, argv)</li><li>转移 = 执行pc处指令，pc++</li></ul><p>就是这么简单！结合上面的代码更容易理解。</p><h3 id="模拟一个C程序的函数调用">模拟一个C程序的函数调用</h3><ul><li><a href="/code/hanoi-r.c">hanoi-r.c</a></li><li><a href="/code/hanoi-nr.c">hanoi-nr.c</a></li></ul><h3 id="二进制程序的状态机">二进制程序的状态机</h3><ul><li>状态 = M(内存) + R(寄存器), 所有能存储数据的东西</li><li>初始状态 = ？</li><li>转移 = 执行pc处指令</li></ul><h3 id="程序-计算-syscall">程序 = 计算 + syscall</h3><p>最基础的main函数都是通过syscall系统调用实现的<br>假设没有syscall，你甚至都不能让程序返回or停止！</p><p>如下是一个最简单的没有syscall的C程序</p><pre><code class="language-c">// main.cvoid _start() {}</code></pre><p>可以通过<code>gcc -c main.c &amp;&amp; objdump -d main.o &amp;&amp; ld main.o</code>的方式编译链接它<br>但当执行<code>a.out</code>时，得到<code>Segmentation fault</code></p><p>尝试用gdb去调试这个程序，得到汇编如下：</p><pre><code class="language-as">0x401000 &lt;_start&gt;       push   %rbp0x401001 &lt;_start+1&gt;     mov    %rsp,%rbp0x401004 &lt;_start+4&gt;     nop0x401005 &lt;_start+5&gt;     pop    %rbp0x401006 &lt;_start+6&gt;     ret</code></pre><p>下面将打印每步执行后的寄存器和堆栈的值：</p><table><thead><tr><th style="text-align:left">汇编</th><th style="text-align:center">rsp</th><th style="text-align:center">rip</th><th style="text-align:center">栈顶</th></tr></thead><tbody><tr><td style="text-align:left">初始</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0x0001, 0x0000</td></tr><tr><td style="text-align:left">push %rbp</td><td style="text-align:center">- 8</td><td style="text-align:center"></td><td style="text-align:center">0x0000, 0x0001</td></tr><tr><td style="text-align:left">mov  %rsp,%rbp</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pop  %rbp</td><td style="text-align:center">+ 8</td><td style="text-align:center">0x0</td><td style="text-align:center">0x0001, 0x0000</td></tr><tr><td style="text-align:left">ret</td><td style="text-align:center">+ 8</td><td style="text-align:center">0x1</td><td style="text-align:center">0x0000, 0x0000</td></tr></tbody></table><p>最后执行ret时，rip的值是0x1，这意味着要取0x1地址上的指令去执行<br>但是0x1的内存是无法访问的！<br>因此报错 segmentation fault</p><hr><p>课程资料: NJU-OS2022 jyy</p><ul><li><a href="http://jyywiki.cn/OS/2022/slides/2.slides">ppt: 操作系统上的程序</a></li><li><a href="https://www.bilibili.com/video/BV12L4y1379V/?spm_id_from=333.880.my_history.page.click&amp;vd_source=db26a19e4b4372574c8ebde86f9333bd">b站: 南京大学2022操作系统-P2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Slidev】基于Markdown的Web-PPT</title>
      <link href="/posts/2CQGWAY/"/>
      <url>/posts/2CQGWAY/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">NOTE</p><ul><li><a href="https://sli.dev/">slidev官网</a></li><li><a href="https://stackblitz.com/edit/slidev-nrxvdx?file=slides.md">slidev在线编辑器</a></li><li><a href="https://demo.sli.dev/starter/1">slidev demo</a></li></ul><p><code>slidev</code>是一款基于markdown语法，基于vite/vue3搭建的开源powerpoint工具，它的最大优势是可以部署在任何网站上，以实现快速、轻便访问目的</p></div><h3 id="使用">使用</h3><div class="admonition warning"><p class="admonition-title">WARNING</p><p>下面这部分看官网文档...</p></div><ul><li><p><code>npm install @slidev/cli @slidev/theme-default</code></p></li><li><p><code>npm init slidev</code>: 初始化一个slidev工程</p></li><li><p><code>slidev build</code>: 项目默认发布到<code>./dist</code>目录</p></li><li><p><code>slidev</code>: 默认以<code>localhost:3030</code>的域名进行预览</p></li></ul><h2 id="演讲者模式">演讲者模式</h2><p>使用<code>http://localhost:3030/presenter</code><br>可以查看注释，并且能同步操作另一处ppt的显示<br>todo：此功能无法用于发布场景</p><h2 id="VSCode快速开发">VSCode快速开发</h2><p>插件：<a href="https://marketplace.visualstudio.com/items?itemName=antfu.slidev"><strong>antfu.slidev</strong></a></p><p><img src="/images/slidev-dev.png" alt=""></p><h2 id="如何编写自己的theme">如何编写自己的theme?</h2><p>所有主题开发遵循npm包规范，且存放在<code>./node-modules</code><br>通过md中<code>theme: default</code>来指定选择的主题</p><p>为了适应公司内分享的ppt需求，特维护了一个slidev theme:<br><a href="https://github.com/593413198/slidev-theme-beautiful"><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> slidev-theme-beautiful</a></p><h3 id="如何部署到服务器">如何部署到服务器?</h3><p><code>slidev build</code>会在当前<code>./dist</code>下生成所有的依赖资源，<code>./dist/index</code>即为访问的ppt主页</p><ul><li>需要将<code>./dist</code>拷贝到对应服务器下，就能通过浏览器在线访问</li><li><code>slidev build --base './'</code> 防止以下的路径使用绝对路径</li></ul><pre><code class="language-html">  &lt;script type="module" crossorigin src="/root/hexo-workspace/source/assets/index-aaad8f94.js"&gt;&lt;/script&gt;  &lt;link rel="stylesheet" href="/root/hexo-workspace/source/assets/index-43f0699a.css"&gt;</code></pre><h2 id="编写规范">编写规范</h2><h4 id="全局配置">全局配置</h4><p>相关配置可以阅读源码：<a href="https://github.com/slidevjs/slidev/blob/main/packages/types/src/config.ts">💡 config.ts</a></p><p>官方推荐的主题：<a href="https://cn.sli.dev/themes/gallery.html">themes 合集</a></p><pre><code class="language-python">theme: seriph # ppt主题background: https://source.unsplash.com/collection/94734566/1920x1080 # ppt背景图class: text-center # 字体对齐方式highlighter: shiki # 代码高亮格式lineNumbers: false # 是否显示行号drawings:  persist: falsetransition: slide-left # ppt跳转方式</code></pre><h4 id="矢量Icons">矢量Icons</h4><p>借助 <a href="https://pictogrammers.com/"><strong>pictogrammers</strong></a> 实现ICONS自由:<br>先在官网查到icon名称, 如<code>unity</code>, 然后在md中插入:<br><code>&lt;mdi-unity/&gt;</code></p><h4 id="transition-跳转">transition 跳转</h4><ul><li><code>fade, fade-out</code> - 淡出</li><li><code>slide-left, slide-right</code> - 左右移出</li><li><code>slide-up, slide-down</code> - 上下移出</li></ul><h4 id="class-对齐方式">class 对齐方式</h4><ul><li><code>text-center</code>: 居中对齐, 一般用于首页</li></ul><h4 id="代码">代码</h4><pre><code class="language-c">// ```ts {2-3}// 表示从2-3行高亮// ```ts {2-3|4-5|all}// 每次显示不同的高亮, 2-3 -&gt; 4-5 -&gt; 全部// ```ts {monaco}// 可以运行编辑器</code></pre><h3 id="主题示例">主题示例</h3><ul><li>一个具备图片轮播的主题<br>github: <a href="https://github.com/godkun/ppt-template">https://github.com/godkun/ppt-template</a><br>示例: <a href="https://ppt.godkun.top/#/4">https://ppt.godkun.top/#/4</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Apache】搭建文件服务器</title>
      <link href="/posts/5S5T02/"/>
      <url>/posts/5S5T02/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><ul><li>文件服务器: <a href="http://110.42.228.178/">http://110.42.228.178/</a></li><li>旧服务器地址即将到期（2023.6.24），已经迁移完毕</li></ul></div><h2 id="apache2-介绍">apache2 介绍</h2><p><a href="https://httpd.apache.org/"><strong>Apache2</strong></a> 又称为 httpd，它是一款开源的网页文件服务器，由于其安全性和可靠的跨平台性，被广泛使用。</p><ul><li>安装：<code>apt-get install apache2</code></li><li>启动服务：<code>systemctl start apache2</code></li><li>停止服务：<code>systemctl stop apache2</code></li><li>重启服务：<code>systemctl restart apache2</code></li></ul><p>Apache2 配置:</p><ul><li>配置文件：<code>/etc/apache2/apache2.conf</code></li><li>字体配置：<code>/etc/apache2/conf-enabled/charset.conf</code></li></ul><p>文件服务器的根目录（默认）：<strong><code>/var/www/html</code></strong></p><div class="admonition warning"><p class="admonition-title">默认显示</p><ul><li>Apache默认展示的网页是 <code>index.html</code>，需要将其删除。</li><li>之后添加文件就能在服务器上看到</li></ul></div><h2 id="内容规划">内容规划</h2><p>该文件服务器主要用于存储一些文件，以方便在不同机器随时访问、以及起到备份的作用。<br>大概分为如下几类：</p><ul><li>pdf：一些书籍、资料、ppt等</li><li>tools：一些工具的安装包（支持正版）</li><li>…</li></ul><h2 id="疑难">疑难</h2><h3 id="软链目录">软链目录</h3><p><code>/var/www/html</code> 目录藏得太深，我们希望软链一个外层的目录，这样更容易修改和获取它：</p><ul><li>先删除 <code>html</code> 目录：<code>rm -rf /var/www/html</code></li><li>新建一个软链 到 <code>~/apache</code>：<code>ln -s ~/apache .</code></li><li>改回默认的 html 名称：<code>mv /var/www/apache /var/www/html</code></li></ul><p>如果此时文件服务器仍无法访问，这是因为需要为root加权限：<br><code>chmod +x ~/apache</code></p><h3 id="加密">加密</h3><ul><li><p>为用户 <code>luhao</code> 创建一个密码，写在passwd中，后续会提示你输入密码的<br><code>htpasswd -c /etc/httpd/passwd luhao</code></p></li><li><p>接着在<code>/etc/apache2/apache2.conf</code>中维护你要加密码的路径：</p></li></ul><pre><code class="language-json">&lt;Directory "/var/www/html/to_lock"&gt;  AllowOverride all  authuserfile "/etc/httpd/passwd"  authname "luhao"  authtype basic  require user luhao &lt;/Directory&gt;</code></pre><h3 id="中文乱码">中文乱码</h3><p>todo，这个还没解决，文件名显示正常，文件内是乱码</p><h3 id="美化">美化</h3><p>默认的apache网页风格实在太丑，推荐如下一个GUI框架：</p><p><a href="https://github.com/fuchcz/simple-apache-directory-listing-theme">Github: simple-apache-directory-listing-theme</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【日志】2023年3月</title>
      <link href="/posts/2023/3/"/>
      <url>/posts/2023/3/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7461458ba6481fa5d6eb6156451374f1dc676560f939f3920d8f93c82ca5ae15">b3dc07a81f6459d120ce338ccca55046116de9af7135eccfa9c61a82756948fc2a685033db839f342fbe3644f374a32778c751268c2722fcafa2a8f38511b56b78650e2cce932aa4eec25b1ef8bafcbfabf65bccd0fd450c8916126348c073c8da6394e16dabb4b5f1d7d49bcb675c654780966c4fc5f7ccbab6211ca668430e1ce67aee0ad4ef92fccefd194f2db6a6c81f7f130b9319631be3985720bf86b43a699748bf0896a9723e84f1f705e194b36b64e5a798155d83cb93a3433d15b33d9b3110bb38a7ad6c993db506d0a32ca10552f04fbadcce3fc8d2741850632243eaab632965c432e22f7c1a4916290b50a01b46b61cafac5873b9130a52daa3356fa546e113bc5f4a89970b1534b3bf425a14a9015e051ade2835d72d57a3c10c4031ee129fe4b3489fb22cadf33f65f40c8deb3db456ca911940431d3176302c5043f2c0c1c3c70902bdf9748e24df71fcd9accee6accfe9fc323ac423a4bf290452d768408e68dc140a28665e7b7b74bb5f6c1c5d9a94bfb53e01810866d8e7d27640b9e5bc86bd4308d7eae057e70df0faea1bfb25113f2f78404e67dc1ff1c8e44e2d757951b0e3382f7bc9307bcce71e3ea6fa2bad92ce1f239c3d2d5d355972490e0ce67f5fe4f548369ee756a347196266e8d56dc5e128e05b59fd1d843bcd1e045a2fa4e6abbccfa88f586e305b6690f9315dd4f74ad3f6ff7ae4bcf3a2a03d18700a396d40b38a513cce6afffc5ccd4c38bbd4428780fa06ac7397d0650450abf305ed91b8acc6a111c881148cb17adc2772b9dadfb3f4e791afcf88ee948f0d55c5b91056fb5e9ef19837518e97ddf8981c2c3c37eede0446a40875d509bdb1ed0f26b051903129e874d14514d8e18d64421a20e786db32e205ce9338fa88869960ba2512b515fd395b2cfc1f72ccfe768f532307de62863f496d6190b19815699cfaacf0a9d3eee9e28c396a9e5bd7991cb5a71e3d5efc250cf32aa19c82e6ae5c850a4d94c6570301a8b9e2186c620a808912da319f8496b2d6acc6418c9d79d8d008a2209c901fd19f3fb927d7e07c6696c9bd55d1196de36ad8a4db4cfee2acc33b85c3b53ca20725db7b0c358f3927dac7e75d5f48e82e6116eb3425b3bf284ea9fb60ffc43b171995ff8139551d93cc1cf2d1b3c98f166219644c699cc22662e766a0ecdaa42ec956e1f48debc0b48526dcf6db5ddc025931f1317a8c522f6d45017e36bfdadc5183e3467c960f3db80dc70f10b6dc3667c6c7ed0b2a3e03f0c4d3300edb5c2024cf66c90391338c0d7321fe73d17386583e31bca4a838aca381358604062e5fb26f8123550a1125a61a979c253a3a317efa22726b43142073eeae5126432f1dc4b3f5193415e691beb32b071305a7dc5d93562dd908997364813849976d8e7ca46801a870d90b9711cb065109b00f6c6d6fe4379f735f8d0904a786a187c247249b72e367d822fcfc97e17c0e3fb853fd8478bb404ab1a6a62414fa644ff1a661298473cfcc51ee729e1a5fc989c0f4a354442efc89cfc492643c6e5cbbc234404a7d5673bd0a7cda0617ceb9772189ed5658f025b7a781d3504d2aba758a5c29e7d5f473f0588e46c6a903bb068a384e6fc153e3d2163ac443f4066a913a8dd8c32daa088d0668abfec75b242d90dde0b97bb2a3a6683ed25c8aa695b551957baf638c5f7c682e1e2d2e51a48312789d7fbc64ae2e42323bc6899cd8bbbe0dca54dd4244e37797133a90836284e1e2ae547e316c0c0b333eee20d837f8d5abf3f7440e96ebde8219f2b34322284f9593dd2e5b22f1db74a103ae4f9e70f08b1ad1f64a1a448df8c768bc9867ba06e6dee4db18282ff447d08f4a38867145645beda234be1b4edcf6af90f5226d67ef8eb9b53eb197334634f3e0ae02ef4c97bd0965c173c1d6dfcd5955e9a027f279b86c5e36485620537877c5b33c1c917c13045c903943243034aa3bd744ecd9a726726e90b1c776fc0e5f2a4e412ceff0eed662ae057f02d584641d4ec931b4f28bbf2b809e0902259665cfe71258ba80f77a4d54907f5aa1723b07c3bbb9e5c5b968f587da18c9eb0ff58fe448165776bb1747c0ce1750f09ba3a355a1c54acec5ab3f70a351ffdafbc816b50a23596bc6a9fe8bd3b928c055d2c7e0d49cf8336deb86a35586345f68b0fd0c2cc71c85c57f64d5f11bca6db134fd68891977e79f8131d707d2bc210493bce0a5ef30818d388cae4953616b06bd2aeb06c8c4770588582eb488d9a6e51c7e85291f969f7fc45ba87bb73d7d0b0797453d4ba718efab30f408e7081f37c8f26f28e3feb4addabd050aa26922f7f747b0ef5a2a188c3cf5e16c9a7b725157e98e2e74d552924f8dfe6226f1d2f9b38ce9c4e7acf86a160a29f326be89b36f8c082dc517b0e0a5bf9202481b5d2ce14ec14da4b48a2b12681eafd363491bbc06e3ff9e25f01c828446ccc6633afa6f89fe2e474cc53777a0a9a65ead9217169824923b8b5e2bf73fa7da63516b542f84a996524c9f213399dc3254001c01df1d1729c7f451c1ad8558d1913f2c035e6a28a2870a502e09b6fa92181cce3f8b437bc993fb9998d35a4d1142282552c1f215a60e74ea9833be1ab34e4736ed6e6d9af67e2021890500e32dcefc4610b33cf8f2ede76bca09ca8a3b3779b78082da4f384b80b149a018bc11f3ccacb2de14a366d4e9bced5054d534f2fd774eb9df5ca2380af77f545b67d64fd8afc1e7db4b4a2130784cc1958c4f5795943f1fa21c3c0c555f1f17fdcbf71a185fa1bddb229dca738900661cf9df76842e428b74f45f47c707c4a3935f67f017f13deea1c8125da3e5b6692a6e9dc4dd72697c572f471e983e0e0d911bba75fdab2aa00e86286b3852798bb7f1ed9021531488913da4c4eb633e08722fe7a8c5cd3bdab3c7e38e21156453ed0d41452d2bfc10964e62c39e7defdd50598d7c77c53a3560710c6061440cf38d301cd89d5dcf21cdf441b59d68f75cbd3c30277b4dc2b91043d5c776599cb07f7eb1f379215ce40326a0173b2b59935d7e9bbae5e97232f255e4a280ae367995e76e91b9f0aac2cfe31f190844d13c745229a66d3073da7143ce33c0f3019c8bb0e3af209a817e0d619aa679cd358d16f39a2e4eaeb66ab66062b0ac1691cd275da2bfa11abb471c28d984f581c02c156dae243fa4aa6b09d53e7b13c4521fa7d0a9f914ad3995147b0ae239535dbe4e94caf2dc9cf2bd4a9aac6db36caaece65d695b3f55cae60505865de06be7cf43984e3eae0855afced8a1eba18fecc206e0589ffb3f8e25d43f9fb67f3336bfc39ce9b686b800d18299c0506c4aa414a3b89312f0b30d2539b698053e00ccedb7b4923836a7afcb87b7efb88f80e5362c8fbd75f4e0a6cbaf6e8840ed27d002be7ab3fc06084efaed7cb430ecfae1b2079d20c6432d21efb2d2d208c8317f66ae0f9c3d0f08bfd4680eb1b2135272d633dbf61873f0f84f2577ebdfbb5242dae268776174e570ce541bb8815fdca426085849cffe76d8c33357c3ecf47ad5079fbc7b125f8e6da5cf4eea0677a4f6369d7cd9d9d9b799401746751a55f72cd3d507f56e5520e8e1136df016c94faaca7c8b6e469a183aa2807818701dca2654deeb39f9363a6066abc89f06f075fce3fb3d25df744af1000edd5c02ed3f3516043b1afb71422b086fdc9a7de284270c9e28d525dfbc455b318bb6f2f4525573bf1e30d05cfb313d1886e5614bed6ca0139906900e0014553d3ab215b5bf13c089a0840354752ba3b963f5cbb8c95cb7aadb49e399b4f816aeb3a55d292f077046671c683bab21a0235bfc242a33acc5bad603ce94895d6e31d61f99fcad5143fd469d20b4bb30b8a7dea62bb64b9bb6bb51bb15c54989e60cf8f3b96a27111d08b24cd47f9e0f4068d46c506393001144c6e7487cc36d990e380c1e5de790b45a3d1bbcddf3d61be5fcece5dfea14765e4eac5d796d4fa376ab448337f909f7f7c3061a83a885d2dc11d5308f5ac2f5bd0cdd8f2cf2d92814d53c2ee8324969e60399dd6d39b79a9cc93f4b1cc1131bebc9302d83010b850e3da81a9e43e9dd13e22e944eb033c7abed65778b2634945078cdbc8137aa43b3049cbc3945f2521d750451982b1e22bc4f9990ce90541e22625b2cc8e7e647c6cc84ea9699f81a6d208f8b64d4d6ac2a6b68ead48706711a4cf40ea6fc0061a9eb58ed092fe703aee6e83df638138e02fe06d1e0b2cf4167aa65a5fc96dfb585a885bae094098dc7b92d7509290c46f27c75f7d7f2f75a819e312627e1ff38839ddc1d1fb97e308eedc335719dc55fa2f340d5ceed0e48f42d3cde44ed38e347063aa79d789817a59eb768bbd75abc9ed721bc8e2c7c3987582078da920cd82fee57f8cff1ed250aceba336a413aeefe0e3c9b71294b2346bdfd0932f69a95923364e9dcdbbe26633132736936364c72b30a229810ef6483a3b8621768b6e2d138452945fb57227772d10a6e7f363de532a25f01bd8b4eab5bc963a8ebd2816aadf83bd8f33e662183292bc9bead5b0a8bf42feac4df957defba50380c957243ee48598e7d13f7c2d4ef71a2cd4e223808493857a7ebcc5eb10a26baf09c306d0e3697e02048bf76330ad34adb464f5956ccd2bcf562a6c09664b467394b2066e4910e3e2fbcb4f1ab7b1c50223ef90acac5a881c6a7b76605b5724af032503cb4ed3e56ad28072afd7495ae9983e2c97bca6127cb767bf7f86d1944445cbc0074051811570c8cd386a68d154a1eed49ab8b1705677964bfc5c0d9ab10e0f27cf484a7cde722febda3f0b0e38d003e26311c294313ad5cccd64babfaf6184d43c19e75ac9c72ce9d49b3c47a199347e73cea06f0e639eac0a6e09f98b7686d07424883572561be7908960ac01593e8a59f3fb5916b343e9d76467c628fd0f6f3895a78e7b8ab9581a8a1c92b61a466f83d18442f91fc07f7ea2294b0be16cbc527ea4f90120cc50d791f28be374babf1e7729884a22f18690fe92509ad8aaf944a8eca19aa674892906dc1cb8ae41e4cbf1055e94840e71eb2f5992298d45bd32d78aefcb678221f1f5542176f8d76949bed21c8b2ebb2e0139128155dc96e5bb99b828416d8470cf8ab79b87ef5c162640c9e0b1c971b4b4d4383a46dbdfe3838b9d719480c37f696c1eb9c08c586dad326190c2708a3686503762ee5ca613006efc6a33eb57482f8339ce3ffd0596634943d8e3269243a806b48ec3eac7d3ef2f11c97a968c3feb9e634021edbff6a09d55748af4845fec96618e3fd4bc2c1ba4ce14399c14796addd1c9d820e714ad16d5d32597de20838d3b354d19269fb6ea586ea1bdb43e8f727867e87b5d7cf60d7dc74221721420d3c65931d292514b5157c2e63a570133ae2ba1b6cb6677c709c6be3650998fb49be85adadd0ef5fa5e1dfffbbb82ef83c316f576553c28b4322f30469dd41fd811354da276ca78715fe414ad38eda1cd86cc300338f014e6dcfb164bd1754e17e12c507466041af96384c770c77dc7b6d46a22e42b9f06df9a10c4e9459fe0533cd7d5dddf1bf2614e448a5d23139c74461fe72f14a98bb487dd57f73f29eb0c5e521a1ea44c09dfc5c23f12c871b2fc04b6da9b80e8ed13e3901539fc891fafa1eab0f5746dd69f6313bb288ea4eec3fdb95a5db7f9fef7247508c2fd8d7ae5abd80a6b3731abc4b05e3d9d19525eb9339c1c33336b640030caf8c28722814c67b104c6a6a0b05067e2fb6fd1976e1eb68c08caba75f9a24cf1d5c84e3cb82656e6a84ce09a0542605558b765bdf54e6a4aaae4414118ded3718b61ea492f0fbb664ad96af9563dd6a8abac5611a069f6beda5a27ef31545844adbd66b1f493c30dba3ce9f4e1175bc41a2828e9fd27277be5a3d37014bd41bdbd6fc7ade9be91e02f6b4e2680880301a03537cd7c74e0f6123c03131a2eb8de0ca0bf457f9c1ecf737b66af42998cd9d4f9f587bae317638057ef1870315be2f298a99837ccf9285e5597d69cf52e904143cb16bbb0630892f0e84ffda1a8a39dbd7abedd72d562df3085b6c5161371dd3244faae7df584fb9bf7147de739c8b96e47e939c414b5fda9cbcaf3692f4eae861d9c89747eca88fa46fb99acd4e1319c6e62f393fc680137b76fb436813ccea42ba185cb4bcbe5f99cf270bc99bff20ab5ccf4b3c6b709e78f2f04be946a798c54a8ab8b9d475c85e2ed4c1afdcbce2374ddc9e155f853fffe0bd1e1fdd01f6ec5e2925e12f3278dafd4550e4f179c5551278fc66d84682b2720f1aa26f01f012360e384068978df7a64fc96f3e4f8b1b81d59f1e4e63aae604b5069055d66cd2c9ad5fa8185f2587a2a4a38784c5fd161f25a12dc58fec2600d5d3342c2b6fe308c99672705c9e4281af62df2b4a4281bc87503a561835fd8fdf20b80ad2bbe9204da3f6faffdd4f3dff95cc113ff3bad3eb1e86f88f817770823c8b632ab918f5952f4300f10117d34808213c8238fb6edf0ae93eeefae112006d990c1bf9d2eccc81054b5c8694729bb3ca3d3bcc5e52cd6edae35efa9a177be42657b637d0d3bc3de23fd983a60f05e5e41ba212112cb7ca484ac1c54c58d915348c691c81c40290bd6c881ba8ed438a5375b0510361cb5a2ba8ba4ec1233873a669a89fb8b67daffb4ec2fa2e053afeca94bd2017f76c8ea5728e6158ee1db25bbbd7d317a20ee8fe87e635cb53783bd82f5bbec4465f002017688ed9a9b5fd051b366fdef1eebcd2eeedd5820d8339adff87bc1c5ad4b29e2d90bc9f4907dcdcb653e4b60d9737d560a76962f1fad2b834fb0dd90663e49ddafa0b1e7a495429aac7597f72bdef2c1d30b15f0325df918c1779cdb370dd62cd4b8a15b2a2394a28fd9b2d8efa79b6905e7ec2896d02a56d4e502657be8ac434d84f01cc336dcdb2ba3a2776738a16f48feba21a39cc17c84dd5ddc533874a9fa2fb510e18c6468a055b2593967d89dc13da1a20acabb6f31cd62f68aa1a2271b7f082ff23e93bf2cd217d6d14a6b80694055c06808c1556355c615339d5a67d5068e042adfaef0395869fa3ed245447fc0a31205bea8026a53317490227a2a8ed5036b5931171832de1c52e65157ddffbb4d5df57de2afebb453f9606f97845544c7de33807812afcf1395ec510665a70a8075d8ddd75e21b37816bb4478a3c3270c7d73448efac43a599f6178a64fe3265673aff3a380c6102c0620ab4a43957d8041064bb67ed7303b28fbf8d24c1970666be1adca34d11f1660444f881053d037a9019b9f476da48186ba02f2bcbcf770256245a85bdb1e048d4a3aa4c7fbf284b315a2add757ca00e5e60dff1d530e3edcdacacb9ef9c36910d87640417723fcfba8c1138c7713291a22348646ed2dfce33365f8385dcfc812607857e74ba833d5bfdebb91108dcb686be47ae038a5fd6f294f8f895c8f9e41f21edf91af6ad189d9d0a26e82e71ea88e0ade2d42803e27fe43ce1e39183f7b585b11428b7a5604512bb394be9f63ca91189c902d33cac5f06c8853ae61381d9cb05f00dfd78944e12f8d09195ff9061970c6f4e445a5b00ec6984ab7c6e62b497ff4cfb1bbd465f0998b8d24368ae00c06fa9ec60f6e0f6e3477222642fd7f78c1774cae7cad8df11069503d36ec2499bce4a0e6578cece39f176c39056701c21fb8b57107a234ac5e092096ed789fdd4cd65f6ce4a54e9fb31fad6862120f5fd6535c48404c25650105ec77f26eb1b9e21463c33181dfde995eb031aa3e229922f14d8c3637f78fda88db3640b50a5348aaf049489193067c53980bdcdf9cb88422f38c30532a8a2f3c5a0ed89fe7a0ed564623fbd0029452eae39e026aa6822214e93bebb90da7d18b497f8b89088a19a6235d86518a21b0a778b42581da018cf50eeb938d826c0bb65f5a147e64074611d5abbdac03f1221ddc6dbb2221ece9634a710224dbdaad01abee03db0797414b9de51f2240a293587fb01062e117a47b37fdfca68eb31ae778cc581b6554b8add2e43d20be9276a8cde78a6d81259952d5e9b03ef46f10f9f771fc2fe398af8f3b207fa0d1dfa0219de21db908af468becf9f2eb5c191669f51c547f6025f7c5d0a94b121bfa39cdba02aec49a6624d3dc40a00b374d713f654fdc1ff9f48784b077872459445fc89770c98bf070a8bf824e35875f672f5e75e83df8246bc0461136644f10e25c6c472187e1ef2e915231fe72f1b0668b09f8a585c2531328e1dcffc2dd5617b579b7e3622b1f36966589a9f5e6367eaa46425d8ddd050</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编（四）：gdb调试</title>
      <link href="/posts/3DJGDAE/"/>
      <url>/posts/3DJGDAE/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://www.sourceware.org/gdb/">GDB: The GNU Project Debugger</a></li><li><a href="https://jyywiki.cn/pages/OS/manuals/gdb-cheat-sheet.pdf">gdb cheat sheet</a></li><li><a href="https://gcc.godbolt.org/">godbolt</a> (C/C++, python等在线转汇编)</li><li><a href="https://www.onlinegdb.com/">online gdb</a> (在线gdb调试)</li></ul><h2 id="godbolt">godbolt</h2><p>推荐这个网站 <a href="https://gcc.godbolt.org">https://gcc.godbolt.org</a>，在线写 <code>C/C++/Python</code> 等代码，并查看整理后的汇编码，非常清晰。</p><p><img src="/images/godbolt.png" alt=""></p><h2 id="Todo">Todo</h2>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编（三）：基础AT&amp;T汇编</title>
      <link href="/posts/1QNHHCN/"/>
      <url>/posts/1QNHHCN/</url>
      
        <content type="html"><![CDATA[<p><em>Read the Fucking Manul</em></p><ul><li><a href="https://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html">x86 Assembly Guide</a></li><li><a href="https://faculty.nps.edu/cseagle/assembly/sys_call.html">Linux System Call Table</a></li><li><a href="https://godbolt.org/">godbolt</a> (C/C++, python等在线转汇编)</li></ul><h2 id="AT-T与intel汇编风格">AT&amp;T与intel汇编风格</h2><ul><li>汇编的编写，离不开寄存器和基础指令，前置知识需要阅读 <a href="https://luhao.wiki/posts/14G1VW3/"><span class="github-emoji"><span>👉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>汇编（二）：基础寄存器</a></li><li>汇编分为<code>AT&amp;T</code>与<code>Intel</code>风格：<a href="https://www.cs.mcgill.ca/~cs573/winter2001/AttLinux_syntax.htm#:~:text=Notable%20differences%20between%20the%20two,Intel%20register%20operands%20are%20undelimited.">Intel vs. AT&amp;T syntax</a></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">Intel</th><th style="text-align:left">AT&amp;T</th></tr></thead><tbody><tr><td style="text-align:center">注释</td><td style="text-align:left">;</td><td style="text-align:left">// #</td></tr><tr><td style="text-align:center">指令</td><td style="text-align:left">mov</td><td style="text-align:left"><code>movb是byte, movw是word, movl是long</code></td></tr><tr><td style="text-align:center">寄存器</td><td style="text-align:left">eax</td><td style="text-align:left">%eax</td></tr><tr><td style="text-align:center">立即数</td><td style="text-align:left">0x12</td><td style="text-align:left">$0x12</td></tr><tr><td style="text-align:center">汇编</td><td style="text-align:left"><code>mov eax, 0x12</code></td><td style="text-align:left"><code>mov $0x12, %eax</code> 移动0x12到eax寄存器</td></tr><tr><td style="text-align:center">编译器</td><td style="text-align:left"><em>windows masm</em></td><td style="text-align:left"><em>unix as</em></td></tr></tbody></table><h2 id="AT-T汇编示例">AT&amp;T汇编示例</h2><p>各个字段的含义，请继续阅读后文</p><pre><code class="language-x86asm">.data   # 定义数据段        t1: .int 0x1230 # 定义int型的t1, t2变量        t2: .int 0x4.text   # 定义代码段.globl _start   # 定义_start函数入口    _start:        mov t1, %eax  # eax: 0x1230        mov t2, %ebx  # ebx: 0x4        add %eax, %ebx # ebx: 0x1234        # 0x80系统调用sys_exit, 退出程序        mov $0x1, %eax        int $0x80</code></pre><h2 id="编译与链接">编译与链接</h2><ul><li>利用汇编器将<code>.s</code>转化为目标文件<code>.o</code><br><code>as hello.s -o hello.o</code></li><li>利用链接器将<code>.o</code>链接为可执行文件<code>hello</code><br><code>ld hello.o -o hello</code></li><li>为什么需要一个链接的步骤?<ul><li><a href="https://www.cnblogs.com/immortal-worm/p/5819036.html">链接器（linker）的作用</a></li></ul></li></ul><h3 id="内存划分-section">内存划分 .section</h3><p><code>.section</code> <strong>将代码划分若干个段</strong>，程序执行时，每个段会被加载到不同的内存地址</p><table><thead><tr><th style="text-align:left">.section</th><th style="text-align:center">含义</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:left"><code>.data</code></td><td style="text-align:center">数据段</td><td style="text-align:center">存放已初始化的全局、静态变量</td></tr><tr><td style="text-align:left"><code>.bss</code></td><td style="text-align:center">数据段</td><td style="text-align:center">存放未初始化的全局、静态变量</td></tr><tr><td style="text-align:left"><code>.text</code></td><td style="text-align:center">代码段</td><td style="text-align:center">存放只读的代码</td></tr><tr><td style="text-align:left"><code>.heap</code></td><td style="text-align:center">堆</td><td style="text-align:center">动态分配的内存</td></tr><tr><td style="text-align:left"><code>.stack</code></td><td style="text-align:center">栈</td><td style="text-align:center">函数局部变量等</td></tr></tbody></table><ul><li>内存划分如图所示：<br>其中除了堆和栈是动态分配的，其他都是静态预先分配的内存</li></ul><p><img src="/images/section.png" alt=""></p><ul><li>调用<code>size [target]</code>查看各个段的内存大小</li></ul><pre><code class="language-python"># 示例见上面的汇编代码size hellotext data  bss dec hexfilename23     8      0     31     1f    out"""text: 代码段大小data, bss: 全局/静态变量大小dec: 总结大小 (hex是十六进制)"""</code></pre><ul><li>统计代码段的内存大小</li></ul><pre><code class="language-x86asm">0x401000&lt;+0&gt;: 0xb8 0x34 0x12 0x00 0x00 ---&gt; mov $0x1234, %eax0x401000&lt;+5&gt;: 0xb0 0x12 0x00           ---&gt; movb $0x1, %el0x401000&lt;+7&gt;: ..."""mov和movb都是操作符, 占1个字节, 分别是0xb8与0xb0因为mov的操作数是16位，因此占2个字节，而movb占1个字节eax和el寄存器也是，分别占2个和1个字节"""</code></pre><ul><li>Linux上可以查看所有虚拟内存的分配：<u class="black"><code>/proc/[pid]/maps</code></u><br>可以通过 <code>man proc</code> 阅读linux文档。<br>观察到：内存 <code>heap</code> 位于低地址，而 <code>stack</code> 位于高地址，没有 <code>pathname</code> 的一般是通过 <code>mmap</code> 分配的匿名内存<br>而读写属性有如下几种：<br>r = read<br>w = write<br>x = execute<br>s = shared<br>p = private (copy on write)</li></ul><pre><code>address                   perms offset  dev   inode                 pathname561155768000-5611557b5000 r--p 00000000 fe:01 410132                /usr/bin/python2.75611557b5000-56115594a000 r-xp 0004d000 fe:01 410132                /usr/bin/python2.7561155ad9000-561155afc000 rw-p 00000000 00:00 0561156b9f000-561156c7d000 rw-p 00000000 00:00 0                     [heap]7f7265abe000-7f7265da5000 r--p 00000000 fe:01 393252                /usr/lib/locale/locale-archive7f7265da5000-7f7265f1b000 rw-p 00000000 00:00 07f7265f1b000-7f7265f3d000 r--p 00000000 fe:01 431545                /usr/lib/x86_64-linux-gnu/libc-2.31.so7f7266278000-7f7266279000 rw-p 0001c000 fe:01 442692                /usr/lib/x86_64-linux-gnu/libpthread-2.31.so7f7266279000-7f726627f000 rw-p 00000000 00:00 07f72662b2000-7f72662b3000 rw-p 0002a000 fe:01 431541                /usr/lib/x86_64-linux-gnu/ld-2.31.so7f72662b3000-7f72662b4000 rw-p 00000000 00:00 07ffd4c51b000-7ffd4c53c000 rw-p 00000000 00:00 0                     [stack]7ffd4c59e000-7ffd4c5a2000 r--p 00000000 00:00 0                     [vvar]7ffd4c5a2000-7ffd4c5a4000 r-xp 00000000 00:00 0                     [vdso]</code></pre><h3 id="数据类型">数据类型</h3><ul><li>文本字符: <code>.ascii</code></li><li>整型: <code>.byte(8位)</code> <code>.short(16位)</code> <code>.int(32位)</code></li><li>浮点: <code>.float</code> <code>.double</code></li><li>指令后缀同时代表精度:<ul><li><code>b, w, l, q</code>: 分别代表8，16，32，64位</li></ul></li></ul><h3 id="start函数">_start函数</h3><ul><li>就像C++的main函数一样，_start是整个汇编程序的入口，你必须显示的定义它</li><li>且需要通过<code>.globl _start</code>，来告诉链接器如何查找_start的符号地址</li></ul><h3 id="系统调用">系统调用</h3><ul><li>Unix下通过<code>int $0x80</code>进行系统调用，其中参数存在<code>%eax</code>等寄存器中：<ul><li><em>查阅对照表:</em> <a href="https://faculty.nps.edu/cseagle/assembly/sys_call.html">Linux System Call Table</a></li></ul></li></ul><table><thead><tr><th style="text-align:center">%eax</th><th style="text-align:center">名称</th><th style="text-align:center">%ebx</th><th style="text-align:center">%ecx</th><th style="text-align:center">％edx</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center"><font color="#ef6d3b"><strong>sys_exit</strong></font></td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center"><font color="#ef6d3b"><strong>sys_fork</strong></font></td><td style="text-align:center">struct pt_regs</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center"><font color="#ef6d3b"><strong>sys_read</strong></font></td><td style="text-align:center">usigned int</td><td style="text-align:center">char *</td><td style="text-align:center">size_t</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center"><font color="#ef6d3b"><strong>sys_write</strong></font></td><td style="text-align:center">usigned int</td><td style="text-align:center">const char*</td><td style="text-align:center">size_t</td></tr></tbody></table><h3 id="star-TODO"><span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> TODO</h3><ul><li>push/pop 栈相关</li><li>loop 循环</li><li>系统调用不够细</li><li><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2022/">PA实验</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编（二）：基础寄存器</title>
      <link href="/posts/14G1VW3/"/>
      <url>/posts/14G1VW3/</url>
      
        <content type="html"><![CDATA[<p><em>约定如下原则：</em></p><ul><li>ax与AX都代表同一寄存器，不区分大小写</li><li>0xAA、0xaa、AAH都代表十六进制的写法</li><li>本文汇编基于<a href="https://www.cs.mcgill.ca/~cs573/winter2001/AttLinux_syntax.htm#:~:text=Notable%20differences%20between%20the%20two,Intel%20register%20operands%20are%20undelimited.">Intel vs. AT&amp;T syntax</a></li></ul><h2 id="什么是寄存器">什么是寄存器?</h2><ul><li>寄存器是cpu中负责数据存储的电子器件</li><li>它的<strong>传输速度最快</strong>，大于l1、l2 cache，远大于RAM和磁盘</li><li>一个16位的寄存器，可以存储2字节的数据，最大可表示0~65536范围的数据</li><li>寄存器一般用约定俗成的命名，来区分其具体用途</li></ul><h2 id="通用寄存器">通用寄存器</h2><ul><li>存储<font color="#ef6d3b"><strong>一般性数据</strong></font>的寄存器，如<code>AX, BX, CX, DX</code>…</li></ul><table><thead><tr><th style="text-align:center">汇编</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>mov ax, 18</code></td><td style="text-align:center">将18写入寄存器ax</td></tr><tr><td style="text-align:center"><code>mov ax, bx</code></td><td style="text-align:center">将bx的数据写入ax</td></tr><tr><td style="text-align:center"><code>add ax, bx</code></td><td style="text-align:center">将ax,bx的值相加，并写入ax</td></tr><tr><td style="text-align:center"><code>sub ax, bx</code></td><td style="text-align:center">将ax,bx的值相减，并写入ax</td></tr></tbody></table><ul><li>寄存器数据溢出时，会自动舍弃最高位，例如：<ul><li>8位寄存器：ax(0xff), bx(0x01)</li><li>执行<code>add ax, bx</code>后, ax中的值为 0x00</li></ul></li></ul><h2 id="段寄存器">段寄存器</h2><ul><li><p>根据 <a href="https://luhao.wiki/posts/3AJJP5S/">《汇编（一）：计算机架构入门》</a>：物理地址 = 段地址 * 16 + 偏移地址</p></li><li><p>因此，<strong><code>CS</code>存储代码段的段地址，<code>EIP</code>存储代码段的偏移地址!</strong></p><ul><li>代码执行地址为：(CS) * 16 + (EIP)，且每次执行一行后，EIP会根据指令长度偏移若干字节</li><li>计算机每次运行，会根据如上计算出的物理地址，取出对应的指令去运行</li></ul></li><li><p>详解下图过程：</p><ul><li>1.取出<code>CS</code>,<code>EIP</code>的值，并放入地址加法器，得到结果是<code>0x20000</code></li><li>2.将物理地址<code>0x20000</code>送上地址总线</li><li>3.读取到该处指令为<code>mov ax, 0123H</code>，并送入数据总线</li><li>4.CPU ALU获取到该指令，将其执行（涉及<code>AX, BX</code>的读写）</li></ul></li></ul><p><img src="/images/register01.png" alt=""></p><ul><li><p><strong><code>DS</code>存储要访问数据的段地址</strong></p><ul><li>当我们要将<code>al</code>中的数据写入<code>0x1000</code>的内存时：</li><li><code>mov bx, 0x1000</code></li><li><code>mov ds, bx</code>: 将bx值写入到ds，注意，不支持直接往ds寄存器写数据!</li><li><code>mov [0], al</code>: [0]代表读取以ds为段地址，以0为偏移的内存地址上的值</li></ul></li><li><p><font color="#ef6d3b"><strong><code>[ax]</code></strong></font>的特殊用法<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> :<br>表示以寄存器ax上的值，为偏移地址（段地址在<code>ds</code>中），此时去对应物理地址寻值</p></li></ul><h2 id="栈寄存器">栈寄存器</h2><ul><li><p>什么栈（stack）？<br>后进先出的操作规则：<code>LIFO(Last in First out)</code>，就像往枪膛里填子弹</p></li><li><p>程序在运行时，会将一段连续的内存空间划分为栈，这里的操作原则符合<code>LIFO</code></p></li><li><p><strong><code>SS</code>存放栈顶的地址，<code>SP</code>存放栈的偏移地址</strong></p></li></ul><table><thead><tr><th style="text-align:center">汇编</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>push ax</code></td><td style="text-align:center">将ax值写入栈顶，即写到<code>SS+SP</code>，并将SP位置下移</td></tr><tr><td style="text-align:center"><code>pop ax</code></td><td style="text-align:center">将栈顶值写入ax，并将SP位置上移</td></tr></tbody></table><p><img src="/images/stack01.png" alt=""></p><ul><li>什么是<code>Stack Overflow?</code><br>因为程序中的系统调用，都是用堆栈实现的，但默认分配的大小为固定的；<br>当你写如下一个Python无限递归时，就会因堆栈溢出而导致<code>RuntimeError</code>而程序退出</li></ul><pre><code class="language-python">def f(n):    return f(n-1)f(100)# RuntimeError: maximum recursion depth exceeded</code></pre><h2 id="内联汇编">内联汇编</h2><div class="admonition error"><p class="admonition-title">TODO</p><ul><li>关于 <strong>内联汇编（inline asm）</strong> 可以单独开一篇学习之</li><li><a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC-Inline-Assembly-HOWTO</a></li><li><a href="https://akaedu.github.io/book/ch19s05.html">C内联汇编</a></li></ul></div><p>写汇编经常遇到 <strong><code>movq %0, %%rsp</code></strong> 的写法，其中的 <code>%0</code> 是什么含义?</p><p>它一般用于 C++内联汇编：</p><pre><code class="language-c++">int a=10, b;asm ("movl %1, %%eax;      movl %%eax, %0;"     : "=r"(b)        /* output */     : "r"(a)         /* input */     : "%eax"         /* clobbered register */    );       </code></pre><ul><li><code>"=r"(b)</code> 表示把 <code>%0</code> 寄存器的值输出给 变量b</li><li><code>"r"(a)"</code> 表示分配一个寄存器 <code>%1</code> 保存变量a 的值</li></ul><p>因此这段代码的作用是：将a赋值给b</p><p><strong>进阶示例:</strong></p><p>下面这段代码，能够切换到指定的堆栈（sp），并执行对应的函数调用（entry arg）</p><pre><code class="language-c++">static inline void stack_switch_call(void *sp, void *entry, uintptr_t arg) {  asm volatile (#if __x86_64__    "movq %0, %%rsp; movq %2, %%rdi; jmp *%1"      : : "b"((uintptr_t)sp), "d"(entry), "a"(arg) : "memory"#else    "movl %0, %%esp; movl %2, 4(%0); jmp *%1"      : : "b"((uintptr_t)sp - 8), "d"(entry), "a"(arg) : "memory"#endif  );}</code></pre><p><strong>输出修饰符:</strong></p><ul><li>a: 使用 eax/ax/al 寄存器；</li><li>b: 使用 ebx/bx/bl 寄存器；</li><li>c: 使用 ecx/cx/cl 寄存器；</li><li>d: 使用 edx/dx/dl 寄存器；</li><li>r: 使用任何可用的通用寄存器；m: 使用变量的内存位置；</li></ul><p>这段代码一共使用了3个寄存器：</p><ul><li><code>"b"((uintptr_t)sp)</code>: 使用 ebx 寄存器（%0）保存 sp 的值;</li><li><code>"d"(entry)</code>: 使用 edx 寄存器（%1） 保存 entry 的值;</li><li><code>"a"(arg)</code>: 使用 eax 寄存器（%2） 保存 arg 的值;</li></ul><p>此时再去理解汇编代码，其作用是：</p><ul><li><code>movq %0, %%rsp</code>: 将 sp 的值传递给 rsp寄存器（函数堆栈）;</li><li><code>movq %2, %%rdi</code>: 将 args 的值传递给 rdi寄存器（传递参数）;</li><li><code>jmp *%1"</code>: 跳转去执行 entry 函数;</li></ul><h2 id="对照表">对照表</h2><table><thead><tr><th style="text-align:right">寄存器</th><th style="text-align:right">作用</th><th style="text-align:center">英文</th></tr></thead><tbody><tr><td style="text-align:right"><code>AX</code>, <code>BX</code>, <code>CX</code></td><td style="text-align:right">通用寄存器</td><td style="text-align:center">Register</td></tr><tr><td style="text-align:right"><code>CS</code></td><td style="text-align:right">（代码段）段寄存器</td><td style="text-align:center">Code-Segment</td></tr><tr><td style="text-align:right"><code>(E)IP</code></td><td style="text-align:right">（代码段偏移）寄存器</td><td style="text-align:center">(Extend)Instruction-Pointer</td></tr><tr><td style="text-align:right"><code>DS</code></td><td style="text-align:right">（数据段）段寄存器</td><td style="text-align:center">Data-Segment</td></tr><tr><td style="text-align:right"><code>SS</code></td><td style="text-align:right">（栈顶）段寄存器</td><td style="text-align:center">Stack-Segment</td></tr><tr><td style="text-align:right"><code>SP</code></td><td style="text-align:right">（栈顶偏移）段寄存器</td><td style="text-align:center">Stack-Segment</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编（一）：计算机架构入门</title>
      <link href="/posts/3RBTN4W/"/>
      <url>/posts/3RBTN4W/</url>
      
        <content type="html"><![CDATA[<p><em>介绍CPU、寄存器、物理内存、寻址等硬件架构与概念</em><span id="more"></span></p><h3 id="架构图">架构图</h3><p>这张架构图清晰的解释了计算机各个硬件之间的关系与作用<br>第一次看不懂，先理解下面各个器件的作用<br>箭头连线代表电信号的传输，从计算机角度就是数据的传输<br><img src="/images/arch01.png" alt=""></p><h3 id="存储器">存储器</h3><p>存储器是存放计算机数据的器件，根据读写属性分为两类：</p><ul><li><p><font color="#ef6d3b"><strong>ROM（Read-Only-Memory）</strong></font><br>只读，一般是显卡、网卡上的默认系统，如<code>BIOS</code></p></li><li><p><font color="#ef6d3b"><strong>RAM（Random-Access-Memory）</strong></font><br>可读可写，显卡上的RAM又成为显存</p></li></ul><h3 id="数据总线-Data-bus">数据总线 Data-bus</h3><ul><li>数据总线是为CPU与存储器<code>提供数据传输</code>的</li><li>1根数据总线（宽度为1），一次能传送1位（2bit）的二进制数据</li><li>数据总线的宽度，决定CPU与外界传输数据的速度</li></ul><h3 id="地址总线-Address-bus">地址总线 Address-bus</h3><ul><li>读写操作时，CPU通过地址总线来<code>指定存储单元</code>的位置</li><li>宽度为10的地址总线，<font color="#ef6d3b"><strong>寻址能力</strong></font>为<code>2^10</code>个内存单元</li></ul><h3 id="控制总线-Control-bus">控制总线 Control-bus</h3><ul><li>代表CPU对计算机器件的控制能力</li><li>如有一根“读线”控制发送内存读取的信号，有一根“写线”控制写信号</li></ul><h3 id="CPU">CPU</h3><ul><li><font color="#ef6d3b"><strong>寄存器</strong></font>负责存<ul><li>对于一个16位寄存器，能存储的最大数值是<code>2^16</code></li></ul></li><li><font color="#ef6d3b"><strong>逻辑算数单元（ALU）</strong></font>负责算</li><li><font color="#ef6d3b"><strong>控制器</strong></font>负责控制各个器件 ?</li><li>CPU也有自己的内部总线, 同上</li><li>主频用来衡量CPU的执行性能，如<code>2.0GHz</code>的CPU，每个时钟周期是<code>0.5ns</code></li><li>可以通过时钟周期衡量各个器件的传输效率</li></ul><table><thead><tr><th style="text-align:center">器件</th><th style="text-align:center">消耗cpu时钟周期 (&lt;<em>1ns</em>)</th></tr></thead><tbody><tr><td style="text-align:center">Register</td><td style="text-align:center">0.5</td></tr><tr><td style="text-align:center">L1 cache</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">L2 cache</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">L3 cache</td><td style="text-align:center">45</td></tr><tr><td style="text-align:center">RAM内存</td><td style="text-align:center">300</td></tr><tr><td style="text-align:center">SSD固态盘</td><td style="text-align:center">300000</td></tr><tr><td style="text-align:center">HDD机械盘</td><td style="text-align:center">&gt;&gt;SSD</td></tr></tbody></table><div class="admonition note"><p class="admonition-title">延伸阅读: 为什么 SRAM 读写速度更快?</p><ul><li><a href="https://rf.eefocus.com/article/id-336795">存储技术SRAM详解</a></li></ul></div><h3 id="物理地址">物理地址</h3><ul><li>计算机的内存单元是一个线性的地址<ul><li>假设总内存大小1M的计算机，<code>(1M=2^20=16^5)</code>，可以理解为<code>[0x0, 0xFFFFF]</code>这样的一维数组</li></ul></li><li>当内存较大，但地址总线较小时，通常采用寻址的方式：<ul><li><code>物理地址 = 段地址 x 16 + 偏移地址</code></li><li>因此通常将<code>内存分段</code>, 但物理意义上内存是连续的</li><li>《汇编语言》(王爽第三版)P23，列举了一个学校、图书馆位置的例子，很好解释了寻址的思想</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
          <category> 汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【C++】编码规范</title>
      <link href="/posts/WTFJWR/"/>
      <url>/posts/WTFJWR/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://www.kernel.org/doc/html/v6.0/process/coding-style.html">Linux kernel coding style</a></li><li><a href="https://bot-man-jl.github.io/articles/?post=2020/Conventional-Cpp#references"><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 聊聊 C++ 的优雅写法</a></li></ul><h3 id="Names-and-Order-of-Includes"><a href="https://google.github.io/styleguide/cppguide.html#Names_and_Order_of_Includes">Names and Order of Includes</a></h3><p>当一个<code>cpp</code>存在非常多的 <code>include</code> 时，请合理地对其进行排序。这个编码规范在很多语言都值得引起注意，如 <code>python</code>、<code>JS/TS</code>。</p><p>顺序逻辑如下，不同模块间请用一行空格隔开：</p><ul><li><code>self</code> header</li><li><code>C</code> header</li><li><code>C++</code> header</li><li>libraries</li><li>project</li></ul><h3 id="Preincrement-and-Predecrement"><a href="https://google.github.io/styleguide/cppguide.html#Preincrement_and_Predecrement">Preincrement and Predecrement</a></h3><p>使用 <code>++i/--i</code> 代替 <code>i++/i--</code>，因为后者会产生一个临时变量的开销。</p><hr><hr><h2 id="分割线">分割线</h2><hr><h3 id="1-缩进">1. 缩进</h3><ul><li><p>Linux指定缩进为 8 个空格</p><ul><li><a href="https://peps.python.org/pep-0008/">python pep8</a> 使用 4 空格缩进 ✔</li><li>一些 C/C++ 开源框架式用 2 空格缩进: <a href="https://github.com/google/leveldb">leveldb</a></li></ul></li><li><p>当缩进层数较多（n&gt;=3），应该考虑代码的设计问题！👍</p></li></ul><h3 id="2-单行长度">2. 单行长度</h3><ul><li>限制在80字符内，利用<code>\</code>换行 （可以借助VSCode提示监督）</li></ul><h3 id="3-大括号">3. 大括号 {}</h3><ul><li>对于函数定义，大括号单独换行</li></ul><pre><code class="language-c">int function(int x){    return x;}</code></pre><h3 id="4-空格">4. 空格</h3><ul><li>对于二元、三元运算符，左右都留空</li></ul><pre><code class="language-c">int a = b + c;</code></pre><ul><li>对于一元运算符，右侧不留空</li></ul><pre><code class="language-c">s = sizeof(struct file);</code></pre><h3 id="5-命名">5. 命名</h3><ul><li>全局变量，使用详细的命名<ul><li><code>g_info</code> ❌</li><li><code>g_send_msg_info</code> ✔</li></ul></li><li>局部变量，力求短小精悍<ul><li><code>is_decoration_always_open</code> ❌</li><li><code>is_open</code> ✔</li></ul></li><li>避免种族歧视的命名 ⚠<ul><li><code>master -&gt; primary</code></li><li><code>blacklist -&gt; denylist</code></li></ul></li></ul><h3 id="6-函数规范">6. 函数规范</h3><ul><li>声明函数原型时，需要包含变量名（尽管编译器允许只写变量类型）</li></ul><pre><code class="language-c">__init void * __must_check action(enum magic value, size_t size, u8 count,                                  char *fmt, ...) __printf(4, 5) __malloc;</code></pre><ul><li><code>.h</code>的函数声明包含默认参数的，<code>.cpp</code>中使用注释注明</li></ul><pre><code class="language-c">// a.hvoid action(size_t a, size_t b = 10);// a.cppvoid action(size_t a, size_t b /* = 10 */) {    // todo}</code></pre><h3 id="7-注释">7. 注释</h3><ul><li><strong>注释是解释<code>What</code>，而不是解释<code>How</code></strong><ul><li>What -&gt; 注释</li><li>How -&gt; 文档、Readme</li></ul></li><li>多行注释的格式如下：</li></ul><pre><code class="language-c">/* * This is the preferred style for multi-line * comments in the Linux kernel source code. * Please use it consistently. * * Description:  A column of asterisks on the left side, * with beginning and ending almost-blank lines. */</code></pre><h3 id="8-宏定义">8. 宏定义</h3><ul><li>常量的宏定义，应该大写</li><li>宏定义 如果使用操作符，务必使用括号扩起</li></ul><pre><code class="language-c">#define CONSTANT 0x4000#define CONSTEXP (CONSTANT | 3)</code></pre><ul><li>函数的宏定义，应该小写</li><li><s>跨行函数，应该使用<code>do-while</code> ❓</s></li></ul><pre><code class="language-c">#define macrofun(a, b, c)                       \        do {                                    \                if (a == 5)                     \                        do_this(b, c);          \        } while (0)</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Forward Lighting的技术优化</title>
      <link href="/posts/2KDTR1T/"/>
      <url>/posts/2KDTR1T/</url>
      
        <content type="html"><![CDATA[<p><em>Foward管线下实时光照计算的若干优化技术</em><span id="more"></span></p><div class="markmap-container" style="height:300px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;<a href=\&quot;#复杂度分析\&quot;>复杂度分析</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;Forward Lighting：<code>O(mesh*light)</code>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Deferred Lighting：<code>O(light)</code>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;1. 硬件MRT&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;2. 半透明渲染 ×&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;3. MSAA ×&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;4. 带宽瓶颈&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<a href=\&quot;#1-降低Mesh\&quot;>优化：减Mesh</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Vertex Lighting&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Pre-Z&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;<a href=\&quot;#2-降低光源数\&quot;>优化：减光源</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Tiled-Based Lighting&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Clustered Lighting&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;Cone &amp;amp; AABB Intersect ⭐&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;球谐SH&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="复杂度分析">复杂度分析</h2><p>谈优化前，先分析一波复杂度</p><ul><li><font color="#ef6d3b"><strong>Forward Lighting</strong></font><br>遍历场景所有的mesh和光源分别计算光照,<br>复杂度是<code>O(mesh*light)</code></li></ul><pre><code class="language-c">for mesh in scene  for light in scene    color += Calc(mesh, light)</code></pre><p>当场景的光源数量上升时，GPU计算开销会骤增，显然吃不消；<br>题外话，为什么Deferred管线下，能驾驭多光源的实时计算呢?</p><ul><li><font color="#ef6d3b"><strong>Deferred Lighting</strong></font><br>在包含SceneColor, SceneNormal的GBuffer上进行光照计算,<br>复杂度是<code>O(light)</code></li></ul><pre><code class="language-c">for light in scene  color += Calc(Gbuffer, light)</code></pre><p>而Deferred管线的弊端，网上很多没说清，因此提一嘴：</p><ul><li><p><strong>硬件不支持MRT</strong><br>不用考虑，根据<a href="http://blog.kurokoz.com/reports/2020-china-mobile-game-quality-white-paper">2020年移动端白皮书</a>，gles 3.0下的占有率已接近0，海外市场具体问题具体分析</p></li><li><p><strong>不支持透明渲染</strong><br>代价低的方案是，在Deferred结束后，新开一个ForwardPass去渲染透明物体，缺点是透明物没有光照</p></li><li><p><strong>不支持MSAA</strong><br>一方面是对GBuffer做AA无意义，另一方面Multi-Sample会使带宽问题雪上加霜</p></li><li><p><strong>带宽瓶颈</strong><br>移动端硬伤, 标准的GBuffer4最低就是128-bits的带宽</p></li></ul><h2 id="优化方向">优化方向</h2><p>对于Forward lighting<br>已知：复杂度是<code>O(mesh*light)</code><br>问：如何优化?<br><strong>答：要么降低Mesh数量（也可理解为Gemotry数量）, 要么减少计算光源数量</strong></p><h3 id="1-降低Mesh">1. 降低Mesh</h3><ul><li><font color="#ef6d3b"><strong>Vertex Lighting</strong></font></li></ul><p>正常的光照计算是在pixel shader, 但如果在顶点做光照计算, 复杂度就很可控<br>但是画面表现很差, 推荐在低画质使用</p><ul><li><font color="#ef6d3b"><strong>Pre-Z</strong></font><br>因为Pixel-Shader是在Depth-Test阶段前进行；<br>那么某个Mesh即便经过光照计算，最终也未必呈现在屏幕上，所造成的算力浪费，就是OverDraw问题；<br>Pre-Z可以在Pixel之前拿到DepthBuffer，就能只对通过深度测试的点做计算:</li></ul><pre><code class="language-c">for mesh in scene  if (DepthPass(mesh.depth))    for light in scene      color += Calc(mesh, light)</code></pre><h3 id="2-降低光源数">2. 降低光源数</h3><p>如何优化光源数量?<br>一方面，光源较多时，适当阉割几盏，对整体光照效果影响不大；<br>另一方面，光源范围都是有限的，适当做一点剔除，也能起优化作用；</p><ul><li><font color="#ef6d3b"><strong>Overlap</strong></font></li></ul><p><img src="/images/unity_lighting.png" alt=""></p><p>如上图，一个像素接受了8盏光源的影响，增加计算量的同时，最后呈现的效果又不明显。<br>不妨先根据距离、强度等信息对光源排序，对应A~H 8盏：</p><ul><li>方案一：只计算前几盏光源；</li><li><strong>方案二：根据贡献度混合计算，如：</strong><ul><li>近（ABC）用Pixel-Lighting</li><li>中（DEF）用Vertex-Lighting</li><li>远（GH）用球谐光照</li></ul></li></ul><p>此时复杂度就下降为<code>O(k*mesh)</code>, 且丢失的光照细节很有限</p><ul><li><font color="#ef6d3b"><strong>Tiled Based Lighting</strong></font></li></ul><p><img src="/images/tiled_lighting.png" alt=""></p><ul><li><font color="#ef6d3b"><strong>Clustered Based Lighting</strong></font></li></ul><p><img src="/images/clustered_lighting.png" alt=""></p><p>对于每个像素, 当我们无脑遍历每个光源时, 思考一个问题:<br><strong>光源的影响范围真有这么大吗?</strong><br>Tiled的主要思想, 就是把屏幕划分多个区域, 记录每个tiles能影响的光源id, shader阶段只用计算受他们影响的光源<br>Clustered是Tiled的三维划分版本, 将视锥空间沿xyz划分成 <strong>24*8*16</strong> 个cluster<br>接下来cpu负责计算，对于每个cluster影响到的光源id和分布, gpu负责计算剔除后的light shading</p><ul><li>根据光源类型如下，需要做如下相交测试:</li></ul><table><thead><tr><th style="text-align:center">Light</th><th style="text-align:center">Intersection</th></tr></thead><tbody><tr><td style="text-align:center">AreaLight</td><td style="text-align:center">AABB &amp; AABB求交</td></tr><tr><td style="text-align:center">PointLight</td><td style="text-align:center">AABB &amp; 球求交</td></tr><tr><td style="text-align:center">SpotLight <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align:center"><strong>AABB &amp; 圆锥求交</strong></td></tr></tbody></table><ul><li><p>严谨的相交检测，在物理引擎中使用较多，可以尝试学习：</p><ul><li><a href="https://github.com/phenomLi/Blog/issues/23"><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Separating Axis Theorem (分离轴定律)</a></li><li><a href="https://www.realtimerendering.com/intersections.html"><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> Realtime Rendering: Static Object Intersections</a></li></ul></li><li><p><font color="#ef6d3b"><strong>圆锥&amp;AABB求交优化</strong></font>:</p></li></ul><p>在做Spotlight的视锥剔除时，传统方案是, 用圆锥的AABB包围盒，或者是包围球，与和视锥的AABB求交。<br>这样就转化为AABB&amp;AABB 或 AABB&amp;球体 的求交问题，相对比较简单，但从剔除率堪忧，因为圆锥占其包围盒的体积比很小，不足三分之一，这里就是我们的优化点<br><strong>我们改成用圆锥与视锥的包围球相交，方案如下：</strong><br>首先圆锥由2个部分组成：侧面、底面，若两者都未与球相交，则说明无相交：</p><ul><li>底面相交:<br>只需计算锥顶到球心的投影（如图红线），范围在<code>(-r, r+h)</code>之间，则判定相交；</li><li>侧面相交:<br>只需计算球到圆锥侧面的最短距离（高中数学题3D版），若小于半径r，则判定相交；</li></ul><p><img src="/images/cone_test_sphere.png" alt=""></p><!-- * 优化后，视锥剔除率对比如下，效果一目了然<iframe  class="embed-responsive-item" srcdoc="<!DOCTYPE html><html> <head><script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.9.0/p5.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.9.0/addons/p5.dom.min.js></script> <meta charset=utf-8> <style>html, body {margin: 0; padding: 0;}canvas { display: block; } </style> </head> <body><script src=/html/Cone_vs_Frustum.js></script></body></html>"width=830 height=410></iframe><iframe  class="embed-responsive-item" srcdoc="<!DOCTYPE html><html> <head><script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.9.0/p5.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.9.0/addons/p5.dom.min.js></script> <meta charset=utf-8> <style>html, body {margin: 0; padding: 0;}canvas { display: block; } </style> </head> <body><script src=/html/Cone_vs_Sphere.js></script></body></html>"width=830 height=410></iframe> --><ul><li>光源信息的建表和查表<br>首先需要一个32位int存储如下信息，以及一张光源信息表</li></ul><pre><code class="language-c">struct ClusterDataDesc{    uint16_t light_idx; // 对应去查light信息表    uint8_t pointlight_count;    uint8_t spotlight_count;}</code></pre><p>查表过程比较繁琐，原理不细讲了，对着下图去看代码会更清楚：<br>原理看这里： <a href="https://km.netease.com/wiki/1072/page/375174">NeoX Wiki: Clustered Shading</a></p><p><img src="/images/light_indices.png" alt=""></p><h3 id="3-球谐SH">3. 球谐SH</h3><p>这篇KM写得很清楚，就不再赘述</p><ul><li><a href="https://km.netease.com/article/363605">基于球谐的动态点光优化方案</a></li></ul><h3 id="引用">引用</h3><ul><li><a href="https://km.netease.com/wiki/1072/page/375174">NeoX Wiki: Clustered Shading</a> (NeoX Clustered实现方案)</li><li><a href="https://www.adriancourreges.com/blog/2016/09/09/doom-2016-graphics-study/">DOOM(2016)- Graphics Study</a> (DOOM Clustered实现方案)</li><li><a href="http://www.humus.name/Articles/PracticalClusteredShading.pdf">Practical Clustered Shading by Emil Persson</a> (正当防卫引擎的Clustered实现方案)</li><li><a href="http://www.aortiz.me/2018/12/21/CG.html">A Primer On Efficient Rendering Algorithms &amp; Clustered Shading</a><br>(好文, 系统且详细地讲解了大部分lighting方案及优化)</li><li><a href="https://www.realtimerendering.com/intersections.html">RealtimeRendering: Static Object Intersections</a><br>(realtimerednering文档，含游戏中常用几何体求交的算法及数学证明)</li><li><a href="https://simoncoenen.com/blog/programming/graphics/SpotlightCulling">Optimizing spotlight intersection in tiled/clustered light culling</a><br>(利用AABB的包围球，近似的算AABB&amp;Cone求交)</li><li><a href="https://bartwronski.com/2017/04/13/cull-that-cone/">Cull that cone! Improved cone/spotlight visibility tests for tiled and clustered lighting</a><br>(同利用AABB的包围球，近似的算AABB&amp;Cone求交)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graphics </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Echarts可视化库</title>
      <link href="/posts/M53XVE/"/>
      <url>/posts/M53XVE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://pyecharts.org/#/zh-cn/intro"><strong>pyecharts</strong></a><br><a href="https://echarts.apache.org/examples/zh/index.html"><strong>Apache Echarts</strong></a><br><a href="https://github.com/593413198/shawshank/blob/main/src/ChartManager.py"><strong>shawshank/ChartManager.py</strong></a></p><p><em>写这个目的是不是搬运代码和图片，而是封装一个便于自己常用的绘制库.</em></p><h2 id="echarts简介">echarts简介</h2><p>echarts是百度开源的一款图表绘制库，包括且不限于折线图、柱状图、蜡烛图及3D图表<br>pyecharts是移植于python的三方库</p><ul><li><p>安装方式:<br><code>pip install pyecharts</code></p></li><li><p><strong>应用重点</strong>:</p><ul><li>性能分析数据: 如帧率折线图、flamegraph火焰图</li><li>量化金融数据：如K线图</li><li>装B应用：地图、词云等</li></ul></li></ul><h2 id="代码示例">代码示例</h2><h3 id="0-基础代码">0. 基础代码</h3><ul><li>写法一：python风格</li></ul><pre><code class="language-python">from pyecharts.charts import Barbar = Bar()bar.add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])bar.add_yaxis("商家A", [5, 20, 36, 10, 75, 90])bar.render() # 默认是./render.html</code></pre><ul><li>写法二：链式调用 （推荐<span class="github-emoji"><span>👍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）</li></ul><pre><code class="language-python">from pyecharts.charts import Bar(    Bar()    .add_xaxis(["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"])    .add_yaxis("商家A", [5, 20, 36, 10, 75, 90])    .render() # 默认是./render.html)</code></pre><ul><li>Fake库：生存随机数据，方便测试</li></ul><pre><code class="language-python">from pyecharts.faker import FakerFaker.choose() # 生成x-axisFaker.values() # 生成y-axis</code></pre><ul><li><code>is_smooth</code>: 曲线平滑</li><li><code>is_symbol_show</code>: 显示数据详情</li></ul><h3 id="1-Line-折线图">1. Line-折线图</h3><ul><li>按年度生成<code>600519贵州茅台</code>的日线价格走势:</li></ul><pre><code class="language-python">timeline = Timeline()df = G.dm.parse(file_name)code = file_name.split('/')[-1]if split_year:    min_year, max_year = df.index[0], df.index[-1]    for year in range(min_year.year, max_year.year + 1):        _df = df[str(year) : str(year)]        line = (            Line()            .add_xaxis(list(map(lambda x: x.date(), _df.index)))            .add_yaxis(f'{code} {year}', _df.close.to_list(), is_smooth=True)            .set_global_opts(                # NOTE: y轴分割线                yaxis_opts=opts.AxisOpts(                    splitline_opts=opts.SplitLineOpts(is_show=True),                    split_number=10                )            )        )        timeline.add(line, str(year))timeline.render()</code></pre><!-- <iframesrc="/html/line_stock.html"height=550width=100%frameborder=0scrolling=yes></iframe> --><h3 id="2-Kline-K线图">2. Kline-K线图</h3><ul><li>按年度生成<code>600519贵州茅台</code>的日K线:</li></ul><pre><code class="language-python">timeline = Timeline(init_opts=opts.InitOpts('1500px', '500px'))df = G.dm.parse(file_name)code = file_name.split('/')[-1]if split_year:    min_year, max_year = df.index[0], df.index[-1]    for year in range(min_year.year, max_year.year + 1):        _df = df[str(year) : str(year)]        oclh = _df[['open', 'close', 'low', 'high']].values.tolist()        kline = (            Kline()            .add_xaxis(list(map(lambda x: x.date(), _df.index)))            # open, close, low, high            .add_yaxis(f'{year}年度', oclh)            .set_global_opts(                xaxis_opts=opts.AxisOpts(is_scale=True),                yaxis_opts=opts.AxisOpts(                    is_scale=True,                    splitarea_opts=opts.SplitAreaOpts(                        is_show=True, areastyle_opts=opts.AreaStyleOpts(opacity=1)                    ),                ),                datazoom_opts=[opts.DataZoomOpts(pos_bottom="-2%")],                title_opts=opts.TitleOpts(title="贵州茅台 600519 日线"),            )        )        timeline.add(kline, str(year))timeline.render()</code></pre><!-- <iframesrc="/html/kline_stock.html"height=550width=100%frameborder=0scrolling=yes></iframe> --><h2 id="TODO">TODO</h2><ul><li>搞懂opts每个配置项对应的图表含义</li><li>MarkAreaOpts: 标记区域</li><li>增加按钮, 在页面打开html</li><li>flamegraph火焰图</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Crontab定时任务</title>
      <link href="/posts/15G1D76/"/>
      <url>/posts/15G1D76/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">资料</p><ul><li><a href="https://www.runoob.com/linux/linux-comm-crontab.html"><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 菜鸟教程crontab</a></li><li><a href="https://tool.lu/crontab/">在线验证 crontab</a></li></ul></div><h2 id="技术背景">技术背景</h2><ul><li>服务器经常定时执行任务（如每日9点开盘），自己维护定时器又容易出Bug，还得做日志模块…</li><li><font color="#1A9BFF"><em><strong>Windows Server</strong></em></font> 推荐 <font color="#1A9BFF"><em>Windows定时任务</em></font>（有GUI和命令行）</li><li><font color="#1A9BFF"><em><strong>Linux</strong></em></font> 推荐 <font color="#1A9BFF"><em><strong>Crontab</strong></em></font>（纯命令行）</li></ul><h2 id="crontab">crontab</h2><ul><li>基本使用</li></ul><ol><li><code>crontab -e</code>: 编辑配置</li><li><code>service cron restart</code>: 重启cron服务</li><li><code>service cron reload</code>: 重新载入cron配置, 修改配置后需要reload</li></ol><ul><li>定时语法</li></ul><pre><code class="language-python"># Part 1:*    *    *    *    *   task-    -    -    -    -|    |    |    |    ||    |    |    |    +----- 星期 (0 - 6) (周日为0)|    |    |    +---------- 月份 (1 - 12) |    |    +--------------- 日期 (1 - 31)|    +-------------------- 小时 (0 - 23)+------------------------- 分钟 (0 - 59)# Part 2:*/5: 代表每5分钟1-5: 代表第1-5分钟都执行</code></pre><ul><li><p>如果不需要任何输出:<br><code>xxx.bat &gt; /dev/null 2&gt;&amp;1</code></p></li><li><p>附上服务器上的crontab量化相关配置</p></li></ul><p><img src="/images/crontab.png" alt=""></p><h2 id="Q-A">Q&amp;A</h2><h3 id="crontab没有日志">crontab没有日志</h3><ol><li><code>/etc/rsyslog.conf</code>: 取消crontab的log注释</li><li><code>service rsyslog restart</code>: 重启syslog</li><li><code>/var/log/cron.log</code>: 接着就可以看crontab的log!</li></ol><h3 id="没有-service-指令">没有 <code>service</code> 指令</h3><p>使用 <code>/etc/init.d/cron reload</code> 等代替</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022年总结（写在除夕夜）</title>
      <link href="/posts/19KZ887/"/>
      <url>/posts/19KZ887/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="10d08a99131d07e3b6b8dd1cfeb11e77ceace130b9f58907c0936b47a7741852">b3dc07a81f6459d120ce338ccca5504661c2b6d199f8abfa2402c5b16901e347024de2c78f361d0ef47e1cde1303c3a8822026a64881b4638ef155338ea76cb1ccbcc2fbbf742a4f3070a7d9b42e431dcbe95d92f1417cbb887e9e54af2d88a5a74520860d80486fcb86fc73e942bf7941a9773e852aedb8200286cb2ab906047f86456675c6bde6c0093bea5239620ad245c2a7ec1b9400de4c95235d9104a6ddc0446748fb69b6a1aa305dfbef999715b3b1ac87d1bab79af8437885d4c9b329e8c8a813b335cdf221b6b663d6c00890b0744d6e159f8a7068da64977cbde3d4d1401637450aa42464b2e281778f55feae741b3c097361af34421b519372dd5a8b7746dc61ea4b32c7f4bea23222785afd438726ff91feb0ef36aba4254fb27b9a63d01ad7e6ea981f479f9e6ec4451625982918852962ef58ed53f9330592f7bf685f81e01f04d76b06e9ddf6926adf50fdcd88aa613666e097f169cf84a95604ad4f25f68b2a116a41f0df70c3befcc81e646b095525205bf86a72b2eb303219e01bb38c361effc1b5cb8afb26e83363549511f6734cb3383abeffd5dcff07f4b6ccf93eb452106d17843bf1f914ce7905f5413eda38f5f2836fa58f194557a356afab190ed393e8b724dbd498f495b8ba5f7c98ad748b1175b35233c91593d4c3f61ad88b9a035d039f9ed1a5c9efea66d4d25da3f152b3ca6da335eddb4e20ab7e226dc390a458a291698af63b9a13755af75ea9cca27893a5aa82591bea44c53d0d154c97c839f627d1b4432801bec0d7d5c0e2337f72e3213e4824321f75f08d64bca7980c9ebe4c06e3c187bb1966858cad410f2089ca030eb0a3a03a87d5d64279eb1f200554e8eac027aa72b1dfb4c6538d3a4dff03ebef5b7a3acf547b6c58849716a5d9f296fc941c5cfe5158c93e7397007a7ac07c2021ef1648594a0caebbf35b5c98147e8353bbaab8eb98bc042e36e4ba143abc072d2f5dad3b6fa06e0909a3ae70da5472a6916588ce97990a6ba87e09cb4cad834b91f3ec0913bb00ebf96561c2c1393939ebbee8bf840ce33d1785f44e1f762e1eae1e58322b80766a61f53cf8b7f854c7a2938c58ee846ce6744fc3038e01a86ae9c43b83683087ab08a73b30a79c8bb7abdd06ba8c558771a3c3455b6c8a6e00ae579d52cacaabc7d9e55cdc7c4c4b756f7d6ebb29faa160243b0268a8c65b76e06a858a324ddfb63c4fe354783e7e876e67ae7e4d682752880eaf589f5be9375c526216f51eb6f1a82a01b4d4fc9f1684fca005eb2e098e35b17fc8fdf45717a7d3ed2d4136ee100ff4263acdc6e8f883b84a894a63d69de30ebe7cda09c4d3a3004cd8e45ec0c04a49ad8c3fc076f6736474cbf50f92f6c1696dcbcebbbb459425970a6be01f93e5b3f2d7b30ceaa79c80c4ede7bc003d91c0f5727bfe25c70b825b0ce263f0f05c57c1ed72d818c9559657a9e3463aca1f95c7589bc39f914bab887fd8aa124379803207b31c344e3a82814c964a0802d00b323ad1cc77c6ffd30255d9629a2b9730657f236f9520eb338d5392b6860f209502f3caac9da96a99f6a2c36543ca6e6e8e63eaac0224a84de69b67d0214aef4b961e9474574049aaf374e78721f0e03693e4d1ceb07c5e8008a632ee4882ddae973edd56059225658172572dbaa6f9eee2825eeab4b3f7189d6cc7fd5428e23a55c4d843a46a52d6a494da2213d844eb1d7bf035c103ee9bb87d7218b11e8208f2aa25a436fe436fbefb18e6596a6786f3d55118207063ceb868366f2dcceab03743286181d4d5937b969bba9b98c29792217dcf01ab51a14b9834d07eb4daae0ea73757bf2419425fac6c695bd88f38b3a546582369255212371fa7466d4607ad4ab1f46e9b4a74d27b1110ccb1e1bcdba65bc1fb6f927fc144f8afd31a208854a61a5f0c0ade394cac9d97c6600eb2bccfff2321d983e7e4b9627f769d4e49e7d01efe7712bb89643bb4c3c435c92bc45a25fc1b884dda77a42f2ec1e21b22b9159b9cb453cde0e5a301f3bf8d85844bf81225dbe1767d75d881be2e636eaa6450bc5f3eed4a8453f7c3632c9eef82a2e0f27c1b34187c047622d6f7f4f5d240138861be413ca74911e7d0558c2d92d5d9e9989828364fb3aaddd143a5fdea53d5e4508c5a307bec84753e5d09370a3e807c3043467a01ee5cd2f855236eb2903f1f126a32d3540db886fa679e73417bdd61f9196d302e45777d0676ab26183c5d9984485a2d2e0c4cca536b76dce3cc8bdade92dad936f58f6c62e8c9a400e0541d40ea1f1658d31a5a94037b320acf85c9b544628bed424214739d0fe52bd2b3ee52305ef9c69fb8fbde13598b09eee99c0c2485a46478d3e6458696f09f3ae5bb60b5895c7a68b8c08f5e68ad1bfd6f64d8e9769c92ce5a8362c27a14fea013aaba724a13a84715cae254748e4f6811d1877f714808d46871893831af89489765d9cc25a7b9272ecf2f20044f92aed2d0c7645d681fbc72e8c980cfd1c733bc519604bfb4feca7779b6b358d277484b63959ec3a4fd86e9c12d4bbe8853461a05d32df6399257df2f2599d65b5b0873e3d24d9f02ed87cc28e6152929b4f920550abe4086dfffe9f306b66b9398545c4a84a46738582bde79c411f8844eb53d5136911fbaadd907d64266144b716dbe3d6b9c240e0e7457e4f1d9c3de0bcd492653f98e18bd47b46132c78ce6504442e629dd6795ea064477d5cedb8f280b3f5d94587991400905e089d9346a063f7b8674fe9ee640a49b0626ee183106da7606575ec9e845a0f998c8e3946bd8721cfd06bbca7870b0e4bacdfa7bf49532c42976b1f87e87b6310907da874f448543dc628aa991053df6608752c2d3b1e3bd1c2ec1c5f04a0cd56f4d615a11af5db83229a103d4581a24b8e846c01c9eba5784ef6ddd165ed553c37041f9ca7c49e6c26ef9432c7514e96983a22b49d28dca8ac8a6d6488c5009e13773c42175dd68afdde5d4e380ddf6e8d69b21827201ed24c34139a571c322f78a3e1f9bdb5000f5674b24c2ef0069a8bce1f0504591b0ae81f060861cb6d4586aa7b16549dcea5219c329b9779d9aa3ba27767f04eea1411e602fc265ea77b5bbd861fb70201bb1c861cc51240195685454366ed9d07ef4a289156c7e6fb8c2454d222572a1fe0bbfbb7916f9e6705ab9f6ec40fd180a04d7d3417ac3eb0dc5ce92b29c559702bf12b922552582e1cdf68fa6207abf5ef763d8168cd372f0c1ad75ff40daa90af561aa00c40bd102fa1b0f0ce80befbb96845ad7d1d7e765076588fde40dad6b83a8cf9dda68926a637e86422a5b6f038630f50f72f0887517100c6f2e1f45cab53018145a2036632c4dd46dbb47c4c3aaa3ab73ff1f5882e034e51c86cf042bf95ceceb5f3d9a305b5993e036deb6e1aedddb9fa55ed76d847090ee72c56bd0f055a05f37d1a621409e9ea927ffb670610e09edc5fb</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>火焰图flamegraph</title>
      <link href="/posts/38ZNGYA/"/>
      <url>/posts/38ZNGYA/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是火焰图">什么是火焰图?</h2><p>首先火焰图, 是一个性能排查的可视化工具, 广泛应用于<font color="#FF1E10"><strong>函数调用开销、内存占用统计</strong></font>等…<br>如图长这样:<br><img src="/images/flamegraph.png" alt=""></p><p>它有两大优势: <font color="#FF1E10"><strong>1.可以看清调用关系, 2. 一眼看出性能瓶颈;</strong></font></p><h2 id="如何生成火焰图">如何生成火焰图?</h2><p>常见的开源flamegraph都是基于perf结果解析出的svg, 再用浏览器打开就是火焰图了;<br>比较经典的开源是这个:<br><a href="https://github.com/brendangregg/FlameGraph"><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>brendangregg/FlameGraph</strong></a><br>但比较可惜，作者基于Perl写的，windows下运行比较麻烦（因为你得为每台工作机装个perl环境吧…）</p><p>推荐一个在线看火焰图的网站:<br><a href="https://www.speedscope.app/"><strong>speedscope.app</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 汇总</title>
      <link href="/posts/2N6K1PK/"/>
      <url>/posts/2N6K1PK/</url>
      
        <content type="html"><![CDATA[<h2 id="语言特性">语言特性</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">时间</th><th style="text-align:left">特性</th></tr></thead><tbody><tr><td style="text-align:center">C++98</td><td style="text-align:center">1998</td><td style="text-align:left">the original standard</td></tr><tr><td style="text-align:center">C++11</td><td style="text-align:center">2011</td><td style="text-align:left">almost a new language</td></tr><tr><td style="text-align:center">C++14</td><td style="text-align:center">2014</td><td style="text-align:left">some improvements</td></tr><tr><td style="text-align:center">C++17</td><td style="text-align:center">2017</td><td style="text-align:left">new features &amp; library extensions</td></tr><tr><td style="text-align:center">C++20</td><td style="text-align:center">2020</td><td style="text-align:left">game-changing new features &amp; libraries</td></tr></tbody></table><h3 id="ISO-Standard-C">ISO Standard C++</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">since</th><th style="text-align:center">Got</th></tr></thead><tbody><tr><td style="text-align:center">nullptr</td><td style="text-align:center">c++11</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">constexpr</td><td style="text-align:center">c++11</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">auto</td><td style="text-align:center">c++11</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">decltype</td><td style="text-align:center">c++11</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">decltype(auto)</td><td style="text-align:center">c++14</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">lambda</td><td style="text-align:center">c++11</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">shared_ptr</td><td style="text-align:center">c++11</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">unique_ptr</td><td style="text-align:center">c++11</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">weak_ptr</td><td style="text-align:center">c++11</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">make_unique</td><td style="text-align:center">c++14</td><td style="text-align:center"></td></tr></tbody></table><h3 id="constexpr">constexpr</h3><p>阅读材料:</p><ul><li><a href="https://en.cppreference.com/w/cpp/language/constexpr">cppreference: constexpr</a></li><li><a href="https://learn.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=msvc-170">Microsoft: constexpr</a></li></ul><p><strong>constexpr和const有什么区别?</strong></p><ul><li><a href="https://stackoverflow.com/questions/14116003/whats-the-difference-between-constexpr-and-const">stackoverflow</a></li><li><code>const</code> simply means that value <strong>cannot be changed</strong></li><li><code>constexpr</code> creates a <strong>compile-time constant</strong></li></ul><p>核心在于, constexpr在编译期就已经完成值计算.</p><h2 id="compile-flag">compile flag</h2><p>阅读资料：<a href="https://linuxhandbook.com/gcc-flags/">Important GCC Flags in Linux</a>，<a href="https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html">Gcc Option-Summary</a><br><code>compile flags</code>，使用合理的编译选项来让你的程序更健壮和友好，掌握如下重点：</p><ul><li><code>-Wall</code>：打印所有的 warning</li><li><code>-Werror</code>：所有 warning 当做 error 处理</li><li><code>-o</code>：指定输出文件</li><li><code>-l</code>：链接共享库，如<code>-lpthread</code></li><li><code>-g</code>：编译包含debug信息</li><li><code>-std=c++11</code>：指定C++标准</li><li><code>-O[0|g|1|2|s|3]</code>：优化级别，<code>-O0</code>不含任何优化</li></ul><h2 id="Value-or-Reference">Value or Reference?</h2><p>引用自《C++ Templates》，总体说使用类对象时传递值，使用基础类型时传递引用。</p><h2 id="quote">quote</h2><ul><li><p>Modern C++ Tutorial<br><a href="https://changkun.de/modern-cpp/en-us/01-intro/">https://changkun.de/modern-cpp/en-us/01-intro/</a></p></li><li><p>cpphacking<br><a href="https://hackingcpp.com/index.html">https://hackingcpp.com/index.html</a><br>强推这个网站</p></li><li><p>fmt库<br><a href="https://github.com/fmtlib/fmt">https://github.com/fmtlib/fmt</a></p></li><li><p>基于C++17的python解释器<br><a href="https://github.com/blueloveTH/pocketpy/blob/main/src/main.cpp">https://github.com/blueloveTH/pocketpy/blob/main/src/main.cpp</a><br>搭配这个看, python写的py解释器<br><a href="https://aosabook.org/en/500L/a-python-interpreter-written-in-python.html">https://aosabook.org/en/500L/a-python-interpreter-written-in-python.html</a></p></li></ul><h2 id="工具">工具</h2><ul><li><p>学习 <code>Makefile</code></p></li><li><p>学习 <code>cmake</code></p></li><li><p>学习 <code>编译选项</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Linux】命令行大全</title>
      <link href="/posts/2G7VBZ2/"/>
      <url>/posts/2G7VBZ2/</url>
      
        <content type="html"><![CDATA[<p>记录常用的Linux指令、踩坑经历<span id="more"></span></p><div class="admonition warning"><p class="admonition-title">导读</p><ul><li>查阅 man 手册是最根本的办法，但某些用法要牢记!</li><li><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md#%E5%86%B7%E9%97%A8%E4%BD%86%E6%9C%89%E7%94%A8">The art of command line</a></li><li><a href="https://explainshell.com/">explain shell，解释任意指令</a></li></ul></div><div class="markmap-container" style="height:550px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;<a href=\&quot;#符号\&quot;>重定向</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#pipe管道\&quot;>pipe</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;<a href=\&quot;#here-document\&quot;>here document</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;<a href=\&quot;#xargs\&quot;>xargs</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#xargs-d\&quot;>xargs -d</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#xargs-find\&quot;>xargs+find</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#match\&quot;>match</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;regex, glob&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;<a href=\&quot;#grep\&quot;>grep</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;<a href=\&quot;#find\&quot;>find</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;<a href=\&quot;#watch\&quot;>watch</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;less&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;head, tail&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;#curl\&quot;>curl</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;curl -X&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;curl -o&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#apt-get\&quot;>apt-get</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;#port\&quot;>port</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;<a href=\&quot;#sed-stream-editor\&quot;>sed</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;<a href=\&quot;#scp-上传-下载\&quot;>scp</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;<a href=\&quot;#disk\&quot;>disk</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;<a href=\&quot;#nohup\&quot;>nohup</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;<a href=\&quot;#compression\&quot;>compression</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;kill&quot;}],&quot;p&quot;:{}}"></svg></div><h2 id="重定向">重定向</h2><p>Linux 的宗旨是 <code>everythin is file</code>，对于进程、IO、设备等，都是以文件的形式存在，这些文件都可以用文件描述符（<code>file descriptor</code>）来表示。<br>Linux 默认有三个文件描述符，你可以始终默认它们是存在的：</p><ul><li>stdin（0）：可以理解为键盘设备的输入信号</li><li>stdout（1）：标准输出</li><li>stderr（2）：标准错误</li></ul><h3 id="符号">符号</h3><div class="admonition note"><p class="admonition-title">重定向操作的格式:</p><ul><li>shell命令 + 重定向符号 + &lt;文件、文件描述符、设备&gt;</li></ul></div><ul><li><p>“<font color="#FF1E10"><strong>&gt;</strong></font>” 默认重定向 stdout，会覆盖原内容<br><code>cmd &gt; file</code>，等价于 <code>cmd 1 &gt; file</code></p></li><li><p>“<font color="#FF1E10"><strong>&gt;&gt;</strong></font>” 是追加，不会覆盖</p></li><li><p>“<font color="#FF1E10"><strong>&lt;</strong></font>” 重定向 stdin，可以从输入设备、文件内读取<br><code>wc -l &lt; file</code>，会统计文件的行数</p></li><li><p>“<font color="#FF1E10"><strong>&gt;&amp;</strong></font>” 符号实现 stdout、stderr 之间的重新绑定。</p><ul><li><code>cmd 1&gt;&amp;2</code>，会将所有 stdout 输出到 stderr</li></ul></li></ul><h3 id="忽略">忽略</h3><p><code>/dev/null</code> 是linux下的一个device，相当于黑洞，任何输出重定向到这里都会被吞掉（即忽略）。</p><p><code>cmd &gt; /dev/null</code>，会忽略所有的stdout，但会保留stderr，想要忽略任何输出，可以使用 <code>cmd 1&gt;/dev/null 2&gt;&amp;1</code></p><h3 id="pipe管道">pipe管道</h3><p>管道（“<font color="#FF1E10"><strong>|</strong></font>”） 和 “<font color="#FF1E10"><strong>&gt;</strong></font>” 的区别在于，它仅仅支持将一个（前面）指令的 stdout 传递给 下一个指令。</p><p><code>cat file | grep luhao</code>，即将file的内容传递给grep，以匹配luhao字段</p><div class="admonition note"><p class="admonition-title">理解pipe：将上一个指令的stdout，重定向到下一个指令的stdin</p><ul><li>阅读材料：<a href="https://www.cnblogs.com/pengliangcheng/p/5211786.html">linux管道和重定向区别</a></li></ul></div><h3 id="here-document">here document</h3><pre><code class="language-bash">command &lt;&lt; EOF    documentEOF</code></pre><p><code>here document</code> 是 linux 一种特殊的重定向方式，它会将两个<code>EOF</code>之间的字符重定向给 command（或者一个程序）。<br>一种常见的用法是，结合 <code>cat</code> 实现多行字符的输出。</p><h2 id="xargs">xargs</h2><p>前面说到 <u class="black">管道</u> 可以在两个指令间传递信息，但很遗憾的是一些指令并不支持管道，例如 <code>echo</code>。<br>这个时候就需要 <code>xargs</code> （<em>eXtended ARGuments</em>）发挥作用！</p><blockquote><p>xargs [-options] [command]<br>xargs 本质是 将stdin转化为command的参数（结合管道使用）</p></blockquote><ul><li><p><code>$ xargs find -name</code><br>回车后会等待用户输入，<u class="black">然后按下 <code>ctrl+d</code></u>，会执行 <code>find -name [input]</code></p></li><li><p><code>$ echo "test" | xargs mkdir</code><br>实际上等价于 <code>mkdir test</code>，如果不加xargs会报错</p></li></ul><h3 id="xargs-d">xargs -d</h3><p>xargs默认根据 “空格” 进行分割，可以用参数 <code>-d</code> 调整其分割策略</p><ul><li><p><code>echo "one two three" | xargs mkdir</code><br>实际会创建名为<code>one</code>, <code>two</code>, <code>three</code>的三个目录</p></li><li><p><code>echo -e "a\tb\t\c" | xargs -d "\t"</code><br>即按照<code>\t</code>分割，实际输出<code>a b c</code></p></li></ul><div class="admonition note"><p class="admonition-title">NOTE</p><ul><li><code>-p</code>：解析完参数，请求用户确认 <font color="#FF1E10"><strong>（当你不确定时请用 <code>-p</code>）</strong></font></li><li><code>-t</code>：打印出参数，直接执行</li></ul></div><h3 id="xargs-find">xargs + find</h3><p>这两个指令搭配好为例无穷，举个例子，搜索目录下所有 <code>*.txt</code> 中是否包含 <code>luhao</code> 的字符：</p><ul><li><code>find . -name "*.txt" | xargs grep "abc"</code> ✔</li><li><code>find . -name "*.txt" | grep "abc"</code> ❌</li></ul><p>再例如，删除所有以 <code>test</code> 开头的文件：（<code>-print0</code>是处理文件名含空格）</p><ul><li><code>find . -name "test* -print0" | xargs -0 rm</code></li></ul><p>高级应用，统计所有 <code>.cpp</code> 文件的代码行数：</p><ul><li><code>find ./source -type f -name "*.cpp" | xargs  wc -l</code></li></ul><div class="admonition warning"><p class="admonition-title">管道和xargs区别?</p><ul><li>管道 将上一个stdout一股脑丢到stdin执行</li><li>xargs 会将上一个stdout根据空格等分离，再一个一个丢进来执行</li></ul></div><h2 id="匹配">匹配</h2><p>linux下有两种匹配规则，分别是 RE正则表达式 和 Glob通配符。<br><code>Glob</code>一般在shell指令下使用较多，因为较多的指令不支持正则表达式。例如 <code>ls</code>、<code>find</code>、<code>sed</code>…</p><ul><li><p><a href="/posts/3SAT4K7/">regex 正则表达式</a></p></li><li><p><a href="https://tldp.org/LDP/abs/html/globbingref.html">glob 通配符</a></p></li></ul><p>linux关于匹配的指令也有多种，使用最多的是 <code>find</code>、<code>grep</code>… 推荐查阅man手册来学习</p><h3 id="font-color-1A9BFF-grep-font"><a href="https://man7.org/linux/man-pages/man1/grep.1.html"><font color="#1A9BFF"><strong>grep</strong></font></a></h3><p>grep 会将匹配的部分高亮输出到 stdout，需要牢记如下几个参数：</p><ul><li><code>-i</code>：ignore-case</li><li><code>-o</code>：only-matching，只打印完全匹配的部分</li><li><code>-v</code>：invert-match，只输出“不匹配”</li></ul><h3 id="font-color-1A9BFF-find-font"><a href="https://man7.org/linux/man-pages/man1/find.1.html"><font color="#1A9BFF"><strong>find</strong></font></a></h3><blockquote><p>TODO：用到时候再来学习</p></blockquote><h2 id="watch">watch</h2><p><code>linux cat</code> 指令会将文件所有的内容输出到 stdout，当文件很大的时候会占用很大的缓冲区，并造成卡顿和等待。因此学会如下几个指令：</p><ul><li><code>less</code>：打印部分，借助vim指令上下滚动</li><li><code>head</code>：打印头部</li><li><code>tail</code>：打印尾部</li></ul><p>可选参数常用的有两种：</p><ul><li><code>-f</code>：follow模式，当文件增长时会刷新stdout</li><li><code>-n</code>：打印指定的行数</li></ul><div class="admonition note"><p class="admonition-title">监测日志时，使用 tail -f *.log | grep xxx 非常有帮助</p></div><h2 id="curl">curl</h2><p>curl 是用来请求web服务器的命令行工具，其名字是 client &amp; url 的结合体。Postman跟它的作用类似，但是带有GUI界面。<br><code>curl https://www.google.com/</code>：无任何参数的curl，就是调用一次 <code>GET</code> 请求。</p><ul><li><code>-d</code>：发送 <code>POST</code> 请求</li><li><code>--head</code>：发送 <code>HEAD</code> 请求</li><li><code>-o</code>：将服务器的返回保存为文件，等同于 <code>wget</code></li><li><code>-X</code>：指定HTTP请求方法，如 <code>curl -X POST ...</code></li></ul><h2 id="apt-get">apt-get</h2><ul><li>debian如何换国内源?</li></ul><pre><code>sudo sed -i -e 's/deb.debian.org/mirrors.aliyun.com/g' -e 's/security.debian.org/mirrors.aliyun.com/g' /etc/apt/sources.listsudo apt-get update</code></pre><hr><hr><p>分割线，下面内容要整理重写</p><hr><hr><h3 id="port">port</h3><ul><li><p>Unix:<br><code>lsof</code>: 打印所有端口的占用情况<br><code>lsof -i:4000</code>: 查看占用4000端口的进程</p></li><li><p>Windows:<br><code>netstat -ano | findstr :6000</code>: 查看占用6000端口的进程<br><code>taskkill /PID 12345 /F</code>: 杀死进程12345, /F表示强制关闭</p></li></ul><h3 id="sed-stream-editor">sed: stream editor</h3><ol start="0"><li><code>sed -i</code>: 直接替换源文件</li><li><code>sed '4a newline' [file]</code>: 第4行新增</li><li><code>sed '1,5s/a/b/' [file]</code>: 1~5行的a替换为b</li><li><code>$</code>: 表示末行</li></ol><h3 id="scp-上传-下载">scp 上传/下载</h3><ol><li><code>scp [local file] root@xx.xx.xx:/root</code>: 上传到服务器</li><li><code>scp root@xx.xx.xx:/root/ [local_path]</code>: 从服务器下载到本地</li><li><code>scp -r</code>: 文件夹操作</li><li><code>scp -P 32200 ...</code>: 带端口的scp</li></ol><h3 id="disk">disk</h3><ul><li><code>df -lh</code>: 查看磁盘剩余空间</li><li><code>du -lh</code>: 查看含目录的大小</li><li><code>rm -f *</code>: 删除目录下所有文件</li><li><code>l --color</code>: 彩色格式显示</li><li><code>ll</code>: 显示详细信息, 如最后修改时间</li><li><code>ls | wc -l</code>: 统计当前文件数, wc表示<code>word count</code>, <code>-l</code>是行数</li></ul><h3 id="nohup">nohup</h3><p>看这篇cnblog就够了: <a href="https://www.cnblogs.com/yunwangjun-python-520/p/10713564.html">nohup和&amp;后台运行</a></p><h3 id="compression">compression</h3><ul><li>zip</li></ul><ol><li><code>unar xx.zip</code>: 可以自动解码中文</li><li><code>vim xx.zip</code>: 查看zip压缩文件结构</li></ol><ul><li>tar</li></ul><pre><code class="language-shell"># .gz ------------------tar -czf x.gz [file]tar -xzvf x.gz# .bz2 ------------------tar -cjf x.bz2 [file]tar -xjvf x.bz2# .rar ------------------rar a x.rar [file]unrar e x.rar# .zip ------------------zip x.zip [file]unzip x.zip</code></pre><h3 id="shell脚本">shell脚本</h3><ul><li>如何写一个自己的脚本?</li></ul><ol><li><code>xxx.sh</code>: 如/luhao/bin/demo.sh</li><li><code>ln -s /luhao/bin/demo.sh /usr/bin/demo</code>: 加入环境变量, 可以直接demo访问</li></ol><ul><li>自定义start, end, restart</li></ul><pre><code class="language-shell">function start() {}case "$1" in    start)start;;    *)esac</code></pre><h3 id="ps-kill-pkill-进程相关">ps, kill, pkill 进程相关</h3><ul><li><code>ps -e</code>: 所有进程</li><li><code>ps -u</code>: 按用户打印进程</li><li><code>ps -x</code>: 没有终端的进程, 后台python应用需要！</li><li><code>kill -9 [pid]</code>: 杀死对应pid的进程</li><li><code>pkill -f [pattern]</code>: 杀死制定名称的进程</li></ul><h3 id="挂载云硬盘">挂载云硬盘</h3><ol><li><code>fdisk -l</code>: 查看新磁盘名称, 如<code>/dev/vdb</code></li><li><code>mount -t ext4 /dev/vdb /data</code>: 将<code>/dev/vdb</code>挂载到<code>/data</code>目录</li><li><code>df -lh</code>: 查看对应硬盘</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《直击本质》书摘</title>
      <link href="/posts/3819NVV/"/>
      <url>/posts/3819NVV/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><ul><li><a href="(https://weread.qq.com/web/reader/78f32cc071d7b80f78f0c1fkc81322c012c81e728d9d180)">《直击本质：洞察事物底层逻辑的思考方法》</a>，专注于“思考方法”的书</li><li>本文旨在记录书中有共鸣、有感触的语句</li></ul></div><h2 id="理解事物本质">理解事物本质</h2><p>思考事物的根本属性，是学一样东西、论述一个原理、解决一个问题、判断一个趋势的基础；<br>当你做到以下中的任何一件，你就理解了事物的本质：</p><ul><li><strong>给出清晰的定义</strong><ul><li>“商品”是用来交换的劳动产品;</li></ul></li><li><strong>做出简单、准确的类比</strong><ul><li>“谈判”就是“找交集”</li><li>切忌用一件晦涩的事物去解释另一件事物，容易将简单的问题复杂化；</li></ul></li></ul><h2 id="升维思考">升维思考</h2><ul><li><p>跳出眼前问题的限制与常规解法，通过层级、时间、视角、边界、位置、结构的变换，重新思考问题及其解决之道的思维方式</p></li><li><p>爱因斯坦：“我们不能用制造问题时的同一水平思维来解决问题。”</p></li></ul><h3 id="1-层级思考法">1. 层级思考法</h3><ul><li><p>上三层：</p><ul><li><strong>愿景层</strong>：人生使命，比如灭霸为了维护宇宙平衡；</li><li><strong>身份层</strong>：我是谁，我想成为谁；</li><li><strong>价值观层</strong>：好坏对错之分；</li></ul></li><li><p>下三层：</p><ul><li><strong>能力层</strong>：技能、状态、策略；</li><li><strong>行为层</strong>：具体的行动，每天做了什么？</li><li><strong>环境层</strong>：学校、职场、家庭的环境影响</li></ul></li><li><p>上层对下层拥有指导作用。当你懒得背单词（行为层），想象你想考上怎样的大学（身份层），背单词就有了驱动力，正是这个道理；</p></li><li><p>面对下层的现象，从上层介入思考会更直击本质。这也是为什么通过一个人的交友圈子（环境层）、言语交谈（行为层）和处事策略（能力层），你基本能推断出其三观与身份特征。</p></li><li><p>如果我们只在下层做出改变，而上层的意识没有变化，下层的改变常常是难以持久的。</p></li></ul><h3 id="2-拉长时间轴">2. 拉长时间轴</h3><ul><li>消除痛苦与烦恼。站在更远的时间线外看待当下，你会觉得，一切的痛苦都会随时间烟消云散。</li></ul><h3 id="3-上帝视角">3. 上帝视角</h3><ul><li><p>为什么你能教别人做事，却过不好自己的生活？居高临下，跳出剧本，才能拥有上帝视角（这我想起了罗永浩的"大局观"）</p><ul><li>上帝视角让我们摆脱自我情绪和感受的束缚；</li><li>上帝视角利于拥有全局观、大局观；</li></ul></li><li><p>普鲁斯特：“真正的发现之旅不在于发现新风景，而在于获得新视角。”</p></li></ul><h3 id="4-第三选择">4. 第三选择</h3><ul><li><p>我们经常陷入非黑即白、非此即彼的二选一思维模式，即“点状思维”。以至于条件反射般地将事物一分为二或两极对立：男人与女人，原告与被告、资本家与工人等等…</p></li><li><p>只有机器人才会只拥有0和1两种选择，试着寻找“第三选择”</p></li></ul><h3 id="5-无边界思考">5. 无边界思考</h3><ul><li><p>哲学家卡斯将人类所有活动比作两类游戏：</p><ul><li><strong>有限游戏</strong>：制定一系列机制与规则（如政治、法律），以取胜为目的（如战争、官司）；</li><li><strong>无限游戏</strong>：没有任何规则，以延续为目的，拥有无限可能与结局（如文化、艺术）；</li></ul></li><li><p>我们总是习惯性给自己限定框架，进行“有限游戏”。如“我只是大专毕业，怎么找得到好工作”；如“我是女生，我一定会受到歧视”；一切身份限制、性别限制、输赢限制等等，都在无形中束缚了我们的发展。</p></li><li><p>所谓无边界思考，即打破人生得到种种限制。关键包括三点：消除时空边界、消除角色边界、修改规则</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VPN搭建一条龙</title>
      <link href="/posts/2R7AP5Z/"/>
      <url>/posts/2R7AP5Z/</url>
      
        <content type="html"><![CDATA[<p><em>Windows/Mac/IOS/Android通用的VPN搭建教程，收费的</em></p><hr><h3 id="1-Shadowrocket安装">1. Shadowrocket安装</h3><ul><li>美区<em>App Store</em>利用 <font color="#ef6d3b"><strong>$2.99</strong></font> 购买 shadowrocket app</li></ul><p><a href="https://shadowsockshelp.github.io/Shadowsocks/apple-id.html"><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 注册美区 Apple ID 帐号的终极指南</a></p><ul><li>美区app如何充值？移步万能的淘宝，搜索AppStore美区礼品卡，买$3的就行</li></ul><h3 id="2-shadowsocket配置">2. shadowsocket配置</h3><ul><li>认准这个网站: <a href="https://v2ww.com/#/dashboard"><strong><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> v2ww.com</strong></a></li></ul><p>里面有详细的Shadowrocket配置教程，和梯子价格清单，<span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>建议购买月<font color="#ef6d3b"><strong>￥9.9</strong></font> 的10GB套餐</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>游戏记录：ARK方舟生存进化</title>
      <link href="/posts/160HQCD/"/>
      <url>/posts/160HQCD/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><ul><li>方舟:生存进化是一款开放世界游戏；</li><li><a href="http://www.teandy.com/">方舟听宇网</a></li><li><a href="https://ark.fandom.com/wiki/ARK_Survival_Evolved_Wiki">方舟资料网站（英文）</a></li></ul></div><hr><h2 id="说几句">说几句</h2><p>这个游戏晕死我了，两个月来玩了200小时，主要是孤岛和焦土DLC。<br>基本玩两小时就恶心发晕，我就是个菜鸡。<br>玩了100小时才知道这游戏有主线和BOSS，不过感觉没啥意思。<br>觉得最大乐趣是探图、建家、抓恐龙，并乐此不疲，像是虚拟世界的一个家园，一片净土吧…</p><h2 id="DLC介绍">DLC介绍</h2><ul><li><p>游戏包含付费DLC和免费DLC, 按照时间顺序:</p></li><li><p>付费DLC</p><ul><li><strong>孤岛（The Island）★</strong></li><li>焦土（Scorched Earth）</li><li>畸变（Aberration）</li><li>灭绝（Extinction）</li><li>创世纪一二（Genesis）</li></ul></li><li><p>免费DLC</p><ul><li>中心岛（The Center）</li><li><strong>仙境（Ragnarok）★</strong></li><li>瓦尔盖罗（Valguero）</li><li>水晶岛（Crystal Isies）</li><li>迷失岛（Lost Island）</li></ul></li></ul><ul><li>本体+全dlc安装，硬盘空间 <code>400G</code></li></ul><h2 id="闪退白框修复">闪退白框修复</h2><p><a href="https://www.bilibili.com/video/BV1NK4y147dD/?vd_source=db26a19e4b4372574c8ebde86f9333bd">【方舟问题】解决方舟所有白框问题。网络问题，驱动问题，地图问题</a></p><p>方舟这个破游戏经常会各种UE的Crash，本人遇到最多的是 <code>NetConnection</code> 的闪退，俗称 4096。<br>搜寻网上各种<s>外行和玄学</s>的解决方案，没有一个百分百有效的。<br>总结如下：</p><ul><li>使用UU加速器（没用）</li><li>插拔路由器（没试过）</li><li>清空所有浏览器缓存（没用）</li></ul><h2 id="修改本机配置">修改本机配置</h2><p><code>...\steam\steamapps\common\ARK\ShooterGame\Saved\Config\WindowsNoEditor</code></p><p>如何修改恐龙等级、刷新规则?</p><ul><li><code>GameUserSettings.ini</code>: 修改恐龙等级、刷新规则等</li></ul><p>可以订阅这个调等级的MOD:</p><ul><li><a href="https://steamcommunity.com/sharedfiles/filedetails/?id=2182894352">Custom Dino Levels</a></li><li><a href="https://steamcommunity.com/workshop/filedetails/discussion/2182894352/2794998850882765005/">配置文档</a><br>其中官方设置的难度表示一个level的等级间隔（如5表示5级）, <code>MinLevel=30</code> 表示最小等级限制为 <code>难度 x MinLvel</code></li></ul><pre><code># GameUserSettings.ini[CustomLevelDistrib]MinLevel=15.000000MaxLevel=30.000000WantsEqualLevels=True# 刷新概率TinyWeight=1.000000 # 5-25LowWeight=0.3500000 # 30-60MediumWeight=0.250000 # 65-100HighWeight=0.250000 # 105-150</code></pre><p>重置地图请删除:</p><ul><li><code>ARK\ShooterGame\Saved\LocalProfiles</code></li></ul><h2 id="方舟私服">方舟私服</h2><p>如果在本机玩，方舟就是个单机游戏，想要和别的玩家一起玩，就得找服务器。（推荐去<a href="http://www.teandy.com/">听宇网</a>找）</p><p>一般服务器的介绍是 <strong>“PVE15通 采3驯10…”</strong></p><ul><li><p>分<code>PVE</code>/<code>PVP</code>两种服务器</p></li><li><p><code>15通</code>: 表示共有15个地图可以互通</p></li><li><p>采n驯m: 表示游戏加速的倍率</p></li></ul><h2 id="实用MOD">实用MOD</h2><table><thead><tr><th style="text-align:center">MODs</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Awesome SpyGlass</strong></td><td style="text-align:left">A+镜，观察恐龙的等级、晕眩度、加点等</td></tr><tr><td style="text-align:center"><strong>Ultra Stacks</strong></td><td style="text-align:left">可以堆叠物品，节省背包的容量！</td></tr><tr><td style="text-align:center"><strong>Automatic Death Recovery</strong></td><td style="text-align:left">死亡物品不掉路！</td></tr><tr><td style="text-align:center"><strong>Pet Finder</strong></td><td style="text-align:left">恐龙丢了用这个找！</td></tr><tr><td style="text-align:center"><strong>Kraken’s Better Dinos</strong></td><td style="text-align:left">修改刷新恐龙的等级、比例</td></tr><tr><td style="text-align:center"><strong>Upgrade Station</strong></td><td style="text-align:left">可以升级鞍具、工具的工作台！</td></tr><tr><td style="text-align:center"><strong>Baby Premium Care</strong></td><td style="text-align:left">100%留痕药、飞龙奶等！</td></tr></tbody></table><h2 id="游戏资源推荐">游戏资源推荐</h2><ul><li><a href="https://www.bilibili.com/video/BV1KK4y1Y7rL?spm_id_from=333.337.search-card.all.click">B站 老司机hot《方舟生存进化》</a></li></ul><h2 id="游戏配置（备忘）">游戏配置（备忘）</h2><p><img src="/images/ark_setting.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript概览</title>
      <link href="/posts/286HTVQ/"/>
      <url>/posts/286HTVQ/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">Note</p><ul><li>在此之前，先看看什么是<strong>JavaScript</strong>?<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Introduction">JavaScript 中文介绍</a> |<a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_is_JavaScript">What is JavaScript?</a></li><li><strong>TypeScript</strong>其实就是<code>Typed JavaScript at Any Scale.</code></li></ul></div><h3 id="ts基本特性">ts基本特性</h3><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">解释</th><th style="text-align:left">Coding</th></tr></thead><tbody><tr><td style="text-align:left"><font color="#ef6d3b"><strong>Staticlly Typed</strong></font></td><td style="text-align:left">静态类型</td><td style="text-align:left"><code>let foo = 1; foo.split(' ');</code> =&gt; 编译报错</td></tr><tr><td style="text-align:left"><font color="#ef6d3b"><strong>Weakly Typed</strong></font></td><td style="text-align:left">允许隐式类型转化</td><td style="text-align:left"><code>console.log(1 + '1');</code> =&gt; 打印11</td></tr><tr><td style="text-align:left"><font color="#ef6d3b"><strong>Type Annotations</strong></font></td><td style="text-align:left">允许类型注释</td><td style="text-align:left"><code>let foo: string = '1';</code></td></tr></tbody></table><h3 id="import-export">import, export</h3><ul><li><a href="https://blog.atomist.com/typescript-imports/">Import statements in TypeScript: which syntax to use</a></li></ul><table><thead><tr><th style="text-align:left">代码</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left"><code>import * as path from 'path</code></td><td style="text-align:left">commonjs模块</td></tr><tr><td style="text-align:left"><code>import fs = require('fs')</code></td><td style="text-align:left">commonjs模块, export=xx</td></tr><tr><td style="text-align:left"><code>const xx = require('xx)</code></td><td style="text-align:left">无类型声明</td></tr></tbody></table><h3 id="var、let、const">var、let、const</h3><ul><li><a href="https://www.tutorialsteacher.com/typescript/typescript-variable">TypeScript - Variable</a></li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">使用场景</th></tr></thead><tbody><tr><td style="text-align:center"><font color="#ef6d3b"><strong>var</strong></font></td><td style="text-align:center">全局作用域</td></tr><tr><td style="text-align:center"><font color="#ef6d3b"><strong>let</strong></font></td><td style="text-align:center">块作用域</td></tr><tr><td style="text-align:center"><font color="#ef6d3b"><strong>const</strong></font></td><td style="text-align:center">块作用域、只读</td></tr></tbody></table><h3 id="function">function</h3><ul><li>下面是一个求和函数的示例：</li></ul><pre><code class="language-ts">function add(a: number, b: number): number {  return a + b;}</code></pre><h3 id="class">class</h3><ul><li>下面是一个类声明的示例：</li></ul><pre><code class="language-ts">class Point {  // 成员变量, 可用readonly, 不可用const  x: number;  y: number;  // 构造函数  constructor(x = 0, y = 0) {    this.x = x;    this.y = y;  }  // 成员方法  getScale(): number {    return this.x + this.y;  }}// 实例化一个类var point = new Point(1, 2)</code></pre><h3 id="参考">参考</h3><ul><li><a href="https://www.typescriptlang.org/">TypeScript官网</a></li><li><a href="https://ts.xcatliu.com/">一个中文的TypeScript入门教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Python】优雅输出</title>
      <link href="/posts/1MJH73F/"/>
      <url>/posts/1MJH73F/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">前提</p><p><code>Linux</code>命令下, 见识了如<code>gcc</code>, <code>apt</code>, <code>pip</code>之流的优雅输出；  <br>这篇博客想仿照之，借Python实现一些优美的输出与交互；</p></div><h2 id="何为优雅">何为优雅?</h2><p>鄙人低俗, 仅想从样式与外在谈论优雅<br>清晰的输出、高亮的样式… 这些就是开源软件的优雅!</p><p><strong>1. pip</strong><br><img src="/images/pip.png" alt=""></p><p><strong>2. oh-my-zsh</strong><br><img src="/images/zsh.png" alt=""></p><p><strong>3. VScode Extension</strong></p><p><strong>4. ipython</strong><br><img src="/images/ipython.png" alt=""></p><hr><h3 id="何为优雅-2">何为优雅?</h3><ul><li><p>彩色文字区分<br>如<font color="#1AAD19"><strong>SUCCEED</strong></font>，<font color="#FF1E10"><strong>ERROR</strong></font>，都应该有专门的色彩，起到警示和强调的作用;</p></li><li><p>进度条<br>对于耗时较长的程序，应该打印一个<font color="#1A9BFF"><strong>进度条</strong></font>，让用户对完成进度有一个直观的概念；</p></li><li><p>条例清晰的LOG<br>每一个指令，都该包含指引(<code>-h</code>)、运行中和运行结果的Log提示；</p></li></ul><hr><h2 id="二、ANSI实现丰富的终端样式">二、ANSI实现丰富的终端样式</h2><ul><li><a href="https://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html">ANSI escape code</a></li></ul><p>ANSI是一种能想终端打印彩色输出的标准编码，你可以理解为<strong>富文本</strong>!</p><p>这是一段python示例代码，我们需要关注<code>0, 30, 42</code>这三个数值:</p><ul><li><font color="#FF1E10"><strong><code>print '\033[0;30;42m' + '...' + '\033[0m'</code></strong></font></li></ul><table><thead><tr><th style="text-align:center">内容</th><th style="text-align:center">图示</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><font color="#ef6d3b"><strong>Style</strong></font></td><td style="text-align:center">0</td><td style="text-align:center">字体样式</td></tr><tr><td style="text-align:center"><font color="#ef6d3b"><strong>Bgcolor</strong></font></td><td style="text-align:center">30</td><td style="text-align:center">背景色</td></tr><tr><td style="text-align:center"><font color="#ef6d3b"><strong>Color</strong></font></td><td style="text-align:center">42</td><td style="text-align:center">字色</td></tr></tbody></table><ul><li>下图罗列了一些字色和背景色：</li></ul><p><img src="/images/ANSI.png" alt=""></p><hr><h3 id="1-Style">1. Style</h3><p><font color="#ef6d3b"><strong>下面是常用的字体样式</strong></font></p><table><thead><tr><th style="text-align:center">作用</th><th style="text-align:center">编码</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">Normal</td><td style="text-align:center"><code>\033[0m</code></td><td style="text-align:center">Hello World</td></tr><tr><td style="text-align:center">Bold</td><td style="text-align:center"><code>\033[1m</code></td><td style="text-align:center"><strong>Hello World</strong></td></tr><tr><td style="text-align:center">Underlined</td><td style="text-align:center"><code>\033[4m</code></td><td style="text-align:center"><u>Hello World</u></td></tr><tr><td style="text-align:center">Changing</td><td style="text-align:center"><code>\033[5m</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Delete</td><td style="text-align:center"><code>\033[9m</code></td><td style="text-align:center"><s>Hello World</s></td></tr></tbody></table><hr><h3 id="2-Color">2. Color</h3><div class="admonition todo"><p class="admonition-title">todo</p><p>下面汇总一些常用颜色</p></div><table><thead><tr><th style="text-align:center">颜色</th><th style="text-align:center">编码</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">black</td><td style="text-align:center"><code>\033[30m</code></td><td style="text-align:center">Hello World</td></tr><tr><td style="text-align:center">red</td><td style="text-align:center"><code>\033[31m</code></td><td style="text-align:center"><font color="#FF0000"><strong>Hello World</strong></font></td></tr><tr><td style="text-align:center">green</td><td style="text-align:center"><code>\033[32m</code></td><td style="text-align:center"><font color="#1AAD19"><strong>Hello World</strong></font></td></tr><tr><td style="text-align:center">yellow</td><td style="text-align:center"><code>\033[33m</code></td><td style="text-align:center"><font color="#f3bb35"><strong>Hello World</strong></font></td></tr><tr><td style="text-align:center">blue</td><td style="text-align:center"><code>\033[34m</code></td><td style="text-align:center"><font color="#1A9BFF"><strong>Hello World</strong></font></td></tr><tr><td style="text-align:center">white</td><td style="text-align:center"><code>\033[37m</code></td><td style="text-align:center"><font color="#FFFFFF"><strong>Hello World</strong></font></td></tr></tbody></table><hr><h3 id="3-Cursor">3. Cursor</h3><p><font color="#ef6d3b"><strong>如何控制箭头（终端的闪烁符）移动？</strong></font></p><ul><li>下面<code>{n}</code>中表示移动的单位数</li></ul><table><thead><tr><th style="text-align:left">作用</th><th style="text-align:left">编码</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">Up</td><td style="text-align:left"><code>\033[{n}A</code></td><td style="text-align:left">上移箭头</td></tr><tr><td style="text-align:left">Down</td><td style="text-align:left"><code>\033[{n}B</code></td><td style="text-align:left">下移箭头</td></tr><tr><td style="text-align:left">Right</td><td style="text-align:left"><code>\033[{n}C</code></td><td style="text-align:left">右移箭头</td></tr><tr><td style="text-align:left">Left</td><td style="text-align:left"><code>\033[{n}D</code></td><td style="text-align:left">左移箭头</td></tr><tr><td style="text-align:left">Next Line</td><td style="text-align:left"><code>\033[{n}E</code></td><td style="text-align:left">移到下一行</td></tr><tr><td style="text-align:left">Prev Line</td><td style="text-align:left"><code>\033[{n}F</code></td><td style="text-align:left">移到上一行</td></tr><tr><td style="text-align:left">Set Column</td><td style="text-align:left"><code>\033[{n}G</code></td><td style="text-align:left">第n列</td></tr><tr><td style="text-align:left">Set Position</td><td style="text-align:left"><code>\033[{n};{m}H</code></td><td style="text-align:left">第n行m列</td></tr><tr><td style="text-align:left">Clear Screen</td><td style="text-align:left"><code>\033[{n}J</code></td><td style="text-align:left">清屏</td></tr><tr><td style="text-align:left">Clear Line</td><td style="text-align:left"><code>\033[{n}K</code></td><td style="text-align:left">清行</td></tr></tbody></table><ul><li><p>对于清屏和清行:</p><ul><li><code>J = 0</code>: 清除光标到末尾（行位）</li><li><code>J = 1</code>: 清除光标到开头（行首）</li><li><code>J = 2</code>: 清除整个屏幕（整行）</li></ul></li><li><p><font color="#ef6d3b"><strong>我们可以借此实现一个百分比的进度更新：</strong></font></p></li></ul><pre><code class="language-python">for i in range(0, 100): # 10秒跑完    time.sleep(0.1)    sys.stdout.write(u"\u001b[100D" + str(i + 1) + "%")    sys.stdout.flush()</code></pre><p><img src="/images/Loading.gif" alt=""></p><ul><li><font color="#ef6d3b"><strong>下面模拟一个实时滚动的进度条，且只停留在最底栏</strong></font></li></ul><pre><code class="language-python">n = 10for i in range(n):    sys.stdout.write(u"\033[-1;0H")    sys.stdout.write(u'\033[2K')    sys.stdout.write(u'\033[100D')    print i    print 'Processing: [' + '#' * i + '.' * (n - 1 - i) + ']' + ' %d%%' % (i+1),    sleep(1)</code></pre><p><img src="/images/process.gif" alt=""></p><hr><h2 id="参考">参考</h2><blockquote><ul><li><a href="https://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html">ANSI escape code</a></li><li><a href="https://stackoverflow.com/questions/287871/how-to-print-colored-text-to-the-terminal">How to print colored text to the terminal</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】性能分析</title>
      <link href="/posts/2NFFW5M/"/>
      <url>/posts/2NFFW5M/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">NOTE</p><p>推荐最快的Profile方法:<br><code>python -m cProfile -o tmp.prof xxx.py</code><br><code>snakeviz tmp.prof</code></p></div><h2 id="Profiler工具原理">Profiler工具原理</h2><p>性能分析的原理是什么？有哪些常用的profile方法呢？</p><hr><p><strong>1. Instrumentation （插装）</strong></p><p>这应该是最容易理解的方式，看下面代码</p><pre><code class="language-python">import timet1 = time.time()# do somethingt2 = time.time()cost_time = t2 - t1 # s</code></pre><ul><li><p>插装的本质就是：统计运行时间或次数</p></li><li><p>常见方法：</p><ul><li>1.首尾手动记录时间/次数…</li><li>2.profile工具自动插入源码；</li><li>3.profile工具修改汇编码/中间码；</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">海森堡Bug</p><p>由于修改了源码，插装有概率会使程序发生不一样的结果，尤其是多进程的情况下；</p></div><hr><p><strong>2. Sampling （采样）</strong></p><p>每隔一段时间中断进程，获取当前堆栈信息，并从统计学上估计每段代码的运行时间；</p><ul><li><p><strong>Visual Studio Profiler</strong> 就是基于采样实现</p></li><li><p>几乎大部分Profiler都是采样实现，因为它有如下几个优点：</p><ul><li>1.不需要修改代码，不需要重新编译；</li><li>2.可以动态修改中断的interval，控制采样精度和开销的平衡；</li><li>3.对程序的性能影响小，结果可靠；</li></ul></li></ul><h2 id="Python-Profiler">Python Profiler</h2><p>下面介绍几个常用的python profile库：</p><p><strong>[1. cProfile]</strong>(<a href="https://docs.python.org/2.7/library/profile.html">https://docs.python.org/2.7/library/profile.html</a>)</p><ul><li>这是一段官方文档示例</li></ul><pre><code class="language-python">import cProfile, pstats, StringIOpr = cProfile.Profile()pr.enable()# ... do something ...pr.disable()s = StringIO.StringIO()sortby = 'cumulative'ps = pstats.Stats(pr, stream=s).sort_stats(sortby)ps.print_stats()print s.getvalue()</code></pre><ul><li>下面是cProfile的结果，很清晰：<ul><li><font color="#FF1E10"><strong>totime</strong></font>：函数本身花费时间</li><li><font color="#1A9BFF"><strong>cumtime</strong></font>：函数累计花费时间（包含子函数递归）</li></ul></li></ul><p><img src="/images/cprofile.png" alt=""></p><hr><p><strong>[2. snakeviz]</strong>(<a href="https://jiffyclub.github.io/snakeviz/">https://jiffyclub.github.io/snakeviz/</a>)<br>snakeviz其实是解析了cProfile的结果，做了个网页端的可视化界面；</p><p><img src="/images/snakeviz.png" alt=""></p><ul><li><strong>snakeviz使用步骤：</strong></li></ul><ol><li><p>先使用cProfile生成prof文件：<br><code>python -m cProfile -o res.prof demo.py</code></p></li><li><p>再解析prof生成网页：<br><code>snakeviz res.prof</code></p></li><li><p>得到如上精美的profiler火焰图；</p></li></ol><h2 id="Profile注意点">Profile注意点</h2><p><strong>1. 多进程</strong><br>不要把cProfile放在父进程，不然profile结果只有<code>acquire</code>；<br>这是因为父进程只起了调度和fork的作用，要在子进程中 profile；<br><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <a href="https://stackoverflow.com/questions/57617496/90-of-the-time-is-spent-on-method-acquire-of-thread-lock-objects">Stackoverflow: 90% of the time is spent on method ‘acquire’ of ‘thread.lock’ objects</a></p><h2 id="参考资料">参考资料</h2><ul><li><a href="https://www.cnblogs.com/zhao-zongsheng/p/13067733.html">CPU性能分析工具原理</a></li><li><a href="https://stackoverflow.com/questions/582336/how-can-you-profile-a-python-script">How can you profile a Python script?</a></li><li><a href="https://dirtysalt.github.io/html/on-python-profiling.html">Python程序性能分析</a></li><li><a href="https://blog.xizhibei.me/2021/01/10/poor-mans-profiler/">穷人的程序性能分析器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】多进程multiprocess</title>
      <link href="/posts/2A7ENQS/"/>
      <url>/posts/2A7ENQS/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><p>多进程（并发）是现代计算机的基本组成之一；介绍了进程、线程、协程是什么，以及相互关系；</p></div><hr><h2 id="1-一篇CSDN博客">1. 一篇CSDN博客</h2><p><img src="/images/csdn_multiprocess.png" alt=""></p><p>这是我大学操作系统期间写的<a href="https://blog.csdn.net/luhao19980909/article/details/89403233">一篇CSDN博客</a>，看到有3w+访问和700+的收藏，这是我意想不到的；<br>回头看这篇文章，几乎没有专业词汇，而是用类比的方式解释了进程相关的基础知识；<br>摘取片段如下：</p><p>=====================================================<br><code>单CPU</code>：一台单核处理器计算机 =  一个车间；<br><code>多CPU</code>：一台多核处理器计算机 =  一座工厂；</p><p><code>进程</code>：一个车间 = 一个进程； （即一个运行的程序）<br><code>多进程</code>：一座工厂可以同时运行多个车间；<br><code>CPU和进程</code>：<strong>单CPU只能同时运行单个进程，多CPU可以同时运行多个进程</strong>。</p><p><code>线程</code>：车间内一个工人 = 一个线程；<br><code>进程与线程关系</code>：<strong>一个进程可以包括多个线程</strong>。</p><p>=====================================================</p><h3 id="什么是进程-Process">什么是进程 (Process)</h3><p><font color="#ef6d3b"><strong>A process is a program that is running on your computer</strong></font></p><ul><li>单核机器为什么给人<em>可以同时处理一堆程序</em> 的错觉？似乎和多核差不多？</li></ul><p>如下图，这些任务其实是依次执行，这叫<font color="#ef6d3b"><strong>并发 (concurrency)</strong></font>；<br><img src="/images/single-cpu.png" alt=""></p><p>如下图，对于多CPU机器，很多任务可以同时执行，这叫<font color="#ef6d3b"><strong>并行 (parallelism)</strong></font>；<br><img src="/images/multi-cpu.png" alt=""></p><hr><h3 id="进程间通信-Process-Communication">进程间通信 (Process Communication)</h3><p>进程间是互相独立，不共享任何数据的，那么跨进程如何交互呢？</p><ul><li><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <a href="https://www.tutorialspoint.com/what-is-interprocess-communication">What is Interprocess Communication?</a></li></ul><div class="admonition todo"><p class="admonition-title">进程通信的例子</p><p>linux grep、windows任务管理器...</p></div><hr><h3 id="什么是线程-thread">什么是线程 (<a href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html#:~:text=A%20thread%20is%20a%20basic,out%20at%20any%20given%20time.">thread</a>)</h3><ul><li><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><a href="https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread">What is the difference between a process and a thread?</a></li></ul><!-- 最直接的区别就是：<font color="#ef6d3b">**进程间不共享内存，但是线程是共享内存的！**</font> --><ul><li>先问一个问题：<font color="#ef6d3b">为什么需要线程，只靠进程不够使用吗？</font></li></ul><div class="admonition warning"><p class="admonition-title">假如OS中只有进程...</p><p>处理input的进程，每当用户敲击键盘，系统就要给出相应处理；想象当你以飞快的速度敲击作输入，而进程又处理不过来呢，电脑是不是就巨卡无比？</p></div><ul><li><p>多线程的意义：<strong>某个任务会阻塞，但又不希望影响到别的任务进行下去；</strong></p></li><li><p>如图所示：</p><ul><li><ol><li>线程存在于进程内，且多线程共享进程内存；</li></ol></li><li><ol start="2"><li>多线程间有自己的寄存器和堆栈，互不影响；<br><img src="/images/threads.png" alt=""></li></ol></li></ul></li><li><p>下图是windows的任务管理器，可以清楚得看到<font color="#FF1E10"><strong>进程</strong></font>与<font color="#1AAD19"><strong>线程</strong></font>之间的从属关系！</p></li></ul><p><img src="/images/task_manager.png" alt=""></p><hr><h3 id="什么是协程-coroutinue">什么是协程 (<a href="https://stackoverflow.com/questions/553704/what-is-a-coroutine">coroutinue</a>)</h3><ul><li>通俗讲，协程是对线程的一种更小粒度的划分 （这里就不多介绍了）</li></ul><div class="admonition note"><p class="admonition-title">扩展阅读</p><p><a href="https://www.csl.mtu.edu/cs4411.ck/www/NOTES/non-local-goto/coroutine.html">借助 C setjmp.h 实现简单的协程</a></p></div><hr><h2 id="2-Python">2. Python?</h2><p>写到这里突然扪心自问，这与python有何关系<span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>？<br>本来是使用Python2的<code>multiprocessing</code>和<code>subprocess</code>踩了坑，想写篇文章记录下；<br>但随着白天查阅资料，大多问题已然解决；<span class="github-emoji"><span>💪</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4aa.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>等以后有缘再来补上吧</p><hr><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://blog.csdn.net/luhao19980909/article/details/89403233">进程和线程的深入理解</a></li><li><a href="https://www.tutorialspoint.com/what-is-interprocess-communication">What is Interprocess Communication?</a></li><li><a href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html">Threads</a></li><li><a href="https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread">What is the difference between a process and a thread?</a></li><li><a href="https://stackoverflow.com/questions/553704/what-is-a-coroutine">What is a coroutine?</a></li><li><a href="https://www.csl.mtu.edu/cs4411.ck/www/NOTES/non-local-goto/coroutine.html">Building Coroutines</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源汇总帖（效率、专业知识）</title>
      <link href="/posts/FYK74B/"/>
      <url>/posts/FYK74B/</url>
      
        <content type="html"><![CDATA[<h2 id="效率工具">效率工具</h2><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://www.listary.com/">Listary</a></td><td style="text-align:left">全局文件搜索，类似于everything</td></tr><tr><td style="text-align:left"><a href="https://www.snipaste.com/">Snipaste</a></td><td style="text-align:left">截图神器，支持桌面悬浮、历史记录</td></tr><tr><td style="text-align:left"><a href="https://www.gpsoft.com.au/">Directory Opus</a></td><td style="text-align:left">Windows资源管理器 神器!</td></tr><tr><td style="text-align:left"><a href="https://www.scootersoftware.com/">Beyond Compare</a></td><td style="text-align:left">代码比对神器，看Diff</td></tr><tr><td style="text-align:left"><a href="https://github.com/zhongyang219/TrafficMonitor">Traffic Monitor</a></td><td style="text-align:left">CPU、内存监视器</td></tr></tbody></table><h2 id="网页工具">网页工具</h2><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://jsoncrack.com/editor">jsoncrack</a></td><td style="text-align:left">json在线可视化</td></tr><tr><td style="text-align:left"><a href="https://godbolt.org/">godbolt</a></td><td style="text-align:left">在线看python、cpp汇编</td></tr><tr><td style="text-align:left"><a href="https://www.speedscope.app/">speedscope</a></td><td style="text-align:left">在线生成火焰图</td></tr><tr><td style="text-align:left"><a href="https://blog.luckly-mjw.cn/tool-show/m3u8-downloader/index.html">m3u8-downloader</a></td><td style="text-align:left">网页m3u8视频下载</td></tr></tbody></table><h2 id="专业书籍">专业书籍</h2><ul><li><p><a href="https://raw.githubusercontent.com/TIM168/technical_books/master/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%8E%8B%E7%88%BD%E7%9D%80.pdf">《汇编语言》（王爽）</a><br>交叉：计算机系统架构 + 汇编 + Unix操作系统</p></li><li><p><a href="https://dokumen.tips/documents/data-abstraction-problem-solving-with-c-walls-and-mirrors-6th-edition.html">《Data Abstraction and Problem Solving With C++》</a><br>交叉：算法/数据结构 + C++11语言特性 + 设计模式与思想</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows Batch脚本</title>
      <link href="/posts/2R1N3XK/"/>
      <url>/posts/2R1N3XK/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><p>Batch(批处理)是 <em>Microsoft</em> 提供的一门基于cmd.exe解释器的脚本语言；客观讲很不好用，但是windows下开发尝尝难以避免；</p></div><hr><h2 id="Batch常用语法">Batch常用语法</h2><p><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <a href="https://en.wikibooks.org/wiki/Windows_Batch_Scripting"><font color="#ef6d3b"><strong>传送门: Windows Batch Scripting</strong></font></a></p><hr><h3 id="1-基本指令">1. 基本指令</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">作用</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:center"><font color="#FF1E10"><strong>echo</strong></font></td><td style="text-align:center">输出字符</td><td style="text-align:left"><font color="#1AAD19"><strong>echo hello world</strong></font></td></tr><tr><td style="text-align:center"><font color="#FF1E10"><strong>rem</strong></font></td><td style="text-align:center">注释</td><td style="text-align:left"><font color="#1AAD19"><strong>rem 这是一条注释</strong></font></td></tr><tr><td style="text-align:center"><font color="#FF1E10"><strong>pause</strong></font></td><td style="text-align:center">暂停命令</td><td style="text-align:left"><font color="#1AAD19"><strong>pause</strong></font></td></tr><tr><td style="text-align:center"><font color="#FF1E10"><strong>call</strong></font></td><td style="text-align:center">调用指定bat</td><td style="text-align:left"><font color="#1AAD19"><strong>call demo.bat</strong></font></td></tr><tr><td style="text-align:center"><font color="#FF1E10"><strong>start</strong></font></td><td style="text-align:center">调用exe</td><td style="text-align:left"><font color="#1AAD19"><strong>start demo.exe</strong></font></td></tr><tr><td style="text-align:center"><font color="#FF1E10"><strong>goto</strong></font></td><td style="text-align:center">跳转到:xx</td><td style="text-align:left"><font color="#1AAD19"><strong>goto 1    :1  call demo.bat</strong></font></td></tr><tr><td style="text-align:center"><font color="#FF1E10"><strong>set</strong></font></td><td style="text-align:center">设置变量</td><td style="text-align:left"><font color="#1AAD19"><strong>set path=C:\</strong></font></td></tr><tr><td style="text-align:center"><font color="#FF1E10"><strong>@</strong></font></td><td style="text-align:center">屏蔽回显</td><td style="text-align:left"><font color="#1AAD19"><strong>@echo off</strong></font></td></tr><tr><td style="text-align:center"><font color="#FF1E10"><strong>&gt;</strong></font></td><td style="text-align:center">重定向</td><td style="text-align:left"><font color="#1AAD19"><strong>echo test &gt; a.txt</strong></font></td></tr><tr><td style="text-align:center"><font color="#FF1E10"><strong>|</strong></font></td><td style="text-align:center">管道，前面的输出重定向到后面的命令</td><td style="text-align:left"><font color="#1AAD19"><strong>echo /Y | start demo.exe</strong></font></td></tr></tbody></table><hr><h3 id="2-高级语法">2. 高级语法</h3><h4 id="1-判断某个路径是否存在">1. 判断某个路径是否存在</h4><p><code>if exist C:\Python27\python.exe ( ... )</code></p><h4 id="2-寻找python的sys-path路径">2. 寻找python的sys path路径</h4><p><code>for /f %%p in ('where python') do(</code><br><code>set PY=%%p</code><br><code>exit</code><br><code>)</code></p><h4 id="3-关闭batch指令的打印（回显）">3. 关闭batch指令的打印（回显）</h4><p><code>@echo off</code></p><h4 id="4-利用管道回到命令行的输入请求">4. 利用管道回到命令行的输入请求</h4><p>可以将/Y作为输出传给后面的指令<br><code>echo /Y | xxxxx</code></p><hr><h3 id="3-建议">3. 建议</h3><p><font color="#ef6d3b"><strong>Windows Batch不是很好写，建议用Python脚本或Linux Shell…</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regex：正则表达式</title>
      <link href="/posts/3SAT4K7/"/>
      <url>/posts/3SAT4K7/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">NOTE</p><p><strong>regex：regular expressions</strong></p><p>本文介绍了正则表达式的基本常用语法</p><p>这篇文章有一些进阶regex应用 <a href="/posts/6X02Y7/">【vscode插件】function decoration</a></p></div><h2 id="Good-Resources">Good Resources</h2><ul><li><p><font color="#1A9BFF"><strong>下面是一些介绍Regex的网站</strong></font>：<br>这些内容很优秀，我写博客仅仅是为了自我记录、及筛选对自己有用的部分；</p><ul><li><a href="https://github.com/ziishaned/learn-regex">learn-regex (github)</a></li><li><a href="https://regexr.com/">Regex Online test</a></li><li><a href="https://regexone.com/">RegexOne</a></li><li><a href="https://regexlearn.com/">RegexLearn</a></li></ul></li><li><p>Regex在线调试:<br><a href="https://regex101.com/"><strong>regex101</strong></a></p></li><li><p>推荐一个在线Regex做题的网站，难度很高!<br><a href="https://alf.nu/RegexGolf"><strong>https://alf.nu/RegexGolf</strong></a></p></li><li><p>这是一个在线regex测试的网站：<br><a href="https://tool.oschina.net/regex/"><strong>https://tool.oschina.net/regex/</strong></a></p></li></ul><h2 id="Regex-Grammar">Regex Grammar</h2><h3 id="1-完全匹配">1.完全匹配</h3><p>1.区分大小写、空格等，严格匹配每个字母的顺序；<br>2.实际用<code>(xyz)</code>表示完全匹配；</p><ul><li><font color="#ef6d3b"><strong>(The)</strong></font> =&gt; <font color="#ef6d3b"><strong>The</strong></font> fat cat sat on the mat.</li></ul><h3 id="2-基本字符">2.基本字符</h3><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">用法</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">匹配换行符外的任意字符</td><td style="text-align:center"><font color="#ef6d3b"><strong>.ar</strong></font> =&gt; The <font color="#ef6d3b"><strong>car</strong></font> <font color="#ef6d3b"><strong>par</strong></font>ked in the <font color="#ef6d3b"><strong>gar</strong></font>age.</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:center">匹配[]内的任意字符</td><td style="text-align:center"><font color="#ef6d3b"><strong>[Tt]he</strong></font> =&gt; <font color="#ef6d3b"><strong>The</strong></font> car parked in <font color="#ef6d3b"><strong>the</strong></font> garage.</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">反义符</td><td style="text-align:center"><font color="#ef6d3b"><strong>[^c]ar</strong></font> =&gt; The car <font color="#ef6d3b"><strong>park</strong></font>ed in the <font color="#ef6d3b"><strong>gar</strong></font>age.</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">匹配$\geq0$个字符</td><td style="text-align:center"><font color="#ef6d3b"><strong>[a-z]</strong>*</font> =&gt; T<font color="#ef6d3b"><strong>he car parked in the garage</strong></font> #21.</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">匹配$\geq1$个字符</td><td style="text-align:center"><font color="#ef6d3b"><strong>c.+t</strong></font> =&gt; The fat <font color="#ef6d3b"><strong>cat sat on the mat</strong></font>.</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">?之前的为可选</td><td style="text-align:center"><font color="#ef6d3b"><strong>[T]?he</strong></font> =&gt; <font color="#ef6d3b"><strong>The</strong></font> car is parked in t<font color="#ef6d3b"><strong>he</strong></font> garage.</td></tr><tr><td style="text-align:center">{n, m}</td><td style="text-align:center">匹配$n\leq k\leq m$的重复次数</td><td style="text-align:center"><font color="#ef6d3b"><strong>[0-9]{3}</strong></font> =&gt; The number was 9.<font color="#ef6d3b"><strong>999</strong></font>7 but we rounded it off to <font color="#ef6d3b"><strong>10</strong></font>.0.</td></tr><tr><td style="text-align:center">(xyz)</td><td style="text-align:center">完全匹配</td><td style="text-align:center"><font color="#ef6d3b"><strong>the</strong></font> =&gt; The fat cat sat on <font color="#ef6d3b"><strong>the</strong></font> mat.</td></tr><tr><td style="text-align:center">A|B</td><td style="text-align:center">匹配A或B字符</td><td style="text-align:center"><font color="#ef6d3b"><strong>(c|g|p)ar</strong></font> =&gt; The <font color="#ef6d3b"><strong>car</strong></font> is <font color="#ef6d3b"><strong>par</strong></font>ked in the <font color="#ef6d3b"><strong>gar</strong></font>age.</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">转义，表示<code>[]().?</code>等</td><td style="text-align:center"><font color="#ef6d3b"><strong>\.</strong></font> =&gt; a<font color="#ef6d3b"><strong>.</strong></font>b</td></tr></tbody></table><h3 id="3-特殊匹配">3.特殊匹配</h3><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">用法</th><th style="text-align:center">等同于</th></tr></thead><tbody><tr><td style="text-align:center">\w</td><td style="text-align:center">所有数字or字母</td><td style="text-align:center">[a-zA-Z0-9_]</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">所有非数字or字母</td><td style="text-align:center">[^\w]</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">所有数字</td><td style="text-align:center">[0-9]</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">所有非数字</td><td style="text-align:center">[^\d]</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">所有空白字符</td><td style="text-align:center">[\t\n\f\r\p{Z}]</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">所有非空白字符</td><td style="text-align:center">[^\s]</td></tr></tbody></table><h2 id="Regex进阶">Regex进阶</h2><h3 id="g-m-i-Flags"><code>/g /m /i</code>: Flags</h3><table><thead><tr><th style="text-align:center">Flag</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">Case insensitive: 忽略大小写</td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">Global Search:全局匹配</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">Multiline: 匹配多行</td></tr></tbody></table><h3 id="lazy-matching"><code>?</code>: lazy matching</h3><p>默认的正则会匹配尽可能多满足条件的字符 (greedy matching)<br>通过使用<code>?</code>, 可以在第一次匹配到的时候即停止 (lazy matching)</p><table><thead><tr><th style="text-align:center">MODE</th><th style="text-align:center">grammar</th><th style="text-align:center">result</th></tr></thead><tbody><tr><td style="text-align:center">normal</td><td style="text-align:center"><code>/(.*at)/</code></td><td style="text-align:center"><code>The fat cat sat on the mat</code></td></tr><tr><td style="text-align:center">lazy</td><td style="text-align:center"><code>/(.*?at)/</code></td><td style="text-align:center"><code>The fat</code> cat sat on the mat</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Depth testing</title>
      <link href="/posts/2M66594/"/>
      <url>/posts/2M66594/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><p>深度测试，决定了投影空间下的物体是否被遮挡，即是否需要绘制；一些关键的技术，离不开精确的深度测试结果；</p></div><hr><h3 id="Depth-test-and-Depth-buffer">Depth-test and Depth-buffer</h3><ul><li><p>先阅读这篇文章：<br><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <a href="https://www.luhao.wiki/posts/2AR5BC4/">Occlusion: 可见性与剔除</a></p></li><li><p><font color="#ef6d3b"><strong>depth buffer</strong></font> (z-buffer)</p></li></ul><p>depth-buffer存储着每个pixel的深度信息（可以理解为一个0-1范围的float值）；<br>而depth-test就是<font color="#ef6d3b"><strong>写深度（write   depth-buffer）</strong></font>的过程</p><p><img src="/images/zbuffer.png" alt=""></p><div class="admonition warning"><p class="admonition-title">depth-test是在pixel shader后进行</p><p>为什么是这样的次序？如果在pixel shader之前做深度测试，有什么后果呢？</p></div><hr><h2 id="OpenGL-Code">OpenGL Code</h2><h4 id="glEnable">glEnable</h4><p>OpenGL是默认关闭深度测试的，因此需要手动开启它；<br>这句标志着，depth-buffer是可写的，且会在每一帧不断写入它；<br><code>glEnable(GL_DEPTH_TEST); </code></p><h4 id="glClear">glClear</h4><p>每一帧绘制完，需要手动清空这一帧的color-buffer和depth-buffer；<br>不然会残留上一帧的深度数据，导致显示Bug；<br><code>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  </code></p><h4 id="glDepthMask">glDepthMask</h4><p>当某一帧不想写深度了怎么办？<br>它用来标记depth-buffer是只读，还是可写；<br><code>glDepthMask(GL_FALSE);  </code></p><h4 id="glDepthFunc">glDepthFunc</h4><p>深度测试，会将每个pixel新的深度信息，与旧的比较，<font color="#ef6d3b">如果满足条件则通过（写入并覆盖旧值）</font>；<br>下面一些参数是不同的通过规则：</p><table><thead><tr><th style="text-align:center">Function</th><th style="text-align:center">Desc</th></tr></thead><tbody><tr><td style="text-align:center">GF_ALWAYS</td><td style="text-align:center">永不通过，后画的在前面，与远近无关</td></tr><tr><td style="text-align:center">GL_NEVER</td><td style="text-align:center">与上面相反</td></tr><tr><td style="text-align:center">GL_LESS</td><td style="text-align:center"><span class="github-emoji"><span>✔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 小值通过</td></tr><tr><td style="text-align:center">GL_EQUAL</td><td style="text-align:center">等于的通过</td></tr><tr><td style="text-align:center">GL_GREATER</td><td style="text-align:center">大于的通过，远的反倒画在前面</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><hr><h2 id="Depth-precision">Depth precision</h2><ul><li>z-value，也就是深度值，是怎么计算的呢？</li></ul><h3 id="线性方案：">线性方案：</h3><p><font color="#0288D1"><strong>$$Z = \frac {z - near} {far - near}， Z \in [0, 1]$$</strong></font></p><ul><li>缺点：<br>近处和远处的depth，拥有一样的精度；<br>是不是很浪费？游戏中我们更关注靠近相机的物体！</li></ul><h3 id="非线性方案：">非线性方案：</h3><p>不如把$z$取个倒数，这样是不是近处的精度就更大了呢？</p><p><font color="#0288D1"><strong>$$Z = \frac {1 / z - 1 / near} {1 / far - 1 / near}， Z \in [0, 1]$$</strong></font></p><p><img src="/images/depthvalue.png" alt=""></p><hr><h2 id="Debug输出z-buffer">Debug输出z-buffer</h2><div class="admonition todo"><p class="admonition-title">TODO</p><ol><li>调试输出，需要转化到NDC空间，感受下z-buffer的变化</li><li>多截图，多说明</li></ol></div><hr><h2 id="Z-fighting">Z-fighting</h2><p>这是一个常见的artifact：当两个三角面离得足够近（coplane）时，做深度测试时由于精度问题，导致两个三角面的计算结果总是反复横跳的，表现上是奇怪的锯齿花纹：</p><p><img src="/images/zfighting.png" alt=""></p><hr><h3 id="解决方案">解决方案</h3><ul><li><p>避免物体摆放过近；</p></li><li><p>增大近裁面的值，相当于提高了整体的z精度；</p></li><li><p>提高z-buffer的精度，比如从24bit -&gt; 32bit，但是带宽消耗也变大了；</p></li></ul><hr><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing">Depth-testing</a></li><li><a href="https://blog.devgenius.io/computer-graphics-depth-buffer-test-5c29807cf475">Depth Buffer and Z-fighting</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graphics </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Model and Mesh</title>
      <link href="/posts/2WF6HFQ/"/>
      <url>/posts/2WF6HFQ/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><p>实际的游戏开发中，（模型）美术会制作<code>fbx</code>,<code>max</code>等资源给程序使用;因此我们要讨论如何导入，以及如何渲染这些3D模型</p></div><hr><h2 id="3D-Formats">3D Formats</h2><p>美术使用的3D软件很多，如Blender、3DMax、Maya等等；<br>不同软件有自己的3D模型格式（虽然大都提供了互相导入导出），所以了解这些常见的格式很关键；</p><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">FBX</td><td style="text-align:center">含动画、材质、骨骼等</td></tr><tr><td style="text-align:center">glTF</td><td style="text-align:center">含动画、材质、骨骼等几乎所有信息</td></tr><tr><td style="text-align:center">OBJ</td><td style="text-align:center">仅模型和材质信息</td></tr></tbody></table><hr><h3 id="FBX">FBX</h3><p><font color="#ef6d3b"><strong>.FBX</strong></font> 是<em>MotionBuilder</em>使用的格式，它是一个动画制作平台；</p><ul><li>FBX支持动画、材质、贴图、骨骼、灯光、摄像机等信息；</li><li>FBX支持法线和贴图坐标，可以写入贴图路径；</li><li><a href="https://en.wikipedia.org/wiki/FBX">Wikipedia: FBX</a></li></ul><hr><h3 id="glTF">glTF</h3><p><font color="#ef6d3b"><strong>.gltf</strong></font> 是OpenGL和Vulkan背后的3D图形标准组织Khronos所定义，它具有最标准与精简的格式，可谓<strong>3D模型的JPG</strong>；</p><ul><li>gltf支持动画、材质、场景、摄像机等几乎所有，甚至可以包含shader程序；</li><li>gltf采用json的格式，因此可读性和兼容性很高；</li><li>gltf可以编译成二进制：bgltf；</li><li><a href="https://en.wikipedia.org/wiki/GlTF">wikipedia: GLTF</a></li></ul><hr><h3 id="OBJ">OBJ</h3><p><font color="#ef6d3b"><strong>.obj</strong></font> 是<em>Wavefront</em>公司推出的跨平台3D模型格式；</p><ul><li>OBJ是纯3D模型，不包含动画（区别FBX）、贴图路径、材质等信息；</li><li>OBJ支持法线和贴图坐标，但需要手动制认贴图；</li><li><a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">Wikipedia: Wavefront.obj</a></li></ul><p>这是一篇介绍OBJ的好文章: <span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <a href="http://www.opengl-tutorial.org/beginners-tutorials/tutorial-7-model-loading/">Tutorial 7 : Model loading</a></p><ul><li><font color="#ef6d3b"><strong>OBJ格式分析</strong></font></li></ul><p>这是一个简单的Cube的obj文件:</p><pre><code class="language-python"># Desc xxx 这里都是注释mtllib cube.mtl # mathlib或usemtl记录了使用的材质# v是vertexv 1.000000 -1.000000 -1.000000v 1.000000 -1.000000 1.000000...# vt是texture uvvt 0.748573 0.750412vt 0.749279 0.501284...# vn是normalvn 0.000000 0.000000 -1.000000vn -1.000000 -0.000000 -0.000000...# f是face, 描述每个三角面的v/vt/vns offf 5/1/1 1/2/1 4/3/1f 5/1/1 4/3/1 8/4/1</code></pre><p><font color="#ef6d3b"><strong>f（face）怎么理解</strong></font></p><ul><li>假设对于某一行：<code>f 8/11/7 7/12/7 6/10/7</code>：<ul><li><code>8/11/7</code>是三角面的第一个点；</li><li><code>7/12/7</code>是三角面的第二个点；</li><li><code>6/10/7</code>是三角面的第三个点；</li></ul></li><li>对于每个三角面：<ul><li><code>8</code>是指第8个vertex，找对应的<code>v</code>；</li><li><code>11</code>是指第11个vertex texture uv，找对应的<code>vt</code>；</li><li><code>7</code>是指第7个vertex normal，找对应的<code>vn</code>；</li></ul></li><li>以上利用了索引（indices）的思想，本质是用时间换空间，节省了内存！</li></ul><div class="admonition warning"><p class="admonition-title">动手尝试</p><p>这么看下来，是不是自己也可以写一个<code>obj</code>的解析器了呢？</p></div><hr><h2 id="Mesh">Mesh</h2><ul><li><strong>既然Model是由很多Mesh组成</strong>，那么什么是Mesh？</li></ul><p><font color="#ef6d3b">A mesh is a collection of vertices, edges and faces that define the shape of a 3D object.</font><br>mesh是一些顶点、边、面的组合，它们定义了一个3D物体的形状.</p><ul><li><strong>我们通常用triangle mesh来代表物体</strong>，为什么？</li></ul><p><font color="#ef6d3b">几乎任何图形都可以用多个三角形表示</font>，比如一个圆，可以是无数个三角形模拟而成；<br>所以三角面越多越复杂，往往意味着模型的面数越高、精度越高；（如下图）</p><p><img src="/images/triagnle_rabbit.png" alt=""></p><hr><h2 id="Assimp">Assimp</h2><ul><li><a href="http://assimp.org/">Open Asset Import Library</a>: 一款支持多种模型格式导入与加载的标准库</li></ul><p>下图是Assimp中一个model的架构：</p><p><img src="/images/assimp.png" alt=""></p><hr><h3 id="font-color-ef6d3b-Scene-font"><font color="#ef6d3b"><strong>Scene</strong></font></h3><p>scene包含一个RootNode指针，以及所有的Mesh和Material对象；</p><h3 id="font-color-ef6d3b-RootNode-font"><font color="#ef6d3b"><strong>RootNode</strong></font></h3><p>RootNode对象中的Children[]中，递归包含了所有Model的指针；<br>它还包含了所有的Mesh对象；</p><h3 id="font-color-ef6d3b-Mesh-font"><font color="#ef6d3b"><strong>Mesh</strong></font></h3><p>什么是Mesh？它包含了所有Rendering需要的信息：<font color="#1A9BFF"><strong>vertex（顶点）, normal（法线）, texture（贴图）, materials（材质）等…</strong></font></p><hr><h3 id="问题汇总">问题汇总</h3><ul><li><a href="http://www.4k8k.xyz/article/qq_36383623/85303483">“由于找不到assimp-vc140-mt.dll，无法继续执行代码。重新安装程序可能会解决此问题。”</a></li></ul><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://en.wikipedia.org/wiki/Category:3D_graphics_file_formats">3D graphics file formats</a></li><li><a href="https://www.quora.com/What-is-a-mesh-in-OpenGL">What is a mesh</a></li><li><a href="http://www.opengl-tutorial.org/beginners-tutorials/tutorial-7-model-loading/">Tutorial 7 : Model loading</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graphics </tag>
            
            <tag> Python </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客写作规范</title>
      <link href="/posts/docs/"/>
      <url>/posts/docs/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li>使用<code>push</code>指令代替hexo，一键生成、发布、更新config</li><li>常用文章自己指定 <code>abbrlink</code></li><li>较长文章开头写 思维导图 大纲</li></ul><!-- * hexo clean: 清除本地 cache* hexo g: 本地 generate（生成路径是`./public`）* hexo s: 本地 server* hexo d: 发布到 github.io* update_config.py: 更新文章数和发布日期 --></div><div class="markmap-container" style="height:350px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;为什么写博客&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2],&quot;f&quot;:true},&quot;v&quot;:&quot;5x reasons&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3],&quot;f&quot;:true},&quot;v&quot;:&quot;优秀博客汇总&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;<a href=\&quot;#博客特性\&quot;>博客特性</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5],&quot;f&quot;:true},&quot;v&quot;:&quot;Config&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6],&quot;f&quot;:true},&quot;v&quot;:&quot;todo：标记未完成&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7],&quot;f&quot;:true},&quot;v&quot;:&quot;top：置顶&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8],&quot;f&quot;:true},&quot;v&quot;:&quot;thumbnail：缩略图&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9],&quot;f&quot;:true},&quot;v&quot;:&quot;password：加密&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10],&quot;f&quot;:true},&quot;v&quot;:&quot;abbrlink：指定链接&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11],&quot;f&quot;:true},&quot;v&quot;:&quot;Description&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12],&quot;f&quot;:true},&quot;v&quot;:&quot;Heading&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13],&quot;f&quot;:true},&quot;v&quot;:&quot;Latex&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14],&quot;f&quot;:true},&quot;v&quot;:&quot;Code&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15],&quot;f&quot;:true},&quot;v&quot;:&quot;Emoji&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;警示框&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[16,17],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#警示框\&quot;>Admonition</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;#链接\&quot;>链接</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19],&quot;f&quot;:true},&quot;v&quot;:&quot;图片&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[19,20],&quot;f&quot;:true},&quot;v&quot;:&quot;文章锚点&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;媒体资源&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[21,22],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#图表\&quot;>iframe 图表</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[22,23],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#视频\&quot;>视频</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;<a href=\&quot;#更新日志-🎉\&quot;>更新日志</a>&quot;}],&quot;p&quot;:{}}"></svg></div><h2 id="为什么写博客">为什么写博客</h2><ul><li>📄 随时查阅的手册</li><li>✏️ 锻炼写文档的能力</li><li>💪 收获感，满足感，正向推动学习的坚持</li><li>💡 反复の增、删、该，是一个逐渐 “加深理解” 的过程</li><li>🎉 博客网页的不断打磨，是一个满足 “强迫症” 的过程</li></ul><p>虽然 <em>www.luhao.wiki</em> 公开了ip，但这是一个完全 “面向自己” 的博客</p><blockquote><p>汇总一些优秀的个人博客:</p><ul><li><a href="https://learn.lianglianglee.com/">lianglianglee 👍</a></li><li><a href="https://coolshell.cn/">酷壳 - CoolShell</a></li><li><a href="https://bot-man-jl.github.io/">BOT Man (Tecent)</a></li><li><a href="https://blog.codingnow.com/">云风的 Blog</a></li></ul></blockquote><h2 id="博客特性">博客特性</h2><ul><li><p><strong>Config</strong></p><ul><li><code>todo: true</code>: 标记未完成, 文章首页显示 📌TODO</li><li><code>top: xxx</code>: 置顶的序号, 文章首页显示 ⭐置顶</li><li><code>thumbnail: /images/xxx.png</code>: 首页的文章icon, 使用 <code>100x100</code> 的像素</li><li><code>password: xxx</code>: 加密, 但愿不会被破解</li></ul></li><li><p><strong>Description</strong></p><ul><li><code>描述xxx&lt;!-- more --&gt;</code>: 对应封面描述</li><li>当文章标题不够清晰时, 请在 “箭头处” 添加额外文字</li><li><img src="/images/whatsmore.png" alt=""></li></ul></li><li><p><strong>Heading</strong></p><ul><li>文章内标题以 <code>##</code> 开始, 样式会标注为棕红色</li><li>更低级的标题以 <code>###</code>, <code>****</code> 等开始</li></ul></li><li><p><strong>Latex</strong></p><ul><li>latex失效看后面的问题汇总</li><li>$sin \alpha + sin \beta = 2 sin \frac{\alpha + \beta}{2} cos \frac{\alpha + \beta}{2}$</li></ul></li><li><p><strong>Code</strong></p><ul><li>要标注代码的语言, 才能正确开启高亮</li></ul></li><li><p><strong>Emoji</strong></p><ul><li>表情仅用作<strong>视觉区分 or 强调</strong>，不要滥用</li><li>✔  ❌ 🔥  ⭐  🎉  💡</li></ul></li></ul><h2 id="警示框">警示框</h2><p><a href="https://squidfunk.github.io/mkdocs-material/reference/admonitions/">Admonition</a> 是一种基于html的警示样式, 规定语法如下:</p><pre><code>!!! NOTE/ERROR/TODO/WARNING title    paragraph ...</code></pre><div class="admonition note"><p class="admonition-title"> Admonition示例</p><ul><li>This is a demo for admonition.</li></ul></div><h2 id="链接">链接</h2><p>基本的链接格式是： <code>![text](link)</code>，其中两个部分要严格按照规范：</p><ul><li><p><strong>图片</strong><br>所有<code>png</code>、<code>gif</code>资源都放在 <code>./themes/pure/source/images/</code> 目录下，因此链接的格式为 <font color="#ef6d3b"><strong><code>![](/images/***.png)</code></strong></font></p></li><li><p><strong>文章锚点</strong><br>所有markdown h1, h2, h3都会插入html锚点，链接格式为 <font color="#ef6d3b"><strong><code>[text](#html-id)</code></strong></font>，注意最好填入 “html源码中的id值”，因为html源码会把空格、特殊字符等作一个替换</p></li></ul><h2 id="图表">图表</h2><ul><li>其实是内嵌html文件, 示例如下:</li></ul><pre><code class="language-html">&lt;iframesrc="https://luhao.wiki/html/render.html" 替换这里的htmlheight=500 width=100% 修改高度即可frameborder=0scrolling=yes&gt; 支持滚动条&lt;/iframe&gt;</code></pre><h2 id="视频">视频</h2><ul><li>利用html语法内嵌视频 (资源来源于w3school)</li></ul><p><video width="500" controls=""><source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4">你的浏览器不支持HTML5视频</video></p><pre><code class="language-html">&lt;video width="400" controls&gt;&lt;source src="https://www.w3schools.com/html/mov_bbb.mp4" type="video/mp4"&gt;你的浏览器不支持HTML5视频&lt;/video&gt;</code></pre><h2 id="更新日志-🎉">更新日志 🎉</h2><h3 id="备注-html报错">备注: html报错</h3><ul><li><code>Uncaught ReferenceError: $ is not defined?</code></li><li>确认 <code>*.ejs</code> 中填写的路径不要是绝对路径<ul><li>错误: <code>/images/a.png</code></li><li>正确: <code>images/a.png</code></li></ul></li></ul><h3 id="3月-首页文章新增-thumbnail-缩略图">3月, 首页文章新增 thumbnail 缩略图</h3><ul><li>修改 <code>themes/pure/layout/_partial/post/title.ejs</code>，根据<code>post</code>对应属性来添加html样式</li><li>所有缩略图在 <a href="https://icons8.com/icons">icons8</a> 网站使用 100x100 的png图标</li></ul><h3 id="4月7日-修复Latex失效问题">4月7日, 修复Latex失效问题</h3><ul><li>确保安装的包是 <code>hexo-renderer-mathjax</code></li><li>需要将<code>node_modules/hexo-renderer-mathjax/mathjax.html</code>中的script替换为:</li><li><code>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"&gt;&lt;/script&gt;</code></li></ul><h3 id="4月30日-优化代码高亮样式">4月30日, 优化代码高亮样式</h3><p>弃用 hexo原生的 <code>highlight.js</code>, 转投 <a href="https://github.com/googlearchive/code-prettify">google/code-prettify</a> 的怀抱, 目前功能如下:</p><ul><li>支持所有主流语言（带自动识别）</li><li>支持行号</li><li>字体编程友好 <code>Consolas</code></li><li>准备将 <code>inline-code</code> 仍然沿用之前的 橙色加外边框 <code>todo</code></li></ul><p>参考：<a href="http://masikkk.com/article/hexo-12-google-code-prettify/">Hexo 接入google高亮的教程</a></p><h3 id="5月5日-集成hexo指令到-push">5月5日, 集成hexo指令到 <code>push</code></h3><ul><li>命令为 <code>. push</code>, 点号表示在当前路径运行 push</li><li>考虑添加 git 提交次数, <code>git rev-list --all --count</code></li></ul><h3 id="6月4日，新增html-红色下划线样式">6月4日，新增html 红色下划线样式</h3><p>效果预览：<u class="error"><code>int *p = *a</code></u><br>借助html代码实现：</p><pre><code class="language-html">&lt;u class="error"&gt;text&lt;/u&gt;</code></pre><h3 id="6月11日，主页左侧新增分类栏">6月11日，主页左侧新增分类栏</h3><ul><li><p>实现方式为在 <code>header.ejs</code> 中遍历添加 <code>site.categories</code> 中的元素。<br>同时关闭了 “所有分类” 的按钮入口。</p></li><li><p>通过 <code>_config.yml</code> 的 <code>enable_left_categories</code> 字段控制开关</p></li></ul><h3 id="6月13日，上传图片脚本">6月13日，上传图片脚本</h3><ul><li><p>windows下通过一个 <code>push.bat</code>（放到环境目录）实现png上传到对应hexo目录</p></li><li><p>同时将 <code>id_rsa.pub</code> 拷贝到 <code>~/.ssh/authroized_keys</code> 下以避免密码输入</p></li></ul><pre><code class="language-bat">scp %1.png root@1.15.115.4:/root/hexo-workspace/themes/pure/source/images/%1.png</code></pre><h3 id="hexo-blog-encrypt-加密文本">hexo-blog-encrypt 加密文本</h3><p>此加密插件会在首页的缩略文字加上 “Here's something encrypted, password is required to continue reading.” 的文字，需要修改如下代码去除：</p><ul><li><code>node_modules/hexo-blog-encrypt/index.js</code></li><li>将 <code>data.excerpt = data.more = config.abstract;</code> 修改为 <code>data.more = config.abstract;</code></li></ul><h3 id="2023-6-18-迁移到新服务器">2023.6.18 迁移到新服务器</h3><ul><li><p>必要组件</p><ul><li>zsh ： <a href="/posts/2N8EPP4/">【Shell】oh-my-zsh</a></li><li>Node.js：  <a href="/posts/1T7TWH8/">Node.js</a></li><li>hexo：  <a href="/posts/16FHVSZ/">Hexo：轻量的博客框架</a></li></ul></li><li><p>迁移服务</p><ul><li>hexo 个人日志 ✔</li><li>apache 文件服务器 ✔</li><li>crontab ✔</li></ul></li><li><p>迁移ssh私钥和公钥</p><ul><li>直接拷贝 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 到新机器的对应目录下</li><li><code>ssh-add id_rsa</code></li><li>如果遇到报错，执行 <code>chmod 400 ~/.ssh/id_rsa</code></li></ul></li></ul><h3 id="支持思维导图-hexo-markmap">支持思维导图 hexo-markmap</h3><ul><li><a href="https://github.com/MaxChang3/hexo-markmap">Github: hexo-markmap</a></li><li><code>npm install hexo-markmap --save</code></li><li>通过缩进控制归属层级，示例如下</li></ul><pre><code class="language-markdown">{% markmap 300px %}# Testa## test1## test2# Testb## test1## test2{% endmarkmap %}</code></pre><ul><li>修复源码 <code>hexo-markmap/lib/template.js</code> 中自定义css的bug一处，配置的css路径为 <code>/html/markmap.css@0.2.7</code>，主要是修改了字体样式</li></ul><p>有空尝试另一种 <code>minimap</code>：<a href="https://hunterx.xyz/use-mindmap-in-hexo.html">https://hunterx.xyz/use-mindmap-in-hexo.html</a></p><h3 id="分类页切为首页样式">分类页切为首页样式</h3><ul><li>修改 <code>category.ejs</code>，将生成html的代码直接替换为 <code>index.ejs</code> 同款；</li><li><a href="https://github.com/593413198/hexo-workspace/commit/0ebb9bb576085e22bf26b0c750ef04686a969236">git commit</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lighting</title>
      <link href="/posts/S7WXS5/"/>
      <url>/posts/S7WXS5/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><p>lighting主要分为：平行光、点光、聚光灯；本文介绍了每种lighting的原理与实现细节；</p></div><hr><h2 id="Directional-Light">Directional Light</h2><ul><li><font color="#ef6d3b"><strong>平行光：</strong></font>（如太阳光）<ul><li>影响范围无限大</li><li>所有点强度一样，只受方向影响</li></ul></li></ul><p><img src="/images/directionallight.png" alt=""></p><ul><li>定义如下：</li></ul><pre><code class="language-c">struct DirectionalLight {    vec3 direction;      vec3 ambient;    vec3 diffuse;    vec3 specular;};void main(){  vec3 lightDir = normalize(-light.direction);  [...]}</code></pre><hr><h2 id="Point-Light">Point Light</h2><ul><li><font color="#ef6d3b"><strong>点光：</strong></font> （如电灯泡）<ul><li>影响范围是个球体</li><li>强度随距离衰减</li></ul></li></ul><p><img src="/images/pointlight.png" alt=""></p><h3 id="font-color-ef6d3b-Attenuation-font"><font color="#ef6d3b"><strong>Attenuation</strong></font></h3><p>怎么衡量这种衰减呢？</p><ul><li><font color="#ef6d3b"><strong>linear equation</strong></font></li></ul><p>强度随距离线性衰减，表现效果比较差！<br>$F{att} = 1.0 - dist / range$</p><ul><li><font color="#ef6d3b"><strong>quadiratic</strong></font></li></ul><p>强度随距离二次衰减，效果贴近现实！</p><p>$F{att} = \frac{1.0}{K{c} + K{l}*d + K{q} * d^2}$</p><p><a href="https://wiki.ogre3d.org/tiki-index.php?page=-Point+Light+Attenuation">Ogre3D’s Wiki</a>, 给了一些取值的参考;</p><hr><h2 id="Spot-Light">Spot Light</h2><ul><li><font color="#ef6d3b"><strong>聚光灯：</strong></font> (如手电筒)<ul><li>影响范围是个圆锥</li><li>强度随距离和半径衰减</li></ul></li></ul><p><img src="/images/spotlight.png" alt=""></p><div class="admonition todo"><p class="admonition-title">都是</p><ol><li>基于OpenGL撸一遍代码；</li><li>尝试抓帧看一看；</li><li>引擎层，尝试构建一个Lighting的forward管线；</li></ol></div><hr><h2 id="参考资料">参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Colors and Materials</title>
      <link href="/posts/SZGATA/"/>
      <url>/posts/SZGATA/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><p>自然界的颜色可以看做是由<strong>Ambient, Diffuse, Specular</strong>三种组成；不同的材质（Materials），决定了颜色的不同显示性质；</p></div><hr><h2 id="Colors">Colors</h2><ul><li><strong>物体的颜色是如何产生的？</strong></li></ul><p>观察下图: 太阳光包含所有可见色（7种），当照射在物体上时（如红色），<strong>只能反射大部分的红光</strong>，如下图所示:</p><p><img src="/images/colors.png" alt=""></p><hr><ul><li><strong>用公式表示简单的反射颜色:</strong></li></ul><p>$reflectColor = lightColor * ObjectColor$</p><ul><li><strong>RGB颜色表示:</strong></li></ul><p>$red = (1, 0, 0)$<br>$green = (0, 1, 0)$<br>$blue = (0, 0, 1)$</p><p>$black = (0, 0, 0)$<br>$white = (1, 1, 1)$</p><div class="admonition warning"><p class="admonition-title">为什么黑色是0, 白色是1?</p><ol><li><strong>从能量看</strong>：黑色能量最低，白色能量最高</li><li><strong>从反射公式看</strong>：黑色不反射任何颜色(0)，白色会反射任何颜色(1)</li></ol></div><hr><h2 id="Phong-lighting-model">Phong lighting model</h2><p>了解了Colors原理，我们学习如何表示现实中的lighting;</p><ul><li>三个组成: <font color="#ef6d3b"><strong>ambient + diffuse + specular</strong></font></li></ul><p><img src="/images/Phong.png" alt=""></p><h3 id="Ambient"><em>Ambient</em></h3><p><strong>环境光: 各种复杂光源反射的颜色，通常表现在较暗的环境下;</strong></p><ul><li>通常会取一个环境光强度(ambientStrength)，乘以光照强度，以计算ambient:</li></ul><p><font color="#ef6d3b"><strong>$color = ambientStrenth * lightColor * ObjectColor$</strong></font></p><h3 id="Diffuse"><em>Diffuse</em></h3><p><strong>漫反射光：直接光照反射的颜色，受光照角度的直接影响；</strong></p><ul><li><p>既然考虑角度，所以引入<font color="#1A9BFF"><strong>normal(法线)</strong></font>的概念：<strong>垂直于顶点所在平面的向量</strong></p></li><li><p>当光垂直入射平面，反射最强，平行入射则最弱；</p></li></ul><p><font color="#ef6d3b"><strong>$color = max(dot(normal, lightDir), 0.0) * lightColor * ObjectColor$</strong></font></p><div class="admonition warning"><p class="admonition-title">怎么算顶点法线?</p><p>todo</p></div><h3 id="Specular"><em>Specular</em></h3><p><strong>高光：光泽表面反射的颜色，</strong></p><p>如下图所示，当视角与光的反射角度越来越小时，我们看到的高光也会越来越强烈 （假设这是一面镜子）；<br>显然：高光强度是受 光入射角 + 面法线 + 视角 共同影响的；</p><p><img src="/images/specular.png" alt=""></p><p>与Diffuse的计算有一点区别，我们使用pow来让越接近反射光线的区域，反射强度越大；</p><p><font color="#ef6d3b"><strong>$color = pow(max(dot(reflectDir, viewDir), 0.0), 32) * lightColor * ObjectColor$</strong></font></p><div class="admonition todo"><p class="admonition-title">32的系数是什么？</p><p>用作pow的系数越大，表示高光影响的范围越小，高光强度也越大；下图可以看到不同系数的效果；</p></div><p><img src="/images/specular_pow.png" alt=""></p><hr><ul><li>最后如何叠加三种颜色呢？<br><font color="#ef6d3b"><strong>$color = ambient + diffuse + specular$</strong></font></li></ul><hr><h2 id="Materials">Materials</h2><ul><li>什么是材质？<br>自然界中，不同物体对光照的反应不同；<br>木头和水泥不会对光产生很强的反射，他们几乎没有高光；但水晶和镜子就会显得闪闪发光…<br>它们本质是各种反射属性和数值的组合，我们将它定义为<font color="#ef6d3b"><strong>Materials(材质)</strong></font></li></ul><pre><code class="language-c">#version 330 corestruct Material {    vec3 ambient;    vec3 diffuse;    vec3 specular;    float shininess; // pow的指数, 衡量高光区域}; uniform Material material;</code></pre><ul><li>对应的，我们也可以维护灯光的简单属性:</li></ul><pre><code class="language-c">struct Light {    vec3 position;      vec3 ambient;    vec3 diffuse;    vec3 specular;};uniform Light light;  </code></pre><ul><li>下面看一个使用材质和灯光属性的示例：</li></ul><pre><code class="language-c">// lighting propertieslightingShader.setVec3("light.ambient", 0.2f, 0.2f, 0.2f);lightingShader.setVec3("light.diffuse", 0.5f, 0.5f, 0.5f);lightingShader.setVec3("light.specular", 1.0f, 1.0f, 1.0f);// material propertieslightingShader.setVec3("material.ambient", 1.0f, 0.5f, 0.31f);lightingShader.setVec3("material.diffuse", 1.0f, 0.5f, 0.31f);lightingShader.setVec3("material.specular", 0.5f, 0.5f, 0.5f); // specular lighting doesn't have full effect on this object's materiallightingShader.setFloat("material.shininess", 32.0f);</code></pre><p><img src="/images/lighting_demo.png" alt=""></p><hr><h2 id="Lightmap">Lightmap</h2><ul><li>想象在实际工作中，我们怎么制定一个真实物体的Materials呢？</li></ul><p>这就是美术同学的工作啦，在编辑器中<strong>指定diffuse、specular、normal等贴图</strong>，这样就赋予了它复杂而美丽的纹理；</p><h3 id="Shader-Sampler">Shader Sampler</h3><p><strong>shader提供了sampler2D，它能够读取各种格式的图片；</strong></p><pre><code class="language-c">struct Material {    sampler2D diffuse;    sampler2D specular;    float     shininess;}; in vec2 TexCoords;uniform Material material;</code></pre><ul><li>感受一下带了diffuse和specular贴图的效果：</li></ul><p><img src="/images/lightmap.png" alt=""></p><hr><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://learnopengl.com/Lighting/Colors">LearOpenGL-Colors</a></li><li><a href="https://learnopengl.com/Lighting/Basic-Lighting">LearOpenGL-Basic Lighting</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次来家的小边牧</title>
      <link href="/posts/25374YZ/"/>
      <url>/posts/25374YZ/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f7f82aef30dc843aa19391473b9896ed7f6c645c482de356d4f2486ec8b060e9">b3dc07a81f6459d120ce338ccca5504603780459e0306826441972681af56d62e5c8df8a8c8b786c064334936495b3bf83228f3b2ead8556cc3cb8048ae26847c8e914621b496b7004fe6882233afe5393b8f32076abfef2f234949bd027a34fbf09d28542fb2cc9c5f9882b568746dcc9aea531b78b578a89781affff46dd1fa58374a252f3877e2b223950d522ca7cacd9c23dee53d4b8288a5801e1c270173893a321c6d4866a1106b1f2e3d1bd31cfb33f0ef0bbd13a9a6e3efa3041006a6d1576d762df28279bb82c05381621827456933196e65ce91c8a134de12c5d48bc681e9207fa4387d1f13347d00eeb4e7190aef02c9513be1e862bb60500d43c83233e444878c99296bfe050082bd5cdf2f32703a2b57f2d5928be52b3366befa83be0205358c86a0fce6a5508a95d0617cadca5c8480cc959948670fa465a55b5f6c427a93185c1cf24271dd50957cf2e5b471f307e600f0c25322309622fa1b1c82e5afc3d54ebcd43e8a7f03e3b5176df84df132992817a53fb25162159aa8f03c78fd67b3b81f4d3595886a042e2e1a0206922bcb6b55d9b50aa83df3c5a70b3247450adbb77dbe39633af9649e89833d053d297fb8b73ee37ef9622bdff7e9b3c02c239613c0c3e0036761d286765d189d5438dcca12ba9ecca925c4fdab1d40880b9a21be5c1361c7f7975b724504e50e32909f9bec7b70c6c1d233363194069cdc2ba141128e908f6fc86a5972e30e57f0488a239f64b4e7d5d31a19f4df49d62fba002a1582c6132b6c2477ae4144a67c9fb67f678b5c690751403a12cfef8634f3e4fd581848f8315f480765fed82ed91d6d2409be289d9cc00bed14e07f70916af1c4edede9b247687347b5ce51f51a4edfb73adfd1e2adbc6ed857a2673f9186802d37db3d031e4dc3d0f7b2d34334fb86e37a07620e1d31bd5b4a2b6f94846c89be35ceb990c9c3519777b6b79b5891ae6172af4e3022497c29242e0d8bb3c43d60a15698d9920f9467d7b405ef0aa77bd8238b748756df5f948b13bd8897c0193c5b6f7d09629328daf529260519b8978c33c8575b273f692cb92fcbc5d68f7cae83734753c61e50291a4519333669048d4c5b9b178ec8c9200c00b323beabe7af5d16f7246d89e49e18349103172f558bbde40e2bb49ee930611d333dff7114201598e391867be30b19af33792be16be58f377a0dab347d6fc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Textures</title>
      <link href="/posts/1EF3PT0/"/>
      <url>/posts/1EF3PT0/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><p>Textures 纹理，让游戏中的物体拥有丰富的色彩表现；其本质是，如何将顶点坐标映射到uv坐标；</p></div><hr><h2 id="What-is-texture">What is texture?</h2><ul><li><p><font color="#ef6d3b"><strong>A texture is a 2D image (even 1D/3D exist) to add detail to objects;</strong></font></p></li><li><p><font color="#ef6d3b"><strong>Texture coord.</strong></font><br>纹理坐标，又称$uv$坐标，是$[0,1]$的浮点数；<br>对于下图我们尝试如下定义$uv$坐标：</p></li></ul><pre><code class="language-c">float texCoords[] = {    0.0f, 0.0f,  // lower-left corner      1.0f, 0.0f,  // lower-right corner    0.5f, 1.0f   // top-center corner};</code></pre><hr><h2 id="Texture-Wrapping">Texture Wrapping</h2><p>对于超过$(0,0)$和$(1,1)$的uv坐标，我们如何去填充呢？<br>OpenGL提供了如下几种方式：<br><img src="/images/texture_wrapping.png" alt=""></p><hr><h2 id="Texture-Filtering">Texture Filtering</h2><ul><li><font color="#ef6d3b"><strong>Determine the texture mapped uv (using the nearby pixels…)</strong></font></li></ul><p>想象CPU传来的$uv$坐标是$(0.3, 0.3)$，纹理尺寸是$64 * 64$；<br>通过计算$0.3*64$，我们得到应该采样$(19.2, 19.2)$；<br>那么问题来了，像素是一块一块采样的，$19.2$到底采哪里呢？</p><ul><li>如下两种情形必然会出现错误：<ul><li><ol><li><strong>纹理大于模型表面</strong>：多对少，错位与丢失像素；</li></ol></li><li><ol start="2"><li><strong>纹理小于模型表面</strong>：少对多，马赛克；</li></ol></li></ul></li></ul><div class="admonition note"><p class="admonition-title">note</p><p>想象一张图片，经过缩小，会看不清；经过放大，会出现马赛克；就是这个意思</p></div><p><strong>OpenGL给了如下两种基本方案:</strong></p><h3 id="1-nearest-neighbor-filtering">1. nearest-neighbor filtering</h3><ul><li>选取离周围4个pixel最近的一个；<br><img src="/images/nearest_neighbour.png" alt=""></li></ul><h3 id="2-bilinear-filtering">2. bilinear filtering</h3><ul><li><p>取周围4个pixel取均值；<br><img src="/images/linear.png" alt=""></p></li><li><p>两种filtering效果对比：<br><img src="/images/filtering.png" alt=""></p></li></ul><h3 id="3-trilinear-filtering">3. trilinear filtering</h3><ul><li>由于bilinear是在同一个Mipmap level做平滑，因此tri-filtering考虑了最接近的两层Mipmap level，并对最后结果做一次线性平滑；</li></ul><h3 id="4-anisotropic-filtering">4. <a href="https://en.wikipedia.org/wiki/Anisotropic_filtering">anisotropic filtering</a></h3><ul><li>前面是基于Texture与模型表面平行下，如果两者形成角度，就会有如下Artifacts；</li><li>4X AF表示需要多采样4倍的pixel；16X同理；</li></ul><p><strong>想象一下，当图片倾斜与平面，我们需要采样更多的点来涂满这个区域!</strong></p><p><img src="/images/anisotropic.png" alt=""></p><div class="admonition todo"><p class="admonition-title">FAQ</p><ol><li>这里要扣一下原理与Coding!</li><li>AF都用硬件做了，但可以尝试用Pixel Shader模拟下玩玩</li></ol></div><h3 id="5-Performance-★">5. Performance ★</h3><ul><li>采样的像素数越多，性能开销越大~</li></ul><table><thead><tr><th style="text-align:center">Filering</th><th style="text-align:center">Samples</th></tr></thead><tbody><tr><td style="text-align:center">nearest-neighbor</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">bilinear</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">trilinear</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">AF 4X</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">AF 16X</td><td style="text-align:center">128</td></tr></tbody></table><hr><h2 id="Mipmaps">Mipmaps</h2><p>想象三维空间成千上万的物体，如果远处的与近处拥有一样大小精度的纹理（贴图），是不是很浪费呢？（远处的成像后未必看得清楚）<br>并且，大纹理映射到小物体，更导致一些列<font color="#ef6d3b"><strong>Artifacts</strong></font>；</p><ul><li><font color="#ef6d3b"><strong>a collection of texture images where each subsequent texture is twice as small compared to the previous one.</strong></font></li></ul><p><img src="/images/mipmap.png" alt=""></p><ul><li><code>glGenerateMipmaps</code>: 帮助我们为一张Texture创建对应的Mipmap；</li></ul><hr><h2 id="Coding实现">Coding实现</h2><p><strong>Vertex data格式:</strong></p><ul><li>单单Pos和Color已经不能满足要求，我们需要扩充一个uv坐标来用于纹理采样</li></ul><p><img src="/images/texture_vertex.png" alt=""></p><pre><code class="language-c">float vertices[] = {    // positions          // colors           // texture coords     0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   1.0f, 1.0f,   // top right     0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   1.0f, 0.0f,   // bottom right    -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.0f, 0.0f,   // bottom left    -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.0f, 1.0f    // top left };</code></pre><hr><p><strong>Vertex Shader:</strong></p><ul><li>根据上面Vertex Data的格式，得出location分别是pos, color, texture：</li></ul><pre><code class="language-c">#version 330 corelayout (location = 0) in vec3 aPos;layout (location = 1) in vec3 aColor;layout (location = 2) in vec2 aTexCoord;out vec3 ourColor;out vec2 TexCoord;void main(){    gl_Position = vec4(aPos, 1.0);    ourColor = aColor;    TexCoord = aTexCoord;}</code></pre><p><strong>Pixel Shader:</strong></p><ul><li>pixel shader只需要输出颜色即可</li></ul><div class="admonition note"><p class="admonition-title">Texture Sampler</p><p>如何将texture传给GPU呢？GLSL提供了一个Sampler的东西；<strong>看ps中的sampler2D</strong></p></div><pre><code class="language-c">#version 330 coreout vec4 FragColor;in vec3 ourColor;in vec2 TexCoord;// texture sampleruniform sampler2D texture1;void main(){FragColor = texture(texture1, TexCoord);}</code></pre><hr><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://www.cnblogs.com/cxrs/archive/2009/10/18/justaprogramer.html">纹理过滤模式中的Bilinear、Trilinear以及Anistropic Filtering</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shaders</title>
      <link href="/posts/3GZKBFK/"/>
      <url>/posts/3GZKBFK/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><p>Shader, 理解为一种GPU Program不要尝试用中文翻译它!</p></div><hr><h2 id="Graphics-Pipeline">Graphics Pipeline</h2><ul><li><font color="#ef6d3b"><strong>The process of transforming 3D coordinates to 2D pixels</strong></font></li></ul><p>我曾尝试去理解什么是“渲染管线”？ 这其实是一个很抽象的翻译，不仿用<strong>造房子</strong>来比喻。<br>建筑工程，其实是<strong>从设计图纸到高楼大厦</strong>的过程，其中有画设计图、打地基、该楼层、装修，等等。<br>渲染管线恰恰与他相反，是一个<strong>把高楼大厦复原到图纸（即屏幕）上</strong>的过程。</p><ul><li><p>渲染管线，即从<strong>三维模型处理到最终二维的屏幕输出</strong>。</p><ul><li>从上面图片可以看一个大概的流程 （当然实际应用复杂的多！）</li></ul></li><li><p><strong>Shaders</strong>: <font color="#ef6d3b"><strong>small programs running on GPU.</strong></font></p></li><li><p>vertex and pixel shader is <strong>neccessary</strong> in OpenGL!</p></li></ul><hr><h3 id="1-Vertex-Shader">1. Vertex Shader</h3><ul><li><font color="#ef6d3b"><strong>Takes a single point and can adjust it.</strong></font></li></ul><p>这一步是为了处理顶点数据，对Vertex坐标做各种变化，然后再输出给Geometry/Pixel Shader；</p><div class="admonition todo"><p class="admonition-title">FAQ</p><p>Vertex Shader会处理颜色吗？是否存Color属性呢？</p></div><hr><h3 id="2-Geometry-Shader">2. Geometry Shader</h3><ul><li><p><font color="#ef6d3b"><strong>Takes each transformed primitive (triangle, etc) and can perform calculations on it.</strong></font></p></li><li><p>处理图元数据，输入可以是三角形等，可以输出多种三角形</p></li></ul><hr><h3 id="3-Rasterization">3. Rasterization</h3><ul><li><font color="#ef6d3b"><strong>maps the resulting primitives to the corresponding pixels on the final screen.</strong></font></li></ul><p>光栅化负责将所有Vertex坐标，映射到不同分辨率的显示屏上；<br>这里有很多研究领域，比如**采样、抗锯齿（AA）**等等；</p><hr><h3 id="4-Pixel-Shader-Fragment-Sahder">4. Pixel Shader (Fragment Sahder)</h3><ul><li><font color="#ef6d3b"><strong>Calculates the colour of a pixel on the screen based on vertex shader, textures and others (shadow, lighting…).</strong></font></li></ul><p>这是渲染管线比较重要的一步；<br>常见的<strong>贴图、光、阴影</strong>等各种着色都在这里计算；<br>因此，Nvidia又称之为<font color="#ef6d3b"><em><strong>Texture Shader</strong></em></font></p><hr><h3 id="5-Alpha-test-and-Blending">5. Alpha test and Blending</h3><ul><li><p>alpha test:</p></li><li><p>blending</p></li></ul><p><strong>透明材质、混合材质</strong>等，由于其特殊性，会在渲染管线比较靠后的位置；不然怎么表现透明呢？</p><hr><h2 id="Pratice-第一个Shader">Pratice: 第一个Shader</h2><h3 id="Vertex-data">Vertex data</h3><ul><li><font color="#ef6d3b"><strong>NDC</strong></font>: Normalized Device Coordinates.<ul><li>vertex shader的输入，就是定义在NDC坐标下.</li><li>如下我们定义一个三角形:</li></ul></li></ul><pre><code class="language-c">float vertices[] = {    -0.5f, -0.5f, 0.0f,     0.5f, -0.5f, 0.0f,     0.0f,  0.5f, 0.0f};  </code></pre><p><img src="/images/NDC.png" alt=""></p><ul><li>接下来，我们要将这些数据传给GPU，用于Vertex Shader的计算！<ul><li><font color="#ef6d3b"><strong>VBO</strong></font>：Vertex Buffer Objects，存放以上数据的GPU Memory</li><li>OpenGL有很多VBO的类型：<code>GL_ARRAY_BUFFER</code>是比较常用的;</li></ul></li></ul><pre><code class="language-c">unsigned int VBO;glGenBuffers(1, &amp;VBO);glBindBuffer(GL_ARRAY_BUFFER, VBO);</code></pre><ul><li>glBufferData: 将顶点数据真正的喂给GPU</li></ul><pre><code class="language-c">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</code></pre><h3 id="Vertex-Shader">Vertex Shader</h3><ul><li>后面会介绍一些简单的语法:</li></ul><pre><code class="language-c">#version 330 corelayout (location = 0) in vec3 aPos;void main(){    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);}</code></pre><h3 id="Compile-Vertex-Shader-run-time">Compile Vertex Shader (run-time)</h3><ul><li>先对char[]编译，后续会扩展开发!</li></ul><pre><code class="language-c">const char *vertexShaderSource = "#version 330 core\n"    "layout (location = 0) in vec3 aPos;\n"    "void main()\n"    "{\n"    "   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"    "}\0";</code></pre><ul><li>如何编译VS?</li></ul><pre><code class="language-c">unsigned int vertexShader;vertexShader = glCreateShader(GL_VERTEX_SHADER);glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);glCompileShader(vertexShader);</code></pre><h3 id="Pixel-Shader">Pixel Shader</h3><ul><li>同理，ps更关心的是color，vs则关心位置</li></ul><pre><code class="language-c">const char *fragmentShaderSource = "#version 330 core\n""out vec4 FragColor;\n""void main()\n""{\n""   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n""}\n\0";unsigned int fragmentShader;fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);glCompileShader(fragmentShader);</code></pre><h3 id="Link-and-Combine">Link and Combine</h3><ul><li>Shader编译完，需要链接并整合起来</li></ul><pre><code class="language-c">unsigned int shaderProgram;shaderProgram = glCreateProgram();glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);glLinkProgram(shaderProgram);</code></pre><ul><li>渲染线程中开始绘制: glUserProgram()</li></ul><pre><code class="language-c">glUseProgram(shaderProgram);// 记得回收glDeleteShader(vertexShader);glDeleteShader(fragmentShader);  </code></pre><ul><li><font color="#ef6d3b"><strong>到这里我们通过vs+ps实现了一个三角形的绘制!</strong></font></li></ul><h3 id="EBO-element-buffer-objects">EBO: element buffer objects</h3><ul><li>假设我们需要画一个正方形, 那么需要两个三角形，即如下6个点:</li></ul><pre><code class="language-c">float vertices[] = {    // first triangle     0.5f,  0.5f, 0.0f,  // top right     0.5f, -0.5f, 0.0f,  // bottom right    -0.5f,  0.5f, 0.0f,  // top left     // second triangle     0.5f, -0.5f, 0.0f,  // bottom right    -0.5f, -0.5f, 0.0f,  // bottom left    -0.5f,  0.5f, 0.0f   // top left}; </code></pre><ul><li><font color="#ef6d3b"><strong>是不是很浪费?</strong></font><ul><li>因为其中两个顶点可以复用，所以其实4个Vertex就够啦！</li><li>尝试用vertex + indices，用4个vertex画出一个正方形!</li></ul></li></ul><pre><code class="language-c">float vertices[] = {     0.5f,  0.5f, 0.0f,  // top right     0.5f, -0.5f, 0.0f,  // bottom right    -0.5f, -0.5f, 0.0f,  // bottom left    -0.5f,  0.5f, 0.0f   // top left };unsigned int indices[] = {  // note that we start from 0!    0, 1, 3,   // first triangle    1, 2, 3    // second triangle};unsigned int EBO;glGenBuffers(1, &amp;EBO);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); // 这里指定用EBO+索引的方式，省了2个VertexglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre><hr><h2 id="Shaders语法">Shaders语法</h2><h3 id="先看代码示例">先看代码示例</h3><pre><code class="language-c">#version version_numberin type in_variable_name;in type in_variable_name;out type out_variable_name;  uniform type uniform_name;  void main(){  // process input(s) and do some weird graphics stuff  ...  // output processed stuff to output variable  out_variable_name = weird_stuff_we_processed;}</code></pre><h3 id="1-Types">1. Types</h3><ul><li>vec类型</li></ul><pre><code class="language-c">vec2 vect = vec2(0.5, 0.7);vec4 result = vec4(vect, 0.0, 0.0);vec4 otherResult = vec4(result.xyz, 1.0);</code></pre><h3 id="2-In-and-out">2. In and out</h3><ul><li><p>#version: opengl版本</p></li><li><p>in: shader的输入</p></li><li><p>out: shader的输出</p></li><li><p><font color="#ef6d3b"><strong>Vertex Shader需要 <code>layout</code>关键词来获取vertex data</strong></font></p><ul><li>location = 0 代表采的indice</li></ul></li></ul><pre><code class="language-c">#version 330 corelayout (location = 0) in vec3 aPos; // the position variable has attribute position 0  out vec4 vertexColor; // specify a color output to the fragment shadervoid main(){    gl_Position = vec4(aPos, 1.0); // see how we directly give a vec3 to vec4's constructor    vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // set the output variable to a dark-red color}</code></pre><ul><li><font color="#ef6d3b"><strong>Pixel Shader的输出必然是一个vec4的Color</strong></font></li></ul><pre><code class="language-c">#version 330 coreout vec4 FragColor;  in vec4 vertexColor; // the input variable from the vertex shader (same name and same type)  void main(){    FragColor = vertexColor;} </code></pre><h3 id="3-Uniforms">3. Uniforms</h3><ul><li><p><font color="#ef6d3b"><strong>uniforms是一种重要的从CPU-&gt;GPU传数据的方式</strong></font></p></li><li><p>uniforms是global变量，任意stage的任意shader都可以访问!</p><ul><li>换个思路，它是不是很费很耗？</li></ul></li></ul><hr><h2 id="Shader通用框架开发-★★★">Shader通用框架开发 ★★★</h2><ul><li>痛点1：咱们总不能每次写个Char*去编译Shader吧？</li><li>痛点2：PC(dx11)到android(gl)到ios(meta)的shader互不兼容，我们每个平台都要写一遍shader吗? (<font color="#ef6d3b"><strong>fuck</strong></font>)</li></ul><h3 id="Writing-Compiling-and-Managing-Shaders">Writing, Compiling and Managing Shaders</h3><ul><li><p>Github Page: <a href="https://github.com/593413198/Garen/blob/master/Garen/gshader.cpp"><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> gshader.cpp</a></p></li><li><p><a href="https://github.com/593413198/Garen/tree/master/Garen/shader">./shader</a>目录：存放所有vs/ps源码</p></li></ul><hr><h2 id="问题汇总">问题汇总</h2><h3 id="1-OpenGL的VAO、VBO、EBO区别">1. OpenGL的VAO、VBO、EBO区别?</h3><ul><li>VBO: 存储大量顶点信息，给Vertex Shader用</li><li>VAO: 告诉GPU如何使用VBO，使用哪个VBO</li><li>EBO: 利用索引节省Vertex的内存开销</li></ul><p><img src="/images/vbo_vao.png" alt=""></p><h3 id="2-Vertex-shader与Pixel-shader的区别">2. Vertex shader与Pixel shader的区别?</h3><ul><li>Vertex shader：对顶点坐标作运算；</li><li>Pixel shader：对每个像素的颜色作运算；（Nvidia又称之为Texture Shader)</li></ul><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://stackoverflow.com/questions/832545/what-are-vertex-and-pixel-shaders">Stackoverflow: What are Vertex and Pixel shaders?</a></li><li><a href="https://learnopengl.com/Getting-started/Hello-Triangle">LearOpenGL: Hello-Triangle</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graphics </tag>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git操作指南</title>
      <link href="/posts/git/"/>
      <url>/posts/git/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><p><code>Git</code>使用指南；<br>汇总了使用<code>Git</code>时遇到的一些坑!</p></div><h2 id="Git原理">Git原理</h2><ul><li><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 这篇文章讲得非常棒：<a href="https://labuladong.gitee.io/algo/di-si-zhan-4baf4/gitsql-zhe-326e1/"><strong>我用四个命令概括了 GIT 的所有套路</strong></a></li></ul><p>Git本质是：<strong>三个分支之间的状态转移与维护</strong>：</p><ul><li><font color="#ef6d3b"><strong>work dir</strong></font>：自己的工作目录</li><li><font color="#ef6d3b"><strong>stage</strong></font>：本地暂存区（缓冲）</li><li><font color="#ef6d3b"><strong>history</strong></font>：本地历史区（永久保存）</li></ul><p><img src="/images/git.png" alt=""></p><h2 id="Git操作">Git操作</h2><p><font color="#ef6d3b"><strong>man git</strong></font></p><pre><code>git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]    [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]    [-p|--paginate|-P|--no-pager] [--no-replace-objects] [--bare]    [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]    [--super-prefix=&lt;path&gt;] [--config-env=&lt;name&gt;=&lt;envvar&gt;]    &lt;command&gt; [&lt;args&gt;]</code></pre><h2 id="Git问题">Git问题</h2><ul><li><p>fatal: unable to access <a href="https://github.com/xxx.git/:Failed">https://github.com/xxx.git/:Failed</a> to connect to <a href="http://github.com">github.com</a> port 443: Timed out</p><ul><li><a href="https://stackoverflow.com/questions/18356502/github-failed-to-connect-to-github-443-windows-failed-to-connect-to-github">stackoverflow</a></li><li>尝试 <code>git config --global --unset https.proxy</code></li></ul></li><li><p>Git Error: OpenSSL SSL_read: Connection was reset, errno 10054</p><ul><li>…</li></ul></li></ul><h2 id="Git插件">Git插件</h2><p>VSCode推荐使用 GitLens 插件, 支持逐行实时Blame, 但是似乎收费?</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【Algorithm】String matching</title>
      <link href="/posts/1RJC6HF/"/>
      <url>/posts/1RJC6HF/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><p>linux grep的效率令人称奇!字符串匹配的常用算法与原理；</p></div><hr><h2 id="字符串匹配算法">字符串匹配算法</h2><p><strong>问题描述</strong><br>在父串$(String, len=n)$中寻找一个合法子串$(Pattern, len=m)$；<br>例如，<code>abcdef</code>的一个合法子串是<code>abc</code>，但<code>ac</code>就不是</p><div class="admonition warning"><p class="admonition-title">warning</p><p>不要尝试写代码和图解，侧重算法思想和推导过程！如果连一个非CS专业的都能看懂，那才叫棒；</p></div><hr><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">精髓</th></tr></thead><tbody><tr><td style="text-align:center"><font color="#ef6d3b"><em><strong>Brute Force</strong></em></font></td><td style="text-align:center">$O(nm)$</td><td style="text-align:center">有脑子就行</td></tr><tr><td style="text-align:center"><font color="#ef6d3b"><em><strong>Robin-Karp</strong></em></font></td><td style="text-align:center">$O(n+km)$</td><td style="text-align:center"><em>字符串Hash</em>，$k$ 是<em>hash hit</em>但不匹配的次数</td></tr><tr><td style="text-align:center"><font color="#ef6d3b"><em><strong>KMP</strong></em></font></td><td style="text-align:center">$O(n+m)$</td><td style="text-align:center">LPS数组</td></tr><tr><td style="text-align:center"><font color="#ef6d3b"><em><strong>Boyer-Moore</strong></em></font></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><font color="#ef6d3b"><em><strong>Sunday</strong></em></font></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><hr><h3 id="暴力匹配">暴力匹配</h3><p>两层$for$循环的遍历：<br>父串$S$中共有$n$个长度为$m$的子串，复杂度$O(n)$<br>将长度为$m$的子串与$Pattern$逐字符比较，复杂度$O(m)$<br>暴力的复杂度是$O(nm)$；</p><hr><h3 id="Robin-Karp算法">Robin-Karp算法</h3><p>暴力中逐字符对比很浪费，尝试<em>Hash</em>算法，可以从$O(m)$ 降低到 $O(1)$；<br>但考虑到<font color="#ef6d3b"><em>hash collision</em></font>，即使<em>hash hit</em>，也需要逐字符对比来验证；<br>时间复杂是 $O(n+km), k$ 为<em>hash hit</em>但不匹配的次数；</p><p><strong>缺陷</strong><br>假设每次都<em>hash hit</em>但又不匹配，那<em>Robin-Karp</em>就退化为了暴力算法；(显然不可能)<br>因此越选择精确的<em>Hash</em>算法，<em>Robin-Karp</em>的效率就越高；</p><hr><h3 id="KMP算法">KMP算法</h3><p><a href="https://www.zhihu.com/question/21923021">如何更好地理解和掌握 KMP 算法?</a><br><a href="http://www.btechsmartclass.com/data_structures/knuth-morris-pratt-algorithm.html">Knuth-Morris-Pratt Algorithm</a></p><p>KMP的精髓在于，<strong>如何跳过一些明显不可能的匹配？</strong><br><img src="/images/KMP.png" alt=""></p><p>如上图，当字母d匹配失败时，暴力法会回到字母b处重新开始对比；<br>这显然是效率低下的；因为回到字母ab处匹配会更好；<br>为什么回到<code>ab</code>处呢？因为<code>ab</code>是$p$的一个前缀！</p><p><strong>LPS数组</strong></p><ul><li><font color="#ef6d3b"><strong>longest prefix and suffix</strong></font>. 最长公共前后缀</li></ul><p>对比<code>abcab</code>，它的LPS就是<code>ab</code>，长度为2；<br>这就是为什么，上图中我们要移动到<code>ab</code>处；</p><ul><li>如何计算LPS数组？<br>利用了递推的思想，有空详细解释下~</li></ul><pre><code class="language-python">LPS[m] # 构建的数组i, j = 0, 1 LPS[0] = 0while j &lt;= m:    if P[i] == P[j]:        LPS[j] = i + 1        i++; j++    else:        if i == 0:            LPS[j] = 0            j++        else:            i = LPS[i-1]</code></pre><p><strong>复杂度</strong><br>时间复杂度$O(m)$，$m$是子串P的长度；</p><p><strong>利用LPS数组做匹配</strong></p><pre><code class="language-python">i = 0 # 父串S下标j = 0 # 子串P下标while i &lt; len(S):    if S[i] == P[j]:        i++; j++    elif j &gt; 0:        j = LPS[j-1]    else:        i++        if j = len(P):        # Match Success        pass</code></pre><p>这一步时间复杂度是len(S)，即$O(n)$<br><font color="#ef6d3b"><strong>KMP算法的复杂度即$O(n+m)$</strong></font></p><div class="admonition warning"><p class="admonition-title">FAQ</p><p>笔者python测试对比如上三种算法（随机字符n=1000w, m=10），时间如下：BF: 5.6sRobin-Karp: 1.18sKMP: 1.41s为什么KMP稳定比RK算法慢？虽然KMP严重依赖Pattern的性质，但不至于稳定差</p></div><!-- ### Boyer-Moore(BM)算法### Sunday算法 --><hr><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://www.zhihu.com/question/21923021">如何更好地理解和掌握 KMP 算法?</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Algorithm </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Algorithm】Sorting</title>
      <link href="/posts/1CKQG3J/"/>
      <url>/posts/1CKQG3J/</url>
      
        <content type="html"><![CDATA[<p><code>这是大学时期写的</code></p><h2 id="排序算法的深入分析和实现">排序算法的深入分析和实现</h2><p><strong>1.1 排序的定义</strong><br>对一序列对象根据某个关键字进行排序。</p><p><strong>1.2 术语说明</strong></p><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</p><p><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</p><p><strong>内排序In-place</strong>：所有排序操作都在内存中完成；</p><p><strong>外排序Out-place</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</p><p><strong>1.3 算法总结</strong><img src="https://img-blog.csdnimg.cn/20190419171130152.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_16,color_FFFFFF,t_70" alt="算法分析与对比"></p><table><thead><tr><th style="text-align:center">排序算法</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">空间复杂度</th></tr></thead><tbody><tr><td style="text-align:center">冒泡排序</td><td style="text-align:center">O(n2)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">选择排序</td><td style="text-align:center">O(n2)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">插入排序</td><td style="text-align:center">O(n2)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">归并排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(n)</td></tr><tr><td style="text-align:center">快速排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(logn)</td></tr><tr><td style="text-align:center">堆排序</td><td style="text-align:center">O(nlogn)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">捅排序</td><td style="text-align:center">O(n+k)</td><td style="text-align:center">O(n+k)</td></tr></tbody></table><h3 id="1、冒泡排序（Bubble-Sort）"><strong>1、冒泡排序（Bubble Sort）</strong></h3><p>相邻两个元素比较大小，一次外循环比较(n-1)次；<br>如跑完第一次循环，最大的元素被移到最后一位；<br>内循环跑(n-i)次，因为最后i个元素已排好序；<br><img src="https://img-blog.csdnimg.cn/20190420003741295.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_16,color_FFFFFF,t_70" alt="冒泡排序"></p><p><strong>时间复杂度分析</strong>：<br>比较次数：不管怎样，冒泡排序都要比较(n+(n-1)+…+2+1)次，即n(n-1)/2 ，O(N^2);<br>交换次数：有序不需要交换，逆序交换n(n-1)/2次；O(N^2);</p><p><strong>稳定性分析：</strong><br>相邻两元素大小一样，自然不会多此一举去交换，因此稳定；</p><p><strong>C++代码实现：</strong></p><pre><code class="language-c">//冒泡排序void bubble_sort(int *a, int n){for (int i=0; i&lt;n-1; i++){ //外循环n-1次for (int j=0; j&lt;n-i-1; j++){ //内循环找出前n-i个中最大元素，不断往末尾移if (a[j]&gt;a[j+1]){                int tmp = a[j];                a[j] = a[j+1];                a[j+1] = tmp;}}}}</code></pre><hr><h3 id="2、选择排序（Select-Sort）"><strong>2、选择排序（Select Sort）</strong></h3><p>每次选择第i小的元素，把它放在index为i的位置上；<br>一共n次外循环，第一次选出最小元素，放在第一个；第i次选出第i小的元素；<br>每次内循环要比较(n-i)次，最终选出后(n-i)个元素中最小的，放到i位置上。<br><img src="https://img-blog.csdnimg.cn/2019042000365789.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_16,color_FFFFFF,t_70" alt="选择排序"></p><p><strong>时间复杂度分析</strong>：<br>比较次数：选择排序同样比较(n+(n-1)+…+2+1)次，即n(n-1)/2 ，O(N^2);<br>交换次数：有序不需要交换，逆序交换n(n-1)/2次；O(N^2);</p><p><strong>稳定性分析：</strong><br>因为涉及相隔较远的元素交换位置！<br>例如3 2 3 1，第一次循环结束，3和1交换，破坏了稳定。显然选择排序是不稳定。</p><p><strong>C++代码实现：</strong></p><pre><code class="language-c">//选择排序void select_sort(int *a, int n){for (int i=0; i&lt;n-1; i++){ //外循环n-1次int min = a[i], index = i;for (int j=i; j&lt;n; j++){ //内循环找出后n-i个中最小元素，放到第i位置if (a[j] &lt; min){min = a[j];index = j;}}a[index] = a[i];a[i] = min;}}</code></pre><hr><h3 id="3、插入排序（Insert-Sort）"><strong>3、插入排序（Insert Sort）</strong></h3><p>类比平时打牌时插牌，拿到新元素，把它放到已排好序的元素中的适当位置；<br>外循环n次，第i次外循环结束，则前i个数已排好序，第一个默认排好序；<br>内循环为执行(n-i)次，将新元素和前i个排好序的依次比较，是一个不断往前插的过程；<br><img src="https://img-blog.csdnimg.cn/20190420003829832.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_16,color_FFFFFF,t_70" alt="插入排序"></p><p><strong>时间复杂度分析</strong>：<br>比较次数：同O(N^2);<br>交换次数：有序不需要交换，逆序交换n(n-1)/2次；O(N^2);</p><p><strong>稳定性分析：</strong><br>插入排序是稳定的；例如 1 2 3 3，前三个已经排好序，最后的3显然不会再往前插；</p><p><strong>C++代码实现：</strong></p><pre><code class="language-c">//插入排序void insert_sort(int *a, int n){for (int i=1; i&lt;n; i++){ //外循环n-1次，第i次外循环结束前i+1个元素排好序列int index = i;for (int j=i-1; j&gt;=0; j--){ //内循环将第i个元素往前插if (a[index]&lt;a[j]){int tmp = a[index];a[index] = a[j];a[j] = tmp;index = j;}}}}</code></pre><hr><h3 id="4、归并排序（Merge-Sort）"><strong>4、归并排序（Merge Sort）</strong></h3><p>采用分治法，将序列分成两个n/2长度的子序列，合并时依次按大小输出到新序列；<br>占用额外空间，非原址排序；<br><img src="https://img-blog.csdnimg.cn/20190420003900232.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_5,color_FFFFFF,t_70" alt="归并排序"></p><p><strong>时间复杂度分析</strong>：<br>每次递归复杂度O(n)，递归层数O(lgn)，所以复杂度为O(nlgn);</p><p><strong>稳定性分析：</strong><br>归并排序是稳定的，合并过程左右两个序列的比较大小保证了这种稳定性；</p><p><strong>C++代码实现：</strong></p><pre><code class="language-c">//归并排序void merge(int *a, int *b, int p, int r, int q){ //合并下标为p到r 与 r+1到q 这两部分int write = p; //写入b的下标int i=p,j=r+1; //分别标记左右序列正要读的位置while (i&lt;=r &amp;&amp; j &lt;= q){if (a[i]&lt;=a[j])b[write++] = a[i++];        else if (a[i]&gt;a[j])b[write++] = a[j++];}//此时左、右序列可能有一个未写完while (i&lt;=r)b[write++] = a[i++];while (j&lt;=q)b[write++] = a[j++];for (int k=p; k&lt;=q; k++)a[k] = b[k];}void merge_sort(int *a, int *b, int beg, int end){if (end==beg){ //1个元素直接返回return;}if (end-beg == 1){ //2个元素，排个序if (a[beg]&gt;a[end]){int tmp = a[beg];a[beg] = a[end];a [end] = tmp;}return;}merge_sort(a,b,beg,(beg+end)/2);merge_sort(a,b,(beg+end)/2+1,end);merge(a,b,beg,(beg+end)/2,end);}</code></pre><hr><h3 id="5、快速排序（Quick-Sort）"><strong>5、快速排序（Quick Sort）</strong></h3><p>从数列中挑出一个元素，称为 “基准”(pivot)；<br>重新排序数列，所有比pivot小的摆放在基准前面，所有比pivot大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p><p>Partition操作实现：<br>pivot选择末尾元素，维护i和j，i指向头，j指向pivot前一个。i不断往后搜索直到找到第一个大于pivot的元素；j不断往前搜索直到找到第一个小于pivot的元素。i,j都找到时交换i,j上的元素，如果j&lt;i，退出循环，此时交换pivot和i位置，满足pivot(即i原来位置)左边都比它小，右边都比它大；<br><img src="https://img-blog.csdnimg.cn/20190420015014337.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_16,color_FFFFFF,t_70" alt="快速排序"><br><strong>时间复杂度分析</strong>：<br>每次递归复杂度O(n)，递归层数O(lgn)，所以复杂度为O(nlgn);</p><p><strong>稳定性分析：</strong><br>快速排序是不稳定的；<br>因为间隔元素的交换，很可能打破原有相同元素的顺序关系；<br>例如3 3 1 1 2，选择2为pivot，那么第一次循环，3和1就发生了交换，打乱了稳定性；</p><p><strong>C++代码实现：</strong></p><pre><code class="language-c">//快速排序int partition(int *a, int p, int q){int pivot = q; //选择最后一个元素作为pivotint i=0,j=q-1;while (i&lt;=j){while (a[i]&lt;=a[pivot] &amp;&amp; i&lt;q ){ //i左边都&lt;=pivoti++;}while (a[j]&gt;a[pivot] &amp;&amp; j&gt;=p ){ //j右边都&gt;pivotj--;}if (i&lt;j){ //i不会等于jint tmp = a[i];a[i] = a[j];a[j] = tmp;}}//交换i和pivotint tmp = a[i];a[i] = a[pivot];a[pivot] = tmp;return i; //partition结束，满足左边&lt;=它，右边&gt;它}void quick_sort(int *a, int beg, int end){if (beg&gt;=end)return;int pivot = partition(a,beg,end);quick_sort(a,beg,pivot-1);quick_sort(a,pivot+1,end);}</code></pre><h2 id="参考资料">参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Occlusion: 可见性与剔除</title>
      <link href="/posts/2AR5BC4/"/>
      <url>/posts/2AR5BC4/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><p><strong>光栅化</strong>决定如何将三维场景画到二维屏幕上；但以什么样的顺序绘制？（<strong>Visibility</strong>）是否所有的物体都要绘制到屏幕上? （<strong>Occlusion</strong>）</p></div><hr><h2 id="Occlusion">Occlusion</h2><ul><li><p><font color="#ef6d3b"><strong>一叶障目，不见泰山</strong></font></p></li><li><p>想象你的视线，远处的物体总被近处的遮挡，这就是Occlusion!</p></li><li><p>将“看不见”的物体剔除掉，是图形学优化的重要方向之一!</p></li></ul><hr><h2 id="Painter’s-Algorithm">Painter’s Algorithm</h2><ul><li><font color="#ef6d3b"><strong>画家算法：由远到近绘制物体，远处总被近处的遮挡；</strong></font><br>因此又称<em><strong>Depth-sort Algorithm</strong></em>;</li></ul><p><img src="/images/painter.png" alt=""></p><ul><li><font color="#ef6d3b"><strong>算法分析</strong></font>:<ul><li>需要对n个物体排序: $O(nlogn)$的复杂度，对$n$面数;</li><li>不能处理多面重叠的情形;</li></ul></li></ul><p><img src="/images/painter_bounds.png" alt=""></p><hr><h2 id="Z-Buffer">Z-Buffer</h2><ul><li>对于每个三角形面片中每个Pixel$(x,y,z$），不断取其$z_{min}$，并赋值位z-buffer上该pixel的值</li></ul><pre><code class="language-py"># init zbuffer for +∞for (each tri T):    for (each pixel (x,y,z) in T):        if (z &lt; zbuffer[x][y]):            framebuffer[x][y] = rgb; # also as color buffer            zbuffer[x][y] = z; # also as depth buffer        else:            # occlusion now!</code></pre><ul><li><font color="#ef6d3b"><strong>算法分析</strong></font>:<ul><li>省略了排序，因此是$O(n)$的复杂度，对$n$面数；</li><li>不能处理两个三角形，存在深度值z相同的pixel的情形；（虽然这种情况很少发生，因为是float32）</li></ul></li></ul><h3 id="什么是framebuffer与zbuffer">什么是<em>framebuffer</em>与<em>zbuffer</em>?</h3><ul><li>通俗的说，它们都是一块内存（<em><strong>RAM</strong></em>）;<ul><li><font color="#ef6d3b"><em><strong>framebuffer</strong></em></font>：存储rgb的颜色值</li><li><font color="#ef6d3b"><em><strong>z-buffer (depth-buffer)</strong></em></font>：存储深度信息</li></ul></li></ul><h3 id="图解z-buffer的生成过程">图解z-buffer的生成过程</h3><ul><li>可以看出，计算z-buffer就是一个不断取$min$的过程！<br><img src="/images/zbuffer.png" alt=""></li></ul><div class="admonition todo"><p class="admonition-title">TODO</p><p>补充一张Nsight抓帧的frame-buffer, depth-buffer截图~</p></div><hr><h2 id="Futhermore…">Futhermore…</h2><ul><li><p>常用的culling方案</p></li><li><p>hlod</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Graphics </category>
          
          <category> Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于开发理念: Simple is Good</title>
      <link href="/posts/1ZMZBDW/"/>
      <url>/posts/1ZMZBDW/</url>
      
        <content type="html"><![CDATA[<p>希望这个理念，能够伴随我所有的开发生涯<br>优秀的开发，是<strong>大道至简，而不是简单问题复杂化</strong></p><h2 id="在这之前">在这之前</h2><p>大学身边有一帮要好的文科朋友，经常会观察到这些现象：<br>理工科出身的同志，喜欢提枪就上，埋头苦干，就算没思路也要把电脑敲的噼里啪啦响；<br>文科出身的同志，喜欢事前构思、冥想，甚至磨半天也挤不出几个字；</p><p>如果要双方取长补短的话，<br>我希望程序员的世界，多一些<strong>主观性的理念的东西</strong>，<br>就是在每次敲代码之前，有个尼采一样的诗人在你耳边朗诵一遍：<br><strong>“1.少用宏； 2.做好封装；3.保持代码整洁 …”</strong></p><p>程序员喜欢review，<strong>把问题留给Bug和Review阶段</strong>，<br>但为什么不学文科生，<br>脑海中树立一些宏观的、虚头巴脑的、理念的东西，<br>每次动键盘前，有个“社会主义核心价值观”在脑子里过一遍：<br>虽然玄学了些，但我觉得是个好建议。</p><p>这就是我写这些随笔的原因。</p><h2 id="Simple-is-Good">Simple is Good</h2><ul><li>我尝试用一些观点来论证<strong>why simple is good</strong><ul><li>运行更快</li><li>Bug几率更低</li><li>维护成本更低</li></ul></li></ul><blockquote><p>有两种软件设计方法:<br>第一种是使得软件足够简单以至于<strong>显然没有错误</strong>;<br>第二种是使得软件足够复杂以至于<strong>没有显然的错误</strong>。<br>(最难的是第一种)<br>- Tony Hoare (1980图领奖得主)</p></blockquote><ol><li><p>如果你说如何让一个复杂的功能保持simple？ 试试 <font color="#ef6d3b"><strong>封装</strong></font></p></li><li><p>优化经常是一个不断<font color="#ef6d3b"><strong>删除代码</strong></font>的过程</p></li><li><p>simple不是无脑删除，合理的<font color="#ef6d3b"><strong>解耦与拆分</strong></font>也是一种simple</p></li><li><p>你可以<font color="#ef6d3b"><strong>尽可能地控制“少”</strong></font>，但你永远无法<strong>控制“多”</strong>；<br>想象一万个人对同一个需求的不同实现，总是千奇百怪。</p></li></ol><h2 id="Simple-拓展阅读">Simple 拓展阅读</h2><p><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>  <a href="https://github.com/awerdx520/awesome-programming-books-1/blob/master/clean-code/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93.pdf">代码整洁之道</a></p><p><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <a href="https://www.zhihu.com/question/26483508">知乎: 一百行以下有哪些给力代码？</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中英文档</title>
      <link href="/posts/XPRTBH/"/>
      <url>/posts/XPRTBH/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">NOTE</p><ul><li>罗列了常用、令人困惑的英文专有词汇，可结合站内 <strong>右上角的搜索</strong> 速查!</li><li>本篇已停更一段时间，尽量使用 <font color="#ef6d3b"><strong>“英语阅读，中文写作”</strong></font> 的方式</li></ul></div><h2 id="好的翻译多重要">好的翻译多重要?</h2><ul><li><p>先祭出CS领域的经典垃圾翻译:</p><ul><li><strong>socket</strong>: 套接字</li><li><strong>robust</strong>: 鲁棒性</li><li><strong>handle</strong>: 句柄</li></ul></li><li><p>再看看什么经典优秀翻译:</p><ul><li><strong>context</strong>: 上下文 (通俗)</li><li><strong>process/thread</strong>: 进程/线程 (进行中的程序)</li><li><strong>garbage collection</strong>: 垃圾回收 (直译就够了)</li></ul></li><li><p>欢迎移步知乎话题:</p><ul><li><a href="https://www.zhihu.com/question/22950899">为什么handle会被翻译成句柄？</a></li><li><a href="https://www.zhihu.com/question/27192923">哪些专业名词翻译得特别烂？</a></li></ul></li></ul><h2 id="中英对照">中英对照</h2><div class="admonition warning"><p class="admonition-title">关于对照表</p><p>1.Wikipedia的解释准确且全面，但可能不易理解；</p><p>2.某些社区(如知乎、博客)会有一些精彩而巧妙的理解，因此贴出来；</p><p>3.个人备注栏，添加了一些自己的理解；</p><ol start="4"><li><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>意味着远离中文!</li></ol></div><table><thead><tr><th style="text-align:center">英文</th><th style="text-align:center">中文</th><th style="text-align:center">官方</th><th style="text-align:left">个人备注</th></tr></thead><tbody><tr><td style="text-align:center">socket</td><td style="text-align:center">套接字</td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Network_socket">Wikipedia</a></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">robust</td><td style="text-align:center">鲁棒性</td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Robustness">Wikipedia</a></td><td style="text-align:left">功能健壮, 具有高扩展性</td></tr><tr><td style="text-align:center">handle</td><td style="text-align:center">句柄</td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Handle_(computing)">Wikipedia</a></td><td style="text-align:left">对一段资源的引用, 像pointer?</td></tr><tr><td style="text-align:center">Cartesian coord.</td><td style="text-align:center">笛卡尔坐标系</td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system">Wikipedia</a></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">Homogeneous coord.</td><td style="text-align:center">齐次坐标系</td><td style="text-align:center"><a href="https://www.zhihu.com/question/59595799">知乎</a></td><td style="text-align:left">n+1维表示n维 <a href="http://localhost:4000/posts/1513JCX/">我的博客</a></td></tr><tr><td style="text-align:center">Viewport</td><td style="text-align:center">屏幕</td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">Projection</td><td style="text-align:center">投影</td><td style="text-align:center"></td><td style="text-align:left"><a href="http://localhost:4000/posts/1513JCX/">我的博客</a></td></tr><tr><td style="text-align:center">Orthographic</td><td style="text-align:center">正交</td><td style="text-align:center"></td><td style="text-align:left"><a href="http://localhost:4000/posts/1513JCX/">我的博客</a></td></tr><tr><td style="text-align:center">Perspective</td><td style="text-align:center">透视</td><td style="text-align:center"></td><td style="text-align:left"><a href="http://localhost:4000/posts/1513JCX/">我的博客</a></td></tr><tr><td style="text-align:center">rasterization</td><td style="text-align:center">光栅化</td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Rasterisation">Wikipedia</a></td><td style="text-align:left">三维场景渲染到二维屏幕</td></tr><tr><td style="text-align:center">anti-aliasing</td><td style="text-align:center">抗锯齿(AA)</td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Anti-aliasing">Wikipedia</a></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">framebuffer</td><td style="text-align:center"></td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Framebuffer">Wikipedia</a></td><td style="text-align:left">GPU memory to store</td></tr><tr><td style="text-align:center">Z-Buffer/Depth-Buffer</td><td style="text-align:center"></td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Z-buffering">Wikipedia</a></td><td style="text-align:left"><a href="https://www.luhao.wiki/posts/2AR5BC4/">我的博客</a></td></tr><tr><td style="text-align:center">painter’s algorithm</td><td style="text-align:center">画家算法</td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Painter%27s_algorithm">Wikipedia</a></td><td style="text-align:left">由远到近排序后绘制，近的覆盖远的</td></tr><tr><td style="text-align:center">NDC</td><td style="text-align:center">Normalized Device Coordinates</td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">VBO</td><td style="text-align:center">vertex buffer object</td><td style="text-align:center"><a href="...">Wikipedia</a></td><td style="text-align:left"><a href="...">我的博客</a></td></tr><tr><td style="text-align:center">VAO</td><td style="text-align:center">vertex array object</td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">EBO</td><td style="text-align:center">element buffer objects</td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">vs</td><td style="text-align:center">vertex shader</td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">ps(fs)</td><td style="text-align:center">pixel (fragment) shader</td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">uv</td><td style="text-align:center">纹理坐标</td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">Texture filtering</td><td style="text-align:center">纹理过滤</td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Texture_filtering">Wikipedia</a></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">Artifacts</td><td style="text-align:center"><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Visual_artifact">Wikipedia</a></td><td style="text-align:left">凡是不接近真实的图形表现</td></tr><tr><td style="text-align:center">Mipmap</td><td style="text-align:center"></td><td style="text-align:center"><a href="https://learnopengl.com/Getting-started/Textures">LearnOpenGL</a></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">Phong lighting model</td><td style="text-align:center"><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Phong_reflection_model">Wikipedia</a></td><td style="text-align:left"><a href="https://www.luhao.wiki/posts/SZGATA/">Colors and Materials</a></td></tr><tr><td style="text-align:center">Ambient</td><td style="text-align:center">环境光</td><td style="text-align:center"></td><td style="text-align:left"><a href="https://www.luhao.wiki/posts/SZGATA/">Colors and Materials</a></td></tr><tr><td style="text-align:center">Diffuse</td><td style="text-align:center">漫反射光</td><td style="text-align:center"></td><td style="text-align:left"><a href="https://www.luhao.wiki/posts/SZGATA/">Colors and Materials</a></td></tr><tr><td style="text-align:center">Specular</td><td style="text-align:center">高光</td><td style="text-align:center"></td><td style="text-align:left"><a href="https://www.luhao.wiki/posts/SZGATA/">Colors and Materials</a></td></tr><tr><td style="text-align:center">Lightmap</td><td style="text-align:center"><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td style="text-align:center"></td><td style="text-align:left"><a href="https://www.luhao.wiki/posts/SZGATA/">Colors and Materials</a></td></tr><tr><td style="text-align:center">directional light</td><td style="text-align:center">平行光</td><td style="text-align:center"></td><td style="text-align:left"><a href="https://www.luhao.wiki/posts/S7WXS5/">Lighting</a></td></tr><tr><td style="text-align:center">point light</td><td style="text-align:center">点光</td><td style="text-align:center"></td><td style="text-align:left"><a href="https://www.luhao.wiki/posts/S7WXS5/">Lighting</a></td></tr><tr><td style="text-align:center">spot light</td><td style="text-align:center">聚光灯</td><td style="text-align:center"></td><td style="text-align:left"><a href="https://www.luhao.wiki/posts/S7WXS5/">Lighting</a></td></tr><tr><td style="text-align:center">hover</td><td style="text-align:center">鼠标悬停态</td><td style="text-align:center"></td><td style="text-align:left"><a href="https://www.runoob.com/cssref/sel-hover.html">CSS hover</a></td></tr><tr><td style="text-align:center">Assembly-Language</td><td style="text-align:center">汇编</td><td style="text-align:center"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">AT&amp;T Syntax</td><td style="text-align:center">AT&amp;T汇编格式</td><td style="text-align:center"><a href="https://www.cs.mcgill.ca/~cs573/winter2001/AttLinux_syntax.htm#:~:text=Notable%20differences%20between%20the%20two,Intel%20register%20operands%20are%20undelimited.">Syntax versus</a></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">Intel Syntax</td><td style="text-align:center">Intel汇编格式</td><td style="text-align:center"><a href="https://www.cs.mcgill.ca/~cs573/winter2001/AttLinux_syntax.htm#:~:text=Notable%20differences%20between%20the%20two,Intel%20register%20operands%20are%20undelimited.">Syntax versus</a></td><td style="text-align:left"></td></tr></tbody></table><p>| socket |  | <a href="...">Wikipedia</a> | |</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> Algorithm </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript数据类型</title>
      <link href="/posts/3YE7XY8/"/>
      <url>/posts/3YE7XY8/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">Note</p><p><span class="github-emoji"><span>🔥</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f525.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <a href="https://github.com/type-challenges/type-challenges/blob/master/README.zh-CN.md"><em><strong>Type Challenge</strong></em></a></p><p>这是为TypeScript打造的<code>Online Judge</code>,可以考察对其<strong>类型</strong>的理解</p></div><h2 id="Builtin">Builtin</h2><p><font color="#ef6d3b"><strong>Primitives Types</strong></font></p><ul><li><em><strong>string</strong></em><ol><li>单引号与双引号皆可 (同python);</li><li><code>${expr}</code>用来嵌入表达式;</li></ol></li><li><em><strong>number</strong></em><ol><li>没有<code>int, float</code>之分;</li><li><code>0x, 0o</code>都是ES6的进制表示法;</li></ol></li><li><em><strong>boolean</strong></em><br><code>true, false</code></li><li><em><strong>空值</strong></em><br><code>undefined, null</code>: 变量赋值<br><code>void</code>: 函数返回值</li></ul><p><font color="#ef6d3b"><strong>Object Types</strong></font></p><ul><li><em><strong>Array</strong></em></li><li>…</li></ul><h2 id="Any">Any</h2><p>当不确定类型时，使用<code>any</code>，这样后面可以赋予它任何类型</p><pre><code class="language-js">let foo: any;foo = true;foo = 'abcd';let arr: any[] = ['John', 88, true];arr.push('luhao');</code></pre><p>any对象可以调用任意属性与方法!</p><pre><code class="language-js">let foo: any;console.log(foo.name); // OKfoo.setName('luhao'); // OK</code></pre><p>没有申明类型的变量，等价于any</p><pre><code class="language-js">// 两者等价let foo;let foo: any</code></pre><p><a href="https://stackoverflow.com/questions/50875618/any-in-typescript">stackoverflow: 申明any与否的意义?</a></p><p><code>tsconfig.json</code>中有如果对"strict"定义为true，那么对所有any的非法访问都是错误的!</p><h2 id="Inference">Inference</h2><p><strong>类型推论</strong>: 对于没有指定类型但已经赋值的变量，TypeScript会推断出一个类型：</p><pre><code class="language-js">let foo = 'luhao'; // 此时TS已推断foo为stringfoo = 100; // Error// error TS2322: Type 'number' is not assignable to type 'string'.</code></pre><h2 id="Union">Union</h2><p><strong>联合类型</strong>使用 <code>|</code> 表示几个类型的并集：</p><pre><code class="language-js">let foo: string | number;foo = 'luhao'; // OKfoo = 100; // OKfoo = true; // Error</code></pre><p>联合类型一旦被赋值，其类型就是唯一的：</p><pre><code class="language-js">let foo: string | number;foo = 'luhao';console.log(foo.length); // OKfoo = 100;console.log(foo.length); // Error, 此时foo是number类型</code></pre><hr><h2 id="interface">interface</h2><p>它就像C中的<code>struck</code>:</p><pre><code class="language-js">interface IPerson {    name: string; // 必选属性    age?: number; // 可选属性    readonly gender: boolean; // 只读属性    [optName: string]: any; // 任意属性}let person: IPerson = {    name: 'luhao',    // age: 24, // 可选    gender: true,    school: 'NJU',}</code></pre><h2 id="Assertion-类型断言">Assertion: 类型断言</h2><p>!!! todo</p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VSCode插件】Markdown-snippet</title>
      <link href="/posts/2167JH4/"/>
      <url>/posts/2167JH4/</url>
      
        <content type="html"><![CDATA[<p>实现了一款用于<strong>Markdown代码补全、CSS样式插入</strong>等功能的VScode插件<br>开发环境：<code>VScode, TypeScript</code></p><hr><h2 id="Github-Repo">Github Repo</h2><p>🏠 <a href="https://github.com/593413198/VScode-Markdown-Snippet"><strong>VScode-Markdown-Snippet</strong></a></p><h2 id="font-size-3-TODO-font"><font size="3"><strong>TODO</strong></font></h2><p><font color="#FF1E10"><strong>这个是若干年前的项目，准备捞回来完善下；</strong></font></p><ul><li>支持fontawesome</li><li>支持骚的html语法</li><li>支持表情的检索</li><li>支持size/color快速自定义</li></ul><h2 id="插件功能概述">插件功能概述</h2><ul><li><ol><li>支持Markdown基本语法插入与补全：表格、超链接、图片…</li></ol></li><li><ol start="2"><li>支持对选中内容：加粗、下划线、划去线…</li></ol></li><li><ol start="3"><li>支持内嵌多种css样式：改变颜色、左右对齐、字号…</li></ol></li><li><ol start="4"><li>支持图片直接复制粘贴到VScode；</li></ol></li></ul><hr><h2 id="W1-环境搭建与Demo">W1: 环境搭建与Demo</h2><ul><li><strong>直接上文档</strong>: <a href="https://code.visualstudio.com/api/get-started/your-first-extension"><strong>VScode API</strong></a></li></ul><p><code>npm install -g yo generator-code</code> : 安装依赖环境<br><code>yo code</code> : 进入开发环境, 如下图</p><!-- - 不得体不说这个开发体验做的真是nice![](/images/surround.png) --><ul><li><strong>观察一下开发目录</strong>：<br><img src="/images/tree.png" alt=""></li></ul><p><font color="#FF1E10"><strong>extension.ts</strong></font>: 插件的脚本逻辑: TypeScript<br><font color="#1AAD19"><strong>package.json</strong></font>: 所有的环境配置选项: 插件名、版本号、command…<br><font color="#1A9BFF"><strong><a href="http://README.md">README.md</a></strong></font>: 发布后的文档</p><ul><li><strong>第一个Demo: 对选中内容加粗显示</strong></li></ul><pre><code class="language-py">**这段文字是加粗显示的**  #这是markdown加粗语法</code></pre><ul><li><strong>下面是实现的ts逻辑</strong><ul><li><a href="https://code.visualstudio.com/api/references/vscode-api">showQuickPick API</a></li><li><a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets">insertSnippet API</a></li></ul></li></ul><pre><code class="language-js">// 当surround插件被激活时，会进入activate函数export function activate(context: vscode.ExtensionContext) {    // 输出一行Logconsole.log('Congratulations, your extension "surround" is now active!');    // surround.sur 定义在package.json中let disposable = vscode.commands.registerCommand('surround.sur', function () {interface CommandQuickPickItem extends vscode.QuickPickItem {command: () =&gt; Promise&lt;void&gt;;}let items: CommandQuickPickItem[] = [];items.push({ description: '对选中的字体加粗', label: 'Font Bold', command: surroundWithBold });vscode.window.showQuickPick(items, { matchOnDetail: true, matchOnDescription: true }).then(selectedItem =&gt; {if (selectedItem &amp;&amp; typeof selectedItem.command === 'function') {selectedItem.command();}});;}// 对选中的内容进行加粗function surroundWithBold() {let msg = "**";let snippet = msg + '${TM_SELECTED_TEXT}' + msg;vscode.commands.executeCommand('editor.action.insertSnippet', {'snippet': snippet} )}</code></pre><hr><h2 id="VScode插件打包与发布">VScode插件打包与发布</h2><h3 id="本地打包测试">本地打包测试</h3><ul><li>这里推荐打包为visx，并使用VScode安装<br><code>npm i vsce -g</code>: 安装vsce打包工具<br><code>vsce package</code>: 在插件目录打包<br><code>xxx.vsix</code>: 在VScode的插件右上角选择<code>Install from VSIX</code></li></ul><h3 id="发布到VScode-Marketplace">发布到VScode Marketplace</h3><ul><li><p>使用Azue注册一个开发组织<br><code>vsce login &lt;publish-name&gt;</code>: 登录自己的开发者账户, 需要tokens<br><code>vsce publish</code>: 发布到marketplace<br><code>vsce publish patch</code>: 使发布的version自增, 会自动修改<code>package.json</code>中的版本号<br><code>vsce unpublish &lt;publish-name&gt;.&lt;extension-name&gt;</code>: 下架</p></li><li><p><a href="https://marketplace.visualstudio.com/manage/publishers/luhao"><strong>这是我的VScode Marketplace的个人主页</strong></a></p></li><li><p>已上架VScode Marketplace<br><img src="/images/vscode-ext.png" alt=""></p></li></ul><hr><h2 id="参考资料">参考资料</h2><blockquote><ul><li><a href="https://code.visualstudio.com/api/get-started/your-first-extension">Building your VScode extension</a></li><li><a href="https://www.typescriptlang.org/">TypeScript</a></li><li><a href="https://liiked.github.io/VS-Code-Extension-Doc-ZH/#/">VScode插件开发 中文文档</a></li><li><a href="https://cloud.tencent.com/developer/article/1827236">VScode LaTex Snippets开发教程</a></li><li><a href="https://www.cnblogs.com/liuxianan/p/vscode-plugin-overview.html">VScode插件开发全攻略十篇</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> VSCode </category>
          
          <category> VSCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VIM】Vi Improved</title>
      <link href="/posts/vim/"/>
      <url>/posts/vim/</url>
      
        <content type="html"><![CDATA[<p><em>vi/vim is the best editor in the world!</em><span id="more"></span></p><div class="admonition note"><p class="admonition-title">骚操作</p><ul><li>终端输入 <code>set -o vi</code>，在命令行使用vim模式（<code>set -o emacs</code>以回退）</li><li>gim配置vim：<code>git config --global core.editor "vim"</code></li></ul></div><div class="markmap-container" style="height:425px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;vim&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;https://stackoverflow.com/questions/11828270/how-do-i-exit-the-vim-editor\&quot;>How do I exit the Vim editor?</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;vim modes&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#normal-模式\&quot;>normal</a>（Esc）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5],&quot;f&quot;:true},&quot;v&quot;:&quot;h（←）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6],&quot;f&quot;:true},&quot;v&quot;:&quot;j（↓）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7],&quot;f&quot;:true},&quot;v&quot;:&quot;k（↑）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8],&quot;f&quot;:true},&quot;v&quot;:&quot;l（→）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#insert-模式\&quot;>insert</a>（i）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#visual-模式\&quot;>visual</a>（v）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;vim commands&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#Command\&quot;>Commnad</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13],&quot;f&quot;:true},&quot;v&quot;:&quot;d（delete）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14],&quot;f&quot;:true},&quot;v&quot;:&quot;y（yank）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15],&quot;f&quot;:true},&quot;v&quot;:&quot;r（replace）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#object\&quot;>Object</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17],&quot;f&quot;:true},&quot;v&quot;:&quot;w（word）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18],&quot;f&quot;:true},&quot;v&quot;:&quot;a（argument）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19],&quot;f&quot;:true},&quot;v&quot;:&quot;), ], &amp;quot; ⭐&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;vimrc&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;https://www.ruanyifeng.com/blog/2018/09/vimrc.html\&quot;>阮一峰：vim配置入门</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;vim pro&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[22,23],&quot;f&quot;:true},&quot;v&quot;:&quot;多行编辑&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[23,24],&quot;f&quot;:true},&quot;v&quot;:&quot;% 配对&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[24,25],&quot;f&quot;:true},&quot;v&quot;:&quot;f 查找&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[25,26],&quot;f&quot;:true},&quot;v&quot;:&quot;...&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="1、Vim-Vi-improvment">1、Vim: Vi improvment</h2><p>先从一个stackoverflow经典问题看起：<br><a href="https://stackoverflow.com/questions/11828270/how-do-i-exit-the-vim-editor">How do I exit the Vim editor?</a></p><p>这是回答：<br>Hit the <code>Esc</code> key to enter “Normal mode”. Then you can type : to enter “Command-line mode”. A colon <code>(:)</code> will appear at the bottom of the screen and you can type in one of the following commands. To execute a command, press the Enter key.</p><p><strong><code>:q</code> to quit (short for :quit)</strong><br><strong><code>:q!</code> to quit without saving (short for :quit!)</strong><br><strong><code>:wq</code> to write and quit</strong><br>…</p><p>到这里，你至少不用窘迫的不知如何退出Vim界面了！</p><ul><li>技巧：所有Vim Operation，都源于英文的缩写 <strong>（例如 <code>q</code> 表示 <code>quit</code>）</strong>, 因此下面的所有Vim快捷键，我都会尽可能列出其英文含义，已帮助你更快得记住它！</li></ul><h2 id="2、Vim-modes">2、Vim modes</h2><p>什么是mode？<br><em>模式，几乎所有的编辑器只有一种模式，即insert 插入</em><br><font color="#ef6d3b"><strong>但是，Vim有起码3种重要的模式：normal, insert, visual</strong></font></p><ul><li>引自3中一句话：Programming大多数的时间消耗，不是在Writing上，而是review和Editing。</li></ul><h3 id="normal-模式">normal 模式</h3><p>如何移动光标?</p><ul><li><code>h</code> - ← move left</li><li><code>j</code> - ↓ move down</li><li><code>k</code> - ↑ move up</li><li><code>l</code> - → move right</li></ul><p>更高效得，如何以单词为单位移动?</p><ul><li><code>w</code> - move to beginning of next word (<strong>word</strong>)</li><li><code>b</code> - move to previous beginning of word (<strong>back word</strong>)</li><li><code>e</code> - move to end of word (<strong>end word</strong>)</li></ul><p><code>just type 'vim' in terminal, and check these with your hands!</code></p><h3 id="insert-模式">insert 模式</h3><p>使用<code>i</code>来进入insert模式，使用Esc来退出insert。</p><ul><li><code>i</code> - insert text before cursor (<strong>insert</strong>)</li><li><code>a</code> - insert text after cursor (<strong>insert after</strong>)</li><li><code>o</code> - Start a new line below cursor, insert text (<strong>??</strong>)</li></ul><h3 id="visual-模式">visual 模式</h3><p>你一定猜到了，使用<code>v</code>可以进入visual模式。<br>此时可以批量成段的选择、编辑文本！</p><h2 id="3、Vim-commands">3、Vim commands</h2><p>直到阅读这篇文章前，我都不曾理解vim command的真正要义：<br><a href="https://blog.carbonfive.com/vim-text-objects-the-definitive-guide/">Vim Text Objects: The Definitive Guide</a></p><p><font color="#ef6d3b"><strong>在Vim的眼中，一切内容分为两种：text和objects</strong></font><br>试想一下，一串无规律的字符串，它在编辑器眼里是text，这不无道理。<br>但如果是一个word，一个sentence，甚至是argument，那vim会视其为一个text object，以实现个更高效的操作。</p><ul><li><p><code>&lt;number&gt;&lt;command&gt;&lt;text object&gt;</code><br>这构成了几乎vim 90%的操作。</p></li><li><p><code>daw</code> – (<strong>delete a(around) word</strong>)<br>没错，它执行了删除一个单词的操作，并取决于你光标所在的位置。</p></li><li><p><code>diw</code> - (<strong>delete inner word</strong>)<br>inner于around有什么区别？around删除了周围的空白符，但是inner只删除了单词！</p></li><li><p><code>vf)</code> - (<strong>visual(select) until(find) first <code>)</code></strong>)<br>选中直到)的所有字符，并进入visual模式！ （需要稍加理解）</p></li></ul><p>下面罗列了几乎所有的command和obejct，标星的表示常用！</p><h3 id="Command">Command</h3><ul><li><code>d</code> - delete ★</li><li><code>y</code> - yank (经典ctrl c) ★</li><li><code>c</code> - change (delete and insert) ★</li><li><code>v</code> - visual (选中并进入visual模式) ★</li><li><code>r</code> - replace (delte and insert)</li></ul><h3 id="Object">Object</h3><ul><li><code>w</code> - word ★</li><li><code>s</code> - sentence</li><li><code>p</code> - paragraph (其实对不同于语言的识别不佳)</li><li><code>a</code> - argument ★ (编辑函数很有用)</li><li><code>"</code> - quoted ★ (引号内)</li><li><code>)</code>, <code>]</code>, <code>}</code>, <code>:</code>… 一切皆可</li></ul><h2 id="4、vimrc">4、vimrc</h2><p><code>~/.viminfo</code>是vim的cache，包括历史操作等<br>vim的配置是在<code>~/.vimrc</code>, 比较多且难记, 可以查看 <a href="https://www.ruanyifeng.com/blog/2018/09/vimrc.html">Vim 配置入门</a></p><p>例如: <code>set number</code>是显示行号</p><h2 id="5、vim-pro">5、vim pro</h2><ul><li><p><strong>多行编辑</strong></p><ul><li><code>v</code>键盘进入<code>visual block</code>模式，然后选中要编辑的所有行</li><li><code>I</code>进入多行编辑模式, <code>Esc</code>退出生效</li></ul></li><li><p>快速光标移动</p><ul><li><code>%</code>: 配对括号、引号等</li><li><code>{、}</code>: 上一个/下一个 空行</li><li><code>[[、]]</code>: 上一个/下一个 代码段</li><li><code>+、-</code>: 上一行/下一行 非空白字符</li><li><code>Enter</code>: 下一行 非空白字符</li><li><code>f</code>+单字符: <strong>行内</strong>搜索+快速移动, 按 分号键<code>;</code> 可以继续查找</li></ul></li><li><p>运用数字表示重复</p><ul><li><code>3j</code>: 表示往下3行</li><li><code>3igo</code>: 结束按esc, 即输入3遍go</li></ul></li><li><p>不熟练操作</p><ul><li><code>~</code>: 转大小写</li><li><code>O</code>: 大写<code>O</code>在上方插入新行</li><li><code>c</code>: 改写操作<ul><li><code>cc</code>: 删除当前行, 并进插入模式</li><li><code>cw</code>: 改写下个单词</li></ul></li></ul></li></ul><h2 id="5、关于Vim的更多">5、关于Vim的更多</h2><ul><li><p><a href="https://wklken.me/posts/2017/03/25/vim-about-edit.html">vim 杂谈 - 关于快速编辑</a></p></li><li><p><a href="https://stackoverflow.com/questions/11828270/how-do-i-exit-the-vim-editor">StackOverflow: How do I exit the Vim editor?</a></p></li><li><p><a href="https://irian.to/blogs/introduction-to-vim-modes/">Introduction to Vim Modes</a></p></li><li><p><a href="https://www.vimgolf.com/">VimGolf</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写给三年内的技术成长目标</title>
      <link href="/posts/goal-2024/"/>
      <url>/posts/goal-2024/</url>
      
        <content type="html"><![CDATA[<div class="admonition warning"><p class="admonition-title">以下 写于2023年7月</p><ul><li>继续惊觉时间飞逝</li><li>有收获，但也有走弯路</li><li>剩余一年时间，保持现有节奏之余，坚持两个核心</li></ul></div><h3 id="核心一：提高效率">核心一：提高效率</h3><p>当追求细化文档、扩散式学习（遇到陌生的点就深挖）后，工作的效率（指做完主线）明显降低。<br>中短期来看，这是不好的迹象，期望通过 <strong>区分任务主次</strong> 来改善。</p><h3 id="核心二：攻城略地">核心二：攻城略地</h3><p>期望 “染指” 更多中大型模块，快速弥补经验上的欠缺。<br>同时，攻坚 <em>modern cpp、linux kernel、network、algorithm</em>… 等领域，计算机的 “万丈高楼平地起”，恰恰依赖这些基础知识。</p><hr><div class="admonition note"><p class="admonition-title">以下 写于2022年5月</p><ul><li>惊觉半年已逝；</li><li>回看曾经的目标，<strong>宏大却不够具体，因此缺乏坚持的动力</strong>；</li><li>这次来细化下目标吧!</li></ul></div><h3 id="坚持阅读、写作">坚持阅读、写作</h3><ul><li><p>每周 <font color="#FF1E10"><em><strong>1+</strong></em></font> 篇博客, 不限题材（算命的、风水的都行）</p></li><li><p>每月阅读 <font color="#FF1E10"><em><strong>1+</strong></em></font> 本书籍 （技术 or 思维 …）</p></li><li><p>每月做 <font color="#FF1E10"><em><strong>1+</strong></em></font> 篇陌生技术的积累（前沿的、其他行业的）</p></li><li><p>尝试捣鼓一些小玩意，如破解插件、工具脚本，<strong>并将这些成果发布在开源网站上!</strong></p></li></ul><hr><div class="admonition note"><p class="admonition-title">以下 写于2021年国庆</p><p><em>希望在三年后(2024.10)，能够达到如下的水平</em></p></div><h3 id="精通2-脚本语言">精通2+ 脚本语言</h3><ul><li><code>python 2/3</code> ➜ 使用层面 ✔</li><li><code>JS/TS</code></li></ul><h3 id="精通1-静态类型语言">精通1+ 静态类型语言</h3><ul><li><s><code>C/C++</code></s> ➜ <code>C++ 11/14/17</code></li></ul><h3 id="精通3-Gameplay模块"><s>精通3+ Gameplay模块</s></h3><ul><li>熟悉常见 Gameplay 模块 ✔</li></ul><h3 id="手写一套基于OpenGL的渲染管线"><s>手写一套基于OpenGL的渲染管线</s></h3><p>基于引擎实现具体中小模块的 <strong>增删查改</strong></p><ul><li><s>Shader (compiler and manager)</s> ➜ cross-platform shadercompiler</li><li><s>Texture</s> ➜ texture-budget</li><li>Camera</li><li><s>Lighting</s> ➜ Cluster Lighting</li><li><s>Shadows</s> ➜ CSM</li><li><s>Model/Mesh</s> ➜ Culling</li><li>Instancing</li><li><s>Postprocess</s>  ➜ SSR</li><li>Animation</li><li>…</li></ul><ul><li>Editor (Image, Scene, Model…) ✔</li><li>Debug Tools ➜ ImGUI、Tracy、RenderDoc…  ✔</li></ul><h3 id="图形引擎其他">图形引擎其他</h3><ul><li>良好的数学基础</li><li><s>图形学基础</s> ➜ GAMES</li><li>UE4/Unity的学习借鉴</li><li>前沿技术的积累</li></ul><h3 id="Learning-and-Coding">Learning and Coding</h3><ul><li>Reading Paper (GDC…)</li><li>Reading Document (API…)</li><li><s>Code review</s> ➜ MR ✔</li><li>Blog Recording (Markdown!) ✔</li><li>Learn from open-source</li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人日志 </category>
          
          <category> 个人日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
            <tag> OpenGL </tag>
            
            <tag> Algorithm </tag>
            
            <tag> linux </tag>
            
            <tag> Compiler </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Algorithm】BinaryTree</title>
      <link href="/posts/1E2J1Y0/"/>
      <url>/posts/1E2J1Y0/</url>
      
        <content type="html"><![CDATA[<p><code>这篇文章是大学写的</code></p><h2 id="二叉搜索树">二叉搜索树</h2><h3 id="1-0-定义">1.0 定义</h3><ul><li>每个节点包含属性left,right和p，分别指向左右子节点和父节点</li><li>二叉搜索树的性质: x.left&lt;= x &lt;= x.right； 左子树&lt;父节点&lt;右子树</li><li>基本操作与树的高度有关，即O(lgn)</li></ul><table><thead><tr><th>数据结构</th><th>查找</th><th>插入,删除</th></tr></thead><tbody><tr><td>数组</td><td>O(n)</td><td>O(n)</td></tr><tr><td>有序数组</td><td>O(lgn)</td><td>O(n)</td></tr><tr><td>二叉树</td><td>O(lgn)</td><td>O(lgn)</td></tr></tbody></table><pre><code class="language-c">struct Node {    int val;    struct Node* left;    struct Node* right;    Node(int x):        val(x), left(nullptr), right(nullptr) {}};</code></pre><pre><code class="language-c">//定义二叉树类型typedef Node TNode;typedef Node* pNode;class AVL { // 平衡二叉树public:    pNode root;    AVL() {root = nullptr;};    ~AVL() {delete root;};    int empty() {return (root==nullptr);};    int maxDepth(pNode p); // 该节点的最大深度    int minDepth(pNode p); // 该节点的最小深度    int findMax(); // 二叉树最大值    int findMin(); // 二叉树最小值    pNode search(int x);    pNode _search(pNode p, int x);    void insert(int x);    pNode findParent(pNode p); // 返回该节点的父节点    pNode successor(int x); // 返回节点x的后继节点    void Delete(int x); // 删除值为x的节点    void levelOrder(); // 层次遍历，用换行表示层数递进    void preOrder(pNode p); // 前序遍历    void inOrder(pNode p); // 中序遍历    void postOrder(pNode p); // 后序遍历};</code></pre><h3 id="2-0-查找二叉树的最大最小值">2.0 查找二叉树的最大最小值</h3><ul><li>最小值一定在树的最左节点，最大值一定在树的最右节点</li><li>不停向左(右)子节点搜索直到NULL即可</li></ul><pre><code class="language-c">int AVL::findMax() {    pNode p = root;    while (p-&gt;right)        p = p-&gt;right;    return p-&gt;val;}int AVL::findMin() {    pNode p = root;    while (p-&gt;left)        p = p-&gt;left;    return p-&gt;val;}</code></pre><h3 id="2-1-返回二叉树的最大、最小深度">2.1 返回二叉树的最大、最小深度</h3><ul><li><p>深度Depth定义：根节点root到叶子节点的距离</p></li><li><p>最大深度：即不断返回左右子树的深度中的较大值+1，递归实现</p></li><li><p>最小深度：即不断返回左右子树的深度中的较小值+1，递归实现</p><ul><li><strong>特殊情况：根节点只有一个子节点的时候，最小深度不是1，因为根节点不是叶子节点！</strong></li><li>处理方式：只有一个孩子，其最小深度就是该子节点的最小深度+1</li></ul></li></ul><pre><code class="language-c">int AVL::maxDepth(pNode p){    if (!p) return 0;    return max(maxDepth(p-&gt;right), maxDepth(p-&gt;left)) + 1;}int AVL::minDepth(pNode p) {    // 深度的定义：p到某个叶子节点的距离;    // 因此当p只有一个孩子时,它的深度并不是1    if (!p) return 0;    if (p-&gt;right &amp;&amp; p-&gt;left) // 有两个孩子，返回较小的深度        return min(minDepth(p-&gt;left), minDepth(p-&gt;right)) + 1;    else // 只有一个孩子，返回此孩子的深度        return minDepth(p-&gt;right) + minDepth(p-&gt;left) + 1;}</code></pre><h3 id="2-2-二叉树的查找">2.2 二叉树的查找</h3><ul><li>search(x)：查找key为x的节点，返回其指针</li><li>先和根节点比较，小的话去左子树搜，大的话去右子树搜，等于则返回</li></ul><pre><code class="language-c">pNode AVL::_search(pNode p, int x) {    if (p-&gt;val == x)        return p;    if (x &gt; p-&gt;val)        return _search(p-&gt;right, x);    return _search(p-&gt;left, x);}pNode AVL::search(int x) {    return _search(root, x);}</code></pre><h3 id="2-2-二叉树的后继节点">2.2 二叉树的后继节点</h3><blockquote><p>x的后继节点(successor node): key值大于x的节点中key最小的一个<br>x的前驱节点(prior node): key值小于x的节点中key最大的一个</p></blockquote><ul><li><p>查找x的后继节点，要对x进行讨论：</p></li><li><p>x有右子节点，那么后继节点是右子节点的最左子节点</p></li><li><p>x没有右子节点，再分两种讨论</p><ul><li>x自身是左子节点，那么后继节点是它的父节点</li><li>x自身是右子节点，那么后继节点是根节点，且必须满足x小于根节点，否则x没有后继节点<br><img src="https://img-blog.csdnimg.cn/2019051102103576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_5,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><pre><code class="language-c">pNode AVL::successor(int x) {    // 后继节点，大于x中最下的那个    pNode p = search(x);    pNode tmp;    if (p == root &amp;&amp; !p-&gt;right) // 根节点且没有右孩子        return nullptr;    if (p-&gt;right) { // 如果p有右孩子，那么后继节点就是右孩子的最左孩子        tmp = p-&gt;right;        while (tmp-&gt;left)            tmp = tmp-&gt;left;        return tmp;    } else { // p没有右孩子        pNode par = findParent(p);        if (p == par-&gt;left) { // p自身是左孩子            return par;        } else { // p自身是右孩子, 返回层数最靠近p的有左孩子de节点            if (p-&gt;val &gt; root-&gt;val)                return nullptr;            pNode ppar = findParent(par);            while (ppar) {                if (par == ppar-&gt;left)                    return ppar;                par = ppar;                ppar = findParent(ppar);            }            return nullptr;        }    }}</code></pre><h3 id="2-3-二叉树的插入和删除">2.3 二叉树的插入和删除</h3><ul><li><p>insert(x):插入新节点，同时维持二叉树的性质</p><ul><li>若树空，直接插入root</li><li>若树不空，通过不断和左右孩子比较，往下移动直到找出合适的位置<br><img src="https://img-blog.csdnimg.cn/20190507225047515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul><pre><code class="language-c">void AVL::insert(int x) {    pNode p = new TNode(x);    if (!root) {        root = p;        return;    }    pNode tmp = root;    pNode par;    while (tmp) {        par = tmp;        if (tmp-&gt;val &lt; x) {            tmp = tmp-&gt;right;        } else {            tmp = tmp-&gt;left;        }    }    if (par-&gt;val &gt; x) {        par-&gt;left = p;    } else {        par-&gt;right = p;    }}</code></pre><ul><li><p>delete(x): 删除已存在的某个节点x，同时维持二叉树的性质</p><ul><li><p>若x是根节点，直接删除</p></li><li><p>若x只有一个孩子，用该子节点替换x</p></li><li><p>若x有两个孩子，找到x的<strong>后继节点nex</strong>并替换x</p><ul><li>先用nex的key替换x的key，接着删除nex节点即可</li><li>若nex是它父节点的左孩子，那么把nex的左孩子顶上来</li><li>若nex是它父节点的右孩子，那么把nex的右孩子顶上来</li></ul></li></ul></li></ul><pre><code class="language-c">void AVL::Delete(int x) {    pNode p = search(x);    if (!p) {        cout &lt;&lt; "Not Existed" &lt;&lt; endl;        return;    }    // case 1: p 没有孩子节点， 直接删除    if (!p-&gt;left &amp;&amp; !p-&gt;right) {        if (p == root)            root = nullptr;        else {            pNode par = findParent(p);            if (par-&gt;right == p)                par-&gt;right = nullptr;            else                par-&gt;left = nullptr;        }    } else if (p-&gt;left &amp;&amp; !p-&gt;right) {        // case 2: 只有一个左孩子，替换即可        if (p == root)            root = p-&gt;left;        else {            pNode par = findParent(p);            if (par-&gt;right == p)                par-&gt;right = p-&gt;left;            else                par-&gt;left = p-&gt;left;        }    } else if (p-&gt;right &amp;&amp; !p-&gt;left) {        // case 3: 只有一个右孩子，替换即可        if (p == root)            root = p-&gt;right;        else {            pNode par = findParent(p);            if (par-&gt;right == p)                par-&gt;right = p-&gt;right;            else                par-&gt;left = p-&gt;right;        }    } else {        // case 4: 有两个孩子, 把它的后继节点替换到该位置即可        pNode suc = successor(p-&gt;val);        int key = suc-&gt;val;        Delete(key);        p-&gt;val = suc-&gt;val;    }}</code></pre><h3 id="二叉树的各种遍历">二叉树的各种遍历</h3><table><thead><tr><th>遍历方式</th><th>遍历顺序</th><th>应用和意义</th></tr></thead><tbody><tr><td>层次遍历</td><td>按一层一层遍历</td><td>符合人的直观感受</td></tr><tr><td>前序遍历</td><td>根结点 —&gt; 左子树 —&gt; 右子树</td><td><strong>打印目录结构</strong>：如每个文件夹下的文件</td></tr><tr><td>中序遍历</td><td>左子树—&gt; 根结点 —&gt; 右子树</td><td><strong>编译底层</strong>：实现表达式树</td></tr><tr><td>后序遍历</td><td>左子树 —&gt; 右子树 —&gt; 根结点</td><td><strong>回溯法:</strong> 实则就是采用后序遍历的形式</td></tr><tr><td><img src="https://img-blog.csdnimg.cn/20190511005459953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_1,color_FFFFFF,t_70" alt="在这里插入图片描述"></td><td></td><td></td></tr></tbody></table><pre><code class="language-c">层次遍历：1 2 3 4 5 6 7 8前序遍历：1 2 4 5 7 8 3 6中序遍历：4 2 7 5 8 1 3 6后序遍历：4 7 8 5 2 6 3 1</code></pre><p><strong>层次遍历</strong></p><ul><li>通过队列实现，每搜索一个节点，将它的孩子按先左后右的顺序加入队列；</li><li>这样保证了  1：层数越低的越先搜索； 2：左子树先于右子树搜索</li></ul><pre><code class="language-c">void AVL::levelOrder(){    if (empty()) {        cout &lt;&lt; "empty Tree" &lt;&lt; endl;        return;    }    queue&lt;pNode&gt; Queue;    queue&lt;int&gt; Level;    Queue.push(root); // 记录节点    Level.push(0); // 记录层数    pNode p;    int h;    int last_h = 0;    while (!Queue.empty()) {        p = Queue.front();        h = Level.front();        if (last_h &lt; h )            cout &lt;&lt; endl;        cout &lt;&lt; p-&gt;val &lt;&lt; ' ';        if (p-&gt;left) {            Queue.push(p-&gt;left);            Level.push(h+1);        }        if (p-&gt;right) {            Queue.push(p-&gt;right);            Level.push(h+1);        }        Queue.pop();        Level.pop();        last_h = h;    }    cout &lt;&lt; endl;}</code></pre><p><strong>前序遍历</strong></p><ul><li>搜索顺序：根结点 —&gt; 左子树 —&gt; 右子树</li><li>算法实现：1.访问根节点 2.前序遍历左节点 3.前序遍历右节点</li></ul><pre><code class="language-c">void AVL::preOrder(pNode p) {    // 先序遍历：根-&gt;左右节点    if (!p)        return;    cout &lt;&lt; p-&gt;val &lt;&lt; ' ';    preOrder(p-&gt;left);    preOrder(p-&gt;right);}</code></pre><p><strong>中序遍历</strong></p><ul><li>搜索顺序：左子树 —&gt; 根结点 —&gt; 右子树</li><li>算法实现：1.前序遍历左节点 2.访问根节点 3.后序遍历右节点</li></ul><pre><code class="language-c">void AVL::inOrder(pNode p) {    // 中序遍历：左-&gt;根-&gt;右    if (!p)        return;    inOrder(p-&gt;left);    cout &lt;&lt; p-&gt;val &lt;&lt; ' ';    inOrder(p-&gt;right);}</code></pre><p><strong>后序遍历</strong></p><ul><li>搜索顺序：左子树 —&gt; 右子树 —&gt; 根节点</li><li>算法实现：1.前序遍历左节点 2.后序遍历右节点 3.访问根节点</li></ul><pre><code class="language-c">void AVL::postOrder(pNode p) {    // 后序遍历：左右节点-&gt;根    if (!p)        return;    postOrder(p-&gt;left);    postOrder(p-&gt;right);    cout &lt;&lt; p-&gt;val &lt;&lt; ' ';}</code></pre><h3 id="3-0-扩展概念">3.0 扩展概念</h3><h4 id="满二叉树">满二叉树</h4><ul><li>顾名思义：每层铺满的二叉树，n层满二叉树有2^n-1个节点<br><img src="https://img-blog.csdnimg.cn/20190511013218832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h4 id="完全二叉树">完全二叉树</h4><ul><li>即倒数第二层以上都铺满，最后一层紧左边铺的二叉树<br><img src="https://img-blog.csdnimg.cn/20190511013303474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h4 id="平衡二叉树（AVL）">平衡二叉树（AVL）</h4><p>递归地满足：左右子树高度差不超过1的树<br><strong>为什么需要AVL?</strong></p><ul><li>因为当二叉树形似链表时，查找效率从O(lgn)变成O(n)，所以想办法使得树的高度尽量平衡<br><img src="https://img-blog.csdnimg.cn/20190921224122215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1aGFvMTk5ODA5MDk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>平衡因子：</strong> 某节点的左右子树高度之差<br><strong>二叉树的整个插入过程，分为四种形态：</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】pyautogui</title>
      <link href="/posts/2KGMM94/"/>
      <url>/posts/2KGMM94/</url>
      
        <content type="html"><![CDATA[<p>Python纯GUI自动化工具<span id="more"></span></p><div class="admonition note"><p class="admonition-title">备注</p><ul><li>这篇是大学于CSDN所写，移植过来</li><li>借助 pyautogui 实现鼠标键盘控制，实现一些自动化操作</li></ul></div><p>pyautogui是一个可以控制鼠标和键盘的python库，类似的还有pywin32。</p><h2 id="pyautogui的安装">pyautogui的安装</h2><p><code>pip3 install python3-xlib</code> 依赖库<br><code>sudo apt-get install scrot</code> 依赖库<br><code>pip3 install pyautogui</code>　python3下安装pyautogui库<br><code>import pyautogui</code> 引入该库</p><h2 id="pyautogui的使用">pyautogui的使用</h2><h3 id="保护措施">保护措施</h3><p>为了防止pyautogui夺取了鼠标的控制权导致我们无法关掉该程序，它提供了一个保护措施，即把鼠标移到最左上角，此时程序报错退出；<br>默认FAILSAFE=True，保护模式开启<br><code>FAILSAFE = False</code> 关闭保护措施</p><h3 id="获取屏幕信息">获取屏幕信息</h3><p><code>size()</code> 获取当前屏幕的分辨率，如(1920,1080)二元组<br><strong>注意：屏幕左上角是原点(0,0)，整个屏幕相当于第一象限</strong><br><code>position()</code> 获取鼠标当前坐标<br><code>onScreen(x,y)</code> 判断点(x,y)是否在屏幕范围内，如负值一定返回False</p><h3 id="移动鼠标">移动鼠标</h3><p><code>moveTo(x,y,duration=0.25)</code> 用0.25s的时间将鼠标移到(x,y)位置<br><code>moveRel(x,y,duration=0.25)</code> 以鼠标所在位置为原点，将鼠标移动到(x,y)处</p><ul><li>下面代码，让鼠标在指定位置绕一个正方形转动１０圈</li></ul><pre><code class="language-python">import pyautoguifor i in range(10):      pyautogui.moveTo(300, 300, duration=0.25)      pyautogui.moveTo(400, 300, duration=0.25)      pyautogui.moveTo(400, 400, duration=0.25)      pyautogui.moveTo(300, 400, duration=0.25)</code></pre><ul><li>下面代码，让鼠标绕当前位置绕正方形转１０圈</li></ul><pre><code class="language-python">import pyautoguifor i in range(10):    pyautogui.moveRel(100, 0,  duration=0.25)    pyautogui.moveRel(0, 100,  duration=0.25)    pyautogui.moveRel(-100, 0, duration=0.25)    pyautogui.moveRel(0, -100, duration=0.25)</code></pre><h3 id="鼠标事件">鼠标事件</h3><p><strong>点击鼠标</strong><br><code>click(x, y, button='left', click=3, interval=0.5)</code></p><ul><li>button有３个选项:left,middle,right，不加则默认点击鼠标左键</li><li>click表示单击次数</li><li>interval表示每次单击之间的时间间隔</li><li>click()函数实际由mouseDown()和mouseUp()组成，即按下和松开；<br><code>pyautogui.doubleClick()</code> 鼠标双击，其实就是执行两次click()函数。<br><code>pyautogui.rightClick()</code> 右击<br><code>pyautogui.middleClick()</code> 中击</li></ul><p><strong>鼠标滚轮</strong><br><code>scroll(200)</code> 控制鼠标的滚轮，正值上滚，负值下滚</p><p><strong>拖拽鼠标</strong><br><code>dragTo()</code><br><code>dragRel()</code></p><ul><li>按下鼠标，并拖拽到指定位置，用法同moveTo(),moveRel()</li></ul><h3 id="窗口截图处理、寻找目标按钮">窗口截图处理、寻找目标按钮</h3><h5 id="截图功能">截图功能</h5><p><code>im = screenshot( region=(x,y,width,heigth) )</code> 截取以(x,y)为左上角且指定宽高的区域，不加参数，默认截取整个屏幕<br><code>im.getpixel( (x,y) )</code>　获取指定位置的像素，是一个三元组(注意输入格式)<br><code>pixelMatchesColor(x,y,(R,G,B))</code> 判断(x,y)处的像素是否等于RGB<br><code>im.save('xx.png')</code> 保存为x.png</p><h5 id="寻找按钮">寻找按钮</h5><p><code>locateOnscreen('xx.png')</code> 寻找屏幕中和xx.png一样的图标位置，是一个四元组<br><code>click( center( locateOnscreen('xx.png') ) )</code> 点击该图标的中心，center用来获取图标中心点的坐标</p><ul><li>比如把网易云音乐的应用存为music.png，上述就执行自动点击网易云的图标</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Python】tkinter</title>
      <link href="/posts/1AMJ55J/"/>
      <url>/posts/1AMJ55J/</url>
      
        <content type="html"><![CDATA[<p>python + tkinter 实现绘图板<span id="more"></span></p><div class="admonition note"><p class="admonition-title">备注</p><ul><li>这篇是大学于CSDN所写，移植过来</li><li>背景是课程作业</li></ul></div><h2 id="python-tkinter实现绘图板">python+tkinter实现绘图板</h2><p>github项目地址: <a href="https://github.com/593413198/DrawingBoard">593413198/DrawingBoard</a></p><p><strong>创建时间：</strong><br><code>2019/5/10</code></p><p><strong>搭建环境：</strong><br><code>Ubuntu 18.04 + python 3.6 + tkinter</code></p><p><strong>使用指南：</strong></p><p><img src="/images/tkinter.png" alt=""></p><p>上方菜单提供了用户界面的所有操作；<br>下方文本框提供了命令行接口，按"执行命令"按钮即可执行指令<br>最底部显示canvas上的所有图元，包括 “类型”+“ID”**</p><p><strong>实现功能：</strong></p><ul><li>重置画布 resetCanvas width height<ul><li>删除canvas所有元素，然后重置窗口大小即可(canvas是始终铺满窗口的)</li></ul></li><li>保存画布 saveCanvas name.bmp<ul><li>因为linux下通过截屏实现，所有保存的画布实际是整个屏幕</li></ul></li><li>设置画笔颜色 setColor R G B<ul><li>tkinter内使用16进制，要转换</li></ul></li><li>设置画笔粗细 setWidth width</li><li>绘制线段 drawLine id x1 y1 x2 y2 algorithm<ul><li>Bresenham</li><li>DDA</li></ul></li><li>绘制椭圆 drawEllipse id x y rx ry<ul><li>中点圆生成算法</li></ul></li><li>绘制多边形 drawPolygon id n x1 y1 x2 y2 … xn yn<ul><li>通过Bresenham绘制多条线段即可</li></ul></li><li>对图元平移 translate id dx dy</li><li>对图元旋转 rotate id x y r</li><li>对图元缩放 scale id x y s</li></ul><p><strong>代码架构：</strong></p><ul><li>第三方库</li></ul><pre><code class="language-python">from tkinter import *import tkinter.messagebox as messagebox # 弹窗import pyscreenshot as ImageGrab # 截图功能 for linux#from PIL import ImageGrab # 截图功能 for MacOS and Windows</code></pre><ul><li>窗口及菜单</li></ul><pre><code class="language-python">window = Tk()  # 主窗口windowcanvas = Canvas(window, ...) # 主画布canvasmenu = Menu(windows) # 顶部主菜单menuentry = Entry(..) # 接受命令行指令的输入button = Button(..) # 读入指令并执行</code></pre><ul><li>全局变量</li></ul><pre><code class="language-python">Type_draw # 记录画图的类型  1:直线 2:点 3:椭圆Flag_draw # 记录是否允许画图  0:不允许 1:允许Color_pen # 画笔颜色 采用16进制表示Width_pen # 画笔粗细</code></pre><ul><li>鼠标事件</li></ul><pre><code class="language-python">onLeftDown()  # 鼠标左键单击，允许开始画图onLeftMove()  # 鼠标左键拖动，开始画图onLeftUp()    # 鼠标左键松开，停止画图</code></pre><ul><li>绘图算法</li></ul><pre><code class="language-python">Bresenham() # bresenham算法画直线Draw_ellipse() # 中点圆生成算法画椭圆</code></pre><ul><li>相关函数</li></ul><pre><code class="language-python">toHex() # 将RGB转化成十六进制色彩表示rotate() # 旋转指定点execute() # 读入命令行并执行</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Algorithm </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Algorithm】Graphs</title>
      <link href="/posts/2W1G2XP/"/>
      <url>/posts/2W1G2XP/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">备注</p><ul><li>这篇是大学于CSDN所写，移植过来</li></ul></div><h2 id="图算法的总结和实现">图算法的总结和实现</h2><h3 id="1-0-图的表示">1.0 图的表示</h3><ul><li>图通常用两种数据结构表示：<strong>邻接矩阵</strong>-&gt;稠密图、<strong>邻接链表</strong>-&gt;稀疏图</li><li>对于图 G = (V, E) ，V是点集，E是边集，|V| |E|分别表示点、边的数目<ul><li>稀疏图：边数很少的图</li><li>稠密图：边数接近|V|^2的图（一个图边数最多是点数的平方，只考虑单边图）</li></ul></li></ul><p><strong>邻接矩阵</strong></p><ul><li>维护一个n*n的数组，n是图的点数|V|</li><li>根据图的性质，数组对角线都为0，上下半角都对称</li><li>矩阵存储的特点，不论边数|E|多大，永远都开|V|*|V|大小的数组<br><img src="/images/graph-1.png" alt=""></li></ul><blockquote><p>因为矩阵的大小取决于|V|，所以当边数足够多的时候，采用邻接矩阵表示对空间的利用率最高</p></blockquote><br><p><strong>邻接链表</strong></p><ul><li>每个节点维护一个链表，储存所有与它邻接的点</li><li>所有链表的头部储存在一个数组中</li><li>数组空间O(|V|)，链表空间是O(|E|)、最坏空间是O(|V|^2)<br><img src="/images/graph-2.png" alt=""></li></ul><blockquote><p>因为链表大小取决于|E|，所以当边数足够小时，采用邻接链表表示</p></blockquote><p><strong>python代码如下：</strong></p><pre><code class="language-python">class Graph():    '''    无向图，点下标从0开始    G[x][y] = 1 存在边xy ; G[x][y] = 0 不存在边xy '''    def __init__(self,n):        # 声明一个有n个点的图G        self.n = n # |V|点数        self.node = [i for i in range(n)] # 所有点        self.G = [[0]*n for i in range(n)] # 邻接矩阵        self.d = [0]*n  # 记录宽搜中每个点到起点的距离        self.order = [] # 记录深搜的顺序    def add(self,x,y,w=0):        # 添加一条(x,y)的无向边        # 不输入边权重的情况默认为1        self.G[x][y] = 1 if not w else w        self.G[y][x] = 1 if not w else w    def remove(self,x,y):        # 删除一条(x,y)的无向边        self.G[x][y] = 0        self.G[y][x] = 0    def neighbour(self,x):        # 返回与x邻接的点        # rtype: 列表        ans = []        for i in range(self.n):            if self.G[x][i]:                ans.append(i)        return ans                def isEdge(self,x,y):        # 判断点x,y是否邻接        return self.G[x][y]</code></pre><br><h3 id="1-1-图的宽搜和深搜">1.1 图的宽搜和深搜</h3><ul><li><strong>BFS：广度优先搜索</strong><ul><li>采用优先队列，先将起点x入队列</li><li>不断从队列中取出元素，访问其所有的邻点，再将其中未访问过的邻点加入队列</li><li>当队列空时搜索结束</li></ul></li><li><strong>DFS：深度优先搜索</strong><ul><li>深搜的顺序不是唯一的；从任一节点开始都可以</li><li>对某一节点，只要找到一个邻点，就对邻点继续搜索邻点的邻点</li><li>理论上的深搜，是对所有节点执行一次上一步骤，这样保证了所有节点都能被搜索完，实际操作中可以维护一个set来记录已经访问过的节点</li></ul></li></ul><pre><code class="language-c">    以1为起点的BFS路径: 1 2 5 3 4    以1为起点的DFS路径: 1 2 3 4 5</code></pre><p><strong>python代码如下:</strong></p><pre><code class="language-python"># 广度优先搜索def BFS(self,x):        # 从点x开始宽搜        vis = [0]*self.n # 记录节点是否搜索过        Q = [x]        while Q:            v = Q.pop(0)            vis[v] = 1            for i in self.neighbour(v): # neighbour表示v的邻点的集合                if not vis[i]:                    Q.append(i)                    self.d[i] = self.d[v] + 1                    vis[i] = 1</code></pre><pre><code class="language-python"># 深度优先搜索def DFS(self,x):        # 从点x开始深搜        vis = [0]*self.n  # 记录节点是否搜索过        def dfs(node):            vis[node] = 1            self.order.append(node)            for i in self.neighbour(node):                 if not vis[i]:                    dfs(i)        dfs(x)        for i in self.node:            if not vis[i]:                dfs(i)</code></pre><h3 id="1-2-图的最短路径算法">1.2 图的最短路径算法</h3><ul><li><strong>单源最短路径问题</strong>：求出某一节点到其他所有节点的最短距离<ul><li>Dijkstra算法</li><li>Bellman-Ford算法</li></ul></li><li><strong>所有节点对最短路径问题</strong>：求出每个节点到其他所有节点的最短距离<ul><li>Floyd算法<br><br></li></ul></li></ul><h4 id="Dijkstra算法">Dijkstra算法</h4><ul><li>给定某一起点x，计算它到所有节点的最短距离<ul><li>dist[v] 记录起点到点v的最短距离，即最终返回结果</li><li>S 一个集合，存放已经处理过的节点</li><li>初始状态：令起点的dist为0，它的邻点的dist就是两点距离，其他节点的dist赋为无穷大</li><li>循环过程：不断取当前dist最小的节点v出来，对它的邻点i做<strong>松弛</strong>操作，当前最小节点视为已处理节点，放入集合S<ul><li><strong>松弛</strong>： <code>if dist[i] &gt; dist[v] + G[i][v]  { dist[i] = dist [v] + G[i][v] }</code></li></ul></li><li>终止状态：所有节点都已放入S，即都处理完毕</li></ul></li></ul><pre><code class="language-python"># dijkstra算法的python实现def dijkstra(self,x):        # dijkstra算法求x到所有节点的最短路径,采用贪心策略        dist = [99999]*self.n        S = set([x]) # 记录已经找到最短路径的节点        for i in self.neighbour(x):            dist[i] = self.G[x][i]        dist[x] = 0        while len(S) != self.n:            # 找到当前距离最小的点，这里用到最下优先队列            MIN = 99999            MIN_i = 0            for i in range(self.n):                if dist[i] &lt; MIN and i not in S:                    MIN = dist[i]                    MIN_i = i            # 松弛relax操作            S.add(MIN_i)            for i in self.neighbour(MIN_i):                if dist[i] &gt; dist[MIN_i] + self.G[i][MIN_i]:                    dist[i] = dist[MIN_i] + self.G[i][MIN_i]        return dist        </code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CSDN】进程和线程的深入理解</title>
      <link href="/posts/2TKZZE3/"/>
      <url>/posts/2TKZZE3/</url>
      
        <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">备注</p><ul><li>这篇是大学于CSDN所写，移植过来</li><li>回头看有点肤浅，但是这种类比学习的思维还是很难得呀</li></ul></div><h2 id="下面是抽象类比：">下面是抽象类比：</h2><p><code>单CPU</code>：一台单核处理器计算机 =  一个车间；<br><code>多CPU</code>：一台多核处理器计算机 =  一座工厂；</p><p><code>进程</code>：一个车间 = 一个进程； （即一个运行的程序）<br><code>多进程</code>：一座工厂可以同时运行多个车间；<br><code>CPU和进程</code>：<strong>单CPU只能同时运行单个进程，多CPU可以同时运行多个进程</strong>。</p><p><code>线程</code>：车间内一个工人 = 一个线程；<br><code>进程与线程</code>：<strong>一个进程可以包括多个线程</strong>。</p><p><code>线程间内存共享</code>：车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。<br><strong>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存</strong>。</p><p><code>内存安全</code>：可是，每个车间容纳大小不同，有的最多只能容纳一个人。车间人满的时候，其他人就进不去了。<br><strong>一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</strong></p><p><code>互斥锁</code>：一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。<br><strong>这就叫"互斥锁"–Mutex，防止两个线程同时读写某一块内存区域</strong>。</p><p><code>信号量</code>：这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。<br><strong>这种做法叫做"信号量"（Semaphore），用来保证多个线程不会互相冲突</strong>。</p><p><code>锁和信号量</code>：不难看出，互斥锁是信号量的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。</p><p><code>操作系统的资源分配与调度逻辑</code></p><ul><li>以多进程形式，允许多个任务同时运行；</li><li>以多线程形式，允许单个任务分成不同的部分运行；</li><li>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</li></ul><h2 id="下面是严谨的解释：">下面是严谨的解释：</h2><h3 id="进程">进程</h3><p><code>进程是程序的一次执行过程</code>，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。</p><h3 id="线程">线程</h3><p><code>线程是CPU调度和分派的基本单位</code>，它可与同属一个进程的其他的线程<strong>共享</strong>进程所拥有的全部资源。</p><h3 id="进程和线程的关系">进程和线程的关系</h3><p><code>线程是进程的一部分</code><br><code>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</code></p><h3 id="进程和线程的区别">进程和线程的区别</h3><p>理解它们的差别，我从资源使用的角度出发。（所谓的资源就是计算机里的中央处理器，内存，文件，网络等等）</p><p><code>根本区别</code>：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位</p><p><code>开销方面</code>：每个进程都有独立的代码和数据空间（程序上下文），<strong>进程之间切换开销大</strong>；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），<strong>线程之间切换的开销小</strong></p><p><code>所处环境</code>：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><p><code>内存分配</code>：系统为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（<strong>线程所使用的资源来自其所属进程的资源</strong>），线程组之间只能共享资源</p><p><code>包含关系</code>：线程是进程的一部分，所以<strong>线程也被称为轻权进程或者轻量级进程</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
