<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luhao&#39;s Blog</title>
  
  <subtitle>luhao wiki</subtitle>
  <link href="http://luhao.wiki/atom.xml" rel="self"/>
  
  <link href="http://luhao.wiki/"/>
  <updated>2023-06-22T12:40:51.748Z</updated>
  <id>http://luhao.wiki/</id>
  
  <author>
    <name>Luhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Computer Networking</title>
    <link href="http://luhao.wiki/posts/network/"/>
    <id>http://luhao.wiki/posts/network/</id>
    <published>2023-06-22T12:18:00.000Z</published>
    <updated>2023-06-22T12:40:51.748Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络大纲，HTTP/TCP/UDP…<span id="more"></span></p><div class="markmap-container" style="height:425px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Network Model&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;TCP/IP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;OSI&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Protocol&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;HTTP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;TCP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;UDP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;KCP&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Web Server&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Apache&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;Nginx&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Tools&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Telnet&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;curl&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;wireshark&quot;}]}],&quot;p&quot;:{}}"></svg></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机网络大纲，HTTP/TCP/UDP…&lt;/p&gt;</summary>
    
    
    
    <category term="Network" scheme="http://luhao.wiki/categories/Network/"/>
    
    <category term="Network" scheme="http://luhao.wiki/categories/Network/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>【网络】http 协议入门</title>
    <link href="http://luhao.wiki/posts/http-1/"/>
    <id>http://luhao.wiki/posts/http-1/</id>
    <published>2023-06-21T16:15:09.000Z</published>
    <updated>2023-06-22T12:16:39.959Z</updated>
    
    <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE">专栏：透视HTTP协议</a> 墙裂推荐 ⭐</li><li>掌握基本理论 + 动手抓包实验</li></ul></div><div class="markmap-container" style="height:450px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;HTTP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#Hypertext\&quot;>Hypertext</a>（html）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;text&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;media&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;hyperlink&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#Transfer\&quot;>Transfer</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;client&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Chrome, Edge&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Telnet&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;server&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;<a href=\&quot;https://nginx.org/\&quot;>Nginx</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;<a href=\&quot;https://httpd.apache.org/\&quot;>Apache</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;CDN（内容分发）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\&quot;>负载均衡</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;加速访问&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;<a href=\&quot;#Protocol\&quot;>Protocol</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#TCP-IP\&quot;>TCP/IP</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;#IP\&quot;>IP</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;<a href=\&quot;#TCP\&quot;>TCP</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;<a href=\&quot;#DNS\&quot;>DNS</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;<a href=\&quot;#域名解析\&quot;>域名解析</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;<a href=\&quot;#DNS缓存\&quot;>DNS缓存</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;<a href=\&quot;#URL\&quot;>URL</a>（网址）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;<a href=\&quot;#URL\&quot;>示例</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP抓包\&quot;>HTTP抓包</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;wireshark&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP报文\&quot;>HTTP报文</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;request-line&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;request-header&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;request-body&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP方法\&quot;>HTTP方法</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;GET, HEAD&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;POST&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;HTTP特点&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;.&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;.&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;可靠传输&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;明文传输&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;无状态&quot;}]}]}]}],&quot;p&quot;:{}}"></svg></div><h2 id="HTTP协议">HTTP协议</h2><p>HTTP 协议是 <a href="https://en.wikipedia.org/wiki/HTTP"><em><strong>HyperText Transfer Protocol</strong></em></a> 的缩写，它是一种用于超媒体信息传输的应用层协议，是互联网通信的基础。</p><p>如何通俗地理解 HTTP协议 呢？</p><div class="admonition todo"><p class="admonition-title">如何理解新概念?</p><ol><li>任何技术思想，在现实生活中都能找到映射</li><li>巧用 “类比” 的手段</li></ol></div><h3 id="Hypertext">Hypertext</h3><p>在互联网早期，传输的信息只有简单的字符文字，即 <code>Text</code>。随着信息爆炸式地增长，网络需要传输的信息被扩展为 图片、音频、视频等等，这些就是超文本。<br>超文本的核心是 <a href="https://en.wikipedia.org/wiki/Hyperlink">超链接 Hyperlink</a>，通过互相引用而形成复杂的网状信息结构。</p><h3 id="Transfer">Transfer</h3><p>HTTP 是一种 <code>Request-Response</code>协议，即将信息在 A、B 两个点之间双向传输，因此有两类参与方：</p><ul><li><code>client</code><br>http请求的发起方，通常指浏览器（如Chrome、Edge）</li><li><code>server</code><br>http请求的接收方，又称为 <code>Web Server</code>，如 <a href="https://nginx.org/">Nginx</a>、<a href="https://httpd.apache.org/">Apache</a> 都是常见的服务器框架</li><li><code>CDN</code><br>client和server之间通常不会直连，而是经过 <code>CDN</code>(<a href="https://en.wikipedia.org/wiki/Content_delivery_network">Content Delivery Network</a>) 这个中间商。它能够实现安全防护、负载均衡等常见功能。</li></ul><h3 id="Protocol">Protocol</h3><p>HTTP 是众多网络协议中的一个，先理解什么是协议?<br>以毕业生签署的“三方协议”为例，参与对象是多元的（自己、学校、企业），同时协议还会规定各方需履行的义务，以及该做什么和不该做什么。因此协议的核心要素是：</p><ul><li><p>多方参与<br>client、server、中转者…</p></li><li><p>通信规范<br>如规定 <code>Get</code>、<code>Post</code> 的请求报文格式，如请求的错误处理等等</p></li></ul><p>在 HTTP 的发展历程中，也经历过很多大版本的迭代，如 <code>HTTP/0.9</code>、<code>HTTP/1.0</code>、<code>HTTP/2</code>、<code>HTTP/3</code>等等。</p><h2 id="TCP-IP">TCP/IP</h2><p><a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">TCP/IP协议</a> 是整个互联网的标准通信协议，它实际上是一系列协议的统称，其中最核心的是 TCP 和 IP，这里篇幅有限只作简单介绍。</p><h3 id="IP">IP</h3><p><strong>IP协议（<a href="https://en.wikipedia.org/wiki/Internet_Protocol">Internet Protocol</a>）主要解决寻址和路由问题</strong>，它提出 <strong>IP地址</strong> 的概念来定位互联网上的每一台计算机。因此可以将其类比为电话号码，而整个运营商的拨号系统就是一个 IP协议。</p><p>IP协议又分为 IPv4 和 IPv6，大部分仍在使用前者，即IP地址是4个用冒号分割的数字，例如 <code>1.15.115.4</code>。之所以出现 IPv6，是因为v4分配的地址已经捉襟见肘，不够整个互联网的使用。</p><h3 id="TCP">TCP</h3><p><strong>TCP协议（<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol</a>）是一种 传输控制协议</strong>，它基于 IP协议 之上，提供可靠的、字节流形式的通信，也是HTTP协议得以实现的基础。</p><p>之所以了解TCP/IP协议，是因为HTTP运行在前者上，因此又称为 <code>HTTP over TCP/IP</code>。</p><h2 id="DNS">DNS</h2><p>在TCP/IP协议中，通常使用纯数字的 IP地址 来标记计算机，这非常不利于用于的使用和记忆。<br>因此 <strong>DNS（<a href="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System</a>）域名系统</strong> 应运而生，它使用具有实际含义的名称来替代IP地址（即英文+数字的组合，也可以是汉字），例如：<code>95.211.80.227</code>是IP地址，<code>nginx.org</code>是其域名，两者指向的是同一个web服务器。</p><h3 id="域名解析">域名解析</h3><p>以 <code>www.apple.com</code> 这个域名为例，当用户尝试访问该域名时，会经过至少3次的DNS域名解析服务器：</p><ul><li><em>Root DNS Server</em>：管理 <code>com</code>, <code>cn</code>, <code>net</code>等顶级域名的IP地址。</li><li><em>Top-level DNS Server</em>：管理 <code>apple.com</code> 的IP地址。</li><li><em>Authoritative DNS Server</em>：管理 <code>www.apple.com</code>的IP地址。</li></ul><h3 id="DNS缓存">DNS缓存</h3><p>目前全世界有 13组 <code>Root-DNS-Server</code> 提供顶级域名的解析服务，但因为全世界的网民都在请求，会造成系统的拥挤并降低访问速度，优化手段之一就是利用 <em>DNS缓存</em>。</p><p>当你已经访问过 <code>www.apple.com</code>，操作系统就会在某个文件（如下↓）<strong>缓存解析后的IP地址</strong>，这样下次访问时，就不再需要经过 DNF解析服务器了。</p><ul><li>linux: <code>/etc/hosts</code></li><li>windows: <code>C:\WINDOWS\system32\drivers\etc\hosts</code></li></ul><h2 id="URL">URL</h2><p>通过 TCP/IP协议 加上 DNS 的组合，我们实现了访问互联网中任意一台机器，但是每台机器上的资源仍然有很多，如何对他们加以区分呢？</p><p><strong>URL（<a href="https://en.wikipedia.org/wiki/URL">Uniform Resource Locator</a>）含义是 统一资源定位符，即俗称的网址</strong>，如下是其组成格式：</p><p><img src="/images/URI.svg" alt=""></p><ul><li><code>scheme</code>：指定http、https、ftp等协议<ul><li><code>file</code>：本地文件</li><li><code>ftp</code>：文件传输</li><li><code>ssh</code>：加密登录</li></ul></li><li><code>://</code>：约定俗成的分隔符</li><li><code>user:passwd@</code>：明文身份信息，已被弃用</li><li><code>host:port</code>：省略端口会用默认值，如 HTTP 80，HTTPS 443</li><li><code>path</code>：资源的在主机的路径，也可能是服务路径</li><li><code>?query</code>：查询参数</li><li><code>#fragment</code>：仅浏览器使用，用于锚点跳转</li></ul><h2 id="HTTP抓包">HTTP抓包</h2><p>“纸上得来终觉浅”，我们通过在windows下快速搭建一个最小化的HTTP模拟环境，借助抓包工具 wireshark 来对 HTTP 的细节一探究竟。</p><blockquote><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/07%20%20%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%8C%E6%90%AD%E5%BB%BAHTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.md">搭建http本地实验环境</a></li><li><a href="https://zhuanlan.zhihu.com/p/82498482">知乎: Wireshark抓包指南</a></li></ul></blockquote><p>在启动本地web服务器后，尝试在浏览器输入 <code>127.0.0.1</code> 访问该server，然后按下回车，wireshark抓包（限制<code>http/tcp port 80</code>）抓包的结果如下：</p><ul><li>前三个包：TCP协议的 “三次握手”</li><li>中间四个包：HTTP协议发送了一个 <code>GET /HTTP/1.1</code> 的请求报文，Server回复OK</li><li>后四个包：HTTP协议发送了请求 <code>/favicon.io</code> 的请求报文，Server回复404</li></ul><p>通过http抓包，基本清楚了http协议的工作流程，<strong>核心是 “Requst-Response”，即 “一问一答”的模式</strong>。</p><p><img src="/images/wireshark-http.png" alt=""></p><h2 id="HTTP报文">HTTP报文</h2><p>通过wireshark也可以清楚看到http请求发送的报文内容，其全部由 ASCII文本 组成，非常容易肉眼阅读。</p><p>HTTP协议的 requet报文 和 response报文 的组成机构基本相同，由三个部分组成，每个部分由一个空行 “CRLF（0x0D0A）” 隔开:</p><ul><li>请求报文</li></ul><div class="markmap-container" style="height:220px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Request-line&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;Method&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;URI&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;http-version&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Request-header&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Key-Value&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;eg. Host: 127.0.0.1&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;eg. Connection: keep-alive&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;eg. User-Agent: xxxxxx&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Request-body（空）&quot;}],&quot;p&quot;:{}}"></svg></div><ul><li>回复报文</li></ul><div class="markmap-container" style="height:180px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Response-line&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;http-version&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Status-code&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;200：成功&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;404：查找失败&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Reason（描述原因）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;Response-header（同上）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Response-body&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;eg. name=luhao&amp;amp;password=1234&quot;}]}],&quot;p&quot;:{}}"></svg></div><ul><li>报文示例<br><img src="/images/http-request.png" alt=""></li></ul><h2 id="HTTP状态码">HTTP状态码</h2><p>既然 HTTP协议 采用 “一问一答” 的模式，那么响应报文内应该包含请求的结果信息，即状态码（Status Code）。<br>目前 RFC标准 规定状态码是三位数，即取值范围是 000 到 999，其从设计之初也有具体的含义区分：</p><ul><li>1xx：提示信息</li><li>2xx：成功<ul><li>200 OK</li></ul></li><li>3xx：重定向</li><li>4xx：客户端请求报文错误<ul><li>400 Bad Request</li><li>403 Forbidden</li><li>404 Not Found</li><li>408 Request Timeout</li></ul></li><li>5xx：服务端内部错误<ul><li>500 Internal Server Error</li><li>502 Bad Gateway</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;导读
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%</summary>
      
    
    
    
    <category term="Network" scheme="http://luhao.wiki/categories/Network/"/>
    
    <category term="Network" scheme="http://luhao.wiki/categories/Network/Network/"/>
    
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【GAMES101】Shading</title>
    <link href="http://luhao.wiki/posts/1XEKK6X/"/>
    <id>http://luhao.wiki/posts/1XEKK6X/</id>
    <published>2023-06-13T15:42:19.000Z</published>
    <updated>2023-06-21T18:06:01.853Z</updated>
    
    <content type="html"><![CDATA[<p>Lambertian、Blinn-phong、shading-tech<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101 Shading</a></li><li><a href="https://www.cs.ucr.edu/~shinar/courses/cs130-spring-2012/schedule.html">CS130 Shading</a></li><li><a href="https://www.cs.toronto.edu/~jacobson/phong-demo/">WebGL demo</a></li></ul></div><div class="markmap-container" style="height:300px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Factors&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2],&quot;f&quot;:true},&quot;v&quot;:&quot;光源&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3],&quot;f&quot;:true},&quot;v&quot;:&quot;平行光&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4],&quot;f&quot;:true},&quot;v&quot;:&quot;点光&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5],&quot;f&quot;:true},&quot;v&quot;:&quot;聚光灯&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6],&quot;f&quot;:true},&quot;v&quot;:&quot;相对位置&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7],&quot;f&quot;:true},&quot;v&quot;:&quot;距离衰减&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8],&quot;f&quot;:true},&quot;v&quot;:&quot;角度（Lambert’s cosine law）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9],&quot;f&quot;:true},&quot;v&quot;:&quot;材质&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10],&quot;f&quot;:true},&quot;v&quot;:&quot;Ambient&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11],&quot;f&quot;:true},&quot;v&quot;:&quot;Diffuse&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12],&quot;f&quot;:true},&quot;v&quot;:&quot;Specular&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Shading-Reflection⭐&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#font-color-750000-Lambertian-Reflection-⭐-font\&quot;>Lambertian</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#font-color-750000-Blinn-Phong-Reflection-⭐-font\&quot;>Blinn-Phong</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Shading-Tech&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[16,17],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#1-Flat-Shading\&quot;>Flat</a>（poly）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#2-Gouraud-Shading\&quot;>Gouraund</a>（vertex）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#3-Phong-Shading\&quot;>Phong</a>（pixel）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;Shading-Normal&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#1-顶点法线\&quot;>Vertex-normal</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[21,22],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#2-像素法线\&quot;>Pixel-normal</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="Shading">Shading</h2><p><a href="https://en.wikipedia.org/wiki/Shading">Wikipedia: Shading</a><br>维基百科对于 shading 的定义非常清楚，即对3维场景中模型 <strong>着色</strong> 的过程，且着色的效果取决于如下几个因素：</p><h3 id="1-光源">1.光源</h3><p>推荐阅读：<a href="https://learnopengl.com/Lighting/Multiple-lights">LearnOpenGL</a>，<a href="https://www.cs.ucr.edu/~shinar/courses/cs130-spring-2012/content/Lecture12.pdf">CS130-Lecture12</a></p><ul><li><p>Ambient lighting<br>环境光照，即使在最黑暗的情况下，存在一些微弱的光亮使得物体呈现出一些颜色。</p></li><li><p>Directional lighting<br>平行光，也称作天光，在固定的光源方向上无任何衰减。</p></li><li><p>Point lighing<br>点光，向四周照射，随距离衰减。</p></li><li><p>Spotlighting<br>聚光灯，呈一个锥形范围照射，随距离衰减。</p></li></ul><h3 id="2-相对位置">2.相对位置</h3><ul><li><p>距离关系<br>光照强度一般随 <strong>距离的平方</strong> 衰减，$ ~ I / r^{2}$</p></li><li><p>角度关系<br>根据 <a href="https://en.wikipedia.org/wiki/Lambert%27s_cosine_law">Lambert’s cosine law</a>，$\vec {n} * \vec {l}$ （结合后面的 Lambertian Reflection 理解）</p></li></ul><h3 id="3-材质">3.材质</h3><ul><li><p>Roughness<br>粗糙度越高，镜面反射能力越强，典型代表如镜子。</p></li><li><p>Metallic<br>金属度越高，漫反射越弱。</p></li><li><p>Translucent<br>具有透光属性，如典型的 <a href="https://en.wikipedia.org/wiki/Subsurface_scattering">SSS</a>。</p></li></ul><h2 id="Local-Shading">Local Shading</h2><p>现实中的光照，需要考虑各种直接光、间接光的反射、吸收效果，想要在图形引擎中模拟它们非常不现实。因此一些大佬提出局部的着色算法，以模拟 <strong>一个独立点的shading计算</strong>，这里统称为 local-shading。<br>我们需要了解 <code>Lambertian Reflection</code> 和 <code>Blinn-Phong Reflection</code>。</p><h3 id="font-color-750000-Lambertian-Reflection-⭐-font"><font color="#750000">Lambertian Reflection ⭐</font></h3><p><strong>Lambertian模型</strong> 一般用来模拟 diffuse光，核心影响分别是：距离、角度。<br>距离基本的衰减关系，前面讲过了。角度根据 <a href="https://en.wikipedia.org/wiki/Lambert%27s_cosine_law">Lambert’s cosine law</a> 计算得一个光照强度的系数，其中 $max(0, n \cdot l)$ 表示任何大于90度的夹角，光照强度都为0。</p><p><img src="/images/lambert-shading.png" alt=""></p><hr><h3 id="font-color-750000-Blinn-Phong-Reflection-⭐-font"><font color="#750000">Blinn-Phong Reflection ⭐</font></h3><p><strong>Blinn-Phong模型</strong> 在前者的基础上引入了 <strong>Ambient 环境光</strong> 和 <strong>Specular高光</strong>，它是一个叫<code>Blinn</code>的教授拓展了<code>Phong</code>的光照模型，其计算方式分别为：</p><ul><li><strong>Specular</strong></li></ul><blockquote><p>$L_{s} = K_{s}(I/r^{2}) max(0, n \cdot h)^{p}$<br>引入一个 <strong>半程向量 $h (=\frac{v+l}{|v+l|})$</strong>，实际含义为入射角和观察角的二分之一夹角。此时衡量 $h$ 和 $n$ 的接近程度，即点乘 $n \cdot h$（<code>Phong</code>模型选取的是 $cos(\alpha)$，$\alpha$是夹角）， $n, h$ 越接近 则点乘值越大，则高光越强烈。<br><br>其中的 p 衡量 <strong>高光随夹角的衰减速度</strong>，p值越大，则呈现高光的范围越小（如下图）。</p><ul><li>p = 5 … 10：塑料</li><li>p = 100 … 200：金属<br><img src="/images/blinn-phong-demo-all.png" alt=""></li></ul></blockquote><ul><li><strong>Diffuse</strong></li></ul><blockquote><p>同 Lambertian模型</p></blockquote><ul><li><strong>Ambient</strong></li></ul><blockquote><p>$L_{a} = k_{a}I_{a}$<br>环境光假设任何点来自环境的 <strong>光照强度是一致的</strong>，即 $I_{a}$，它与实际光照方向无关。<br>笔者粗暴地理解为自发光、固有色。</p></blockquote><p><img src="/images/blinn-phong.png" alt=""><br><br></p><h2 id="Shading-Tech">Shading Tech</h2><p>推荐阅读：<a href="https://en.wikipedia.org/wiki/Shading">Wikipedia</a>，<a href="https://www.cs.ucr.edu/~shinar/courses/cs130-spring-2012/content/Lecture14.pdf">CS130-Lecture14</a></p><p>前面讨论光照模型的计算，但是忽略了一个重点：<strong>以什么对象（或粒度）进行Shading?</strong><br>基于前面的知识得到，任何 mesh 都是由顶点和三角形（或Poly）组成，因此自然想到如下几种方案：</p><ul><li>Tri（Poly）：基于三角面的 Flat Shading</li><li>Vertex：基于顶点的 Gouraud Shading</li><li>Pixel：基于像素的 Phong Shading</li></ul><p><img src="/images/shading-tech.png" alt=""></p><h3 id="1-Flat-Shading">1. Flat Shading</h3><p>对<strong>每个三角形（或Poly）</strong> 计算出一个法线，可以通过叉乘得到，并基于法线作光照计算。此时三角形内的Shading结果是一样的。可以理解为 <code>Low-Poly</code> 的渲染风格。</p><h3 id="2-Gouraud-Shading">2. Gouraud Shading</h3><p>对<strong>每个顶点</strong>作计算（假设顶点没有自己法线，可以根据周围几个三角面的法线求均值）。可以理解为 <code>Vertex-Shader</code>。</p><p><img src="/images/gouraud-shading.png" alt=""></p><h3 id="3-Phong-Shading">3. Phong Shading</h3><p>对<strong>每个像素</strong>插值出单独的法线，基于此作光照计算。因为是全像素的，所以性能开销高。可以理解为 <code>Pixel-Shader</code></p><h3 id="三种方案对比">三种方案对比</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Flat</th><th style="text-align:center">Gouraud</th><th style="text-align:center">Phong</th></tr></thead><tbody><tr><td style="text-align:center">光照粒度</td><td style="text-align:center">poly</td><td style="text-align:center">Vertex</td><td style="text-align:center">pixel</td></tr><tr><td style="text-align:center">表现</td><td style="text-align:center">劣</td><td style="text-align:center">中</td><td style="text-align:center">优</td></tr><tr><td style="text-align:center">性能需求</td><td style="text-align:center">低</td><td style="text-align:center">中</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">需要顶点法线</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><h2 id="Normal">Normal</h2><p>Shading的着色计算非常依赖 <strong>法线</strong>，下面介绍两种常见的法线计算方式：</p><h3 id="1-顶点法线">1. 顶点法线</h3><ul><li><p>模型自带，例如 <code>obj</code> 格式可以指定逐顶点的法线</p></li><li><p>计算顶点周围 <code>Poly</code> 的法线均值</p></li></ul><p><img src="/images/vertex-normal.png" alt=""></p><h3 id="2-像素法线">2. 像素法线</h3><ul><li>通过两个顶点的法线插值，记得归一化！</li></ul><p><img src="/images/pixel-vertex.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Lambertian、Blinn-phong、shading-tech&lt;/p&gt;</summary>
    
    
    
    <category term="Graphics" scheme="http://luhao.wiki/categories/Graphics/"/>
    
    <category term="Graphics" scheme="http://luhao.wiki/categories/Graphics/Graphics/"/>
    
    
    <category term="OpenGL" scheme="http://luhao.wiki/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【CSAPP】Virtual Memory</title>
    <link href="http://luhao.wiki/posts/1X3A6C1/"/>
    <id>http://luhao.wiki/posts/1X3A6C1/</id>
    <published>2023-06-13T12:33:56.000Z</published>
    <updated>2023-06-22T07:24:12.375Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟内存，cache，内存分配<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="http://1.15.115.4/CSAPP-3rd.pdf">CSAPP 第9章：Virtual Memory</a></li><li><a href="/posts/3RBTN4W/">汇编（一）：计算机架构入门</a>（站内文章，硬件基础知识）</li><li><a href="https://fengmuzi2003.gitbook.io/csapp3e/dixzhang-xu-ni-nei-cun">CSAPP重点解读：虚拟内存</a></li><li><a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf">What Every Programmer Should Know About Memory</a>（114页pdf）</li><li>ptmalloc，tcmalloc，jemalloc... （功力还不够）</li></ul></div><div class="markmap-container" style="height:250px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;What/Why&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;physics-memory 及弊端&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;virtual-memory&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Virutal-Page&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#PTE\&quot;>页表 PTE</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Cache&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#page-hits-✔\&quot;>页命中</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<a href=\&quot;#page-faults-❌\&quot;>缺页</a>&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;<a href=\&quot;#locality\&quot;>Locality</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;时间局部性&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;空间局部性&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="virtual-memory">virtual memory</h2><p>物理内存有什么问题？1. 内存空间不够，2. 产生内存碎片，3. 没有内存保护。从这个角度看，<strong>虚拟内存是一个中间层，本质是到物理内存的一层映射关系</strong>。<br>并非所有系统都会使用虚拟内存，一些古老or简单的系统就会直接使用物理内存。</p><p>物理地址和虚拟地址的对比如下：</p><ul><li><p><strong>Physical-Address</strong>：物理地址，从0开始每个byte递增1<br>物理地址可以直观反应内存大小，且是连续的，例如 <code>0x0000 ~ 0xFFFF</code> 表示 <code>64KB</code> 的内存。</p></li><li><p><strong>Virtual-Address</strong>：虚拟地址，是一种到物理地址的映射（<a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>）<br>使用虚拟地址，可以节省地址总线的位数，且利于cache实现。</p></li></ul><p><img src="/images/virtual-memory.png" alt=""></p><h2 id="cache">cache</h2><p><strong>存储器</strong> 是计算机用来存储数据的器件，即通常所说的磁盘。其根据读写特性又可以分为两类：</p><ul><li><p><strong>ROM（Read-Only-Memory）</strong><br>只读，一般是显卡、网卡上的默认系统，如<code>BIOS</code></p></li><li><p><strong>RAM（Random-Access-Memory）</strong><br>可读可写，显卡上的RAM又成为显存</p></li></ul><p>为了提高CPU读写数据的速度，现代计算机在 CPU和RAM之间又增加了 <strong>速度更快、内存更小、造价更高的</strong> <em><strong>L1, L2, L3 Cache</strong></em>，这部分称为 SRAM（Static）。<br>作为对比，DRAM（Dynamic） 一般用作虚拟内存的cache。<font color="#FF1E10"><strong>（???）</strong></font></p><p>至于为什么 SRAM 速度要比 DRAM 快很多？这需要从硬件制造上理解，参考阅读：<a href="https://rf.eefocus.com/article/id-336795">存储技术SRAM详解</a></p><h2 id="page">page</h2><p>计算机内存会被划分为固定大小的 <strong>页（page）</strong>，划分页是为了实现缓存的功能。</p><p>对于虚拟内存而言，任何一个 <strong>虚拟页（virtual page, VP）</strong> 中的内存只能处于如下三种状态：</p><ul><li>unallocated：未分配内存，即不占用任何物理内存</li><li>cached：已缓存（在物理内存中）</li><li>uncached：未缓存（在物理内存中）</li></ul><h3 id="PTE">PTE</h3><p>为了描述 虚拟页 和 DRAM 之间的缓存关系，操作系统引入 <strong>页表 PTE（Page Table Entry）</strong> 的概念。通常情况下，它有一个有效位和一个n位地址 组成：</p><ul><li><strong>有效位</strong>：对应的虚拟页是否 cached</li><li><strong>地址位</strong>：若cached，则对应 DRAM 的物理地址</li><li>其他许可位：如可读、可写、可在内核运行等</li></ul><p>配合下图理解，一段虚拟内存被分为 8个虚拟页，对应着左侧的 8个PTE，其中的虚拟页1、2、4、7已经在物理内存中被缓存，同时在PTE中存储了对应地址。</p><p><img src="/images/virtual-page.png" alt=""></p><h3 id="page-hits-✔">page hits ✔</h3><p>页命中，即虚拟页已经在DRAM中被缓存，读取时只需根据 PTE 找到对应的物理地址。</p><h3 id="page-faults-❌">page faults ❌</h3><p>页缺失，即虚拟页 <code>cache miss</code>，这是它在 PTE 中的有效位是0，即代表其在 DRAM 中未缓存。<br>此时内核会选择一个已经被缓存的 “无辜儿” 去替换成该页，这个无辜儿又称为 <strong>牺牲页（victim page）</strong>，同时进行如下两个操作：</p><ol><li>（物理内存中）用 查找页 替换 牺牲页</li><li>（页表PTE中）交换 查找页和牺牲页 的 cache有效位</li></ol><p>注意这里的 <a href="https://forum.huawei.com/enterprise/en/thread/667215004455288832?page=1">替换策略</a> 很重要，主要有如下两种（实际应用会更复杂）：</p><ul><li>write-through：直写，发生改变时更新cache和内存</li><li>write-back：回写，发生改变时只更新cache</li></ul><p>DRAM 为了性能考虑，采取的是 <code>write-back</code> 方案。</p><h2 id="locality">locality</h2><p>虚拟内存、分页之所以能达到非常好的cache优化，是因为程序的局部性原理 <a href="https://en.wikipedia.org/wiki/Locality_of_reference">Locality of reference</a></p><ul><li><p><strong>时间局部性</strong>：一个刚刚被访问的内存地址，在未来有更大概率被再次访问</p></li><li><p><strong>空间局部性</strong>：被访问的内存地址，其周围的内存更容易被访问</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟内存，cache，内存分配&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://luhao.wiki/categories/Linux/"/>
    
    <category term="Linux" scheme="http://luhao.wiki/categories/Linux/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>【CSAPP】CMU 15-213</title>
    <link href="http://luhao.wiki/posts/2GDQQH6/"/>
    <id>http://luhao.wiki/posts/2GDQQH6/</id>
    <published>2023-06-11T18:00:54.000Z</published>
    <updated>2023-06-22T12:22:26.435Z</updated>
    
    <content type="html"><![CDATA[<p>CS网课中的 “圣经”<span id="more"></span></p><style type="text/css">blockquote{    line-height: 30px;    padding: 4px 16px;}</style><blockquote><ul><li><a href="https://www.cs.cmu.edu/~213/">课程主页</a> | <a href="https://www.bilibili.com/video/BV1iW411d7hd/">B站视频（中字）</a> | <a href="https://www.cs.cmu.edu/~213/lectures/">课程ppt</a></li><li><a href="http://1.15.115.4/CSAPP-3rd.pdf">CSAPP pdf 英文版</a></li><li><a href="https://github.com/Maecenas/ICS-15213-CSAPP3e-CMU">Labs Github</a></li><li><a href="https://fengmuzi2003.gitbook.io/csapp3e/">CSAPP重点解读</a></li><li><a href="https://wdxtub.com/work/">读薄/读厚 CSAPP</a></li></ul></blockquote><h2 id="CSAPP">CSAPP</h2><p>CSAPP 是 《Computer Systems: A Programmer’s Perspective》 这本书的缩写，它作为CMU大学的ICS课教材，被誉为计算机系列课程的圣经，其内容涉及：计算机组成原理、操作系统、编译优化、网络和并发等。</p><p>“万丈高楼平地起，勿以浮沙筑高台”，学习计算机的底层原理，是在修炼内功、在夯实基础，这比修一个bug或者读几段代码更加实在。</p><h3 id="站内文章">站内文章</h3><ul><li><a href="/posts/24H1CZ3/">2. Information Storage</a></li><li><a href="/posts/1X3A6C1/">9. Virtual Memory</a></li></ul><h2 id="关于-labs">关于 labs</h2><p>首先 <code>CSAPP</code> 的整个学习过程：以 <code>labs</code> 为主，视频和ppt 为辅。在github上找到一份疑似官方一致的repo，自己fork了一份用于开发：<a href="https://github.com/593413198/ICS-15213-CSAPP3e-CMU">🔥<em><strong>Github Repo</strong></em></a></p><p>整个 labs 的设计非常精巧，还囊括了测试、评分的用例，后者是用 python2 脚本编写。以 lab-0 为例稍微介绍其整体的架构设计：</p><ul><li><code>RAEDME</code>：实验说明</li><li><code>Makefile</code>：通过 <code>make</code> 完成实验的编译、运行与测试</li><li><code>*.c, *.h</code>：lab源码 ⭐</li><li><code>qtest</code>：脚本驱动的测试框架，值得一读 ⭐</li></ul><p>其中 <code>console.c</code> 实现了一个精巧的可交互命令行，并集成一些用于 lab 的指令。<code>qtest</code> 集成了前者和一些测试用例，它将评判你的代码是否通过多少case、以及获得多少得分。</p><p><strong>通过实验，读懂实验框架代码，这两件事都很重要！</strong></p><h2 id="Lab0-c-programing">Lab0 - c programing</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;CS网课中的 “圣经”&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://luhao.wiki/categories/Linux/"/>
    
    <category term="Linux" scheme="http://luhao.wiki/categories/Linux/Linux/"/>
    
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【cpp】constructors &amp; destructors</title>
    <link href="http://luhao.wiki/posts/10R6MRC/"/>
    <id>http://luhao.wiki/posts/10R6MRC/</id>
    <published>2023-06-10T18:42:16.000Z</published>
    <updated>2023-06-18T13:12:53.652Z</updated>
    
    <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">提要</p><ul><li><a href="https://hackingcpp.com/cpp/lang/destructors.html">hackingcpp: destructors</a></li><li>面向一些基础使用，因此所涉比较浅</li></ul></div><h2 id="基础">基础</h2><p><code>cpp</code> 有 3 种特殊的成员函数，本文所有的内容都围绕它们展开：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">what</th><th style="text-align:center">when</th></tr></thead><tbody><tr><td style="text-align:left"><code>T::T()</code></td><td style="text-align:center">默认<u class="green">构造</u>函数</td><td style="text-align:center"><code>T</code>创建时</td></tr><tr><td style="text-align:left"><code>T::~T()</code></td><td style="text-align:center">默认<u class="green">析构</u>函数</td><td style="text-align:center"><code>T</code>销毁时</td></tr><tr><td style="text-align:left"><code>T::T(param…)</code></td><td style="text-align:center">特殊<u class="green">构造</u>函数</td><td style="text-align:center"><code>T</code>带参数创建时</td></tr></tbody></table><p>即使用户不去声明 构造 和 析构 函数，编译器也会<strong>自行创建者两者</strong>。</p><p>构造函数的调用时机很容易理解，但<strong>析构函数的调用时机</strong>很特殊。</p><ul><li><p>显式地销毁对象</p></li><li><p>隐式地被销毁，如局部变量的作用域结束</p></li></ul><pre><code class="language-c++">if (...) {    T x;  // constructor}  // destructor</code></pre><h2 id="Constructor">Constructor</h2><p>构造函数根据构造的类型，又分为如下几类：</p><pre><code class="language-c++">class Test{public:    Test(int a);  // 构造函数    Test(const Test&amp;);  // 拷贝构造函数    Test&amp; operator=(const Test&amp;);  // 拷贝赋值operator    Test();   // 构造函数    ~Test();  // 析构函数}</code></pre><p>考虑如下两个初始化的用法，才能看出调用构造函数的区别：</p><ul><li><code>Test t1(88);</code>：普通构造函数</li><li><code>Test t1 = t2;</code>：拷贝构造函数</li><li><code>Test t1; t1 = t2;</code>：拷贝赋值operator</li></ul><div class="admonition warning"><p class="admonition-title">C++11 delete</p><ul><li>申明为 <code>Test(const Test&amp;) = delete;</code> 可以禁止用户使用拷贝构造函数</li><li>此时如果调用，会有编译报错：<u class="error"><code>error: use of deleted function ‘Test::Test(const Test&amp;)’</code></u></li></ul></div><h2 id="Destructor">Destructor</h2><p>析构函数的调用顺序是编译器严格限制的，即<strong>析构顺序与声明顺序相反</strong>。</p><p>对于如下的结构体 <code>Test</code>，当对象发生销毁时，执行析构的顺序依次是：</p><ul><li><code>Test -&gt; t3 -&gt; t2 -&gt; t1</code></li></ul><pre><code class="language-c++">class Test {    T1 t1;    T2 t2;    T3 t3;public:    Test();    ~Test();}</code></pre><h2 id="RAII">RAII</h2><blockquote><p><em>Resource Acquisition Is Initialization</em></p></blockquote><p>这条 <a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii">stackoverflow</a> 认为<code>RAII</code>应该称作<code>Scope-Bound Resouce Managerment</code>，这样更容易理解，笔者深表赞同，因此下面也围绕这个理解展开。</p><p><strong>Resource</strong></p><p>首先理解什么是 <code>Resource</code>? 可以理解为任何需要被合理控制的c++对象</p><ul><li><em>file handles</em></li><li><em>thread</em></li><li><em>lock</em></li><li>…</li></ul><p>对于任何一个resouce，它的生命周期会经历 <u class="black"><strong>创建 -&gt; 使用 -&gt; 销毁</strong></u> 三个阶段。而销毁往往最容易被忽视，这会引起内存泄漏等问题。</p><p><strong>Scope-Bound</strong></p><p><code>Scope</code>是指一个resource的作用域，当其离开作用域时，应该自动调用其析构函数以使其销毁。</p><div class="admonition note"><p class="admonition-title">总结</p><ul><li><code>RAII</code> 是一种防止内存泄漏而进行自动析构的cpp特性</li></ul></div><h3 id="RAII应用">RAII应用</h3><p>一些 C Library 总是会成对出现一些功能性的函数，例如：</p><ul><li><code>gpulib_init</code>, <code>gpulib_finalize</code></li></ul><p>如果只调用了init函数，而忘记调用负责析构的后者，就会出现内存泄漏、资源hung-up等bug。<br>因此我们可以在cpp层通过 RAII 的理念将它们封装一层：</p><pre><code class="language-c++">#include &lt;gpulib.h&gt;class GPUContext {  int gpuid_;public:  explicit  GPUContext (int gpuid = 0): gpuid_{gpuid} {    gpulib_init(gpuid_);  }  ~GPUContext () {    gpulib_finalize(gpuid_);  }}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;提要
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hackingcpp.com/cpp/lang/destructors.html&quot;&gt;hackingc</summary>
      
    
    
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/"/>
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/C/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【talkshow】xxxx</title>
    <link href="http://luhao.wiki/posts/2CP1SAW/"/>
    <id>http://luhao.wiki/posts/2CP1SAW/</id>
    <published>2023-06-07T15:37:02.000Z</published>
    <updated>2023-06-18T13:12:53.660Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="390b9a25c4a13f2347890878438d830a81e157ff649c9d1b9d9ec385fdd5b566">b3dc07a81f6459d120ce338ccca550468031e953d3bd13f897dad4c574bcccba38e6cb7c8214bc93cae50bc6c83d479b782250b803055710988efcf503fd2a20984a58bbe6cff1760171498aa89a27519166281642613aa35ddb1524a4663b549cabeb1ef96809c9c95ee2aa1b84bc8941326c42938e1bd920d0b54da784f4fd474241f4b3adc39c9993c63cfdb85f91283fcac5b5965a553b7ff557c404604a4e32cfea3b0dbb8a52851f026a51da33c8f394bba65a4a0b4aa61d4161b4a38c1db4bca7f21dd706dbd0a6f5ce2b9932d0df4f62048d159b055229a543e66fc5a73c2367d7716c45beebdef95dbbf9f529098514ac69c281d8b840ec7417bbd417491323417d1436077d41e2ad5333d5ad83eec718f4258f3de7c780eeff7c7f2a8f0a7c13d00202f1fda0926c3324f1b073249f8daeaab3b211c8a35f722db42cb1e4ea219d90152f49349aad51f64180dd1fa9de49aa8f3df182e347a03dbea2e65a97deb733d65910675d32867db474b0764dbe4e88ccd81609e624e5ed7af6ca11006c2d6535c771fca4aecc465c06b19f498250dbd2f36897c7a829a926bd4c23c42089910ed69278de83ee5290c7a0334af87c54990a59a0e45512837fb565a1cdfa8b979c2ee5b013b57c3226a53f17ee5844ca6c03a0aa05f6a3fc7744078e52115009fc4be7096ecb89c6c6a5c191cc9c0425d49bd52d3a53c42e6986216f5d51b2724207645c2a2364c51aad404d71766b1b3c42f558918d8662cbab9a2f0e653a10101579c0605026721f5c72edaa14f451b5172f3aefaae08825055ac019e07a90e9fe7e8a2bbac9faf001052f6a9794c82f9d434881c7cf74efc958f05c016cae84b7bd86123b83801434b12e4da0d306d7cb6f8ffec735e241eebf3af4b5fb78954cda4d919a58ad6bdde8583d01f892a0c12fa61ac604e8e54d09a6365466caedfdaee7045e651553017736787ecee1348e9c9f1486f772137e2fcd9830fedfbc320b3c028d769a706577ddc6b48989bc405bc28abdc8c60c6926ea3deb975c6ce79c34a74bcb6913b27c110b6721d205a9d3357720cb1f5c993e2c585411ff9598c631601a4c785c98389fb0baa2f9d3289065079e32606794ed271d80cbfd7819f2296a6b50dfab2b18a61486a2c2f7f82b9867caed4fd3aceb1f2402344846ff01d5abe058af88b6af99bd893a830708817a6f9ef7146e24e335f32ae3dea768cf7e8fbf4c355c11d55d451b12dae7043e8a53f997aa3467da47602a71ea373b9280826bd3ee3e39d0af83062268261880bbc3c925117ea75f83c4a3b4e55c4aa3db04a4cadea18844ecd11c9fbccaa8aee5f52e97a9af53833fd9f8d5169501280a40aea95ec8aa6f2af303a8686f1ea25131a64be257d6bf633b989894dae5c194d023b57b4b4c3857b460fce16e451075ead2503064917b80c09f64720a50c219653ca48de4588a39ded6cbcd02c6e45f80f7530036f8be704e0760bbdb6678c8d001755bb3f16074be3a93eca9dc73634687ffeccd84d4adb0df5b28d4b051164ac740dca4929c2e37b0b44bf7960acda1c492571d78436d7ada2d2fd01783c748b2d6a89ecd6af044203b0178d1f164dcdc0db0b76531ab415ff91e7951081d05ede329777aa8c68088e4489d440dd116605f714695f1437503ac1a732415c86cf3ef100f3f408d855a5d5fbc7ec835fde2957c8ee292c524a683bac53fa4fa5cadd4d1d0dee26450ba96ce14e1bac0e868321f2f9dc439db96fad265f6e144f62b4ece3c0658b434059e0bdce857b2669b445d9e31dea9129f1aabf49407070b3ec00bfcdf82f05a82ecc247cca12430d09867a8762f1956f6fcbbb2e1f8e824376c8d1c13cf67b8d452425d89e302a806dab64c1a038b363f3d770f282fe9a9420bbad00774a1aff4160f6f193b6f40a71418c0425082134f5296aa49be2729a404f9899acfbe63db9646df5694fbc3ea729283185aa5e00b2bd7c98216ae7d0458df7ceee3db617c0f64db2cc9f5fc2ec8b59c532ec8862b6b512a786f2838cb94a6910b69722c09f5214283026ec6f4ebb9915e10e4a659a66b56ef150ef7d76c29314118ac3570f6add8e49e95be79f075dd8bed3e3ec5f2d2fb056d02a64a381833375e8c947f0368b1276cbf5720c720a80bcca76784913cc1f8bf977db812e324bf0a9a403841c7c860a713e675ee56c4be1f30d1c767190297110452827a42e2339cb8af2ab748c908092639901e49a192c4dda98a61703bc54672e6ac03a847d016eb12193d41caee213b85e1436d4a2704cff16c9cbc3629806293915fc000c7040cfe13a8b2107b34eb4798163927baa6defbea2623f6ec9b3526b75739cfd62e46e264e93e4166e05385c5bd7c677a45b3998e68880eff2ac6c0573c9dcfb461981bcf4d028d4bdb4547fe96d7f44d72b7f53aaa2b7a667b94ce86b904df49d3ccba330ef71658601f6da7429d0c73c4d5cfd86ea085dc5aae7aa441b3345064d676e5359b5aa10d6ef1822dbf88fc75598ee43e0341a4bf1acb832169d5786061dd66ab03f9e4d9699a9e72dbe8309c13730d058740436d96352b9422d6a556e25127e6fbc1c69dbbd13f53333750b4dd83517e6b8bcad6b1fbb5623d94d4cf068abbedad1684f87b5bdd1365e5f87dde1c19633bd786e372f60bcc92349ec67b14e469f29a8d86aeb20491ae141698401e8001e3777389da0e015be9c08c235a8ef6351266b3ef1b9cc0bc9d95031542c435e64319640ffaf73d56ba55603493f6a4bf6e394751ae85c5ef7179f902e934d0b9536fb6cfd839ae5929febe5f2806d7b5fa0895e50f03fdb84b7f58d8b5c22d318f3220919588fcb02d0421ca71e6a400880aa7b30e85aeb79b633d892e666c19614d2dec32f29025a5dd40ecb1abefc47b7db4c12609bc8df62785fd246215cc454b87f0276a72ed2dde3c69c360adbb8fa24f03a6f0c1c084398e5265c86945ff49a092c93e62ad7f5127f6ac2e271c8e08231afeea5bb62bf2f8d2f3e45932d8d91eda13525e21d8e5713e44939f59582c025a5e5d8c2c67967f2dc59dd09d4d65657e0a88ca6fc8c2a9383767593539640f3663175d50218e898036ab93dddc404bcf5836a97d5392ad75b44343c3cba18274a12136b716e540a152111086bd1caf4f9ab9bceed0a2837e415a29b0b90df9ff85a26f2ac9ab89b42ac24bdab67f125faf646079069ad5c3b0398a0fefac85a38c9c1748359d5121523a40d984d6e5f6525f37ddcd63114ba9ffe76a49c1daf0edc4c5d42c28e58787a80dda64a832b2604b8eeaa4fcc98405c7b36bafdc3d2efb39233266c3ca8c222cdf615e785d449b94c09ff2b306a8085cd97ff479cb65e9e8c1f88590fcd084d6d4c0cc991edf29778bf19d532e04b0fb52e7ab84ecdfe5e11eac707a85ba662c2e6d04d1dfdc4ce87791d5a9274758c337815d650667396d2e54e89616f99f11818d14a134c46a34990642800923d17078b4d4f3f0afb0d4baff893ac68751de51dd6c131f968140ed82e875432ab6838045a8941e9cf08dd04ee05a2497ed9045c9ccbc18871110e547a5dfbff8422e94109997584d58445c1fa3fc405f5b6505977c33d2f42dcc136e7d5fcde5b7da5dc46f8d4d87fc6fb0784f8fc773b71dbca5df0f667d728d94a4c6ee664a5c6c34e42fff3e87c2230b65bc5cddb691d63dc8a86b179d4d33d8d6720e1a61cfbddba8d695d5f4f1208c34e2c3202e9165679801a0f98aa004386c7622a82f36a8cd1d9ebaf004c5fe08d861c0478b2ad09b6692d276126ee451a35808d5e8e06d0f7124d5537930c07f72d3e1fdaa34aff93c391ffb7b87524764290ec8368e6e42a196e60fbb86c056a201a2ff1f639f79a69793fe328cab297192d91247cacd7f1a50dc3584006b461947428453aaabcb6b247d71f59b5c480b7bf2f5e34bfc64a95c866c3b6b935eb8a1b0b09034dd0dceb52233a226d142e0333a1ff5d687c93576287c7e625a16f65a51a69caeb18f1895073b01bbaf2f6be0176e7a9c81321bc55a130586362f9e829cf737feab9a209f8e642a651fd5af16551d61de681baa3a1097b42895eb1b0f0f997f69e95d76e3efefb1557d28d8ae8d48a14bc71aab3be34fab94423e4f0ad21eecb1486712fd66b52a348e58798d8251ccc25ed1d71e6dcf687a80062050576cc23fe1e8ab51f2abc7587a9af3849f7400851e4e08d94d6ba46c208a9204c938d638f77d2c744d0b7b83e96dbe3bfc40ac743f24fc8c7a459e30bf4bc14eebd36317c9cfc1c8fac87574800e73e5f31397eae0f26a4760e116bf93e7493ac83f25c97e7d381e5b35d3a33cc50f5e54b7b64b72b405527e5343c42ebcfc3644df25bd317d8365e43cac17baefba21402cbcc44395109330af06229f47664fd284320cc38b8d5ee6ffb8273e74f0d87a6e607211e3ed8968f8e2e433811e9cc70cc8e08536f97bd735d9c77344a0b1c4fb8b1f229db2fd9ed901cb8b835c7a17a6c32847b761195c6c18e37f7629884ff2c1911582550495b003720de529cf3a6877789c106d550079ba389e82f254f9fb26e912501226bc3412f8d71bc83b3be540d9f85058459a954860d6851507d73d2b40bbd2545b9182592e7a0a7917456ea3ac1005a9410b7d4f819965207b2be5d0a942d271d6e896763af4ab5bfe5803f3307d0a580c66011f494431e66e2f11705b274bf71ffd06e46a1cb1607b8b36899287d17423571fb7921b0b63846315bed225e95a716e00fc77b5e32feae1a12325f063a5aed02a1c9e0ce015639e4e3ff899c20e025bad52772d4bc41466e6d4250982e05a1fe2f3c5a1cfda463ac18effdb553c5c9c27067700c9426d3cb23148d97d6dc795446c0e13d0d9d2e703acbd04af5f4e79029599b0d174fd2c77f723d755431deddb78e8aca5765f88abcc5d150790c06d1f4ce175bebf9d3749de2f16ee98e283e8f2e602a25ccb380537957362aa1c9b966057e5bbce471634004dbd1c3a49169d578ebc52a1367b9e7038be4f5e8d933a385c6542fae17fdaf29e254303a7627fefffe6ab18f3fbc49c2720903c4ff2e58c3a3015023afe2d2366d8f947cd797a704e63cfeff263d89d92b987b722b896d1896fe5a2e78a83b165bbaf0669eb1162af68a4cbe87024a5e7651cdf714a53bd1a272354f86486af19c93d5995cb8b836adf15324640dfb471f7bb3e59a6047e91fd6eb7e5e867bbd670ac22da7cd72ae7d841c3e7141e5fbda7fdc04b2f3de7aec96548daedf773fbcfb402dde950ca04d2ee6009c278f6d8a3b2293017a7c0a03cd84d865e127cfee37abccdddae69c1ca8425ff9e7b68912fb40774e97d786a1848a16688167057a78e0b5d1a6e5aa4c7ac8d2db584b6b4ce0d84885a92227c2c3bafa2f7389b0c247a360b960a9e0fbab0ea62f1daa85e05f3e759572ce86836d77628b2cffa487cb966e0064893485353a6ee7a0c43a9e20e0cd8ddb79ccaeb39d712cb5ba40f6b9c11ac8d0a71b167af689852209f9542404d046831f9b87b0b64a6167d61fcff0ed73c0f78164786f31368bf227325e5a01263a7e34706d401ec771f646a9e7bb9610b5136b7c6a1a35c10882b17a41871ef8eb1d5e0da495a93c6c48de44b455788bdf4bb6bc42862500f00b8371414b9137f653500ae2205273951d34a6cfd5c16b5e3a362cc2d90e88de94f0ea496f96aa32d0c213b90afdc576067b85b4f16de58e59e33b5b6703fae17765f0ad75351fc0e69c961ae189e305bf6fc6441f281306477e5127de13b0909dc149fe04b1fe07d9d30779efaca1ca635188d123a5f1547ee02afecd22f0cfe93cd19fd7a796542a6d2611d20af1144616da28b18d0a54604502a1492ceb08f2cdee3678c7b9162822b9019185a2562b9a306ba81bdae53b2e52bae1bfa00cda117a684943c5a9366ffd9afa4a94876b54dffea5f25a1345e3cb2bb26a0a8f7cc9dadd87aafa73076babb77090f09fc085e266cf05e1763609f7b12a6d2c7e76f9f731ad44054a538ac6f00bcfa3f6bb7e9f2f72c9795dbd7fedd98ba1dd6c8a8374f9212dba8c30bf6b56786a6229d96030250a4d6a429004a80d95bff815ff3ce795bf12d62bd53fe2a0fbee6fd0aea5b5ca75c98109299b835f860825a23bca1cc9e32264464f53a3a572e1e27a6f36775cc68c18a7a9d3d6ee30de67d29af048ec164fe017067a4110bfd2830d06a02a4f918f8e43ae4ae3edcb1acac70c86252faf1f6716af274965f5cb03a163ed5a4c607e98b1be82307d1ebfb781bc29c32bc91c7a552494c99fe4daa5b3016ad1dd3d46637a44466d3e63a29906a6961f3757ef7f9cdfdf753169620580fd55f81f38a047d3e13b6e12c64e96f1f6e58ce5303e51c55a19e8f5f24891efa5ce17350ae1fea3c3abd7ebac99bfda045256ab6e44712e9501d7a7bb53374b6fd3941e73db72cb5de23a5edcaf67bc84fe4ad4daf7aa8c5030623515197f21d350877d54ef2536e2639dc57552a02743d5ee1d433e832144818329affb09e9725393951a914f9799841d607c2a433ef2ba90ee96f3250b1070b32f204598ddcbb0f20577a908372ffe6e7e87f9bcbdc0434a8d09e835da2011a753abc6f4dc58fdea1c9f23552d14797fea5eecf12a57ed7f7a7c58798efa1bc1eda2ee93b50d71a2201064af78537d31910a89af227d1bb407fc0acc40b19f91924716566aef112d23a92bf32339e6d60cde02fc15d35bc2fcfa494c1fabbefeee42fb53f15503fc9d67b4aebfe7aea9fdd75bf58655e852b055692e93a282b2d87991db02a69d0b867c6c7208c4541b90bbae584244f2bf493faebec6c0eb5886ff05a08a72c1efe8ef32a2ce0cf180232a8cd936a149928d6dc35c9833cede8e80560dc20b5b23126df9e996ac357bde8d3f7216ca42e865016f4769de1b07eda651102b4ca57393b643c16408c0a990750ee83a34886bf0c6a377ea2a8e5ee82c0e17cdee9ceb7ae05cf899b3791a7bdc46906727d32b60a6d59c3da5cbf76747cc211263b8ec580ebdc73657c9fab9e41f2429277a80d2d8aa9fe04c1af31c0d2d5441f023e3b28b049e99b2ba44942d7856398546459d2ee552ff5f52e26be4b93435d3f7732e2d85db671c0e3445c81a1d1c78530eafabb463e5833117bdd3c00ec582c6f9df754a7048ec9b1882d8535428e9068517d8b095b6119556edef89f402fa1a5c028c9731afa3c5aeebbe046bfdcd46cc4f64f613fcd54c6b880b14a53af0e0c497555fcbe2fd78d173b82050161dd2eceb8e4cf59e57946dcca81c79ebc0dae192edbf705fb46bcf2c6101ffd22</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">&lt;p&gt;内部分享的提纲，&lt;code&gt;7月13日&lt;/code&gt;前完成&lt;/p&gt;</summary>
    
    
    
    <category term="量化" scheme="http://luhao.wiki/categories/%E9%87%8F%E5%8C%96/"/>
    
    <category term="量化" scheme="http://luhao.wiki/categories/%E9%87%8F%E5%8C%96/%E9%87%8F%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>2023下半年规划</title>
    <link href="http://luhao.wiki/posts/2023b/"/>
    <id>http://luhao.wiki/posts/2023b/</id>
    <published>2023-06-04T17:29:53.000Z</published>
    <updated>2023-06-22T07:14:15.347Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="59637a3213e1087be70c3fc82283098261043cb96d42eb8968049ba0c04dbff5">b3dc07a81f6459d120ce338ccca5504603780459e0306826441972681af56d62ee5e99a6b2a15c89d5fbc320a13f63ed9ba268edabaf6c1c008413d66883445c58b4a2e699e4db9148ef23f3cdb870ec629634ee078e07787bd698a1a7017441544b629e2ca45641055b5256dddc3850ef7b32f2b68d3790a725ce8ee1848b4e29139d82dc7e412ad454c07aa205233a72745362d1b46e637326d420e4ac5e28b017b61b1e296a78ef19174eaf108459d882e5566ca8f8f60623de7fad8d11de55ac7a485bf7431c027be922ed67691382f46e870981bfa2d5f44c37647e9f884f2c949ff8f74e5fa4d637bdc965636ed0230500af093bd31a7b09acf2445adb8794690deae28484535dfdb43f905e86f1f116f0169e8c1fc959c8cdc8f536d29b45e0055f060e277960438f3b7441e4433b8e2b0b25e0c1c984a9b970f79be5c299c53e9f5649de409de0e9c8271ac72737be89130de7d9f651119ab27e5db8285e6066a31d7b630681769a831d8ad44976a85e28a763b4e128e8b541d4187fe92bdc1db792ded7ac589105fac7f2d847e01e1a2a4f54a7b50fa605979ec03db403e8432e439bde891e8575497cc028b90ff9967d7c5a4e51231b481d54100f0f49e9eafc22bf6070256368edfd9e80e8eaae554fac1e4dc028ae0ec799eb5c80e216caa6c3f06ae212a2de09fde666bfce2ff1ae39b5f753fa6f722c992264a9f8bbb82603edd5a61c84689807651c2df19c599531905a44b8c489d26b9c1dcdc9238f1a1ed5c0def5941890a95761e2df3b9762f297d04c15152a63ee349727ecd6e6be2d2ed4ade30aba550296fb0f738b65941e17c316c53c758eb2d95913c80b7f91722185b2f4c60599c87333bcd7b9d1385db4c8cc2ba4f4aa34ef1c970586e81333bb7de97542008f3d98a7a068c3a540aafe63311b0e22063c405710aa58c9802c0e4d9936d09177f24ede9cb6bc78b4de6095b1abb21f564a29591330e6c50784064a5a619ce48ab6005088029d5d0a2d78d3b34e82d7968f694d49a1fd754cd77543466aca41b9ae87ddf12a3b4db481fcb5ebcb647279324a6212675e72aa580e1f954524c631eef02912552cab06da0e20bf2d57e3bf77afc5b021db5fa2210aa43507fc58a3e1069a01fd5389803856cdfe8561ec2b0dde9c0362ee608a731175a65af9a8ff6fe23e76836ac35bca9a52f91275b2bdbcf09d5b8bac458596d5fd129cb6b02964c81981515846888f64157dffad5d856edaec88321f498ff8a410cd50298f0cc9d53b85cc7ce786f8688cee4b6c5f05619fbcd63da27df903b06685101f7a828a2abf41c3bd95a506af6d585c3e0b8a522b8c3e18fe0db3b6a494ef9ac5a1f9213a6992c2dda381f1312bd9ebc0d604794bf7fcb88bfc58f724d9f85552f935620ce8b0f9eec0e03dd7739860ce0eeacc7e641fd97eccc7ad6b67f152e2e7e31eec0f1cf9a0652f1abafe4a8de911ead81c311b2e367b1f9157d70cbf36480cbd8611c79339eddef46e400e9af76c0912f4446907bfcea6160d3255557e6758c1b1e366ae5646ab42b034d9f288311b040c3c5963761796ad20a343d0844b9fb69e6c0630be98f92e5357ad75d317a4e52fb87fab01edafe02d1d205ae9c30fdeb881ea761076bfa9c6cad543ea094de9b9066cb808df299e2c32513d062115c64af48f81724fe7c5ee6a9e90ad78aae2dd3e9b009398317db2ba4fd95b1ff571a755cbf425d238289ab2591d2b45eb521368940530b70a3c5731b2b257f98bce74e90e3f45207fc400e666d8594297ac514cb5c1bb0fdfaf1972798838d8d3af3dd3a15717915dcaad4d178b849b983caa36097b63aa47202e11eed82292c3d77e2919845a931c254bf226d6410317226876b88d6db241ed69527460feb15d1401aa6359298f64e92aa70340c7bcc232fb18cf0eb2bfad82e4b872d89d171213bc763cadc0e43e6e969b25610b1d42b6ca2a331c7e4560e22026496ace61faff05a9f354d9f258af77957f8dff1f6b955ba37908d42f17caeef9f57901510bab7761177adb1cdc13b36ab9e860530aed4c25f56408ff58c1c2c77ce1a9a4bf744f3435f7ee8570733434630f40194737f75e5adcfe6f3ccfe1f34568bf704ada31cb4a84fee98a51dfc2f0a072893083974a23479d68a8a6a11f5c5be9a0befd60e427afbdd56026d96b2a94c0077a4288eadcc776c83f4ae039bc0eb25ee224a0e93fad8724f1c27ecad94f4a8f0ab3f549483c61a50d0ee216c5ae2ecb4c5fd5453d36aae6b3490df0d286666ebf913e7eba88320da5e5a94fb86b8fc8eb9c4ce9d0d617733d95ab8f2e3f01425b259d403712415693ea05bc7fda4001d86c9249fa9caa789b6b59e4180cd8e89f9d09f90e7c46c1379d930c8bb08d52577cb43016f02bb17e91ee794cec282cab04fb5d215fc0f73c8a3de30300431fd82545416ddfb87a678d7253dc194baf1fb6a2867aa9abaf1362293d830aa61b06b596294ebf0917e7d7d616ceac8b9da5cb03e35448154b3ab3484e8f020b07b85444b81274f07a3098f1a817378cea286c5a6871920dae37eece68d3ecb6781b7ed513d2af751f4d5f866bbe8f91f31cc5dea64ad6a2dbf5574ee6fdee59f6b2cd80173eef4a966694ac95f4358591d586b356407135a4d91476e7e04f0271791128e4b38a04a8379e4935127754320f2fd2844c397470b6bea8ddd47fae6070b08637bb09f4b32a5770e243a5cbb64e1ad257420198222923665c263010d0481b9e7ca6a3c4d0c7864e71ab1c73ffea76ac0a62139167fc50f9689d187dcd1ce5607b52649cf18df2b50ca14ce0d9d3f9759927c55df446ec96862c0354e096790fbd0db5f944c8f24b1dad01c47500f6969ff6e483fcb710d2b027d9372d8540f3d21398cf2a06637cef499db0454b60ff306c858737fa6ebe8f5dda4b07e7d88730562eef0d57f91b2d61972a357da27e8c30876761add6520a034cb73cdf3448f4566f528f316c02024580c0af5f5edd9f75709435a98e62bf54369cc16e5c21eb6ba741a0f5fb4f91e70fd72252294cf357b9f6ed20242814edf9bf4d2e8d193df0467ed451ea192733ccdf8e44b9b4a7a2612592210adfa3e301658d0693565484def3bc67ca82431421ea0daed0999016c6d732b1edce6cf8253be7181663d08746d84b463a780a37c876602de24a1e6d48778f3e2e504219005153a8ea8cd704cedaf9783f50955463f242e7db8032e1b24eec409dc6fbe0bb68c77ea477b5a87a886f5f79b5530d547db9875e6d1ac1a08413c99f7dbb15e32cfeaa4c9a379a010e03051f327300f99997e161783787cd84f4c4c524c2175125eadc8ce10965404d830362e80f1c302c24477abe8911d910648a17576f0caa1045b425a5c1b505ba772fff5b66d6f97d2004d7660b515b7cfa1751d6b3a039b0cb2a0016850b26f1ccc17400dbc60a1a1a3c3f807590602a9c3432b17d5857e46a52f0ae21f513b7b2b7bd7593a92bdf0ff03aef50b42e057186c2a022a192fa3b97315f0d90741c117dc68fe6b02c6e5ea5958ab9764f6f63faa5edb63d6ad33f1597d71a24b6b9c64e30beb9e16940de5d0bb85b5055a9c342e00bc95f02738952024fab86d4b45b21fa65d9e1ef3458f94a3ba5d17048a010bc28a4f813d365c1d3d5c8196bcf6394e675dc648446e2854a62940d1a5b581e4321a570abb8788921a92ca46bd4e1577de0fc995f0d05f25b1a4113166c82a9c661796473860b43bf07fb47f0f10003a2333ef2e001c62cdfe726aff732ea244b9c78c9b8f78ebbd497f6bdb5d89ff11fcb5c21e018f26a96a6d0034779c6bda6bec218aec87b188f07855e1f6b5907fd648096e9e69cdfcb82b9db5efae763f742ab7ec3641c4f6bcbe743b7d74d34d12b6fca74ad60d31cadd77f372b8971d2d4f30899ee94cb5d4faa462aa3e2b940f2a085f2686caabc354c618462b23c548344b4db3f35edee6022ecce0df2536dffc455d4ca2758ad8b3e568eb303aa4323ba1cb66ed8fef7af5988dba97af725f0fe2b8652ab7da4ff20c26195a1d5cdd6371b27d2caae4e0d7c1d743728f60cfe723881d57cf235a57308cbb3a5285cd9bdf4567becfd2a5da1a655e709735cac84c9b5625fb0d901c23ead9aab29c6339f7b0bbe4e0afd37504e8d009bffbd0f2df10e6c698f239dc4419f21d193223135fee683c6708fb287fce2ddb1eecc2243b147eea8e3ab877abf7cf1fb91cd4c4899af7cbfe8ab07c3479e372a2f220a70e2ed2025457304fad08d13d11ee1cd853f1c7a94c52a3051517af48aabb7e8268f65ce5dcea6021d100f26c89944e8d94a69aa0e83c2660fbbcc57b92461c0102a85ab81c59fca27f176d357de6b646a7023962d20c2e69a93adb9e17c46d3446dfe28482e1e069b78fe1641a3e04a996cbb8b8bcc4a37d1ab02e5ba4403b971a694e00397e21824db7196bf1f2d4955480be315c972409b17dffeb513560f03cccfdd2be8ab68ddfcd0cec028deb70c8cbe6b916e9bb8963f8b29f216a5bbb438f0e528c71f3c0050c39c4a6f52087ac3b7fc6cfdea2378299d5d0fdf36031550cef5bc160c48edd985dc2f998ec84b1b6448e281144779935623f8a511ff53c4e5bf6029973070b38edbd2ed80a202e861d9f33ae8300d19efc2d9cc004de841c6eb3e00757a7596daf21a0b2aca2da5ca6b7daf520502499812f44d63675e992a992b0e45b363a1a577425412d5d3490afd5a02325dc36aee39b98f9e24ec2101e53426a8267e41095c54751ae849ba972906621130815b59febc5a80f178c6c450b07b84c78872bd90906b360f95a167c93b84bda7577ee5c55c2a513859c72c2b7ba284231f71ad58e606b3de1c08dd26bf2db60299cba50676ddca4db93b47dda52ade1d4bc9ba99c1ca8f725bdf23b3262d05565d3c3a64b47a37057bd2c4631c065f12964afda9cc5813939fc3bb9e37dd5621207e827bf24ae3651342cd09dc46bab0581003f91522e3c225efb6c70c407e825a287e07312e8cbf30e7b03e1fdada59a1b4a81945555a1f029082e62a95b05bfccacae0a519b68252e9e49f2a75c7356738eaf8b8e617773cea60f116cbbc1f8022f7c72e4c01a3126dc830e5f5160a8d698c892d366d807d37095a9d2275dce57a1b1e2662aaf43e12d214318c86cf19</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;Oh, this is an invalid password. Check and try again, please.&quot; data-whm=&quot;OOP</summary>
      
    
    
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
    <category term="Compiler" scheme="http://luhao.wiki/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>【日志】2023年6月</title>
    <link href="http://luhao.wiki/posts/1EGK4YJ/"/>
    <id>http://luhao.wiki/posts/1EGK4YJ/</id>
    <published>2023-06-04T17:12:32.000Z</published>
    <updated>2023-06-22T07:26:16.512Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c58cf158fbe7cf686e4566ef061bc45f606c072060d50fa406c5f0c136504b2f">b3dc07a81f6459d120ce338ccca55046116de9af7135eccfa9c61a82756948fcae4c3cc473844621871b3bf7628173181c1be4905051239391b666ee485504c66d85480d349e1439269cd141b054513abe3cbaf44c0c3dae519bdf68d5787cac792dda3b4ab2f387e8f009fd50398b36b3ea19a52275fad6f6d73afa75594cad29b01b77df8c5e2fe96c908234929d6bd1995f2269c0c718261ab1ef3c101db8da99b02f7e18dcc548394d76d9c2ef5e1bf220070f5df4d1fd037dd621f93e7ea6c92c6de298983425b4f1aea4ebd4b25979fe3d14372494ccff8186a9fd55289f86272227534fd1ae2461d38728bb18d386a15416f5b180811f8f597b33cf099b09e0a3d99a383da118fa7f8da422f5d07c35bbe6991badc5a2c46130b0ed8b9eef828eca1728479463b206c146ed8e4d6d02a067b2de6ce2a628a002338d592f44b6402fcc0244f995a21ed6be757a8e9e16c0824fdcaece322d1f63905dfbfb3eabb87dc42389c3630359b6379ff653d8ab6423b85b4037e38d412ed4ade5a43ef9257cd70401a42740ad8306f5dc9a3a2adc7a52ed39167d5af67365b5d3e3c1630f71c4422032ef1de262692133c905fd49cb8994a1700cb6bafeb2a3203972fc89fd32620c79b512f473d956b9a5a95b5826ada97fa7c92159ca6fb1771e11318573a9c0a10aa8d109c632d6c69daf96001c635e5c7a6556e3994cce7875a487b8cd3a7555e1ce88ca5117775e96c9785881d1adcfa50d9b20babdbf62017ffa803fb4e82d9bbf9f4303a14d185264788496b8390993c206a28aaf68cb4cb9155db731ce72faeabf227a7c906a2d12534574e3115b1e725b224291816adde03304e5ae55949e138963f07d259dd913db0800e415c7757f046a12bbadd23e2f99e1c467c30bd5ed9a7c8be9d0420e2bcef38c2fd36c6af6f0a262bd7f82ed4a8cc80069e2de6fa380d5b217bf3d1d1247e22b90917511bd2a3639338ea9b5989116c7b52840fe16d2f6bae801efba481e193f06d1ca9251fb307717951675e295f311ed12dc1c63a0a9902fa1ae9724aa59aa12b00c9620b04f505b2a29eaf46f45ccdbabd1998c610a4133d039c5ec8bad5a281b5f47277d79b4542a127ce98f3797fc20efa96bc12c5ede27e1bb683bc1e55b690abc2b116ed4e9b4e9933d740be49b7ca08b7de4288a573f4dc07b8adec9aee2d02c542aab82510fd1dafb41e92f9c4a1265fb8b691dd180112b9145a42c9b13db357db980b10e15a5f2797f5449a59a98820117fe4959b36e52052a99d92e52609e56337891bba6519d7b4be99cb813e6705e1bd8572d6157e5dcf16c780ba06a3afc393ddaa8476ce34fee0ca5f516b818e6166207af96156eb7bead4a017b1e4a8607251b4d78530f1df141465fff952a6ef54aed4d5f86249da3d9684897e7ef156af00f779db85cad8a4938cff63e696f5001e0a7ab86852b5398a0c112c584473abaaaffcd21a4dd5f5898424eee5432a4db3ec0b10b90fbd4f8ff0e1850392ee02f815819768644756c99381bbd753916210d726232b51f15d8c23e63ce6dcf84407bf69366dd7da555f361a4930c523e9cc9f987ffc54c400c8566e460d755af0cacb536ce738bf140182805db683cc070548583533e420bd4cba67e5ede3f070efc9f7fe0db685a3cc3fe646b8bc9d95cbe8a3b6ec93097c75029ca3c405dcd029713b1b639cd773a230b3b5733b0819ad8d61456c7fd53aa75746c96210551abe5ebb8739b91bc9c6956ebfa2585748e7f279a951014e069a5f6be9098e3afd4b0e2950650070bce78e2af45348f949b35e64a0271d66b48d9f76553079d2e0080bff63d705ffea89c2e2022d06720f8c460ebc95becb396df32ea080016735ca06c3228b7910f612fc6389e6371a4fa64db763011687b281083f475675d17eb1e7fc7e124ed9df3363b667e4ebc492e534cf60c5c12552d7773f1e2c9cf01cdf468e90a2544c49daa43b7c643df1d8d058b8793c564e8deacced51c9f70f84cf2c038bbb3aa437531102fe2eb960fcacbea0b5ac42195d4868dcb2ee5dff6ecf114330bdcdb0f018528b4b66e83a95cf2ec9ebab1485a4fcfba5aaea033546742c4e59668c92899f7b6e2a75bb266165aac05d90479ca4c91f4fd80345912ba8f5c64d90cf743d8c467afe5e82835b1b2013b7c4578148c595a6bb92093019f33146666d04123969aff3ce11d1d5aecc58832f9a804f7420a3e646657a1bf1bdb8237e232ceeaf7bf1ed903a2175392d2f30688fb04366c425b025b492e5adddcc01b824b82fa2113ab9b67711284b5763b06f61f12324882c3bf8e54b6e5ef97f692f5f1fc3483a054aef263d0706f261b02c01ad6fa1f40d87e36ca9e1ed0223cca45c2fb642a71b874fdcffa34cbe41f9b2635004ffa70b4cf08e9de9aeaa0eaf11f8c82c3125f6c77ae5f99d71cde7d57dc4a8c836cbfa05893b1470f4ad8a53e807138c8f2a6dd7c2de1645225b83314efbd531dbe47449ff5360b0b351da27ed54b723d0e52563f88dbf9524630d54b678c20311d12837c5390d1382c397dda26b380411539204349aff444228e29faafc2f615c544e6f30d2d841ee2cb7a8f0a0706a5b485e98cd320faf79ca66014972fddd28f89c0f418c97277b2d0745a12ffe085f8bd20e953f6b2dce1e601a92f0faaf2fe816461d28acc11cec76fd53047ac10d055107b31db73219f66c3e079b5a5ad551f94777580b3ca6c5b34a4d57a4bdef0bfaee793ee8d3172632885b68e0adca4efe6703af0d23255c8b2cc56b6ee5847642674f5a8033798e9e7d4b86d7c4aec97cb203a850717da8b7a4ff8306d1470d3750791e57b5a46a09b89fe43507e13178640ce3867cefc9e36c263a087de0878c49a8e01db1a313a24d0e22dbf71f20681420fce46f8a070a6998f6c51793226389321bdcc18ac383ba2b7965acc7fde0705ad2ae8dbdca098971c939ca5800d28680e2a6e4c27664fec58618b2e1e4cfdb0e117f462dd55de45ff1bb89316f6488550136bf6d354928e60b275d7fcb0a882aab325e33b9a4fea3b5a50fd9ea3df5b1374850cefcd8416ac5bdfcb46225c19dc7e59f409a5983c61b1968de26dd66ae2f7321a47d6b3426ed21d810d9201b8de566c5d53da730995de8ad11df3e74b506b6c753c869ef83e71d00819f32f2d59926ed20d1e58336cc4644da99894f3ed46e603ffdbfad892da019517c47fa07f69ca09d0db32aee12abebe22449cc8f7bf9780bcea0a957cca9a53309a8b7eec0c9c5a56f63c10b3c273337cdc0bb4c940ded4db0cf43360e2f7a5c86105c0df8de92f52290a0c129b8fc8b44a7589dbf7ddcdb38df181a5866f4616a01a4a9e4e1afe691d6117759e3236bc309f2dc543efc22f229921281facdacebd3dcaeee5bf1465492b744dc75b17c38cadc3518c99e53e848270d8c27ebf78a81027f2f61bf6514fd2a9f58e5c807e5d8b7fe547aab6d22a4910f2add9b2fc0f173f2989b77f62792305b00d64157d0875dd2c58ff6f5df874287719b695de663653d6c655c648bebf629b900ca52bdb4c5e48965e431a626651eb8dea30b717fa2d4219ce9665985cf8b3ee46e280bafdc0ef801488712afa98009a68d0b1cc506acf966506ab67d25ed38ced1f87e7b9b4c18dce151c1e339206ed9cc9ebd9e69c484a4939ab69f81d1545e8ff888de85ca2a19198957c1beff6edbfe49e1b8aa64e623a6d565b4ae12cc80b4a342c63fcb0de545eab99a73647219de134af9ac62d1b04ec997f079ece689f154c4a1ac56d30665238640951917c22878f44e004956af19f2c6bef2b7231c7a7011b4191a086b9c6b971416a5c194f251a23df83b97a25cc2faf99db6eca82bb67704de190b4daf422fffa0ff18b49c4f53950d143d887af6f4bb7e403cfca8976c063c1c5751a24f83d4efbb1122c2630c852618f0bd60be2eec1db6ba21eded3efbeda615e0947c94a100f63d70e62c6e66429d4097e93f47e76b7240e8851edfb10c51a3ad751a556485a1d2dcb817416113f994806996291eb82678a9dab16f86bcb324f125059e89dfe12c588540267d2f82087c0a4b01e7305f3d75d746ad71ac17eeb4548921d4d6d57a5ed0165bf518bef2dc9aba9aa2cdc6fdf4d2d0e85dd3a678a7bf0d305021fc263793d1a7a20645d709cf4fd6747d7e44dbe0c0aba2b479b464b6d211e37f833ba8099b2e1443ec654fd88958cde35fc5f15a16895472030cfcdb9e1b835f7d66f7379f15182145f7d9683816fd5ccf09bd7b3fde38d4408bb3885b67c001f92e3e27b596f0ead3381227d189825a9b11d5322ed6602aa0b9abc3f1f6da67f2290cb418f8123f9ec0dad442a8ea67d05c4091e5b57f68bd33e60437b421029d81aead8d99d71cdcf302fdee92a8357cd7e574a7a3a1520b2cc63dbcde269a60801e847327882c762f9fce207506b8329e726d262213874122982d0a6759929ffaf6a94d2000cbf3b2f6ef66cb7015f57128b7a411c33e0d95a215d74333fe9b5656289242174723afbc4b8742d941d361450123ee1d5a6c8d197d6b249c9d5e3c7d858d1a15aed19c5aaed5db2344c08083f36c729d6cf45a030b751e5fd861c57fc9797431f2d8bba499ed5721056421a9e9f1a8a6c387cb743d9a73840c216d8faa201e0badbc7e9e53c9db81c66aa1ad4a6aedede096d768327fd2b7653b8e11f4f6b62dce2c60b956aaf820ffd7f983c777e55f576ca2697506fe5c9513e3c9ef913235d14ef22a59720b20d8665f56898ec162536e048e8b0628f7c240a29e69aba653a5cde8d179eb181e1e2735b83b63b1b5372b24a12b59021af3408932a6701edc5cf0501987ef3b8003984929c0f8785f69123b2339feb3ddbbd135a16e766b161441ce359e6806ef24ce2e10b373f36d1f5dbbfc0d4dba7e63f9d580e81c307fbab490d68c09547172fbb89521fd2f9203e4553baf0b81333d3a533906278c9c60770d82892b1a6a575d8ad1c2468538980ac10cb4242cf2a3bda21025e05595ed21dc383c6551b84e18f6f2a3bc8a24111e5709f9571ae1ab85b1982bb4a4be5ad16f4da23cccfe152b59b3fe1949a42e7dd1a3bee90edb9750dd5c9057f33f528b14a351c923f2cebdeede65fc1fa1b4a095747b737214d7f541cdd31e3837db3681676970880c3c4c97087dc55ca04eb483726688eb5e43d568187473c50978be3c29f1ffc26644751e400f5afa323bdc265122d13c68e1e45bdabc8f21ab8ef7ed5e5d9dfa279b6f70965488caabc9aa680c6be8ac81f186768794ded5b0b8d66d03e613c2d86b766a1112380c996ec1cbac743a4c529f22f943a0844840605714d4399382f3f74b62c0bf5f8e26a4e3258996c49ae6e9ec6d7dc60dda03da7db9b3176e9f701f24e266a057576a01239de844e0ac384582feedfc6340e849e1b58403cd24fed6257e2f428a1b2e160eba64625176ad92d1513504a947de90e370d07ff30d72f6bde0419b8d73140614097289607e44445acd3fe4b6f2b5c63a5260350919929f74d5b838a672d9bb21a9a19358e72d68d52e3f917d037b36fe6185441d41dc55a242fb9bc94609a388f7c41df47c78aa97ed5f0cd2cf2dc0129428ceaea008c09c714896356e90a15d85f546587b59c2cf46507f853c3aaf6be4f92364db8adeee0bdb23d13fc3f96398bdacad9051dd2240278470289cc59d619e5786f0bc5276b7d1fe80234c68ae4022523ce9a4aa0b32fa75e01055e912d3a90d2a6e9aa60f6ddefd7cf219f9f67eda4d00071c04218eba2e4535ce4260caa70a98881b4eeca737522949ef237319c44eca54de60871fedef377eb09f00115c8c8c6ff5d04cb9874630b01f8e27da10eab7ca224e117899212eb50851cc5f3bd617424181d0115b787628e01ceb3cd7e439e2b4c78924fe1fe57b36d03d127e8a96732b92d0bbfa67a97631b3129e594a6b63b6b6fe1ba1e6032db94a509d59563be7830fed11691a7ff453e55637d191bb8dec0ee64fe6b92f0af152a7cb2ce6e635fc201379f5147773c3bd6f59fbaa6ffb4d85ec5cef8b134503d903f233ba16e30d98dc596f02a9de7a8a2fe738624d9591211cebce1366e2674a32b35adb475e37abe0359ddc550d1be43abd27640907969a85ba26ca0d15e55d0caae0b4a16f96507b9cbfd41433d862cdb2c2700d0efc94f84809074063b410db01599726ae5a40b43c592eaf5b3c2038530c2f13b181ef07c7bad18a617643a1ee9249aa1d2278ee88140aae0ccd78b89ab8a673a6abca2cf4d197016e6c20f4bce973318ee09d501f153f8a36625ecb66148c50ac6842e94c13b40fccc5fc476142664767a70ddc1c4ac9ec77b126e70b74838921fe86112da7a4bd8c52f50e9db3b734bc8a5349ae68fae2853f206e91c42fb16847ff945d08d81c052e5c39b3af479684d7ab1d3ce2f5056e493be2d612d5a331719e6822454592803d42959c884845cb1cddee9006257b00806805d7d4ab4c755524744a7a86a6b0a8b4b697d4605265d9ac3e283274b7b4114f62ec4c259bf6db994fb7790966f945d63e5093fe39a0ef452314972108bf3fd9fe363d169e7adfdee5e31c93524eb9cef07d6db167d1152eb75e301d14aba12fbd450eadc4526014520ab0649ef52240fb2e9613a60a2f3189d819e5df22036afd55ef4f9717ec5a280616e0b8d724e37b4faec4f3a168734da99d731039e441f2a7c46b1e0ce268a1850edd1e5a589af6a95803b2dd28eafc792b0e815ce8cc83d386774ab52dd034feb74338226f4973349f9676783fb0a055a9f46d424501d701d3cf2945b8f175db28c709806ac13aa9bf281d553aba20175cbfd9a726b94c8438523fa1bf4130a7ef942059c2dabc13c00188b8afb1f8162a85fdbd322fa0b0e0b85ce50045fcae3bf097fd323380191a65a951fb198c52064763cedf8b89b912553111bc1ae3e5ec609ab3318435cb6e9060b82e46d84f02ba72bfa58b8b39f828cd95cebc416fdd19a0b8694ed9077f1ed839e22e6aa8b739196f6256523c389e7e2c12a5f7a86242c87258fe7ccf5402586434b5ed050ddd0d383769a4315e9cdf87998d6a85913126e3485a106bac4baf0cfe4821a11e16ec5895895ee3d57b0a3fa6dc3c97ea07d59b77fb123a1cba7efa6ff3ee352c911658c4c5984bd03c554e01a4c0ac2d66913cb3a7a3f248a495c006d62c9422d1c92a7a96e665d38702a314a261d8b3c2ce979aa53f485d653ab3195a655f886974dc6338351bdf58c59ab44d8cdda39ee2af1d83e8c4fa5ae3e333e8139bfc5308bfe04b4a50ddb83e74c3ced4dc8c8a64f8261f9f95619a0eeabf1103bd4122c8e287c280fd196d9e925e48ca2ab4118f72b46096b31087e5ad2523d113fabd0ddf3213cd1b64b6e76a2db4e250455a4c4a09e9802a4282dc607e556a4d5821984f7ea59ae35156dee9c8a4395c3e297073223d90a2c5b40a992eebbec</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;Oh, this is an invalid password. Check and try again, please.&quot; data-whm=&quot;OOP</summary>
      
    
    
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【vscode】如何配置断点调试</title>
    <link href="http://luhao.wiki/posts/1RVNF84/"/>
    <id>http://luhao.wiki/posts/1RVNF84/</id>
    <published>2023-06-03T16:50:52.000Z</published>
    <updated>2023-06-18T13:12:53.656Z</updated>
    
    <content type="html"><![CDATA[<p>包含<code>python、cpp、ts/js</code>等调试<span id="more"></span></p><div class="admonition note"><p class="admonition-title">概要</p><ul><li><a href="https://code.visualstudio.com/docs/editor/debugging">vscode debug 官方文档</a></li><li>附一张日常开发调试用的 vscode调试面板 截图<img src="/images/vscode-debug.png" alt=""></li></ul></div><h2 id="环境配置">环境配置</h2><p>vscode 虽然是一款轻量级编辑器（相比于Visual Studio、pycharm），但只要搭配正确的插件使用，依然可以轻松拥有 <code>IDE</code> 的断点debug功能。</p><h3 id="launch-json">launch.json</h3><p>vscode 的调试配置都写在 <code>launch.json</code> 文件中，它的位置是在 <code>.vscode</code> 目录下。如下是一个最简单的 python debug 配置：</p><pre><code class="language-xml">{    "version": "0.2.0",    "configurations": [        {            "type": "python",            "request": "launch",            "name": "Python: debug",        }    ]}</code></pre><p>常见字段的含义和配置方法如下：</p><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">作用</th><th style="text-align:center">必选</th></tr></thead><tbody><tr><td style="text-align:left">type</td><td style="text-align:left">调试语言，需要安装对应的<code>debug extension</code></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left">request</td><td style="text-align:left">支持 <code>launch</code> 和 <code>attach</code> 两种模式</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left">name</td><td style="text-align:left">调试选项中展示的名称</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left">program</td><td style="text-align:left">调试的目标文件，如 <code>main.py</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">args</td><td style="text-align:left">参数，格式为 <code>["1", "2"]</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">env</td><td style="text-align:left">环境变量</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">cwd</td><td style="text-align:left">设置工作目录</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">port</td><td style="text-align:left">attach模式指定端口</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">console</td><td style="text-align:left">使用哪种终端: <br><code>internalConsole</code>, <code>integratedTerminal</code>, <code>externalTerminal</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">preLaunchTask</td><td style="text-align:left">debug之前运行指定Task</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">postDebugTask</td><td style="text-align:left">debug之后运行指定Task</td><td style="text-align:center"></td></tr></tbody></table><p>一些常用的环境变量：</p><ul><li><code>${file}</code>：表示正在打开的文件</li><li><code>${workspaceFolder}</code>：表示 <code>workspace</code> 的根目录</li></ul><h2 id="python">python</h2><p>python一般选择调试当前文件，要注意工作目录是否正确。</p><pre><code>{    "name": "Python: 调试当前文件",    "type": "python",    "request": "launch",    "program": "${file}",}</code></pre><div class="admonition warning"><p class="admonition-title">python2调试</p><ul><li>新版的 <code>python extension</code> 往往不支持 python2 断点调试，需要回退到<code>2021</code>年左右的版本</li></ul></div><h2 id="cpp">cpp</h2><p><a href="https://code.visualstudio.com/docs/cpp/cpp-debug">官方文档: Debug C++ in VSCode</a></p><p>C/C++ 的断点调试略微复杂，需要分为两个步骤：</p><ul><li>使用 <code>gcc/g++</code> 将源码编译为 可执行文件（默认为<code>a.out</code>）</li><li>使用 <code>gdb</code> 调试 可执行文件</li></ul><h3 id="1-编译">1. 编译</h3><p>首先借助 vscode tasks 将cpp源码编译为可执行文件，配置如下：<br>详细可以阅读 <a href="https://code.visualstudio.com/docs/editor/tasks">官方文档：VSCode Tasks</a></p><pre><code class="language-xml">{    "tasks": [        {            "type": "cppbuild",            "label": "C/C++: gcc build",            "command": "/usr/bin/g++",            "args": [                "-g",                "${file}", // 编译的cpp文件                "-o",                "${workspaceFolder}/a.out" // 生成的可执行文件            ],            "options": {                "cwd": "${workspaceFolder}"            },            "problemMatcher": [                "$gcc"            ],        }    ],}</code></pre><p>配置 <code>tasks.json</code> 完毕后，可以通过 <code>ctrl+p</code> 输入 <code>Run Task</code> 并选中 <code>C/C++: gcc build</code>，可以将当前cpp源码编译为指定的 <code>a.out</code> 可执行文件。<br>后面的调试需要用到这个task。</p><h3 id="2-调试">2. 调试</h3><p>接下来配置 <code>launch.json</code> 以实现对上一步生成的 <code>a.out</code> 调试，配置如下：</p><pre><code class="language-xml">{    "name": "gcc/g++ debug",    "type": "cppdbg",    "request": "launch",    "program": "${workspaceFolder}/a.out", // 需要调试的二进制文件    "args": [],    "stopAtEntry": false,    "cwd": "${workspaceFolder}",    "environment": [],    "externalConsole": false,    "MIMode": "gdb",    "setupCommands": [        {            "description": "Enable pretty-printing for gdb",            "text": "-enable-pretty-printing",            "ignoreFailures": true        }    ],    "preLaunchTask": "C/C++: gcc build",    "miDebuggerPath": "/usr/bin/gdb"}</code></pre><p>其中的 <code>preLaunchTask</code> 会在按下 <code>f5</code> 调试按钮后，先行运行指定的Task，即编译指定的cpp源码文件，然后调用 linux下的 <code>/usr/bin/gdb</code> 对可执行文件进行调试。</p><h2 id="Node-js">Node.js</h2><p>vscode 对于 <code>js/ts</code> 的开发生态支持度非常高（毕竟vscode插件都是基于<code>typescript</code>所开发的）</p><pre><code class="language-xml">{    "type": "node",    "request": "launch",    "name": "JS/TS debug",    "skipFiles": [        "&lt;node_internals&gt;/**"    ],    "program": "${file}"}</code></pre><h2 id="others">others</h2><div class="admonition warning"><p class="admonition-title">其他语言用到时再补充</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;包含&lt;code&gt;python、cpp、ts/js&lt;/code&gt;等调试&lt;/p&gt;</summary>
    
    
    
    <category term="VSCode" scheme="http://luhao.wiki/categories/VSCode/"/>
    
    <category term="VSCode" scheme="http://luhao.wiki/categories/VSCode/VSCode/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【cpp】pointers</title>
    <link href="http://luhao.wiki/posts/142JHJQ/"/>
    <id>http://luhao.wiki/posts/142JHJQ/</id>
    <published>2023-06-03T14:58:55.000Z</published>
    <updated>2023-06-18T13:12:53.652Z</updated>
    
    <content type="html"><![CDATA[<p>cpp指针、地址、引用相关<span id="more"></span></p><div class="admonition note"><p class="admonition-title">概要</p><ul><li>指针是C++学习中绕不过去的难题，需要对计算机内存有深入的理解。</li><li><a href="https://hackingcpp.com/cpp/lang/pointers.html">hacking C++ Pointers</a></li><li><a href="http://alumni.cs.ucr.edu/~pdiloren/C++_Pointers/">Learning C++ Pointers for REAL Dummies</a></li><li><font color="#FF1E10"><strong>todo: unique_ptr, shared_ptr ...</strong></font></li></ul></div><h2 id="When">When</h2><p>任何一门技术（或者概念），都是服务于具体的需求，或者在特定的需求场景下，才会诞生。<br>C++的指针也不例外，它的出现是为了满足如下三个常见的场景：</p><ul><li><p><strong>持有（任意的）对象</strong><br>在避免 copy 的情况下持有对象，这是 cpp 最重要的语言特性之一，通过指针可以实现对象的引用。</p></li><li><p><strong>访问动态内存</strong><br>这块暂时没理解，todo…</p></li><li><p><strong>创建某些动态的数据结构</strong><br>如 vector，链表，树等结构。</p></li></ul><h2 id="What">What</h2><blockquote><p>Pointer to Object of type <code>T</code>，which stores a memory address.</p></blockquote><p>指针<strong>永远指向一个具体的对象</strong>（任意类型<code>T</code>），也可以是空对象（<code>nullptr</code>）。<br>指针的<strong>本质是一个内存地址</strong>，这个地址在 x64 的机器上占 64 Bits，即 <code>usigned int64</code>。<br>指针的生命周期，和它所指向对象的生命周期，两者是相互独立的。</p><div class="admonition todo"><p class="admonition-title">TODO: 通常说的 “指针” 是指c++默认指针，不包括如下（有空补充）</p><ul><li><code>std::unique_pointer</code></li><li><code>std::shared_pointer</code></li><li><code>std::weak_pointer</code></li></ul></div><h2 id="Operators">Operators</h2><p>C++有三个操作符与指针相关，分别是 <code>&amp;</code>、<code>*</code>、<code>-&gt;</code>，需要区分其不同的使用场景和含义。</p><h3 id="Address"><code>&amp;</code>: Address</h3><p><code>&amp;</code> 的含义是<strong>取地址</strong>，<code>&amp;a</code> 会<strong>返回对象a的地址</strong>。</p><p><img src="/images/cpp-address.png" alt=""></p><h3 id="Dereference"><code>*</code>: Dereference</h3><p><code>*</code> 的含义是<strong>解引用</strong>，该操作符后面会跟随一个地址，<code>*p</code>会<strong>返回地址p上的值</strong>。</p><p><img src="/images/cpp-pointer.png" alt=""></p><h3 id="Member-Access"><code>-&gt;</code>: Member Access</h3><p><code>-&gt;</code> 的作用是<strong>访问类成员</strong>，准确说是访问一段地址上的某个成员属性，经常会和 <code>.</code> 使用混淆。</p><ul><li>对于指针类型，使用 <code>-&gt;</code></li><li>对于具体的对象，使用 <code>.</code></li></ul><p><img src="/images/cpp-access.png" alt=""></p><h3 id="和-的区别"><code>&amp;</code> 和 <code>*</code> 的区别</h3><p>作为不同的操作数有不同用法，区别如下：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>*</code></th><th style="text-align:center"><code>&amp;</code></th></tr></thead><tbody><tr><td style="text-align:center">声明符</td><td style="text-align:center">定义指针: <code>int *p = nullptr</code></td><td style="text-align:center">定义引用: <code>int &amp;a = b</code></td></tr><tr><td style="text-align:center">一元操作符</td><td style="text-align:center">解引用: <code>char a = *p</code></td><td style="text-align:center">取地址: <code>auto p = &amp;a</code></td></tr><tr><td style="text-align:center">二元操作符</td><td style="text-align:center">乘法运算: <code>a * b</code></td><td style="text-align:center">与运算: <code>a &amp; b</code></td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">不要在单行申明多个指针</p><ul><li><u class="error"><code>int *a, b</code></u>：容易产生歧义，建议多行申明</li></ul></div><h3 id="pointer-to-pointer-⭐"><code>**</code>: pointer to pointer ⭐</h3><pre><code class="language-c++">int   v = 5;int*  p = &amp;v;  // 指向intint** pp = &amp;p  // 指向int*</code></pre><h2 id="nullptr-C-11">nullptr (C++11)</h2><blockquote><p>nullptr is a special pointer value</p></blockquote><p><code>NULL</code> 完全等同于0，<code>nullptr</code> 本质是一个空指针对象，注意两者的区别！<br>作为规范，<code>nullptr</code> 通常代表 <strong>无法访问的变量</strong>（value not available）</p><div class="admonition note"><p class="admonition-title">nullptr 编码规范</p><ul><li>指针初始化时，赋值为nullptr：<code>int *p = nullptr</code></li><li>解引用时，检查该指针是否为nullptr：<code>if (p != nullptr) { *p = 8; }</code></li></ul></div><h2 id="const-pointer">const pointer</h2><blockquote><p>Read-only and preventing pointer redirection.</p></blockquote><p><code>const</code> 搭配指针会产生奇妙的化学反应，一共有如下四种情形：<br>牢记口诀：<strong><code>const</code> 左边的永远是不可变的。</strong></p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">指向的对象 可修改?</th><th style="text-align:center">指针自身 可修改?</th></tr></thead><tbody><tr><td style="text-align:left"><code>int *</code></td><td style="text-align:center">✔</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left"><code>int const *</code></td><td style="text-align:center">❌</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left"><code>int * const</code></td><td style="text-align:center">✔</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:left"><code>int const * const</code></td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr></tbody></table><p>下面看一段代码示例：</p><pre><code class="language-c++">int i = 5;int j = 8;int const* cp = &amp;i;*cp = 8;   //  ❌ COMPILER ERROR: pointed-to value is constcp = &amp;j;   //  ✔int *const pc = &amp;i;*pc = 8;   //  ✔pc = &amp;j;   //  ❌ COMPILER ERROR: pointer itself is constint const*const cpc = &amp;i;*cpc = 8;  //  ❌ COMPILER ERROR: pointed-to value is constcpc = &amp;j;  //  ❌ COMPILER ERROR: pointer itself is const</code></pre><h2 id="this-pointer">this pointer</h2><p><code>this</code> 仅在类内部使用，<strong>本质是一个指针</strong>。</p><ul><li><p><code>this</code> 返回类对象的地址</p></li><li><p><code>*this</code> 访问类自身</p></li><li><p><code>this-&gt;</code> 用来访问内部的成员</p></li></ul><h2 id="Memory">Memory</h2><p>接下来从 <strong>内存分配</strong> 的视角，理解指针在计算机内的存储，以及指针运算符做了什么。</p><ul><li><p>根据内存对齐，<code>char</code> 和 <code>short</code> 在内存中都占据 4 bytes</p></li><li><p>指针的本质，就是第一个byte的16位地址（因此 <code>sizeof(p) = 2</code>）</p></li></ul><p><img src="/images/pointer-memory.png" alt=""></p><ul><li><p>下图演示指针的<code>++</code>，会根据指向对象的内存大小而进行偏移</p></li><li><p><code>pointer += 2</code> 或者 <code>pointer --</code> 也是同样道理</p></li><li><p><code>pointer[3]</code> 等价于 <code>pointer += 3</code> 后的取值</p></li></ul><p><img src="/images/pointer-memory-add.png" alt=""></p><h2 id="⚠️-Warning">⚠️ Warning</h2><p>指针使用经常会出现如下几种错误：</p><h3 id="1-dangling-pointer">1. dangling pointer</h3><blockquote><p><em><strong>dangling</strong></em>： pointer points to an invalid/inaccessible memory address</p></blockquote><p>永远确保 <strong>指针指向的对象是合理的</strong>，否则出现 悬空指针（迷途指针）。</p><ul><li>error 1：访问 未初始化的对象</li></ul><pre><code class="language-c++">int *p; // p not initialized!*p = 7; // ❌</code></pre><ul><li>error 2：访问 nullptr</li></ul><pre><code class="language-c++">int *p = nullptr;*p = 7; // ❌</code></pre><ul><li>error 3：指向 无法访问的内存<br><code>p = 0x0000001</code>，这是运行程序无法访问的内存段，运行时会报错。</li></ul><h3 id="2-pointer-argument-passing">2. pointer argument passing</h3><p>当函数的参数定义为指针时，注意传入的参数，不能是一个非法的指针。</p><pre><code class="language-c++">void swap_values (int* a, int* b) {  int t = *a;  *a = *b;  *b = t;}int x = 3, y = 4;swap_values(&amp;x, &amp;y)        // ✔swap_values(&amp;x, 0);        // ❌ UNDEFINED BEHAVIORswap_values(&amp;x, nullptr);  // ❌ UNDEFINED BEHAVIOR</code></pre><h3 id="3-hard-code">3. hard code</h3><p>通过合理的编码，区分 <code>*</code> 的频繁使用，尤其是乘法和指针混合使用的场景。</p><p><code>*p = *p * *p + (2 * *p + 1);   // SO MANY STARS!</code></p><h2 id="指针习题">指针习题</h2><p>当你以为入门了cpp指针，尝试解答下面的题目，常看常新：</p><ul><li>已知如下的地址和取值，问如下输出</li></ul><pre><code class="language-c++">cout &lt;&lt; v;cout &lt;&lt; p;cout &lt;&lt; pp;cout &lt;&lt; &amp;v;cout &lt;&lt; &amp;p;cout &lt;&lt; &amp;pp;cout &lt;&lt; *v;cout &lt;&lt; *p;cout &lt;&lt; **pp;</code></pre><p><img src="/images/pointer-question.png" alt=""></p><h3 id="解析如下："><strong>解析如下：</strong></h3><ul><li><p><code>cout &lt;&lt; v</code>：5</p></li><li><p><code>cout &lt;&lt; p</code>：0x44</p></li><li><p><code>cout &lt;&lt; pp</code>：0x48</p></li><li><p><code>cout &lt;&lt; &amp;v</code>：0x40 (=p)</p></li><li><p><code>cout &lt;&lt; &amp;p</code>：0x44 (=pp)</p></li><li><p><code>cout &lt;&lt; &amp;pp</code>：0x48</p></li><li><p><code>cout &lt;&lt; *p</code>：5</p></li><li><p><code>cout &lt;&lt; *pp</code>：0x40 (=p)</p></li><li><p><code>cout &lt;&lt; **pp</code>：5</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp指针、地址、引用相关&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/"/>
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/C/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="Compiler" scheme="http://luhao.wiki/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>hackingcpp.com</title>
    <link href="http://luhao.wiki/posts/1GTNS16/"/>
    <id>http://luhao.wiki/posts/1GTNS16/</id>
    <published>2023-05-31T17:20:56.000Z</published>
    <updated>2023-06-18T13:12:53.652Z</updated>
    
    <content type="html"><![CDATA[<p><code>hackingcpp</code> 网站的学习记录<span id="more"></span></p><div class="admonition note"><p class="admonition-title">背景</p><ul><li><a href="https://hackingcpp.com/"><em><strong>hackingcpp</strong></em></a> 是一个偶然发现的优秀C++学习网站，开这篇记录学习过程。</li><li><a href="/posts/142JHJQ/">pointers</a></li><li><a href="/posts/10R6MRC/">constructors &amp; destructors</a></li></ul></div><h2 id="Environment">Environment</h2><h3 id="ISO-Standard-C">ISO Standard C++</h3><p>C++语言标准，前后经历如下几个大的版本。大学教程所传授的C++基本是围绕 98 展开，工作中使用的 “现代C++特性” 基本也不出 11。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">时间</th><th style="text-align:left">特性</th></tr></thead><tbody><tr><td style="text-align:center"><em>C++98</em></td><td style="text-align:center">1998</td><td style="text-align:left">the original standard</td></tr><tr><td style="text-align:center"><em>C++11</em></td><td style="text-align:center">2011</td><td style="text-align:left">almost a new language</td></tr><tr><td style="text-align:center"><em>C++14</em></td><td style="text-align:center">2014</td><td style="text-align:left">some improvements</td></tr><tr><td style="text-align:center"><em>C++17</em></td><td style="text-align:center">2017</td><td style="text-align:left">new features &amp; library extensions</td></tr><tr><td style="text-align:center"><em>C++20</em></td><td style="text-align:center">2020</td><td style="text-align:left">game-changing new features &amp; libraries</td></tr></tbody></table><h3 id="Compiler">Compiler</h3><p>主要有 gcc, clang, MSVC 三种主流的C编译器，其跨平台、兼容性、代码生成和优化都有所差异。不过 99% 的开发场景不需要考虑到 这三种编译器 之间的差异性。</p><p>看到一些资料，都会说 <strong>clang 的性能和内存都要优于 gcc</strong>，这里不了解所以不作为何描述。</p><ul><li><p><font color="#1A9BFF"><strong>gcc/g++</strong></font><br>GNU C++ 编译器，使用最为广泛。</p></li><li><p><font color="#1A9BFF"><strong>clang/clang++</strong></font><br>又称 LLVM，一般作为 Mac 默认的编译器，因为其同时支持 C、C++、Objective-C。<br>关于 gcc和clang的对比，推荐阅读该材料：<a href="https://opensource.apple.com/source/clang/clang-23/clang/tools/clang/www/comparison.html#:~:text=Clang%20is%20much%20faster%20and,does%20not%20support%20expressive%20diagnostics">Clang vs GCC</a></p></li><li><p><font color="#1A9BFF"><strong>MSVC</strong></font><br>Microsoft Visual C++ 是由微软开发的C++编译器及相关环境，只使用于 Windows。简单来说，这是 windows C++ 开发的 <s>唯一</s> 最好选择。</p></li></ul><h3 id="Running">Running</h3><p><code>g++ hello.cpp -o sayhello &amp;&amp; ./sayhello</code></p><p>C++是一门编译型的静态语言，（区别于 Python）其源代码是无法直接运行的，而是需要通过前面说的编译器 转换成二进制的机器代码。因此一个 <code>.cpp</code> 文件的执行需要经过如下几个步骤：</p><p><img src="/images/cpp-running.png" alt=""></p><h3 id="Compiler-Flags">Compiler Flags</h3><p><code>g++ -std=c++20 -Wall -Wextra -Wpedantic -Wshadow input.cpp -o output</code></p><p>需要掌握基本的 <a href="https://caiorss.github.io/C-Cpp-Notes/compiler-flags-options.html">C++编译选项</a>，如 Warnings、编译标准、优化等级 等。</p><table><thead><tr><th style="text-align:center">编译选项</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>-std=c++20</code></td><td style="text-align:left">使用 <em>C++20</em> 标准编译</td></tr><tr><td style="text-align:center"><code>-Wall</code></td><td style="text-align:left">打开一系列的编译警告</td></tr><tr><td style="text-align:center"><code>-O0 </code></td><td style="text-align:left">优化选项，代表关闭所有优化</td></tr></tbody></table><p>当你在 windows  MSVC 开发时，借助 Visual Studio 可以在 “属性页” 查看和编辑所有的优化选项。它实际上是提供了一个可配置的GUI框。</p><h2 id="Variables">Variables</h2><p>最基本的变量申明方式有两种：</p><ul><li><code>type var = value</code>: 通用写法</li><li><code>type var {value}</code>: <em>C++11</em> 标准</li></ul><div class="admonition warning"><p class="admonition-title">undefined behavior</p><ul><li>时刻牢记初始化变量，这样能避免很多类似Bug</li></ul></div><p>注意 <code>a++</code> 和 <code>++a</code> 的区别，在合适的场景使用两者：</p><ul><li><code>a++</code>：返回旧值</li><li><code>++a</code>：返回新值</li></ul><h3 id="Type-Narrowing">Type Narrowing</h3><ul><li>低精度 向 高精度 转换：OK</li><li>高精度 向 低精度 转换：NARROWING，有信息丢失</li></ul><h3 id="Control-flows">Control flows</h3><div class="admonition note"><p class="admonition-title">if (statement; condition) {...}</p><ul><li><code>C++17</code> 允许这样的写法: <code>if ( int x = 5; x &gt; 0) { ... }</code></li><li><code>switch</code> 同理</li></ul></div><h3 id="using">using</h3><p>使用 <code>using</code> 代替 <code>typedef</code>，用来作类型的赋值，例如：</p><ul><li><p><code>using real = double</code></p></li><li><p><code>usning int_vector = std::vector&lt;int&gt;</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;hackingcpp&lt;/code&gt; 网站的学习记录&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/"/>
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/C/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
    <category term="Compiler" scheme="http://luhao.wiki/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>【selenium】自动秒杀脚本</title>
    <link href="http://luhao.wiki/posts/3R1HHH2/"/>
    <id>http://luhao.wiki/posts/3R1HHH2/</id>
    <published>2023-05-29T16:06:36.000Z</published>
    <updated>2023-06-18T13:12:53.656Z</updated>
    
    <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><ul><li>借助 <code>Python + Selenium</code> 实现 <code>taobao</code> 购物车自动秒杀</li></ul></div><div class="admonition error"><p class="admonition-title">TODO</p><ul><li>增加定时秒杀的功能</li><li><code>time.sleep</code>的时间把控（短则逻辑错误，长则秒杀失败...）</li><li>实测，实战</li></ul></div><h3 id="环境">环境</h3><p>下面以 windows 环境为例，因为高度依赖 chrome ui 界面操作，linux 暂且按下不表</p><ul><li><p><code>pip3 install selenium</code>，直接下载最新的 <code>selenium</code> 库</p></li><li><p><code>chrome://version/</code>，在 <code>chrome</code> 浏览器输入 以查看当前版本</p></li><li><p><a href="https://registry.npmmirror.com/binary.html?path=chromedriver/"><code>mirrors/chromedriver/</code></a>，下载对应版本的 <code>chromedriver.exe</code></p></li></ul><h3 id="访问网页">访问网页</h3><p>只需要掌握 <code>webdriver</code> 的几个核心接口：<code>Chrome</code>、<code>ChromeOptions</code>、<code>find_element</code></p><ul><li><code>options = webdriver.ChromeOptions()</code><br>创建一个 chrome 的配置项，实际用途是避开反爬虫的js检测。<br>具体代码如下，复制粘贴即可：</li></ul><pre><code class="language-python">options.add_experimental_option('excludeSwitches', ['enable-automation'])options.add_argument("--disable-blink-features=AutomationControlled")</code></pre><ul><li><p><code>driver = webdriver.Chrome(executable_path='./chromedriver.exe', options=options)</code><br>创建一个 chrome 的自动化示例，它会唤起一个谷歌浏览器，但是又不同于正常打开的 <code>chrome.exe</code>。<br>注意，需要传入对应版本的 <code>chromedriver.exe</code> 的路径。</p></li><li><p><code>driver.get('https://cart.taobao.com/cart.htm')</code><br>利用 chrome 访问指定的网页</p></li><li><p><code>driver.find_element('id', 'xxx')</code><br>根据html、css规则，查找指定的对象。<br>可选的参数有 <code>id</code>、<code>xpath</code>、<code>name</code>…<br>注意，旧版的方法是 <code>find_element_by_id</code>…</p></li></ul><h3 id="自动登录">自动登录</h3><p>前面访问的网页是 <a href="https://cart.taobao.com/cart.htm">cart.taobao.com/cart.htm</a>，如果浏览器没有对应的缓存，则会自动跳转到登录界面。<br>这时候需要借助 <code>find_element</code> 实现自动登录与跳转。</p><table><thead><tr><th style="text-align:center">find_element</th><th style="text-align:center">Arg1</th><th style="text-align:center">Arg2</th></tr></thead><tbody><tr><td style="text-align:center">用户名</td><td style="text-align:center">name</td><td style="text-align:center">fm-login-id</td></tr><tr><td style="text-align:center">密码</td><td style="text-align:center">name</td><td style="text-align:center">fm-login-password</td></tr></tbody></table><p>代码示例为：</p><pre><code class="language-python"># 用户名input = driver.find_element('name', 'fm-login-id')input.clear() # 清空# time.sleep(0.2) # 防止过快input.send_keys('*******') # 输入您的用户名# 密码input = driver.find_element('name', 'fm-login-password')input.clear() # 清空# time.sleep(0.2) # 防止过快input.send_keys('*******') # 输入您的密码# 跳转driver.find_element("xpath", "//*[@id='login-form']/div[4]/button").click()</code></pre><h3 id="自动下单">自动下单</h3><div class="admonition note"><p class="admonition-title">某宝下单成功有三个步骤</p><ul><li>1.购物车中 “勾选商品”</li><li>2.点击 “结算” 按钮 （选中商品后，按钮才是可点击态）</li><li>3.点击 “提交订单” 按钮 （选择收货地址）</li></ul></div><table><thead><tr><th style="text-align:right">步骤</th><th style="text-align:right">Arg1</th><th style="text-align:right">Arg2</th></tr></thead><tbody><tr><td style="text-align:right">1. 勾选商品</td><td style="text-align:right"><code>id</code></td><td style="text-align:right"><code>J_SelectAll1</code></td></tr><tr><td style="text-align:right">2. 点击结算</td><td style="text-align:right"><code>id</code></td><td style="text-align:right"><code>J_Go</code></td></tr><tr><td style="text-align:right">3. 提交订单</td><td style="text-align:right"><code>link text</code></td><td style="text-align:right"><code>提交订单</code></td></tr></tbody></table><ul><li>勾选商品</li></ul><p>下面简化为购物车内的商品全选。</p><pre><code class="language-python">while 1:    try:        select_all = driver.find_element("id", 'J_SelectAll1')        if select_all:            select_all.click()            break    except:        print ('Retry: 全选商品')</code></pre><ul><li>点击结算</li></ul><pre><code class="language-python">while 1:    try:        buy = driver.find_element("id", 'J_Go')        if buy:            buy.click()            break    except:        print ('Retry: 点击结算')</code></pre><ul><li>提交订单</li></ul><pre><code class="language-python">while 1:    try:        a = driver.find_element("link text", "提交订单")        if a:            a.click()            break    except:        print ('Retry: 提交订单')</code></pre><h3 id="代码示例">代码示例</h3><pre><code class="language-python"># coding: utf-8import timefrom selenium import webdriverusername = ''password = ''TB_LOGIN_URL = 'https://cart.taobao.com/cart.htm'options = webdriver.ChromeOptions()options.add_experimental_option('excludeSwitches', ['enable-automation'])options.add_argument("--disable-blink-features=AutomationControlled")# exe path for chromedriver.exeexe_path = r'E:\chromedriver.exe'driver = webdriver.Chrome(executable_path=exe_path, options=options)driver.get(TB_LOGIN_URL)input = driver.find_element('name', 'fm-login-id')input.clear()driver.implicitly_wait(0.5)print ("Username:", username)input.send_keys(username)input = driver.find_element('name', 'fm-login-password')input.clear()driver.implicitly_wait(0.5)print ("password:", password)input.send_keys(password)driver.find_element("xpath", "//*[@id='login-form']/div[4]/button").click()time.sleep(0.2)# while 1:#     try:#         select_all = driver.find_element("id", 'J_SelectAll1')#         if select_all:#             select_all.click()#             break#     except:#         print ('Retry: 全选商品')# time.sleep(0.2)# while 1:#     try:#         buy = driver.find_element("id", 'J_Go')#         if buy:#             buy.click()#             break#     except:#         print ('Retry: 点击结算')# time.sleep(0.2)# while 1:#     try:#         a = driver.find_element("link text", "提交订单")#         if a:#             a.click()#             break#     except:#         print ('Retry: 提交订单')    assert(0)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;概要
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;借助 &lt;code&gt;Python + Selenium&lt;/code&gt; 实现 &lt;code&gt;taobao&lt;/code&gt; 购物车自动秒杀&lt;/l</summary>
      
    
    
    
    <category term="Python" scheme="http://luhao.wiki/categories/Python/"/>
    
    <category term="Python" scheme="http://luhao.wiki/categories/Python/Python/"/>
    
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【GAMES101】Anti-Aliasing</title>
    <link href="http://luhao.wiki/posts/3P0T9MZ/"/>
    <id>http://luhao.wiki/posts/3P0T9MZ/</id>
    <published>2023-05-28T13:13:49.000Z</published>
    <updated>2023-06-21T17:37:26.635Z</updated>
    
    <content type="html"><![CDATA[<p>信号处理、抗锯齿<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://learnopengl.com/Advanced-OpenGL/Anti-Aliasing">LearnOpenGL: Anti Aliasing</a></li><li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_06.pdf">GAMES101: Rasterization and Anti Aliasing</a></li><li><a href="https://www.zhihu.com/question/19714540/answer/1119070975">知乎：如何理解傅里叶变换公式？</a></li><li><a href="https://www.zhihu.com/question/264302905">知乎：如何理解图像经傅里叶变换后所得频谱图意义？</a></li></ul></div><div class="markmap-container" style="height:400px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;信号处理&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;时域&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;频域&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;空域&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#傅里叶变换（Fourier-Transform）\&quot;>傅里叶变换</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;走样&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#什么是走样（Aliasing）\&quot;>What</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Jaggies&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Moiré&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Wheel-effect&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;<a href=\&quot;#为什么产生走样\&quot;>Why</a>（从信号处理角度）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;How&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;<a href=\&quot;#Blurring\&quot;>Blurring</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;#High-Pass-Filter\&quot;>Filter</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;<a href=\&quot;#Convolution\&quot;>Convolution</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;实际应用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#MSAA\&quot;>MSAA</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;#FXAA\&quot;>FXAA</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;<a href=\&quot;#TAA\&quot;>TAA</a>&quot;}]}]}],&quot;p&quot;:{}}"></svg></div><h2 id="信号处理">信号处理</h2><p>了解反走样与抗锯齿之前，需要学习一些基础的信号处理相关知识，其中最重要的就是 时域、频域 及两者的相互转化关系。</p><h3 id="1-时域-Time-domain">1. 时域 (Time-domain)</h3><blockquote><p>时域 是描述一个数学函数（或物理信号）对于时间的关系（函数）</p></blockquote><p>电脑上的音频文件（例如mp3、wmv…）就是一个时域信号的典型例子，其本质是音频（波形图）在时间上的分布，如下所示：</p><ul><li>横轴：时间 t</li><li>纵轴：声音的振幅<br><img src="/images/signal-mp3.png" alt=""></li></ul><p>声音信号是由 高音、中音、低音 三个部分组成，如果我们想加强低音部分，仅仅通过时域信号是没法修改的。因为高中低音在时域中是混合在一起的，没法通过逆变换将他们抽离开来。<br>因此引申出 频域 的概念 ↓</p><!-- **因此 [傅里叶变换](https://zh.wikipedia.org/wiki/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2) 的出现，就是为了将信号在时域和频域之间相互转化。** --><h3 id="2-频域-Frequence-domain">2. 频域 (Frequence-domain)</h3><blockquote><p>频域 是描述频率分布的关系</p></blockquote><p>频域的理解有点困难，需要结合时域一起看（如下图）。时域上的信号可以看做不同频率的信号的叠加，因此频域就是展示这些不同频率信号的分布。</p><ul><li>横轴：频率</li><li>纵轴：该频率的振幅（&gt;0）</li></ul><p><img src="/images/frequence-vs-time.png" alt=""></p><div class="admonition note"><p class="admonition-title">空域 (Spatial-domain)</p><ul><li>又称为空间域、图像空间（image space），可以理解为像素在屏幕空间（x，y）的分布。</li></ul></div><h3 id="时域与频域">时域与频域</h3><blockquote><p>时域与频域 表示的是同一个信息，只不过呈现的方式不同。</p></blockquote><p>下面以标准正弦函数 $sin(x)$ 为例，展现时域和频域的不同表示：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">函数</th><th style="text-align:center">示意图</th></tr></thead><tbody><tr><td style="text-align:center">时域</td><td style="text-align:center">$y = sin(t)$</td><td style="text-align:center"><img src="/images/time-domain-demo.gif" alt=""></td></tr><tr><td style="text-align:center">频域</td><td style="text-align:center">$f = \frac{1}{2π}$</td><td style="text-align:center"><img src="/images/frequence-domain-demo.png" alt=""></td></tr></tbody></table><h3 id="傅里叶变换（Fourier-Transform）">傅里叶变换（Fourier Transform）</h3><div class="admonition warning"><p class="admonition-title">关于傅里叶变换</p><ul><li>这部分浅尝辄止，理解基本概念和用法即可</li></ul></div><ul><li><p>任何函数都可以表示为 $sin$、 $cos$ 函数的组合</p></li><li><p>将时域转化到频域（傅里叶变换）</p></li><li><p>将频域转化到时域（逆变换）</p></li></ul><h2 id="什么是走样（Aliasing）">什么是走样（Aliasing）?</h2><p>如下概括了三种常见的走样的导致的 Artifacts：</p><table><thead><tr><th style="text-align:center">Artifacts</th><th style="text-align:center">原因</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Jaggies">Jaggies</a></td><td style="text-align:center">空域采样频率不足</td><td style="text-align:left"><img src="/images/raster-jaggies.png" alt=""></td></tr><tr><td style="text-align:center">Moiré Patterns</td><td style="text-align:center">空域采样频率不足</td><td style="text-align:left"><img src="/images/raster-moire.png" alt=""></td></tr><tr><td style="text-align:center"><a href="https://en.wikipedia.org/wiki/Wagon-wheel_effect">Wagon wheel effect</a></td><td style="text-align:center">时域采样频率不足 <a href="https://michaelbach.de/ot/mot-wagonWheel/">demo</a></td><td style="text-align:left"><img src="/images/raster-wheel.gif" alt=""></td></tr></tbody></table><h2 id="为什么产生走样">为什么产生走样?</h2><h3 id="从信号处理角度理解">从信号处理角度理解</h3><blockquote><p><em>Signals are <font color="#1AAD19">changing too fast (high frequency)</font>, <font color="#FF1E10">but sampled too slowly</font>.</em>  —— GAMES101</p></blockquote><p>将图像信息看做空域信号，根据傅里叶变换得出，可以表示为任何正弦信号的叠加，因此光栅化的过程可以理解为：<strong>以某个频率对原始信号进行采样的过程。</strong><br>由于造物主的超然存在，自然界的所有采样频率可以当做无穷的（时间是连续的、世界是无穷多个像素点…），而妄图用有限的频率去描述、去采样现实世界，即用有穷描述无穷，必然会带来信号和信息的损失。<br>以下图为例，采样频率固定时，当原始信号的频率越低，采样产生的误差也就越小；当原始信号的频率越高，采样产生的误差越大。</p><p><img src="/images/antialisaing-why.png" alt=""></p><p>上面3种常见的 <strong>采样导致的Artifacts</strong>，都是因为采样的频率较低（低于原图像的变化频率）。</p><p>原始图像的信号不是随着时间而变换（时域变换），而是随着空间中x、y的值而变化（空域变换）。信号的变化频率高是指：像素之间的RGB颜色是否发生骤变（如白色255变成黑色0）。<br>从这个角度理解走样的原因：</p><div class="admonition note"><p class="admonition-title">为什么锯齿都在图形的边缘?</p><ul><li>因为内部的信号变化慢，低频采样没什么影响；而边缘的信号变换频率会骤增。</li></ul></div><h2 id="如何进行反走样（Anti-Aliasing）？">如何进行反走样（Anti-Aliasing）？</h2><p>Anti-Aliasing，又称为反走样、抗锯齿，提高采样频率是最直接的反走样方案，如增加分辨率。<br>下面介绍一些常见的AA理论。</p><h3 id="Blurring">Blurring</h3><p>模糊化是反走样的一个基本操作，即在光栅化之前对原始图像做一个模糊的操作。</p><p><img src="/images/aa-blurring.png" alt=""></p><h3 id="High-Pass-Filter">High-Pass Filter</h3><p>高通滤波，即高频的信号可以通过，过滤掉低频的信号</p><h3 id="Low-Pass-Filter">Low-Pass Filter</h3><p>低通滤波，即低频的信号可以通过，过滤掉高频的信号</p><h3 id="Convolution">Convolution</h3><p>前面的滤波技术，本质不是丢弃某些特定频率的信号，而是把它们变成一个新的信号。即$m*n$的信号通过滤波之后，得到的仍然是 $m*n$ 的信号。它的本质就是 <strong>将信号在时域上卷积</strong>，即求平均值。</p><ul><li><strong>滤波器</strong>：一个固定大小的信号，如 $1*3$，且每个信号都对应一个数值（系数），如下所示：<ul><li><img src="/images/aa-filters.png" alt=""></li><li>对于每个像素，根据滑动窗口计算 经滤波器后 的取值。</li><li>示例，对应为 $5$ 的像素，滤波后的结果是 $3*1/4 + 5*1/2 + 3*1/4 = 4$</li></ul></li></ul><p>下图是一个 1/9 的滤波器，它起到了图像模糊化的作用，其本质也是一个低通滤波器（模糊的本质，是去掉高频变换的边缘区域）</p><p><img src="/images/low-filter.png" alt=""></p><div class="admonition warning"><p class="admonition-title">理解困难</p><ul><li>如何理解：时域（空域）的乘积，本质是频域上的卷积</li></ul></div><h3 id="MSAA">MSAA</h3><p><a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing">MSAA（Multi-Sampling AA）</a> 的本质是在更高倍分辨率下进行采样。<br>下图是一个 <em>4 x MSAA</em> 采样的示例，即对于每个像素，采样其中四个子像素，根据是否在三角形内的比例，得出其颜色的贡献值。</p><p><img src="/images/4xMSAA.png" alt=""></p><p><strong>MSAA的额外开销</strong></p><ul><li>n-MSAA，意味着 N 倍的采样量</li><li>可以尽可能的复用之前的采样值</li></ul><h3 id="FXAA">FXAA</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E8%BF%91%E4%BC%BC%E6%8A%97%E9%8B%B8%E9%BD%92">FXAA（Fast-Approximat AA）</a> 是在屏幕空间的快速近似抗锯齿，它是在后处理阶段进行的。<br>在有锯齿的图像上，找到其边界，并替换为无边界的图像，与采样无关。</p><h3 id="TAA">TAA</h3><p><a href="">TAA（Tempol AA）</a> 将采样从单帧扩展到多帧，尽可能地复用之前帧的结果。需要额外处理动态物体的情况。</p><div class="admonition warning"><p class="admonition-title">写在最后</p><ul><li>MSAA，FXAA，TAA等抗锯齿方案需要更深入的学习和实践，这里只是浅尝辄止</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;信号处理、抗锯齿&lt;/p&gt;</summary>
    
    
    
    <category term="Graphics" scheme="http://luhao.wiki/categories/Graphics/"/>
    
    <category term="Graphics" scheme="http://luhao.wiki/categories/Graphics/Graphics/"/>
    
    
    <category term="OpenGL" scheme="http://luhao.wiki/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【GAMES101】Rasterization</title>
    <link href="http://luhao.wiki/posts/M5TXVE/"/>
    <id>http://luhao.wiki/posts/M5TXVE/</id>
    <published>2023-05-26T15:13:46.000Z</published>
    <updated>2023-06-18T13:12:53.656Z</updated>
    
    <content type="html"><![CDATA[<p>光栅化与硬件基础<span id="more"></span></p><div class="admonition note"><p class="admonition-title">前集提要</p><ul><li><a href="/posts/30P8RVY/">GAMEASA101-Transformation</a>描述了基础的线性变化，以及MVP变换的过程</li><li>本文讨论的是在MVP变换后，如何将一个正交的 $(0, 1)^{3}$ 坐标映射到屏幕坐标上</li></ul></div><h2 id="显示设备">显示设备</h2><h3 id="CRT-阴极射线管">CRT 阴极射线管</h3><p><a href="https://zh.wikipedia.org/wiki/%E9%98%B4%E6%9E%81%E5%B0%84%E7%BA%BF%E7%AE%A1">阴极射线管</a>（英语：Cathode ray tube，缩写 CRT），是较早的显示仪器，曾广泛的应用于示波器、电视机和显示器上。<br>其原理是利用阴极电子枪发射电子，在阳极高压的作用下，射向荧光屏，使荧光屏上的荧光粉发光。<br>同时电子束能够在偏转磁场的作用下，作上下左右的移动来达到扫描显示的目的。（高中物理的磁场计算题…）<br>早期的CRT仅能显示光线的强弱，因此是黑白画面；直到1941年，CRT才支持红绿蓝三种颜色的电子束，这告别着彩色电视机技术的问世。</p><p>因为采用电子束的技术，CRT显示器具有亮度高、伤眼睛的特点。因此早期小朋友看彩电时，经常被家长督促离得远一些。<br>同时 CRT显示器 的分辨率做不高、屏幕做不到，导致2000年后逐渐被LCD、LED取代。<br><a href="https://www.zhihu.com/question/57752884">知乎：为什么 CRT 画质这么好也被淘汰，液晶反而发展的很好？</a><br><img src="/images/CRT.png" alt=""></p><h3 id="隔行扫描技术">隔行扫描技术</h3><p>通常的显示器在成像时，会从上到下地扫描每帧图像。这个过程消耗的时间很长、占用带宽也很高。<br>因此CRT显示器采用一种 “隔行扫描” 的技术，即每次只传输和显示一半的图像，一场只包含奇数行或者偶数行。由于人眼具有视觉暂留效应，所以仍然会看到完整的一帧画面。</p><div class="admonition note"><p class="admonition-title">视觉暂留效应</p><ul><li>光对视网膜所产生的视觉，在光消失后，<strong>仍然会保留一段时间（约1/16秒）</strong></li><li>例如日常使用的日光灯每秒大约熄灭100次，但不会感觉到灯光的闪动</li></ul></div><h3 id="LCD-LED">LCD &amp; LED</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:left">LCD</th><th style="text-align:left">LED</th></tr></thead><tbody><tr><td style="text-align:center">功耗</td><td style="text-align:left">❌ 功耗高10倍</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">寿命</td><td style="text-align:left"></td><td style="text-align:left">✔ 寿命更长</td></tr><tr><td style="text-align:center">视角</td><td style="text-align:left">❌ 视角较小</td><td style="text-align:left">✔ 视角宽达160°</td></tr></tbody></table><p><a href="https://zh.wikipedia.org/wiki/%E6%B6%B2%E6%99%B6%E6%98%BE%E7%A4%BA%E5%99%A8">LCD液晶显示器</a> 和 <a href="https://zh.wikipedia.org/wiki/%E7%99%BC%E5%85%89%E4%BA%8C%E6%A5%B5%E7%AE%A1">LED发光二极管</a> 涉及较多的物理和光学专业知识，这里不详细展开，就对比两者的优劣和差异。</p><h3 id="E-Ink-电子墨水屏">E Ink 电子墨水屏</h3><p><a href="https://zh.wikipedia.org/zh-hans/%E9%9B%BB%E5%AD%90%E5%A2%A8%E6%B0%B4">电子墨水技术</a>是由 <em>E Ink Corporation</em> 公司提出，常被用于制作电子显示器，例如大名鼎鼎的 <em>Amazon Kindle</em><br>它的表面由大量包含正负电子的微胶囊组成，当设置电场为正时，白粒子向微胶囊的顶部移动，所以呈现白色；反之电场为负时，呈现黑色。</p><p>电子墨水的一大缺点时，即重置屏幕时具有延迟，因为要通过改变电场使粒子发生移动，例如Kindle阅读翻页时有明显等待。</p><p><img src="/images/kindle-tech.png" alt=""></p><h2 id="光栅化">光栅化</h2><h3 id="Pixels">Pixels</h3><p>首先如何从计算机的角度定义一个屏幕?</p><ul><li>颜色：（<font color="#FF1E10"><strong>R</strong></font>，<font color="#1AAD19"><strong>G</strong></font>，<font color="#1A9BFF"><strong>B</strong></font>）</li><li>坐标：由分辨率决定的二维数组<ul><li>左下角：$(0,0)$，右上角: $(width-1, height-1)$</li><li>像素实际坐标：$(x+0.5, y+0.5)$</li></ul></li></ul><p><img src="/images/pixels.png" alt=""></p><p>要解决的实际问题：<br>将$[-1, 1]^{2}$ 映射到 $[0, width] \times [0, height]$</p><p>先经线性变化（先从屏幕左下角平移到屏幕中间，再经过缩放操作）：</p><p><img src="/images/viewport_matrix.png" alt=""></p><h3 id="Triangles">Triangles</h3><ul><li>为什么用 <strong>三角形</strong> 表示几何物体?<ul><li>顶点数最多的平面几何（再少一个点就是线段了）</li><li>任何多边形都可以由三角形组成（三生万物）</li><li>利于做差值、判断内外…</li></ul></li></ul><p>一些常见的三维模型格式，例如obj、fbx，其内部都是用三角形（或者Poly）表示模型的。<br>可以看这篇文章：<a href="/posts/2WF6HFQ/">Model and Mesh</a></p><h3 id="问题建模">问题建模</h3><p>光栅化实际要解决的问题如下:<br>对于每个三角形，逐个像素判断是否在三角形内，是则着色，不是则跳过。</p><div class="admonition note"><p class="admonition-title">判断三角形内</p><ul><li>通过三次叉乘实现</li><li>参考这篇文章：<a href="/posts/30P8RVY/">【GAMES101】Transformation</a></li></ul></div><p><img src="/images/raster-demo.png" alt=""></p><pre><code class="language-python">for tri in tris: # 所有三角形    for (x, y) in pixels: # 所有像素        output[tri, x, y] = inside(tri, x, y)</code></pre><p><strong>观察如上算法，是一个 $O(N^{3})$ 的遍历算法，是否有优化的方法呢？</strong></p><h3 id="加速：AABB">加速：AABB</h3><p>利用三角形的包围盒来加速。<br>实际绘制中，不可能每个三角形都填充满整个屏幕，因此可以通过AABB剔除掉在包围盒外的像素点。</p><h3 id="加速：Incremental-Triangle-Traversal">加速：<a href="http://15462.courses.cs.cmu.edu/fall2019/lecture/drawingatriangle/slide_068">Incremental Triangle Traversal</a></h3><p>可以理解为更精细的AABB。<br>从三角形每排的最左侧到最右侧执行光栅化，基本不会多遍历一个像素点。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;光栅化与硬件基础&lt;/p&gt;</summary>
    
    
    
    <category term="Graphics" scheme="http://luhao.wiki/categories/Graphics/"/>
    
    <category term="Graphics" scheme="http://luhao.wiki/categories/Graphics/Graphics/"/>
    
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【CSAPP】Information Storage</title>
    <link href="http://luhao.wiki/posts/24H1CZ3/"/>
    <id>http://luhao.wiki/posts/24H1CZ3/</id>
    <published>2023-05-22T14:13:19.000Z</published>
    <updated>2023-06-22T05:49:06.587Z</updated>
    
    <content type="html"><![CDATA[<p>原码、反码、补码、Integer、Float…<span id="more"></span></p><div class="admonition note"><p class="admonition-title">材料</p><ul><li><a href="https://www.cs.sfu.ca/~ashriram/Courses/CS295/assets/books/CSAPP_2016.pdf">CSAPP chapter 2</a></li><li><a href="https://fengmuzi2003.gitbook.io/csapp3e/di-er-zhang-zhong-dian-jie-du">CSAPP 重点解读</a></li><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86">IC S解读</a></li><li><a href="https://0.30000000000000004.com/">0.30000000000000004.com</a></li><li><a href="http://graphics.stanford.edu/~seander/bithacks.html">Bit Hacks</a>（位运算的奇技淫巧）</li></ul></div><div class="markmap-container" style="height:250px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;字节序&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#大端（Big-Endian）\&quot;>大端</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;<a href=\&quot;#小端（Little-Endian）\&quot;>小端</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;编码&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#原码\&quot;>原码</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#反码\&quot;>反码</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#补码\&quot;>补码</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;浮点数&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;<a href=\&quot;#小数的二进制\&quot;>小数的二进制</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;<a href=\&quot;#IEEE-754\&quot;>IEEE-754</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="导读">导读</h2><p>CSAPP花费较多篇幅介绍计算机的二进制系统，以及“1字节=8比特”的设计。既然人类已经习惯使用十进制计数法，为什么计算机要改用二进制呢？</p><ul><li>二进制 对应电路中的高低电平，容易区分</li><li>二进制 利于物理存储，磁极、凹凸、光照等</li></ul><blockquote><p>推荐阅读如下前置知识：</p><ul><li><a href="/posts/3RBTN4W/">计算机架构入门：CPU、存储器</a></li><li><a href="/posts/1X3A6C1/">Virtual Memory</a></li></ul></blockquote><h2 id="大端小端">大端小端</h2><p>先看什么是大端、什么是小端，这些统称为字节序（Endianess）</p><p>假设 <code>int a = 0x01234567</code>，地址为 <code>0x100</code>，因为int类型占4个字节，所以写入 <code>0x100 0x101 0x102 0x103</code> 这四个字节的内存地址：</p><h3 id="大端（Big-Endian）">大端（Big-Endian）</h3><p>将 数据的低字节 放在 内存的高位，符合人类的阅读习惯，又称为 <em>network byte order</em><br><img src="/images/big-endian.png" alt=""></p><h3 id="小端（Little-Endian）">小端（Little-Endian）</h3><p>将 数据的低字节 放在 内存的低位，与人类的阅读习惯相反，又称为 <em>host byte order</em><br><img src="/images/little-endian.png" alt=""></p><p><strong>大小端利弊</strong></p><p>为什么没有厂商一统江湖，选择 “利于阅读” 的大端呢？<br>原因是两种存储方式各有利弊，谁也无法说服谁…<br><a href="https://www.zhihu.com/question/25311159">知乎: 大小端字节序存在的意义，为什么不用一个标准</a></p><ul><li><ol><li>因为 “符号位” 存储在第一个字节（后文讲到），此时大端能快速判读大小、正负</li></ol></li><li><ol start="2"><li>执行加法运算时，高位往往需要添加额外的数据，此时小端效率更高，大端要额外移动</li></ol></li></ul><p><strong>常见字节序</strong></p><p>大端：IBM，JPEG …<br>小端：Intel，BMP …</p><h3 id="观察字节序">观察字节序</h3><pre><code class="language-c++">// Demo_2:观察字节序的一个简单例子typedef unsigned char *pointer;void show_bytes(pointer start, size_t len){    size_t i;    for (i = 0; i &lt; len; i++)    printf("%p\t0x%.2x\n",start+i, start[i]);    printf("\n");}int main(){    int a = 0x01234567;    show_bytes((pointer) &amp;a, sizeof(int));}// 输出结果(Linux x86-64)Demo$ gcc -o chp2 chp2.c ; ./chp20x7ffc837a0b3c0x670x7ffc837a0b3d0x450x7ffc837a0b3e0x230x7ffc837a0b3f0x01</code></pre><h3 id="记录一个未区分大小端导致的Bug">记录一个未区分大小端导致的Bug</h3><p>如下定义了一个 <code>struct</code> 类型，大小是 32位，占 4字节。<br>假设 <code>idx</code> 存储的数据是 <code>0x1234</code><br>当在shader中解析 <code>idx</code> 的取值时，因为存储在贴图的通道中，所以只能逐字节decode。<br>由于默认 <code>0x12</code> 在 低位，所以解码为 <code>L + H &lt;&lt; 8</code>，但是对于小端存储的机器（如Intel CPU），这个取值就是错的，因为实际算出来是 <code>0x34 + 0x12 &lt;&lt; 8</code></p><pre><code class="language-C++">struct DataDesc{    uint16_t idx;    uint8_t  count1;    uint8_t  count2;}</code></pre><ul><li>修复方法</li></ul><p>利用 <code>htons</code> 将小端统一转化为大端存储，<a href="https://linux.die.net/man/3/htons">htons(3) - Linux man page</a><br>注意头文件，Linux下是 <code>#include &lt;arpa/inet.h&gt;</code>，windows下是 <code>#include &lt;winsock.h&gt;</code></p><h2 id="原码">原码</h2><blockquote><p>最高位表示符号位，其他位存放数值</p></blockquote><p>数据的存储只能是 0 和 1 两种状态，如果想区分一个数值的正负，先人提出用 “最高位” 的 0 和 1 来表示：</p><ul><li>1：负数</li><li>0：正数</li></ul><div class="admonition warning"><p class="admonition-title">思考一下为什么用1表示负数，而不是0呢？</p></div><p>假设用 3 bits 表示一个整数，则 1个符号位 加上 2个数值位，可以表示的范围是 <code>-3 ~ +3</code>，如下表：</p><table><thead><tr><th style="text-align:center">二进制</th><th style="text-align:center">符号位</th><th style="text-align:center">真值</th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">+</td><td style="text-align:center"><font color="#FF1E10"><strong>+0</strong></font></td></tr><tr><td style="text-align:center">001</td><td style="text-align:center">+</td><td style="text-align:center">+1</td></tr><tr><td style="text-align:center">010</td><td style="text-align:center">+</td><td style="text-align:center">+2</td></tr><tr><td style="text-align:center">011</td><td style="text-align:center">+</td><td style="text-align:center">+3</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">-</td><td style="text-align:center"><font color="#FF1E10"><strong>-0</strong></font></td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">-</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">110</td><td style="text-align:center">-</td><td style="text-align:center">-2</td></tr><tr><td style="text-align:center">111</td><td style="text-align:center">-</td><td style="text-align:center">-3</td></tr></tbody></table><h3 id="原码的缺陷">原码的缺陷</h3><ol><li><p>原码中存在两个0，即正零和负零，意味着判断是否要0要两个时钟运算…</p></li><li><p>原码作运算时，如果符号位不同，会导致计算结果错误（需要硬件额外处理）：<br><code>001 + 101 = 110</code>，表示 <code>1 + (-1) = -2</code></p></li></ol><h2 id="反码">反码</h2><blockquote><p>正数的反码是原码，负数的反码是符号位除外、其他按位取反</p></blockquote><p>反码的出现是为了解决原码的弊端，即 “相反数之和不为0”。这里干脆从结果反推，为了使和为0，不如用一个整数的“按位取反” 来表示负数。</p><p>例如，<code>001</code>表示+1，则-1的反码是<code>110</code>，此时相加为 <code>001 + 110 = 111 = 0</code></p><table><thead><tr><th style="text-align:center">原码</th><th style="text-align:center">反码</th><th style="text-align:center">真值</th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">000</td><td style="text-align:center">+0</td></tr><tr><td style="text-align:center">001</td><td style="text-align:center">001</td><td style="text-align:center">+1</td></tr><tr><td style="text-align:center">010</td><td style="text-align:center">010</td><td style="text-align:center">+2</td></tr><tr><td style="text-align:center">011</td><td style="text-align:center">011</td><td style="text-align:center">+3</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">111</td><td style="text-align:center">-0</td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">110</td><td style="text-align:center">-1</td></tr><tr><td style="text-align:center">110</td><td style="text-align:center">101</td><td style="text-align:center">-2</td></tr><tr><td style="text-align:center">111</td><td style="text-align:center">100</td><td style="text-align:center">-3</td></tr></tbody></table><h3 id="反码的缺陷">反码的缺陷</h3><ol><li><p>仍然有两个0</p></li><li><p>表示有点反人类，不够直观</p></li></ol><h2 id="补码">补码</h2><blockquote><p>正数和0的补码是原码，负数的补码是反码 +1</p></blockquote><ul><li>如何根据补码求真值?<br>牢记口诀，正数照求，负数将数值部分按位取反 +1</li></ul><p>如下表，<code>3 bit</code> 补码的真值范围是 <code>-4 ~ 3</code>，比原码、反码多出一个值，是因为去掉了重复的正负零。</p><table><thead><tr><th style="text-align:center">补码（正数略）</th><th style="text-align:center">真值</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">-4</td></tr><tr><td style="text-align:center">101</td><td style="text-align:center">-3</td></tr><tr><td style="text-align:center">110</td><td style="text-align:center">-2</td></tr><tr><td style="text-align:center">111</td><td style="text-align:center">-1</td></tr></tbody></table><p>因为补码是现代计算机硬件应用最广泛的编码方式，顺便提一下补码的运算规则：</p><ol><li><p>加法<br>不论正负数，直接对补码相加即可：<br><code>3 + (-2) = 011 + 110 = 001 = 1</code></p></li><li><p>减法<br>补码的减法，实际就是加一个负数，道理和加法是相同的：<br><code>3 - 2 = 3 + (-2) ...</code></p></li></ol><h2 id="浮点数">浮点数</h2><p>C++中计算浮点数加法时，经常会出现 <code>0.1 + 0.2 = 0.30000000000000004</code> 的类似现象，导致浮点数判相等很困难，这也是源于 <code>IEEE 754</code> 的存储方式。<br>首先，不论是0.1 还是0.2，在十进制这是一个有限的小数，但是在计算机二进制的表示中，他们是无限不循环的，这就造成了运算的精度误差。</p><h3 id="小数的二进制">小数的二进制</h3><div class="admonition note"><p class="admonition-title">如何理解小数二进制</p><ul><li>核心是科学计数法，十进制的 $0.525 = 5 * 10^{-1} + 2 * 10^{-2} + 5 * 10^{-3}$</li><li>对应二进制为：$0.525 = 1 * 2^{-1} + 1 * 2^{-2}$</li><li>口诀是：<strong>乘2取整，顺序排列</strong></li></ul></div><p><strong>有限不循环的十进制，在二进制下 可能无限不循环</strong>，而数据存储的bits是有限的，这就是浮点数误差的根本原因。</p><p>以小数 0.2 转成二进制为例，按照上面的算法得出如下的计算过程：</p><table><thead><tr><th style="text-align:center">依次乘2</th><th style="text-align:center">取整数</th><th style="text-align:center">二进制</th></tr></thead><tbody><tr><td style="text-align:center">0.2 * 2 = 0.4</td><td style="text-align:center">0</td><td style="text-align:center">0.0</td></tr><tr><td style="text-align:center">0.4 * 2 = 0.8</td><td style="text-align:center">0</td><td style="text-align:center">0.00</td></tr><tr><td style="text-align:center">0.8 * 2 = 1.6</td><td style="text-align:center">1</td><td style="text-align:center">0.001</td></tr><tr><td style="text-align:center">0.6 * 2 = 1.2</td><td style="text-align:center">1</td><td style="text-align:center">0.0011</td></tr><tr><td style="text-align:center">0.2 * 2 = 0.4</td><td style="text-align:center">0</td><td style="text-align:center">0.00110</td></tr><tr><td style="text-align:center">…循环</td><td style="text-align:center"></td><td style="text-align:center">0.00110011…</td></tr></tbody></table><h3 id="IEEE-754">IEEE 754</h3><p>通用的浮点数标准是 <code>IEEE 754</code>，在1985年提出并沿用至今。</p><p>下面以浮点数 <code>178.125</code> 为例，描述二进制的计算过程：</p><ul><li>整数部分：178，二进制为 <code>10110010</code></li><li>小数部分：0.125，二进制为 <code>001</code></li><li>合起来二进制为 <code>10110010.001</code></li><li>转换成二进制的科学计数法，为 <code>1.0110010001 * 2 ^ 7</code>，7用二进制表示为<code>111</code></li></ul><p>接着对照下面的公式，代入三个部分的取值：</p><ul><li>符号位 S = 0</li><li>尾数 M = 0110010001</li><li>指数 E = 111，结合偏移值得到 10000110</li><li>因此 <code>178.125</code> 的单精度浮点数是 <code>0x43322000</code></li></ul><p><img src="/images/float-demo.png" alt=""></p><h3 id="32位浮点数-转换公式">32位浮点数 转换公式</h3><blockquote><p>$V = (-1)^{S} \times M \times R^{E}$<br>S：符号位，0为正、1为负<br>M：尾数（float），对于 $2.18 \times 10^{-2}$ 中的 2.18<br>E：指数（int），对于 $2.18 \times 10^{-2}$ 中的 -2<br>R：基数，十进制为10，二进制位2</p></blockquote><p><img src="/images/32bit-float.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原码、反码、补码、Integer、Float…&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://luhao.wiki/categories/Linux/"/>
    
    <category term="Linux" scheme="http://luhao.wiki/categories/Linux/Linux/"/>
    
    
    <category term="Graphics" scheme="http://luhao.wiki/tags/Graphics/"/>
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【Python】UnitTest单元测试</title>
    <link href="http://luhao.wiki/posts/A20MTJ/"/>
    <id>http://luhao.wiki/posts/A20MTJ/</id>
    <published>2023-05-21T15:16:02.000Z</published>
    <updated>2023-06-18T13:12:53.656Z</updated>
    
    <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">概要</p><ul><li>工作中经常遇到一些阻碍开发流程的提交，希望通过 <code>UnitTest</code> 避免类似的commit</li><li>todo: Python unittest，关于自动化测试的方法，测试理论等</li><li>plan: 预期这周内完成，伴随一些工作的脚本开发</li></ul></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;概要
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;工作中经常遇到一些阻碍开发流程的提交，希望通过 &lt;code&gt;UnitTest&lt;/code&gt; 避免类似的commit&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Python" scheme="http://luhao.wiki/categories/Python/"/>
    
    <category term="Python" scheme="http://luhao.wiki/categories/Python/Python/"/>
    
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>PDCA 闭环思维</title>
    <link href="http://luhao.wiki/posts/120QJ0A/"/>
    <id>http://luhao.wiki/posts/120QJ0A/</id>
    <published>2023-05-20T07:18:56.000Z</published>
    <updated>2023-06-18T13:12:53.660Z</updated>
    
    <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">提要</p><ul><li>阅读材料来源：<a href="https://www.zhihu.com/question/421674339/answer/2863380386">知乎：有什么行为习惯昭示着你是个编程**？</a></li><li>本文都从工作的角度讨论，不涉及个人生活作息</li></ul></div><h2 id="为什么讲闭环">为什么讲闭环</h2><p>闭环思维，决定你是否能把一件事做到完美，决定你是否能成为一个靠谱的人。</p><p>通俗理解闭环思维，就是无论做什么事情，都要有始有终，能够形成一个完整的闭环。</p><h2 id="五个核心">五个核心</h2><p>通俗地理解，闭环思维有五个核心，须牢记于心：</p><ul><li><p>凡事有计划</p></li><li><p>约定必落实</p></li><li><p>问题早只会</p></li><li><p>及时报进程</p></li><li><p>事后须反馈</p></li></ul><h2 id="PDCA循环-⭐">PDCA循环 ⭐</h2><p>闭环思维的理论依据是“PDCA循环”，由美国管理专家 休哈特博士 提出，将每件事分为四个阶段：</p><ul><li>Plan：计划</li><li>Do：落地</li><li>Check：检讨/检查</li><li><s>Action</s> Improve：改善/改进</li></ul><p>如下图所示，一个需求可能需要多个回合的改善才能完成，即代表多个“PDCA循环”：<br><img src="/images/pdca.png" alt=""></p><p>这个模型完全可以应用于程序的日常开发，过去自己往往只关注 <code>Do</code> 的部分，而忽略了其他三个环节。<br>后面的改进：</p><ul><li>需求提出初期，明确 <code>Plan</code> 环节</li><li>推动落地期间，逐步记录 <code>Do</code> 的过程</li><li>需求开发完毕，主动 <code>Check</code> 完成度、潜在的bug、回归范围</li><li>提出待改善项，即 <code>Improve</code></li></ul><p>针对目前的工作流程，如下是一个 <code>PDCA</code> 的示例：</p><table><thead><tr><th style="text-align:center"><code>PDCA</code></th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>Plan</code></td><td style="text-align:left">∘ 3月5日完成功能A<br> ∘ 3月7日完成功能B</td></tr><tr><td style="text-align:center"><code>Do</code></td><td style="text-align:left">∘ 3月5日：完成A，同时优化了xxx<br> ∘ 3月8日：完成B，同时修复了xxx</td></tr><tr><td style="text-align:center"><code>Check</code></td><td style="text-align:left">∘ A的性能存在问题<br> ∘ B的code review有两处comments</td></tr><tr><td style="text-align:center"><code>Improve</code></td><td style="text-align:left">∘ 计划4月通过xxx优化方案解决A的性能问题<br> ∘ code review问题已修复<br> ∘ B完成延期一天，原因是xxx</td></tr></tbody></table><h3 id="5W2H分析法">5W2H分析法</h3><ul><li>What：先阐述清楚要做的事情是什么，确保合作职能可以理解</li><li>Why：为什么要做这件事？</li><li>Who：参与协作的职能</li><li>When：交付时间</li><li><s>Where</s></li><li>How：准备怎么做</li><li>How much：做到什么程度</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;提要
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;阅读材料来源：&lt;a href=&quot;https://www.zhihu.com/question/421674339/answer/286</summary>
      
    
    
    
    <category term="随笔" scheme="http://luhao.wiki/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="随笔" scheme="http://luhao.wiki/categories/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>【GAMES101】Transformation</title>
    <link href="http://luhao.wiki/posts/30P8RVY/"/>
    <id>http://luhao.wiki/posts/30P8RVY/</id>
    <published>2023-05-12T17:55:34.000Z</published>
    <updated>2023-06-22T05:55:57.647Z</updated>
    
    <content type="html"><![CDATA[<p>向量与线代、空间变换、投影<span id="more"></span></p><div class="markmap-container" style="height:350px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;空间向量&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#点乘\&quot;>点乘</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;<a href=\&quot;#叉乘\&quot;>叉乘</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;线性变换&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#缩放\&quot;>缩放</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#旋转\&quot;>旋转</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#平移\&quot;>平移</a>&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<a href=\&quot;#齐次坐标系-Homogeneous-coord\&quot;>齐次坐标</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;What：<code>(x, y, z, w)</code>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Why：解决平移&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;几何意义&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;w=0：向量&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;w≠0：点&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;#欧拉角\&quot;>欧拉角</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;MVP变换&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;<a href=\&quot;#小数的二进制\&quot;>Model</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#IEEE-754\&quot;>View</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;#IEEE-754\&quot;>Projection</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;正交投影&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;透视投影&quot;}]}]}],&quot;p&quot;:{}}"></svg></div><h2 id="点乘">点乘</h2><ul><li><p>$\vec {a} \cdot \vec {b} = |\vec {a}| |\vec {b}| cos \theta$</p></li><li><p>几何意义：$\vec {a}$ 在 $\vec {b}$ 方向上的投影与 $\vec {b}$ 的乘积</p></li><li><p><img src="/images/dot.png" alt=""></p></li><li><p><strong>图形学应用</strong></p><ul><li>衡量两个向量是否接近：值越大越相近</li><li>判定两个向量是否同向：正值同向、0为垂直、负值反向</li></ul></li></ul><h2 id="叉乘">叉乘</h2><ul><li><p>几何意义：$\vec {a}$ 和 $\vec {b}$ 围成平行四边形的面积</p></li><li><p>$\vec {a} \times \vec {b}$ 垂直于两个向量所在的平面</p></li><li><p>方向：右手螺旋定理</p><ul><li>四个手指顺着 $\vec {a}$ 指向 $\vec {b}$ 的方向，则大拇指表示 $\vec {a} \times \vec {b}$ 的方向</li></ul></li><li><p><img src="/images/product.png" alt=""></p></li><li><p><strong>图形学应用</strong></p><ul><li>判定左右：$\vec {a} \times \vec {b}$ 叉乘为正，说明 $\vec {a}$ 在 $\vec {b}$ 的右侧</li><li>判定内外：<ul><li>需要三次左右判定，如可以通过 $\vec {AP} \times \vec {AB}$ 得到 $P$ 在 $\vec {AB}$ 的左侧</li><li><img src="/images/product-tri.png" alt=""></li></ul></li></ul></li></ul><h2 id="正交左手（右手）系">正交左手（右手）系</h2><p>可以通过 “叉乘” 定义一个正交坐标系</p><ul><li><p>$|\vec {x}| = |\vec {y}| = |\vec {z}| = 1$</p></li><li><p>$\vec {x} \cdot \vec {y} = \vec {x} \cdot \vec {z} = \vec {y} \cdot \vec {z} = 0$</p></li><li><p>$\vec {y} = \vec {z} \times \vec {x}$ （左手系 or 右手系）</p></li></ul><p><img src="/images/left-hand-axis.png" alt=""></p><h2 id="矩阵">矩阵</h2><ul><li>$(M \times N)$: 表示 $M$ 行 $N$ 列的矩阵</li></ul><p>$(M \times N) (N \times P) = (M \times P)$</p><p><img src="/images/matrix-multiply.png" alt=""></p><h2 id="线性变换">线性变换</h2><h3 id="缩放">缩放</h3><p>以 $x$,$y$ 分别缩放 $a$,$b$ 为例：</p><ul><li>$x’ = ax$</li><li>$y’ = by$</li></ul><p>$<br>\left[\begin{matrix}<br>x’\\y’<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>a &amp; 0\\0 &amp; b<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>x\\y<br>\end{matrix}\right]<br>$</p><h3 id="反射">反射</h3><p>以绕y轴反射为例：</p><ul><li>$x’ = -x$</li><li>$y’ = y$</li></ul><p>$<br>\left[\begin{matrix}<br>x’\\y’<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>-1 &amp; 0\\0 &amp; 1<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>x\\y<br>\end{matrix}\right]<br>$</p><h3 id="旋转">旋转</h3><p>以绕坐标原点旋转 $\theta$ 角为例：</p><p>$<br>\left[\begin{matrix}<br>x’\\y’<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>cos\theta &amp; -sin\theta\\sin\theta &amp; cos\theta<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>x\\y<br>\end{matrix}\right]<br>$</p><h3 id="平移">平移</h3><p>尝试了一波，发现没法用一个 $2\times2$ 的矩阵表示二维的平移变换？<br>（后续为了解决此问题，引入了第三维度 $w$）</p><h2 id="齐次坐标系-Homogeneous-coord">齐次坐标系 (<em>Homogeneous coord.</em>)</h2><div class="admonition warning"><p class="admonition-title">为什么引入 齐次坐标系?</p><ul><li>考虑用 $M_{2 \times 2}$ 叠加平移变换</li><li>$x' = x + p$</li><li>$y' = y + q$</li><li>二维变换下，$x' = M_{2 \times 2} \quad x$ 无法作常量的平移变换</li><li>只能写成 ： $\left[\begin{matrix}x'\\y'\end{matrix}\right] =\left[\begin{matrix}a &amp; b\\c &amp; d\end{matrix}\right]\left[\begin{matrix}x\\y\end{matrix}\right] +\left[\begin{matrix}p\\q\end{matrix}\right]$</li></ul></div><h3 id="平移变换">平移变换</h3><ul><li>$<br>\left[\begin{matrix}<br>x’\\<br>y’\\<br>w’<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>1 &amp; 0 &amp; p\\<br>0 &amp; 1 &amp; q\\<br>0 &amp; 0 &amp; 1<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>x\\<br>y\\<br>1<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>x+p\\<br>y+q\\<br>1<br>\end{matrix}\right]<br>$</li></ul><h3 id="w-维度">$w$ 维度</h3><ul><li><p>区分 点 和 向量</p><ul><li>点：$(x, y, 1)^{T}$</li><li>向量：$(x, y, 0)^{T}$</li></ul></li><li><p>区分 二维运算</p><ul><li>向量 +/- 向量：$w$ 维度为0，得到向量</li><li>点 - 点：$w$ 维度为0，得到向量</li><li>点 + 向量：$w$ 维度为1，得到点</li><li>点 + 点：$w$ 维度为0，得到点</li></ul></li></ul><h3 id="x-y-w-T-几何意义">$(x, y, w)^{T}$几何意义</h3><ul><li>$w = 0$：表示向量</li><li>$w ≠ 0$：表示点 $(\frac{x}{w}, \frac{y}{w}, 1)$</li></ul><h3 id="总结">总结</h3><p>此时可以表示 Scale、Rotation、Translation 三种线性变换：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Matrix</th></tr></thead><tbody><tr><td style="text-align:center">Scale</td><td style="text-align:center">$\left[\begin{matrix}s_{x} &amp; 0 &amp; 0\\0 &amp; s_{y} &amp; 0\\0 &amp; 0 &amp; 1\end{matrix}\right]$</td></tr><tr><td style="text-align:center">Rotation</td><td style="text-align:center">$\left[\begin{matrix}cos\theta &amp; -sin\theta &amp; 0\\sin\theta &amp; cos\theta &amp; 0\\0 &amp; 0 &amp; 1\end{matrix}\right]$</td></tr><tr><td style="text-align:center">Translation</td><td style="text-align:center">$\left[\begin{matrix}1 &amp; 0 &amp; t_{x}\\0 &amp; 1 &amp; t_{y}\\0 &amp; 0 &amp; 1\end{matrix}\right]$</td></tr></tbody></table><p>另外，可以用 $M^{-1}$ 表示逆变换（反向操作，逆函数）</p><h3 id="欧拉角">欧拉角</h3><ul><li><a href="https://www.zhihu.com/question/47736315/answer/236284413">知乎: 如何通俗地解释欧拉角？</a></li><li><a href="https://en.wikipedia.org/wiki/Euler_angles">Wikipedia: Eular angles</a></li></ul><p>欧拉角使用三个角度来描述刚体在 $xyz$ 坐标系中的旋转，这三个角度分别表示绕 “三个轴” 旋转的角度，不同顺序会产生不同的结果</p><p>也可以用 roll, pitch, yaw 来表示欧拉角，如图所示<br><img src="/images/roll-pitch-yaw.png" alt=""></p><ul><li>旋转所绕的轴有两种划分<ul><li>世界坐标系（静止）：$xyz$</li><li>局部坐标系（动态）：$XYZ$</li></ul></li></ul><div class="admonition warning"><p class="admonition-title">TODO</p><ul><li>万向节死锁这部分没完全弄懂</li><li><a href="https://en.wikipedia.org/wiki/Gimbal_lock">万向节死锁</a></li></ul></div><h2 id="MVP变换">MVP变换</h2><ul><li>首先前面提到过 $(x, y, z, w)^{T}$ 表示三维的信息<ul><li>$w = 0$: 表示向量 $(x, y, z)$</li><li>$w ≠ 0$：表示点 $(\frac{x}{w}, \frac{y}{w}, \frac{z}{w})$</li></ul></li></ul><p>三维空间的点，最终展现到二维屏幕上，需要经过一些列的空间变换，可以概括为 <font color="#ef6d3b"><strong>“MVP”</strong></font></p><p>MVP 变换可以想象为一个拍照的过程：</p><h3 id="Model-变换">Model 变换</h3><blockquote><p>“将人群和景色放到一个合适的位置”</p></blockquote><p>将所有模型移动到统一的世界坐标下（world space）</p><p>局部坐标 -&gt; 世界坐标</p><h3 id="View-变换">View 变换</h3><blockquote><p>“找一个合适的相机角度”</p></blockquote><ul><li>如何描述相机的信息?<ul><li>坐标：$\vec e = (x_{e}, y_{e}, z_{e})$</li><li>相机朝向 Look-at：$g$</li><li>相机上方向 Up：$t$</li></ul></li></ul><p>通过一个 View矩阵 $M_{view}$ 将所有模型转换到 view空间，只需要 平移变换 + 旋转变换：<br>即 $M_{view} = R_{view} T_{view}$</p><p><strong>先平移 $T_{view}$</strong></p><p>平移变换是为了将相机移到中心原点，因此矩阵很好得到：</p><p>$<br>\left[\begin{matrix}<br>x’\\y’\\z’\\w’<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>1 &amp; 0 &amp; 0 &amp; -x_{e}\\0 &amp; 1 &amp; 0 &amp; -y_{e}\\0 &amp; 0 &amp; 1 &amp; -z_{e}\\0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{matrix}\right]<br>\left[\begin{matrix}<br>x\\y\\z\\w<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>x - x_{e}w\\y - y_{e}w\\z - z_{e}w\\w<br>\end{matrix}\right]<br>=<br>\left[\begin{matrix}<br>x - x_{e}\\y - y_{e}\\z - z_{e}\\1<br>\end{matrix}\right]<br>$</p><p><strong>后旋转 $R_{view}$</strong></p><p>拆解开来，需要作如下三个轴的旋转：</p><ul><li>$g$ 旋转到 $- \vec Z$</li><li>$t$ 旋转到 $\vec Y$</li><li>$g \times t$ 旋转到 $\vec X$</li></ul><p>将 “局部轴旋转到$XYZ$轴” 很困难，因此可以求逆变换：“将$XYZ$轴旋转到局部轴”</p><ul><li>将 $\vec X (1, 0, 0)$ 变换到 $(x_{g \times t}, y_{g \times t}, z_{g \times t})$</li><li>将 $\vec Y (0, 1, 0)$ 变换到 $(x_{t}, y_{t}, z_{t})$</li><li>将 $\vec Z (0, 0, 1)$ 变换到 $(x_{-g}, y_{-g}, z_{-g})$</li></ul><p>将这三个特殊值代入，可以解出 $R_{view}^{-1}$ 矩阵为：</p><p>$<br>R_{view}^{-1}=<br>\left[\begin{matrix}<br>x_{g \times t} &amp; x_{t} &amp; x_{-g} &amp; 0\\<br>y_{g \times t} &amp; y_{t} &amp; y_{-g} &amp; 0\\<br>z_{g \times t} &amp; z_{t} &amp; z_{-g} &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{matrix}\right]<br>$</p><p>根据转置矩阵得到 $R_{view}$：</p><p>$<br>R_{view}=<br>\left[\begin{matrix}<br>x_{g \times t} &amp; y_{g \times t} &amp; z_{g \times t} &amp; 0\\<br>x_{t} &amp; y_{t} &amp; z_{t} &amp; 0\\<br>x_{-g} &amp; y_{-g} &amp; z_{-g} &amp; 0\\<br>0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{matrix}\right]<br>$</p><div class="admonition note"><p class="admonition-title">逆向思维</p><ul><li>“求逆” 是线性代数解决问题的常见思路</li></ul></div><h3 id="Projection-变换">Projection 变换</h3><blockquote><p>“按下快门！拍照”</p></blockquote><p>投影变换是最重要的部分，因为它塑造了 “立体感”，它分为两种：</p><ul><li>Perspective Projection: 近大远小，符合人眼</li><li>Orthographic Projection：远近一致</li><li><img src="/images/transformation.png" alt=""></li></ul><p><strong>正交投影</strong></p><div class="admonition warning"><p class="admonition-title">疑问?</p><ul><li>正交投影 为什么把任何立方体投影到一个(-1, 1)的正方体?</li></ul></div><p><strong>透视投影</strong></p><div class="admonition todo"><p class="admonition-title">TODO</p><ul><li>这部分有点复杂，教程中利用 “相似三角形” 和 “特殊值法” 求出了矩阵，有空补一下</li></ul></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;向量与线代、空间变换、投影&lt;/p&gt;</summary>
    
    
    
    <category term="Graphics" scheme="http://luhao.wiki/categories/Graphics/"/>
    
    <category term="Graphics" scheme="http://luhao.wiki/categories/Graphics/Graphics/"/>
    
    
  </entry>
  
  <entry>
    <title>【C99】setjmp.h</title>
    <link href="http://luhao.wiki/posts/3CKYSDZ/"/>
    <id>http://luhao.wiki/posts/3CKYSDZ/</id>
    <published>2023-05-10T03:40:54.000Z</published>
    <updated>2023-06-18T13:12:53.652Z</updated>
    
    <content type="html"><![CDATA[<p>学习<code>setjmp</code>C标准库, 实现轻量级协程<span id="more"></span></p><div class="admonition note"><p class="admonition-title">写在最前面</p><p><em><strong><code>setjmp</code></strong></em> 是C99的一个标准库, 其实现了 <em><strong><code>non-local jumps</code></strong></em>, 本次学习路线是:</p><ul><li>阅读手册、文档 ✔: <a href="https://man7.org/linux/man-pages/man3/longjmp.3.html">man(3)</a>, <a href="https://en.wikipedia.org/wiki/Setjmp.h">wikipedia</a></li><li>阅读代码示例 ✔: <a href="https://en.wikipedia.org/wiki/Setjmp.h#Example_usage">wikipedia: Example usage</a></li><li>coding: <a href="http://jyywiki.cn/OS/2022/labs/M2">M2: 协程库 (libco)</a></li><li>可选: 阅读 <code>setjmp.h</code> 的源码</li></ul></div><h2 id="man-setjmp">man setjmp</h2><h3 id="what">what</h3><p>准确说是 <code>man 3 setjmp</code>, <code>3</code> 的含义是 <em><code>Linux Programmer's Manual</code></em>.<br>先看其基本的定义:</p><blockquote><p><em>setjmp, sigsetjmp, longjmp, siglongjmp  - performing a nonlocal goto</em></p></blockquote><p>也就是说, <code>setjmp</code>的作用是执行一个 nonlocal goto;<br>为什么说 nonlocal?<br>举个例子, 看下面的 C 代码, main函数 中尝试借助goto跳转到 func函数内部, 编译会报错<br><font color="#ef6d3b">因为 goto 只能实现函数堆栈内部的跳转，即 local jump!</font></p><pre><code class="language-c">void func() {outer:    printf("into func...");}int main() {inner:    // ...     goto outer; // error: label "outer" used but not defined    goto inner; // ok    // ...}</code></pre><h3 id="how">how</h3><p>继续阅读 Description 部分:</p><blockquote><p><em>The setjmp() function dynamically establishes the target to which control will later be transferred, and longjmp() performs the transfer of execution</em></p></blockquote><p>直译过来就是说，<code>setjmp()</code> 扮演的是定义 label 作用，<code>longjmp</code> 扮演的是goto跳转作用</p><p>继续看这两个函数体的定义:</p><pre><code class="language-c">int setjmp(jmp_buf env);void longjmp(jmp_buf env, int val);</code></pre><p><code>setjmp</code> 接收一个 <code>jmp_buf env</code> 的参数, 看看手册是如何解释 env 的:</p><blockquote><p><em>The setjmp() function saves various information about the calling environment (typically, the stack pointer, the instruction pointer, possibly the values of other registers and the signal mask) in the buffer env for later use by longjmp()</em></p></blockquote><p>写的很直白了， <code>env</code> 保存了调用处的局部环境，例如 栈指针、pc指针…<br>（这块如果看不懂，需要恶补汇编知识，建议阅读：<a href="/posts/1QNHHCN/">汇编（三）：基础AT&amp;T汇编</a>）<br><code>setjmp</code> 负责写入env，<code>longjmp</code> 会读取env并恢复调用时的环境，这样就达到了 <code>nonlocal goto</code> 的作用</p><p>ok基本看明白了，但是还有一个 <code>int val</code> 的参数，作用是什么？</p><ul><li>这里我觉得 man手册 没说清楚，自己总结下吧<ul><li>如果是 <code>setjmp</code> 的直接调用：返回 0</li><li>如果是 <code>longjmp</code> 的跳转调用：返回 一个非0 的 参数</li></ul></li></ul><div class="admonition note"><p class="admonition-title">setjmp的两次返回值</p><ul><li>这里很抽象，需要结合代码理解</li><li><a href="https://stackoverflow.com/questions/1692814/exception-handling-in-c-what-is-the-use-of-setjmp-returning-0">StackOverflow: What is the use of setjmp() returning 0?</a></li></ul></div><h3 id="注意点">注意点</h3><p>阅读 man手册 的 Caveats 部分，有两点注意事项:</p><ul><li>如果 调用 <code>setjmp</code> 的函数 在 <code>longjmp</code> 调用之前返回，那么行为不确定.</li><li>如果 在多线程 中使用 <code>nonlocal env</code>，那么行为不确定.</li></ul><p>这两点在实际开发中暂时不会遇到，先列在这里吧</p><h2 id="code-example">code example</h2><p>talk is cheap, show me the code：这部分开始讨论代码</p><p>下面的代码展示了 <code>setjmp / longjmp</code> 的基本使用:</p><p>核心：记住 <code>setjmp</code> 处会被call两次</p><ul><li>第一次是用户自己调用的</li><li>第二次是 <code>longjmp call</code> 回来的</li></ul><pre><code class="language-c++">// https://en.wikipedia.org/wiki/Setjmp.h#include &lt;stdio.h&gt;#include &lt;setjmp.h&gt;jmp_buf env;int longjmp_ret = 8;         // paramater pass to longjmpvoid second() {    printf("second 1\n");    // √    longjmp(env, longjmp_ret);    printf("second 2\n");    // ×}void first() {    printf("first 1\n");     // √    second();    printf("first 2\n");     // ×}int main() {    int val = setjmp(env);    if (!val) {        printf("setjmp return: %d\n", val);        first();               // when setjmp executed, setjmp returns 0    }    else {                     // when longjmp returns, setjmp returns 1        printf("setjmp return: %d\n", val);        printf("main :: else\n");     }    return 0;}// setjmp return: 0// first 1// second 1// setjmp return: 8// main :: else</code></pre><h2 id="setjmp-实现协程"><code>setjmp</code> 实现协程</h2><h3 id="实验要求">实验要求</h3><p>看到这里觉得自己很牛逼了，觉得都会了，是骡子是马，上实验遛遛：<br>这里 NJU 操作系统的实验，利用 setjmp 实现一个轻量级的协程: <a href="http://jyywiki.cn/OS/2022/labs/M2">M2: 协程库 (libco)</a></p><p>首先你要理解什么是 <a href="https://en.wikipedia.org/wiki/Coroutine">协程</a> （Python Generator 就是一种协程）</p><p>其次实现实验里给出的 api:</p><ul><li><code>co_start</code>: 创建一个新的协程，并返回一个指向struct co的指针（类似于 pthread_create）</li><li><code>co_wait(co)</code>: 表示当前协程需要等待，直到co协程的返回才能继续执行（类似于 pthread_join）</li><li><code>co_yield()</code>: 将当前协程“切换”出去，随机选择下一个线程执行</li></ul><pre><code class="language-c++">// co.hstruct co* co_start(const char *name, void (*func)(void *), void *arg);void co_yield();void co_wait(struct co *co);</code></pre><p><strong>如下是一个使用的例子：</strong></p><pre><code class="language-c++">#include &lt;stdio.h&gt;#include "co.h"int count = 1; // 协程之间共享void entry(void *arg) {  for (int i = 0; i &lt; 5; i++) {    printf("%s[%d] ", (const char *)arg, count++);    co_yield();  }}int main() {  struct co *co1 = co_start("co1", entry, "a");  struct co *co2 = co_start("co2", entry, "b");  co_wait(co1);  co_wait(co2);  printf("Done\n");}</code></pre><div class="admonition error"><p class="admonition-title">TODO</p><ul><li>为什么这里 <code>count++</code> 不会有线程安全问题?</li></ul></div><p>其中co1和co2这两个协程共享 <code>count</code> 变量，因此输出是：<br><code>b[1] a[2] b[3] b[4] a[5] b[6] b[7] a[8] a[9] a[10] Done</code></p><p><strong>一个小小的调试技巧:</strong></p><p>当你不希望某些调试用的输出，出现在正式环境，可以借助宏重写 printf:<br>（其中 <a href="https://learn.microsoft.com/en-us/cpp/preprocessor/variadic-macros?view=msvc-170"><code>__VA_ARGS__</code></a> 用来表示不定数量的参数）</p><pre><code class="language-c++">#ifdef DEBUG_MODE  #define debug(...) printf(__VA_ARGS__)#else  #define debug(...)#endif</code></pre><p>编译时增加 <code>-DDEBUG_MODE</code> 的编译选项，即可打开 <code>DEBUG_MODE</code> 宏，即实现了输出控制</p><p><strong>VSCode 调试 C++:</strong></p><p>因为一直 <code>VSCode Remote-SSH</code> 在服务器上写代码，不适合用 VS、Clion 等现代IDE调试，gdb这种又贼难用，所以配了一下VSCode调试的环境，看 <a href="/posts/3HCBFZ8/">这篇博客</a>；</p><p>限制还是有的：1. 只适合小型的 c/c++ 项目，2. 依赖太多三方库等文件时，<code>launch.json</code>不太好写</p><h2 id="实现">实现</h2><p>首先将协程的状态分为几类:</p><pre><code class="language-c++">enum co_status {  CO_NEW     = 1, // 新创建  CO_RUNNING = 2, // 已经执行  CO_WAITING = 3, // 在 co_wait 上等待  CO_DEAD    = 4, // 已经结束};</code></pre><p>状态的划分很重要，因为 <code>co_yield</code> 会选取下一个幸运儿进行调度执行，选择标准就是协程的状态；<br>理想情况下，选取一个 <code>CO_WAITING</code> 状态的协程继续执行，正在执行的协程状态是 <code>CO_RUNNING</code>，且同时有且只能有一个 <code>CO_RUNNING</code>…</p><p>那么选取下一个协程时，有两种情形要处理：</p><ul><li>有 <code>CO_WAITING</code>：直接切换</li><li>无 <code>CO_WAITING</code>：怎么办?<ul><li>继续执行？显然违背了 <code>yield</code> 的原理</li><li>正确做法是切回到 <code>main</code>（可以将 <code>main</code> 理解为一个主协程）</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习&lt;code&gt;setjmp&lt;/code&gt;C标准库, 实现轻量级协程&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/"/>
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/C/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
  </entry>
  
</feed>
