<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luhao&#39;s Blog</title>
  
  <subtitle>luhao wiki</subtitle>
  <link href="http://luhao.wiki/atom.xml" rel="self"/>
  
  <link href="http://luhao.wiki/"/>
  <updated>2023-08-20T17:58:30.454Z</updated>
  <id>http://luhao.wiki/</id>
  
  <author>
    <name>Luhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【C++11】lvalue &amp; rvalue (references)</title>
    <link href="http://luhao.wiki/posts/rvalue/"/>
    <id>http://luhao.wiki/posts/rvalue/</id>
    <published>2023-08-20T14:53:43.000Z</published>
    <updated>2023-08-20T17:58:30.454Z</updated>
    
    <content type="html"><![CDATA[<p><code>C++</code> 左值、右值引用<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c"><em><strong>Understanding the meaning of lvalues and rvalues in C++</strong></em></a></li><li><a href="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners"><em><strong>C++ rvalue references and move semantics for beginners</strong></em></a></li><li><a href="https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html"><em><strong>Move semantics and rvalue references in C++11</strong></em></a></li></ul></div><h2 id="前言">前言</h2><p>从接触、学习、运用 <code>C++</code> 至今，左右值引用一直是自己困惑的点。伴随着现代C++的发展，它们开始扮演越来越重要的作用（如 <code>std::move</code>、<code>std::remove_reference</code>…）。<br>这篇争取彻底搞懂他们。</p><p>先看 <code>gcc</code> 一个编译报错，为什么 <code>666 = x</code> 的语法是错误的？<br><em><font color="#FF1E10"><strong>error:</strong></font> lvalue required as left operand of assignment</em></p><p>编译器是在说：<strong>赋值符号 <code>=</code> 的左操作数，必须是左值 <code>lvalue</code> ! 换句话说，这里的 <code>666</code> 不是一个左值。</strong></p><pre><code class="language-c">int x;666 = x;</code></pre><h2 id="lvalue-rvalue">lvalue &amp; rvalue</h2><p>如何区分 左值 和 右值？</p><ul><li><strong><code>lvalue</code>：指向明确的内存地址</strong>，又称 <code>variable</code></li><li><strong><code>rvalue</code>：没有明确的内存地址</strong>，又称 <code>literal constant</code></li></ul><p>下面看几个示例：</p><ul><li><code>int x = 666</code>：<code>x</code> 是 <code>lvalue</code>，<code>666</code> 是 <code>rvalue</code></li><li><code>int* y = &amp;x</code>：<code>x</code> 是 <code>lvalue</code>，<code>y</code> 是 <code>lvalue reference</code></li></ul><p>编译规则，赋值<code>=</code> 和取地址<code>&amp;</code> 的左边必须是 <code>lvalue</code>，不然会报如下错误：</p><blockquote><p><em><font color="#FF1E10"><strong>error:</strong></font> lvalue required as left operand of assignment</em><br><em><font color="#FF1E10"><strong>error:</strong></font> lvalue required as unary ‘&amp;’ operand`</em></p></blockquote><div class="admonition warning"><p class="admonition-title">区分 左值 和 左值引用</p><ul><li><code>int x = 1</code>：x是左值</li><li><code>int&amp; y = x</code>：y是左值引用</li></ul></div><h2 id="function-reference">function reference</h2><p>函数的返回值可以是 左值，也可以是 右值。</p><ul><li>右值 ×</li></ul><pre><code class="language-c">int setValue() { return 6; };setValue() = 3; // error: lvalue required as left operand of assignment</code></pre><ul><li>左值 √</li></ul><pre><code class="language-c">int x = 100;int&amp; setValue() { return x; };setValue() = 1;</code></pre><h2 id="lvalue-to-rvalue">lvalue to rvalue</h2><p>左值 经常会被转化为 右值，如下示例：</p><ul><li><code>x, y</code> 都是 左值</li><li><code>x + y</code> 被转化为 右值</li></ul><pre><code class="language-c">int x = 1;int y = 3;int z = x + y;   // ok</code></pre><p>上面经历了一次 <strong>lvalue -&gt; rvalue</strong>  的隐式转换，很多操作符（<code>+, -, /</code>）都会提供。</p><h2 id="rvalue-to-lvalue">rvalue to lvalue</h2><p>右值 到 左值 的转换是被禁止的，如下代码是非法的：</p><pre><code class="language-c">int&amp; x = 10;// error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int'</code></pre><h2 id="rvalue-reference-🔥">rvalue reference 🔥</h2><p>C++ 的一条重要编译规则是：<strong>你无法绑定一个 右值 的地址，除非绑定到一个 <code>const</code> 类型</strong>，例如：</p><pre><code class="language-c">int&amp; x = 666; // error: cannot bind non-const lvalue reference of type 'int&amp;' to an rvalue of type 'int'const int&amp; x = 666; // OKstd::string s1 = "Hello ";std::string s2 = "world";const std::string&amp; s3 = s1 + s2;s3 += " luhao";  // error: no match for 'operator+=' (operand types are 'const std::string'</code></pre><p>但是上面的写法有个弊端，<strong>即无法再修改 <code>s3</code> 的值</strong>。<br>为了能够修改右值（即临时变量），<code>C++11</code> 正式引入右值引用（<code>rvalue reference</code>），其符号是 <code>&amp;&amp;</code>：</p><pre><code class="language-c">std::string s1 = "Hello ";std::string s2 = "world";std::string&amp;&amp; s3 = s1 + s2;s3 += " luhao"; // OK</code></pre><p>上面的示例看出来用处不大，<strong>因为 <code>rvalue reference</code> 真正大展拳脚的地方，是在 移动语义（<code>move semantics</code>）。</strong></p><h2 id="move-semantics-🔥">move semantics 🔥</h2><p>阅读资料</p><ul><li><a href="https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html"><em><strong>Move semantics and rvalue references in C++11</strong></em></a></li></ul><p><strong>移动语义 是一种利用右值引用的技术，来避免拷贝临时变量的优化手段。</strong></p><h3 id="为什么需要-move-semantics-💡">为什么需要 move semantics? 💡</h3><p>假设 <code>class Holder</code> 是一个(内存)非常繁重的类，考虑到如下的构造和拷贝构造函数。<br>当调用 <code>Holder h1(h)</code> 时，因为 <code>std::copy</code> 造成巨大的内存拷贝开销，如果后文中 <code>h</code> 也不再继续使用，为什么不尝试将 <code>h</code> 转交给 <code>h1</code> 呢?</p><pre><code class="language-c">class Holder{public:    Holder(int size) {        m_data = new int[size];        m_size = size;    }    Holder(const Holder&amp; other)    {        m_data = new int[other.m_size];        std::copy(other.m_data, other.m_data + other.m_size, m_data);        m_size = other.m_size;    }    ~Holder() { delete[] m_data; }private:    int*   m_data;    size_t m_size;}int main(){    Holder h(10000);    Holder h1(h); // 调用 std::copy 带来非必要开销    return 1;}</code></pre><p>借助移动语义，可以优化掉上面的拷贝。注意到下面使用了 <a href="#std-move"><em><strong>std::move</strong></em></a>，它能将左值转化为右值，是C++标准库的成员函数，后面有介绍。</p><pre><code class="language-c">Holder(Holder&amp;&amp; other){    // 赋值    m_data = other.m_data;    m_size = other.m_size;    // 清空other的状态    other.m_data = nullptr;    other.m_size = 0;}int main(){    Holder h(10000);    Holder h1(std::move(h));    return 1;}</code></pre><h3 id="std-move">std::move</h3><p>阅读材料：</p><ul><li><a href="https://en.cppreference.com/w/cpp/utility/move"><em>cppreference</em></a></li><li><a href="https://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-api-4.5/a00936_source.html"><em>libstdc++: move.h</em></a></li></ul><p>阅读 <code>std::move</code> 的源码，其实只是作了类型转化，将 任意形式的<code>_Tp</code> 转化成右值:</p><ul><li><code>std::remove_reference</code>：去掉引用</li><li><code>static_cast</code>：隐式转换</li></ul><div class="admonition note"><p class="admonition-title">std::move</p><ul><li><code>move</code> 右值：直接返回</li><li><code>move</code> 左值：转成右值，并返回</li></ul></div><pre><code class="language-c">  /**   *  @brief  Convert a value to an rvalue.   *  @param  __t  A thing of arbitrary type.   *  @return The parameter cast to an rvalue-reference to allow moving it.  */  template&lt;typename _Tp&gt;    constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;    move(_Tp&amp;&amp; __t) noexcept    { return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); }</code></pre><h3 id="std-remove-reference">std::remove_reference</h3><p><code>remove_reference</code> 顾名思义，就是去除任意类型的引用，借助模板实现。<br>核心是对于 <code>_Tp&amp;</code> 和 <code>_Tp&amp;&amp;</code> 这两种带引用的传参，需要去掉其引用的部分，只获取其类型（通过 <code>::type</code> 获取）</p><pre><code class="language-c">  template&lt;typename _Tp&gt;    struct remove_reference    { typedef _Tp   type; };  // 特化  template&lt;typename _Tp&gt;    struct remove_reference&lt;_Tp&amp;&gt;    { typedef _Tp   type; };  // 特化  template&lt;typename _Tp&gt;    struct remove_reference&lt;_Tp&amp;&amp;&gt;    { typedef _Tp   type; };</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;C++&lt;/code&gt; 左值、右值引用&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/"/>
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/C/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++17】refl-cpp</title>
    <link href="http://luhao.wiki/posts/refl-cpp/"/>
    <id>http://luhao.wiki/posts/refl-cpp/</id>
    <published>2023-08-17T16:27:58.000Z</published>
    <updated>2023-08-20T13:40:16.985Z</updated>
    
    <content type="html"><![CDATA[<p>品读<code>C++</code>经典反射库<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li>源码：<a href="https://github.com/veselink1/refl-cpp"><em><strong>veselink1/refl-cpp</strong></em></a></li><li>blog：<a href="https://veselink1.github.io/blog/cpp/metaprogramming/2019/07/13/refl-cpp-deep-dive.html"><em>refl-cpp — A deep dive into this compile-time reflection library for C++</em></a></li><li>这篇博客大致是英文版的 直译 + 自己理解，旨在提高对 <code>templates</code> + <code>reflections</code> 的掌握</li><li>精读blog ➜ 理解源码 ➜ 上手仿造</li></ul></div><h2 id="目录">目录</h2><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li><li><a href="#compile-time%E5%8F%8D%E5%B0%84">compile-time反射</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98">构建类的成员</a></li><li><a href="#%E4%BD%BF%E7%94%A8-macros-%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81">使用 <code>macros</code> 组织代码</a></li><li><a href="#%E5%87%BD%E6%95%B0%E5%8F%8D%E5%B0%84">函数反射</a></li><li><a href="#%E9%81%8D%E5%8E%86%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98">遍历类的成员</a></li></ul><h2 id="前言">前言</h2><p><code>refl-cpp</code> 的设计初衷是：</p><ul><li>支持 在 <strong><code>C++17</code></strong> 及更高版本 <strong>提供编译期反射（Compile-time）</strong> 的方法。</li><li>支持 <code>enumeration</code>，<code>introspection</code><ul><li><code>enumeration</code>：类似 <code>Python dir()</code> 枚举对象所有的属性</li><li><code>introsection</code>：类似 <code>Python getattr</code> 访问对象的指定属性</li></ul></li><li>支持 类型模板、成员模板</li><li>支持 <code>attributes</code> <font color="#FF1E10"><strong>TODO</strong></font></li></ul><p><code>refl-cpp</code> 的设计避免如下：</p><ul><li>避免 使用宏魔法</li><li>避免 <code>Private</code> 私有成员的反射</li><li>避免 运行时 按名称查询类型信息</li></ul><h2 id="compile-time反射">compile-time反射</h2><p>首先 <code>refl-cpp</code> 是一个 <code>compile-time</code> 的反射库，这意味着它不会维护一个 runtime 的数据结构来实现反射目的，例如下面是不可取的：</p><pre><code class="language-c">struct TypeInfo {    std::string name;           // 对象的类型名称    std::vector&lt;?&gt; members;     // 对象的所有成员    std::vector&lt;?&gt; attributes;  // 对象的所有成员取值}// ↓ 维护一个全局的反射数据结构std::unordered_map&lt;std::string, TypeInfo&gt; s_typeRegistry;</code></pre><p>相反，<code>refl-cpp</code> 的做法是，通过 cpp模板特化 以一种类相关的方式（<code>type-dependent</code>）来存储 <code>metadata</code>，例如下面的做法：</p><pre><code class="language-c">template &lt;typename&gt; struct TypeInfo {};// ↓ Point类的编译期信息template &lt;&gt;struct TypeInfo&lt;Point&gt; {  static constexpr char name[] = "Point";  ??? members = {};  ??? attributes = {};};</code></pre><h2 id="构建类的成员">构建类的成员</h2><p>上一节提供了存储 类信息 的方法，但是如何存储 其成员变量（和方法）呢？<br><code>refl-cpp</code> 使用一种新颖的方式来存储：</p><pre><code class="language-c">template &lt;size_t N&gt;struct MemberInfo;/* 第0个成员的模板特化 */template &lt;&gt;struct MemberInfo&lt;0&gt; {  /* ... */};/* 第1个成员的模板特化 */template &lt;&gt;struct MemberInfo&lt;1&gt; {  /* ... */};static constexpr size_t MemberCount = 2;</code></pre><p><code>MemberInfo</code> 是类成员的模板特化，因此将其添加到 <code>TypeInfo</code> 的作用域（如下）。<br><code>typename Dummy</code> 是因为C++不允许成员完全模板特化，而部分成员的模板特化是允许的。<font color="#FF1E10"><strong>TODO</strong></font></p><pre><code class="language-c">template &lt;&gt;struct TypeInfo&lt;Point&gt; {  template &lt;size_t N, typename Dummy&gt;  struct MemberInfo;  /* 第0个成员的模板特化 */  template &lt;typename Dummy&gt;  struct MemberInfo&lt;0&gt; {    /* ... */  };  /* 第1个成员的模板特化 */  template &lt;typename Dummy&gt;  struct MemberInfo&lt;1&gt; {    /* ... */  };  static constexpr size_t MemberCount = 2;};</code></pre><h2 id="使用-macros-组织代码">使用 <code>macros</code> 组织代码</h2><p>上一节提供了粗略的 类 + 类成员 的反射方案，那么如何声明它们呢？<br>答案是借助 <code>macros</code> 实现（作者不是不建议使用宏么😂…）</p><ul><li><code>__COUNTER__</code> 是非标准库的宏，每次调用增加<code>1</code>，且从<code>0</code>开始</li><li>宏展开后的代码，可看示例：<a href="https://gist.github.com/veselink1/f4e2fa94bda0514631753f13a9b93f9b"><em>refl-cpp-deep-dive-5-generated.cpp</em></a></li><li>另外每个 <code>TypeInfo</code> 和 <code>MemberInfo</code> 还应该包含如下内容：<ul><li><code>static constexpr char name[] = …</code></li><li><code>static constexpr std::tuple&lt;…&gt; attributes = {…}</code></li><li><code>static constexpr auto* pointer = &amp;Type::MemberName</code></li></ul></li></ul><pre><code class="language-c">template &lt;typename T&gt;struct TypeInfo {};#define REFLECT_TYPE(TypeName) \  template&lt;&gt; struct TypeInfo&lt;TypeName&gt; { \    template &lt;size_t, typename&gt; struct MemberInfo; \    static constexpr size_t MemberIndexOffset = __COUNTER__ + 1; #define REFLECT_FIELD(FieldName) \  template &lt;typename Dummy&gt; struct MemberInfo&lt;__COUNTER__ - MemberIndexOffset&gt; \  {}; \#define REFLECT_END \    static constexpr size_t MemberCount = __COUNTER__ - MemberIndexOffset; \  };// Usage:REFLECT_TYPE(Point)   REFLECT_FIELD(x)   REFLECT_FIELD(y)REFLECT_END</code></pre><div class="admonition note"><p class="admonition-title">Tips: 借助 VisualStudio 查看宏展开</p><ul><li>鼠标悬停在宏上，点击 <code>Expand Inline</code><img src="/images/vs-macros-expand.png" alt=""></li></ul></div><h2 id="函数反射">函数反射</h2><p><code>refl-cpp</code> 还提供反射函数的功能。</p><p>为了区分成员（是变量还是方法），每个 <code>MemberInfo</code> 有一个公共的 <code>typedef</code>，它等同于 <code>refl::members::field</code> 和 <code>refl::members::function</code> 两者之一。而考虑到 函数的重载和模板，这部分功能（相对于反射成员）会更加复杂。</p><p><code>refl-cpp</code> 通过如下方法：<font color="#FF1E10"><strong>TODO</strong></font></p><pre><code class="language-c">template &lt;typename R, typename... Args&gt;auto resolve(R(*fn)(Args...), Args&amp;&amp;... args) -&gt; decltype(fn);/*   Imagine 12 more overloads of resolve for different pointer-to-member   combinations (plain, &amp;, &amp;&amp;, const, volatile qualifiers)*/template &lt;typename... Args&gt;static constexpr decltype(detail::resolve(&amp;Type::MemberName, std::declval&lt;Args&gt;()...)) pointer { &amp;Type::MemberName };</code></pre><p>↑ 上面这段代码理解起来较为困难，我们可以将其功能拆解一下，它是为了解决什么问题？</p><p>想象类型 <code>A</code> 具有两个函数重载：</p><ul><li><code>f(int)</code></li><li><code>f(const std::string)</code></li></ul><p>当拥有一个指向f的函数指针（<code>&amp;f</code>）时，编译器怎么知道调用哪个？<br><code>refl-cpp</code> 实际会帮助编译器 推导出正确的重载函数（通过将 <code>&amp;f</code> 作为参数传递给另一个函数的方式，来直接触发函数）。<br><code>resolve</code> 没有任何定义，它只是一个 <code>prototype</code>，作用是作为编译器的一个提示。</p><p>这种方法总结起来是：<strong>传递函数性质的参数（由 <code>std::decalval</code> 产生）</strong>。它的好处是：所有的参数类型转换都适用，即我们可以通过 <code>MemberInfo&lt;?&gt;::pointer&lt;int&gt;</code> 并得到一个 <code>void(*)(long)</code> 类型的指针作为结果。</p><h2 id="遍历类的成员">遍历类的成员</h2><p>前面讲了如何创建和存储类成员的 <code>metadata</code>，这节介绍如何遍历它们（<code>compile-time</code>）。<br>核心思想是 借助可变参数模板，创建一个 <code>TypeList</code> 的类型成员列表，并提供枚举的方法。</p><pre><code class="language-c">template &lt;typename... Ts&gt;struct TypeList {};</code></pre><p>!!! NOTE 这块讲的不是很细，没搞懂…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;品读&lt;code&gt;C++&lt;/code&gt;经典反射库&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/"/>
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/C/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【cpp】Templates</title>
    <link href="http://luhao.wiki/posts/templates/"/>
    <id>http://luhao.wiki/posts/templates/</id>
    <published>2023-08-13T17:47:03.000Z</published>
    <updated>2023-08-20T18:02:09.566Z</updated>
    
    <content type="html"><![CDATA[<p>C++模板、meta-programming<span id="more"></span></p><div class="markmap-container" style="height:300px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Function Templates&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#模板基础\&quot;>模板基础</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;<a href=\&quot;#编译检查\&quot;>编译检查</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;<a href=\&quot;#参数推导\&quot;>参数推导</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#多参数\&quot;>多参数</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#函数重载\&quot;>函数重载</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;Class Templates&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<a href=\&quot;#模板特化\&quot;>模板特化</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;偏特化&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;<a href=\&quot;#模板特化-代码示例\&quot;>代码示例</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;SFINAE <font color=#FF1E10><strong>TODO</strong></font>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;std&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;<a href=\&quot;#⭐std-max\&quot;>std::max</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;#⭐std-pair\&quot;>std::pair</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;<a href=\&quot;#⭐type-traits\&quot;>type_traits::is_integral</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;<a href=\&quot;/posts/rvalue/#std-move\&quot;>std::move</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;反射 <font color=#FF1E10>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;/posts/refl-cpp/\&quot;>refl-cpp</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="Function-Templates">Function Templates</h2><h3 id="模板基础">模板基础</h3><p>下面是一个最简单的函数模板示例：</p><pre><code class="language-c">template &lt;typename T&gt;T max (T a, T b){    return b &lt; a ? a : b;}</code></pre><ul><li><code>T</code> 是定义类型的变量，它可以是 <code>int</code>、<code>float</code>、任何class…</li><li><code>typename</code> 是关键字，<code>template&lt;class T&gt;</code> 是兼容 C++98 的一种正确写法</li><li>上面有两个潜在约束：1. <code>T</code>必须支持<code>&lt;</code>操作符，2. <code>T</code>必须支持拷贝构造函数，为了<code>return</code></li></ul><p>下面是简单的模板使用实例：</p><pre><code class="language-c">::max(7, 8);          // 8::max(1.2, 1.5);      // 1.5::max("abc", "abcd"); // abcd</code></pre><p>当调用上者时，模板会自动实例化为：</p><pre><code>int max(int, int);double max(double, double);char const* max(char const*, char const*);</code></pre><h3 id="编译检查">编译检查</h3><p>模板的编译检查分为两个阶段（<code>Two-Phase Translation</code>）</p><ul><li>定义阶段</li><li>实例化阶段</li></ul><pre><code class="language-c">template &lt;typename T&gt;void foo(T t){    undeclared(); // 未定义函数，定义阶段报错    undeclared(t); // 引用了T，所以实例化阶段才报错}</code></pre><h3 id="参数推导">参数推导</h3><p>编译器会根据传入参数的类型，自动推导 <code>T</code> 的取值</p><ul><li>若引用传递：不允许类型转化</li><li>若值传递：只允许退化（<code>decay</code>），<code>const</code>和<code>volatile</code>会被忽略。引用会被转化成引用的类型。</li></ul><pre><code class="language-c">int const c = 42;int i = 1;::max(i, c); // OK: (int, int)::max(c, c); // OK: (int, int)int&amp; ir = i;::max(i, ir); // OK: (int, int)int arr[4];::max(&amp;i, arr); // OK: (int*, int*)</code></pre><h3 id="多参数">多参数</h3><p>模板允许定义多组不同的参数，以如下函数示例，其<strong>返回值的类型是不确定的</strong>：</p><pre><code class="language-c">template&lt;typename T1, typename T2&gt;T1 max (T1 a, T2 b){    return b &lt; a ? a : b;}</code></pre><ul><li><font color="#ef6d3b"><strong>返回类型推断</strong></font></li></ul><p>从<code>C++14</code>开始，允许使用 <code>auto</code> 声明函数的返回值，即让编译器自己决定。</p><pre><code class="language-c">template&lt;typename T1, typename T2&gt;auto max (T1 a, T2 b){    return b &lt; a ? a : b;}</code></pre><p>在<code>C++11</code>中，<code>auto</code>必须配合 <code>trailing return type</code> 使用，否则编译报错如下：</p><div class="admonition error"><p class="admonition-title">error: 'xxx' function uses 'auto' type specifier without trailing return type</p></div><pre><code class="language-c">template&lt;typename T1, typename T2&gt;auto max (T1 a, T2 b) -&gt; decltype(b&lt;a?a:b);</code></pre><ul><li><font color="#ef6d3b"><strong>类型萃取</strong></font></li></ul><pre><code class="language-c">#include &lt;type_traits&gt;template&lt;typename T1, typename T2&gt;std::common_type_t&lt;T1,T2&gt; max (T1 a, T2 b)</code></pre><div class="admonition note"><p class="admonition-title">Trick: C++如何获取变量x的类型?</p><ul><li><code>#include &lt;typeinfo&gt;</code></li><li><code>typeid(x).name()</code></li></ul></div><h2 id="Class-Templates">Class Templates</h2><h3 id="模板特化">模板特化</h3><ul><li>这篇中文资料说得通俗易懂：<a href="https://sg-first.gitbooks.io/cpp-template-tutorial/content/jie_te_hua_yu_pian_te_hua.html"><em><strong>深入理解特化与偏特化</strong></em></a></li><li>源码 推荐阅读： <a href="#%E2%AD%90type-traits"><em><strong>type_traits</strong></em></a></li></ul><p>模板特化的作用是，<strong>针对模板的参数类型，从而定义不同的实现</strong>。<br><font color="#ef6d3b"><strong>只要你教得好，它可以 “见人说人话，见鬼说鬼话”</strong></font><br>（有点类似 函数重载 和 虚函数继承 的思想）</p><p>模板特化实现思路是：</p><ul><li>先定义基本模板（能说话）</li><li>再针对每种参数实现特例（能见人下菜碟）</li></ul><p>下面仿照 <code>Python</code> 实现 <code>C++</code> 的 <code>type</code> 函数:</p><pre><code class="language-c">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;template&lt;typename T&gt;class TypeId{public:    static constexpr char const* type = "NULL";    TypeId(T t) {}};template&lt;&gt;class TypeId&lt;int&gt;{public:    static constexpr char const* type = "INT";    TypeId(int t) {}};template&lt;&gt;class TypeId&lt;std::string&gt;{public:    static constexpr char const* type = "STRING";    TypeId(std::string t) {}};int main(){    ::cout &lt;&lt; TypeId(1).type &lt;&lt; "\n";                   // INT    ::cout &lt;&lt; TypeId(std::string("abc")).type &lt;&lt; "\n";  // STRING    return 1;}</code></pre><h3 id="模板特化-规则">模板特化 规则</h3><p>模板特化 符合 函数重载 的两个条件之一：</p><ul><li>参数数量相同、类型不同</li><li>参数数量不同（<strong>特化只能少于等于</strong>）</li></ul><p>否则出现报错：</p><div class="admonition error"><p class="admonition-title">error: too many template arguments for class template xxx</p></div><p>示例如下：</p><pre><code class="language-c">template &lt;typename T, typename U&gt; struct X            ;    // 0 // 原型有两个类型参数// 所以下面的这些偏特化的实参列表// 也需要两个类型参数对应template &lt;typename T&gt;             struct X&lt;T,  T  &gt; {};    // 1template &lt;typename T&gt;             struct X&lt;T*, T  &gt; {};    // 2template &lt;typename T&gt;             struct X&lt;T,  T* &gt; {};    // 3template &lt;typename U&gt;             struct X&lt;U,  int&gt; {};    // 4template &lt;typename U&gt;             struct X&lt;U*, int&gt; {};    // 5template &lt;typename U, typename T&gt; struct X&lt;U*, T* &gt; {};    // 6template &lt;typename U, typename T&gt; struct X&lt;U,  T* &gt; {};    // 7template &lt;typename U, typename T&gt; struct X&lt;U,  T, T &gt; {};  // Error</code></pre><h3 id="模板特化-代码示例">模板特化 代码示例</h3><ul><li><a href="/code/refl-sum.cpp"><em><strong>refl-sum.cpp</strong></em></a></li><li><a href="/code/refl-factorial.cpp"><em><strong>refl-factorial.cpp</strong></em></a></li></ul><h2 id="std">std</h2><h3 id="⭐std-max"><a href="https://gcc.gnu.org/onlinedocs/gcc-4.9.2/libstdc++/api/a01226_source.html">⭐std::max</a></h3><ul><li><code>_GLIBCXX14_CONSTEXPR</code> 在 <code>C++14</code> 会被替换为 <code>constexpr</code></li><li>实际可以展开为：<code>constexpr inline const _Tp&amp; max(const _Tp&amp; __a, const _Tp&amp; __b)</code><ul><li><code>constexpr</code>无实质作用，重点是参数使用 <code>const &amp;</code></li></ul></li></ul><pre><code class="language-c">  template&lt;typename _Tp&gt;    _GLIBCXX14_CONSTEXPR    inline const _Tp&amp;    max(const _Tp&amp; __a, const _Tp&amp; __b)    {      // concept requirements      __glibcxx_function_requires(_LessThanComparableConcept&lt;_Tp&gt;)      //return  __a &lt; __b ? __b : __a;      if (__a &lt; __b)return __b;      return __a;    }</code></pre><!-- ### [⭐std::stack](https://gcc.gnu.org/onlinedocs/gcc-4.8.3/libstdc++/api/a01566_source.html) --><h3 id="⭐std-pair"><a href="https://gcc.gnu.org/onlinedocs/gcc-4.9.2/libstdc++/api/a01240_source.html">⭐std::pair</a></h3><ul><li><a href="https://en.cppreference.com/w/cpp/utility/pair/pair"><em><strong>[cppreference] std::pair</strong></em></a></li><li><a href="https://stackoverflow.com/a/9270585/16823597"><em><strong>[stackoverflow] What is the purpose of std::make_pair vs the constructor of std::pair?</strong></em></a><ul><li>c++14及之前，<code>std::pair</code>需要显式指定类型，<code>std::make_pair</code>不需要</li></ul></li></ul><pre><code class="language-c"> template&lt;typename _T1, typename _T2&gt;    struct pair    : private __pair_base&lt;_T1, _T2&gt;    {      typedef _T1 first_type;    ///&lt; The type of the `first` member      typedef _T2 second_type;   ///&lt; The type of the `second` member      _T1 first;                 ///&lt; The first member      _T2 second;                ///&lt; The second member      _GLIBCXX_CONSTEXPR pair()      : first(), second() { }      // ...    }</code></pre><h3 id="⭐type-traits"><a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.4/libstdc++/api/a01417_source.html">⭐type_traits</a></h3><ul><li>以 <code>is_integral</code> 为例，判断是否为整型</li></ul><pre><code class="language-c">  template&lt;typename _Tp&gt;    struct is_integral    : public __is_integral_helper&lt;__remove_cv_t&lt;_Tp&gt;&gt;::type    { };</code></pre><ul><li><code>__is_integral_helper</code> 是一个标准的模板特化，<strong>非常简单</strong>！</li></ul><pre><code class="language-c">template&lt;typename&gt;    struct __is_integral_helper    : public false_type { };  template&lt;&gt;    struct __is_integral_helper&lt;int&gt;    : public true_type { };  template&lt;&gt;    struct __is_integral_helper&lt;char&gt;    : public true_type { };  // ...</code></pre><ul><li><code>true_type</code> 相关定义如下，其<code>value</code>变量就是一个bool类型的 <code>true</code></li></ul><pre><code class="language-c">  /// integral_constant  template&lt;typename _Tp, _Tp __v&gt;    struct integral_constant    {      static constexpr _Tp                  value = __v;      typedef _Tp                           value_type;      typedef integral_constant&lt;_Tp, __v&gt;   type;      constexpr operator value_type() const noexcept { return value; }      // ...    };  template&lt;typename _Tp, _Tp __v&gt;    constexpr _Tp integral_constant&lt;_Tp, __v&gt;::value;  /// The type used as a compile-time boolean with true value.  typedef integral_constant&lt;bool, true&gt;     true_type;  /// The type used as a compile-time boolean with false value.  typedef integral_constant&lt;bool, false&gt;    false_type;</code></pre><h2 id="反射">反射</h2><p>先看看什么是 <a href="https://en.wikipedia.org/wiki/Reflective_programming"><em><strong>reflection</strong></em></a>:</p><blockquote><p><em>reflection is the ability of a process to examine, introspect, and modify its own structure and behavior.</em></p></blockquote><ul><li>通俗解释，反射就是从一个对象(<code>object</code>)，能够反推其类型、成员和方法</li><li>以<code>Python</code>为例，<code>getattr</code> 就是经典的反射功能</li></ul><div class="admonition warning"><p class="admonition-title">为什么cpp没有反射?</p><ul><li>反射会导致编译后文件过大</li><li>cpp很少用到元编程（相对于C#)</li><li>cpp有模板，足够应付大部分需求...</li></ul></div><h2 id="阅读材料">阅读材料</h2><ul><li><p><a href="http://110.42.228.178/pdf/CPP_Templates_2nd.pdf">CPP-Templates-2nd 英文</a></p><ul><li><a href="https://github.com/wuye9036/CppTemplateTutorial">CPP-Templates-2nd 中文版翻译</a></li><li><a href="https://github.com/r00tk1ts/cpp-templates-2nd">cpp-templates-2nd 中文版翻译</a></li></ul></li><li><p><a href="https://github.com/wuye9036/CppTemplateTutorial">C++ Template 进阶指南</a></p></li><li><p><a href="https://veselink1.github.io/blog/cpp/metaprogramming/2019/07/13/refl-cpp-deep-dive.html">refl-cpp</a></p></li><li><p><a href="https://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/">What Does Haskell Have to Do with C++?</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++模板、meta-programming&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/"/>
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/C/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>日志：2023年8月</title>
    <link href="http://luhao.wiki/posts/2023/8/"/>
    <id>http://luhao.wiki/posts/2023/8/</id>
    <published>2023-07-31T16:35:13.000Z</published>
    <updated>2023-08-20T13:40:55.145Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fddbb92bf2b80e397b1837b0097b45fb71c53ef8b3f4b4758a56f48de6c54e45">b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475debb79baf718116b8398ebb7a36965f5712db04a990a04196bf7d89b9188d2f59608c72ed5aa29e6fc56a5ff1b29fef766d4c0885ae8cf2dca8001db9ea7dd57171e66061d8a834aadac2d5261a378e855f619f74a4d6dbb2143558f830195ad778bbec3dcb3f658d755d1900562037e667a8aeb10ee60aaaef6c52df6297f9462edb95ad5b1ef626d83551b4a58dc951356f6585adb2fd17b3f8d279cf52c2f8d72cc91aa7ad9374c68556628b6eac552549325a74655db38d4286e3fa840b98e0408e308b794dc520706702d1e5a648710f2b0704af019ed7dc709aa8cf405ced8efaa8fdbac2203c6ce96208efe57d7e2d72fe01e3bc8e35c39f220eeb9d0568b16c7395989c8a3ffea28948b5a1c9ed00afe9b11a56b77e9874b5b6cf9645b45974eb7ed2bac3a14e1ce82e707e2522e09e4c37920fafb31e7fe5a21326d5a43bebf4eab3711053db91cc5b209b999fc80211043ad24815e9a374238d271fd3d711b65280397672cef4e4d3461cb41ba49deddc80e4f3b30c750609f0f25b59efae2fe80ebae24acb9c047b2068668259642e3e9a0f27cdc41cf311d0ebc5a24b82ba3ed0f6ccfa571b54a3e7e3a704e519f657f1ea8eb75f2fded7129096e2e1fca27e5bb2617c0a8f99466efc5f68295b7911fe3778a5ea4e16db2c84cb9839407869859b4a7191958b092862a296ec353f400476415a834b1829baaf90289616ec5ba0392f328b07c1f97aa73e9cdef0916b973a6df234dc823c3146eab5add396b126146c76b2be15463ff42c2cd0329cf34970f2a62eb963dead6b82e4a5efb4b663450a719c3e9b8da5c5cbb316f0e42e43440c4c658dc947d30eeec7e2d16b39d06193550ad8489f616a4ae717b005d705902d679aae9763195834a7e625d15d12d0a3a16ec32cc4a116a0f3ffd5509781546d00f5a0d84143f78fa6a874c25d68d4e5cbb6009c83f15082c269e2dd181de259475aad3f8ea08830502366e2367964d43afc84604f0ad96060ad46d601ddae5ee189ff904b0711180ad8a42be64d7f461743d490a388b44e3ced184f34dc6de0c3f54b738ab7f242635df50784c8230b8eab0e69d0b08deab08391b2074e65fc943767314aa1c2d43d26999c8508a027b605640d9919a9bc1686def16635bf9e385371a76a252778f862b451d5986cf360e31b71cd52a08b88c5b9ae237d43370290c0147d01a0e8cd3a53ddaf42cdb39316a4a318d6b4bf17bff1b8afe9d3898f9278171c4b3aa0533f70bf7426267192ec1f58578278d8adc15e420e7ff48cc56fdd090a3655b7a91593b587a5ed7755388b8fffdb9b7cfee3191631ef5095cafc65557a989126e3cbf276b8413a9bf8b44e6b401a1a2ba10de7d4bcd8200df8d1ab6df1c7c9b01abba1832b28a9d1854083851e9c9e73de3f25a2c95db99d1666eb71504e086d9d5dbf21963b2aed14bc22cf9187fe29cdde15e81a65b71577e16765edb7772f0083202d03e5978692211dcc204b41dab528a9ce9b663f98d457b62bd9bdcd853a926842cae283321b6eec2e1d3a335885230ffe83fec90987fccbe649959588c2fa1b100a6903534c318ba689678bf1fa13c9e9e9b4ddbd74d2dd202b23a0f6920e8bb0ff84bcf0d2dbc770ec59c175650f12fb262fdc76025a5fe0a71971bd4f337fec572dab704e3fa4fa76f716ed70eb1b48285ed83e70c7182f2c1bf1ff60b436c815bdf1ea3b1b393346054ecd4ad3be05de97b3f475e48e121d99cb6e852d40f8ebef972de62f7b5d29b34ed4458ff7fd932dae099085c0675c7815be99bdc133fde84d9414693171ae294a8acf89d55020a7b34e1849cdd4f94362c1403a019233806b1d3e5c331c3eb6972546cb7d2f9ead31e959f69f9ae60e1a8966c4f5872f86bcfaa9b96cc3012bb2267e4f5ba6a0391d4aefeb5441fa79750a41b2b04067425bc88da53342d503f70d00b7bfb2cb37cdc62606584ce93ff887ba6417435df7a68246cace15780bbaac9e8c19a197acb1c8002d807e792c3efb866034ea8c5f7a3a51837d014e889fc20c2d5b63832c4591e493fb4237310e3d68f74b693a60fa59a68305b9a43b63e2c72c421e56d9f8118d42b50e6fca51cfb0217c59269998d654af508e5cf7e971d609af8cd340582104b668b263bb8effbcee2b16626fe835b4c511daf6ab02dbce6f1ca7dfce664e7cfeb202c1dbefb8c9dda144f3450f431e58f8306076aff84369dd4f1bf65e7f7bcaad9dd9c8b5116f2aa4fad667aa76fc10163f1483d2f40d070edd4e703e75ef76995a2971b4f93544c27fa2e2a619547c10b46f2ad95cf7bbf2bdd02a497c072e616f29f12e38086b745e3d83455c729bd51c46bcca824cf50bad81adcc16bcd355677e3f1439d312058a1aff2199c555dc3222bfbd0dcb0e466b810b4717ec21fa6128d526ab2b0e6c314fa8fa86742767212e6cccb7f8a9da56b943c46000c3afa1f608b55297c88767a71e99d955414de39d472ea0f0e1c94db3c72c41d67e8ac4b4348e49530d0c9eb9be061aa158ed33827b5ba50d5bf18a63a27d9ac0fd8b6be243df94a44a1b69fada08c6da200eed89132e2d30390a236d9a7435c81d4b0943ab17c6798115c2c289dc2e48f22bbe6b0e5f4011348aa51fd3a7205056ca1fe9691db4964b9ad3d75f170470883d71b987555ef98873c0dd4a280d64807e93e7d8bff03858c9fe36ff38145d7739829d2ed1a910c9aa4828481879d4d3b9dbeb1814cd952d0a30955a8c23959851b6f0ab85bfe0d0b796d69626a7152dd9c5c6e7219e85f23070b25f30c55ca6a27e1ea126ee807acaaf68ec6a3899327fb41a58f98e4375af04c842b28da5dbf8d8cdec614b2403ec1463b14693183c28bb8f04633b4cc0fff78848b998d4c8d6d56ab433065541c0f29d3c597273fa15c011902b7ea79cbc06c2d4b73a8cc051c9fc5e6e442048efdace87bc6b97d19e3ae09d6657bba9154e8d5c7a93807baa8cfbe9406ee</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;Oh, this is an invalid password. Check and try again, please.&quot; data-whm=&quot;OOP</summary>
      
    
    
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【vscode】vim定制化插件</title>
    <link href="http://luhao.wiki/posts/vscode-vim/"/>
    <id>http://luhao.wiki/posts/vscode-vim/</id>
    <published>2023-07-23T12:04:39.000Z</published>
    <updated>2023-07-29T18:41:03.599Z</updated>
    
    <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://github.com/VSCodeVim/Vim">VSCodeVim</a> 是仿照vim的vscode插件</li><li>本文在其基础上添加一些额外的个性化功能</li></ul></div><h3 id="VSCodeVim">VSCodeVim</h3><p>vscode vim主流插件有两款，分别是:</p><ul><li><a href="https://github.com/VSCodeVim/Vim">VSCodeVim</a>：仿vim的插件，功能不全</li><li><a href="https://github.com/vscode-neovim/vscode-neovim">VSCode Neovim</a>：基于Neovim，功能较全，但依赖nvim环境且配置复杂</li></ul><p>笔者一直使用前者，因此本文全部围绕 VSCodeVim展开。</p><h3 id="缺陷-😞">缺陷 😞</h3><p>VSCodeVim Github 拥有 1.5k 未处理的 Issues，作者的维护迭代速度非常慢，因此有很多缺陷和功能不足之处：</p><ul><li>不支持 vimscript function</li><li>不支持 vim bash</li><li><font color="#FF1E10"><strong>【bug】</strong></font>经常Esc失效，弹窗报错 <code>vim.Escape is undefined</code>… 需要重装插件</li></ul><h3 id="亮点-🎉">亮点 🎉</h3><p>打开 <code>"vim.statusBarColorControl": true</code>，可以使底部 <code>statusBar</code> 跟随 vim模式 而改变颜色。<br>本文希望进而改变 Cursor 和 当前行 的颜色、高亮显示，并支持 config 配置，效果图如下：</p><p><img src="/images/vim-mode-demo.png" alt=""></p><h3 id="改进-💡">改进 💡</h3><ul><li><p><strong>支持配置 StatusBar, Highlight 等颜色配置</strong></p></li><li><p><strong>支持区分 Normal, Insert, Visual 三种模式的颜色</strong></p></li><li><p>下载链接:<br><a href="https://github.com/593413198/Vim/releases/tag/vim-mode-1.0">https://github.com/593413198/Vim/releases/tag/vim-mode-1.0</a></p></li><li><p>配置文件:</p></li></ul><pre><code>    "vim.statusBarColorControl": true,    "vim.alpha": "80",    "vim.statusBarColors.visual": "#005f5f",    "vim.statusBarColors.insert": "#5f0000",</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;导读
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/VSCodeVim/Vim&quot;&gt;VSCodeVim&lt;/a&gt; 是仿照vim的vsc</summary>
      
    
    
    
    <category term="VSCode" scheme="http://luhao.wiki/categories/VSCode/"/>
    
    <category term="VSCode" scheme="http://luhao.wiki/categories/VSCode/VSCode/"/>
    
    
    <category term="vim" scheme="http://luhao.wiki/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>随手记</title>
    <link href="http://luhao.wiki/posts/idea/"/>
    <id>http://luhao.wiki/posts/idea/</id>
    <published>2023-07-21T19:15:33.000Z</published>
    <updated>2023-08-14T17:58:14.051Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="97b3274af59e124ff830c0b5664368fdf721b53edd1012e5a6d5d84548f985d9">b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475debb79baf718116b8398ebb7a36965f5712db04a990a04196bf7d89b9188d2f5969b089300c199c887ad4490953d1810357cd375ac06e732d356d4ec27b642aa2d46c8fdf198d48a4b9620936f8c18efa99cd53c0e6c5befbd6da9ebb0e8d473ba88daf9814bf097589053470cd244c49759b29258898ae147d3b92406541ecc1426781b7f965d69488f8227468d25ace43c6b69c8a19f97354453e8ff96435fa7c142eabaa7418866597b071d73575a4fa98f09916a3b6256959c82764411afd8c8baf90fb4965fdfacbf4695b2488acf5d7f161a49b796a0b1b992232c56c8393b9705588b441acf55138be81fe973cfb15be2e79a6f99afa38481729479c286ec6a02cc951fd7f863308221e3409f3e1974680d2f02c063980d44af8e06e16848b8bd660fed16d9b5d1445f1619d498731bec635a5437f3f2dd0b389fbb52905c7c24ebbf54885173e06c7c5b2e3915335e700578626ce7eac45b801a88360b8431a63f02f909f337c51c8aca522afdfb179a032059d1b0c60d82a39c9101894591c99a69d4788c0964ffdf8c8bd340d4f4d0c40c91f0d7b04f33253a142ee29a844e5b7eca56476ebd534d90b54953c9f26a98bfd690dc70f043a224f68814d251f07166ef0cdd195c05dc74eb39f54b5345f809b762a7889cd161f77be58e0d1a2d473e983209035a731b88905105060112483e9324a6df5104a9d6be63f87da391c0963d4f09a7cab737a5ca573d7cc00e96996d16164c26f39cad48b191074aafceccb1b3d53728962bd363fbc5627a401d1e619cec7e88b364d74eb44372b771b3298a63f2ee75e774d3e77dfbd897be6acdde70394ef7580df602e0a38bce10cad68512761784e406a8013db99dd0603f12f71922b4c0096b6300d7650275d8ecb2786e40c1187ee12fd4fb1775bda1356f771b8b5a57a0bed3378dfad7dc5baad11f5881526cb7ac9ab7611d612d3c29b056a9b9bf0de347f042f4450adfc4ea792893a9036ac653c750ef496314e75ab9bba2d0cc6fbb432a6d0f3660175d4b2ad9eeec969249f0bbbbda47a5f4f7dce869e349d36873f7467f4f5ec0aa44ad792b07401cc88a8dc033e02944369446cb5b05697fe8bf6bbf65a9d346bff04820224139dfd1a1cf85deca75e794f0b832b49512771efbf8f1a0eef19813c8e81a9c512407b82da2a92ce4ff5c7498c4616570b114c4726cf5e093b6db53b0caae6b68f5c41bafd3160eb97aa989ea35ceb03a147a590f98ce818c50346ca8f47237f31af4a0cfeb0791050d948fbca28ef55ded16209f8e41edb8a9842d0ef9827896b599286592e161b849811ca388e6bf80f06961d2ea9f358183636ff61f5eec59b8ac1545fe823aa00d11178e27670035ef3bd2b9d8f471ca1d586eec438333b06b5fc4108afbf9f7944b8e3d322f9080ca0b7257758b2afa40fc4d13c8d7f981ef5695731074e28a121caf34662a362ae542b924e7d4fd9ceae3b9fa8e2156b05a39f3097052cb253621faf9b116c4036437439ec93b0b62c96bf2919ef9ad9253db93e51b547212058a17ae92375a14a55c772414c4522f55a3ef5efdeb323b24c79caa9357d59432b46a8573d1493361c7c3590e11bb944e909a82ddc36bf88270aeae872ca68dfe902569a78f619b1adb34b97df39eeffb28a5014b262ec15a7ed4bebb1b7f2460ceda958ff9a7de6a055c36de7dbe157c0525ba2e49875514a08865a7a718a47c8a33a8eb7d47d7f3a4d64ebda713869f43b091edfa61119340049ca058007dd9905e1cc2965a213a563431740a7102aac4e0a994a8e9a940ff8dc13e0c45ff1a51a04224bac0b622b1dd70b405b4050db4461ffabbdcb3ea261b7a472e18505cfdb68b66bfa1e27083b8c3c13607300fd56b4a27f0cd5ef639af34fbfeb0efd525cc23fcdbec7c41d22200f013fc7ae0e12bb3b4f5097232b15478fdbe6123c2c57c5103580cb7f658f88c2fef06b6f95cd263e9b8efdff49ba91912030d3dcb27186e876b79c55a7d858c879ced8f072df33819cb630a99d257c12908716bf5641cee7f6194f99d50b48bf8f89a313966f1444bb912ece43df34b7d076ddadd04196cddb3a91e66e6087e8f45627d2a079cb965614c87013a5c72dc3eb9bb4ead78c8d1731c6a6ec05c3c3df91531183798efc466bb311e25c69c8eccdcbc01d9988bb464bf5fce429d571caaa21955f9edfe44ede26630953d2435425e61f24a70cf49102abd5bb9214225f69386c2c95b7979d5229a20d297de7c7868295ca0acbc0231fc8dac08bf5406b8ee577d2e149a87a97feda2e744bd178b37f08700dc7a3ad0f0ec4931472a967e48665fb734bfce821d359eb03fa8ce1a71fb3631b151e449073a58c9cdb11e8a00b7561fffa36adb40edaff25ed6f18b146238b350fea5bfe68c44b6d3371f8e4c86eabee6495898c28c6fc39559860856313745c4b39bc2a01e82f0cab968733f206a603d192013a8be40d62b477810bcda312ab9aa5776ed3473a97a8f3997855b4b79cec7279a5682d14884cc6248576e0a71e3da135c4ec8724f71d7b06577bf0cb7e966cfe4471d37fb036984a7b009a29aef0bcd3895fcd5f07525e7d491e25c9e780b7326483f7c21afe885f107131ee9ca7dc92d4d6b59d9fcf6abaa10585a6bf751c8bd689d490e9c8ff97835323c668d9ba245b927eae9a6b3177b043f607119550e419a2bbcdcf0a986701ca14dbad99d73fc81ee268eff8e72d99808084674afdb4fb85fb80fd97f22e133498a507accb9f4874a765e5ac5c2e0e47c20e79024456b8095e492fed0473bef96d448aaf792d3345ca87c7083d3f5403b4d3248e50e1d821c5457d81e7506e0cc1947d85cacbf5b8bf1cf05be2b6c146299b84f1a9353ad7c631265d788671b71d1566ebcace6f8ae3e7836fdb14b5733ebe7325d37eeca274c8e128b2d8afbc759dcf20ca02fbccbb4769edf7c0e557b145f1f9a5f9ff138fb39aff43683d7ed57fe10273069f4f3dc7154e4a30eb0fe46e65e0ac4e9ccc9e736a8a2af677db27adb58b60cf4c7248fc82c7224bc0bcd1a9cce4e5e53108c34664b647c0371796ab9d9a8aff79dc3a9260a090d5594cee5fba116b8f17702211ba61dba5569bd148e4f9f3bdf1d79be05cbc391e35cbe5efcd993d3598ddf98a7705049a7f33615e2058b2c817f5320170bcc9dceacaf5de7f1cd6d250c8ea202bd2e76f6d4398f8bb134683ff43f630f606abec6e9b0d1afcda6435bfc232f15fecf0e93ecb9ffb7beb00aa8809dc6f728a12d8d8e2a73c0721c090fe197a7d2c9a82f2b5bf1388c3389f16fc0484e1c6b6587aec6a0f901699ff4320531447fd91adeb30ec99f71241ec6b2a7992414a6f4725cd24f67b5215118c2908e7300bcd74447aaad4184bfe76fd8745d76024dc03e77dd13fee09d5206ab5d99bfaa1e2b9065a49f27ff9ad259b0e05699cc885f0814aae8783b91eebc04774db8867aa018e66f9689a65ad73c01b3edb3a2e924e83f397fd449a669b25593f11f4f6e7738208cdc40c4ee97aa10f01c59ca11428df34e92ebaab91f2fb688989b88400d894299b7f8edebb2ec04234bd3f419c66e01785905662e74d6139bc67d5472ad88900e7dffa19f6d7213f7e5e0ac959cea7d1a41effca6b1cd739fa84e4d8f7dfe2432bdaa83f225282787a92e873235e06510d44225a66fc723fdd8778d36d48bb42c9f02f74068881db80f7466f5901fbdd4ed0d3857e5f987425527f9269454f1495a11e5bcbf49ba88ed0ad22b4e15c72e7a5ab8c12e8bc245e1cc10a3c4d2c402ccabcf611b713078c234f3a4fafa9699b5d7d2e85e426515495a36e18872de9ee0e664ca807be324c24ce7b956ccc438e8ce250599959fcbcedb4e0b8ecf709c3ec098e3e57b43af40e96c20c77f7110e46b0b050aaa4bc42f5f71298440244cef61cab7acb5fe43615017b162543382f1663940e565f39821225f7786238a349dcc903bc3395a4c3241e6d696f6d8ed7339563e8ab261443eae67b7154b1238c93434b3e7d95fd1ecae1b06aebe78a52c7c40ebd81a50081c4e30d2abd5b563d0d789449f48f23c43e8bdc66f5d40a3a0d1cfa331025e7a444334538e2acc8ef62f62d0dee33894d26b895429da5e6d4963d58c59e836911f65116cc55dd10f543c3b37ea3e50f0575e278f35968f767388b896d0214f1e28cebb1ef02c7517629935a29f9248bafea8c8fc1868ab3aeeb3760c840b800f34f79d3d36eff7021599d842d814176e74cef86284c8d3e8ae631257650e20796c3b35b5e4dc6155ef75464f99510b73f43cec90eeb5cfd10af1a6c486b70a4d37fd0ee9c6dedb15ab418df602348ceff776af60e167dd68b5d1e7d36c008ef91bfa315ce60da8bc45ac62c7308e1f72ed434333bd24c9d7793dbdd0e867c96679ebe5f4fdbe87acc5dd9b552601cb2aeb09f9dd9c1bb3bde713640d04cf68a603ae05179c4aa3676497ed19d4fa4adfd809e13f899d022555b165775c2ff1c85ac805eae6fa3a3d09d047e3dd7c0e72aaad8c452d216e3bd0584c81d38e325116d2614e4cb6d6a4a97e214aa5e69101522377eedb66e104f3fde3c63f2af22912d15ac40c78e539138ef8173dd3cecc7c65eb9c412050965fe98a1c70bab93ffa41a83bdf2e4f7cc597f4165c7c4e6944d993846e5033510f5612e6926b0dabffcf6a08f027541740fc819712d85ffdde7a77ec18b1cf902b200c9ad604536b569811cc31158e4f4986f1a972d34736c5579c30417c04dfa4c4deb97d18ecef466e658512536e3dd36335b619966585773488c7ec3dc9eb2d73</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;Oh, this is an invalid password. Check and try again, please.&quot; data-whm=&quot;OOP</summary>
      
    
    
    
    <category term="随笔" scheme="http://luhao.wiki/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="随笔" scheme="http://luhao.wiki/categories/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>【表达技巧】跟罗永浩学演讲</title>
    <link href="http://luhao.wiki/posts/talk/"/>
    <id>http://luhao.wiki/posts/talk/</id>
    <published>2023-07-09T16:52:35.000Z</published>
    <updated>2023-08-16T17:17:05.401Z</updated>
    
    <content type="html"><![CDATA[<p><code>罗永浩15堂演讲私教课</code>学习总结<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li>B站视频：<a href="https://www.bilibili.com/video/BV1PP411T7fv">【演讲】罗永浩15堂演讲私教课</a></li><li>知乎：<a href="https://zhuanlan.zhihu.com/p/619973080">【学习笔记】罗永浩演讲私教课</a></li></ul></div><h2 id="前言">前言</h2><p>开这篇是因为近期，有一个在公司内部分享的计划。<br>因为不是技术类型的讲座，技巧因素占比就会很低（而技术分享更注重将东西解释清楚）。所以萌生学习这类演讲 + 表达技巧的念头。<br>认识罗永浩，最初是 6个亿 的负债梗，更深入的是在 脱口秀大会 作为嘉宾时期的发言，对其有几个认识：</p><ul><li><p><strong>听感</strong>：表达清晰连贯，但嗓音条件恶劣（据本人调侃是老太监音色）</p></li><li><p><strong>逻辑</strong>：知识涉猎广泛，且临场反应迅速（后者是幽默感 + 经验累积）</p></li><li><p><strong>内核</strong>：善于制造一句<strong>核心话题</strong>，并反复洗脑callback（如脱口秀的“大局观”，如演讲课的“因为大脑就是被这样设计的”…）</p></li></ul><h3 id="关于这个教程">关于这个教程</h3><p>基于罗老师 <strong>“演讲都是有套路和技巧”</strong> 的观点，将其演讲课的套路总结如下三点：</p><ul><li><p><strong>为什么要这样?（赢得认同）</strong></p></li><li><p><strong>如何达到这样?（方法论）</strong></p></li><li><p><strong>举例、类比论证（深入人心）</strong></p></li></ul><h2 id="十三个要素">十三个要素</h2><p>这些技巧比较多，难以短时间记忆和掌握，因此先记录一下核心观念，剩下的在实践中掌握和理解。</p><div class="markmap-container" style="height:350px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;让观众听下去&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<strong>讲笑话</strong>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;吹牛逼&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;装逼&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;让观众容易理解&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;讲故事&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<strong>作类比</strong>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<strong>三段式</strong>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;提问题&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;具有说服力&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;有逻辑&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;有数据&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;让观众产生共鸣&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;有激情&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;有情感&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;<strong>升华境界</strong>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;核心&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<strong>有画面</strong>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h3 id="精华摘要">精华摘要</h3><ul><li><p>开始一场演讲的最好方式，就是<font color="#ef6d3b"><strong>讲笑话或讲故事</strong></font>。（千万不能讲道理）</p></li><li><p>对于晦涩或陌生的事物，要<font color="#ef6d3b"><strong>巧用类比</strong></font>，如 谈判就是找交集。</p></li><li><p>开始主体内容前，用<font color="#ef6d3b"><strong>三段式</strong></font>介绍提纲。（思维导图）</p></li><li><p>讲故事的三要素：冲突（吸引注意力） + 行动（故事的发展） + 结局（表达的内涵）</p></li></ul><h2 id="其他技巧">其他技巧</h2><h3 id="1-用坐标系描述事物">1. 用坐标系描述事物</h3><p>举例，如何看待 <strong>“量化交易”</strong>?</p><p>首先，一个交易策略的评判标准有两个维度，分别是：</p><ul><li>Interpret：（金融底层的）解释能力</li><li>Predict：（金融市场的）预测能力</li></ul><p>因此，引入一个二维坐标系，甚至可以类比不同事物在其分布，例如：</p><ul><li>进化论：能解释为什么猿猴进化到人类，但无法预测人类未来进化的趋势</li><li>地心说：能预测太阳东升西落，但底层科学原理是错的</li></ul><p><img src="/images/interpret-predict.png" alt=""></p><p>最后，根据 量化交易 预测能力强，但无法自圆其说的特点，可以将它放在类似进化论的位置。</p><p><strong>该方法论可以让听众直观清晰地了解事物的多维度特征。</strong></p><hr><h3 id="2-结尾升华主题">2. 结尾升华主题</h3><ul><li><p>几天过后，观众未必会记得你讲了什么，但他们或许能从情感上认同你。</p></li><li><p>这很大程度上，来源于结尾的几句升华。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;罗永浩15堂演讲私教课&lt;/code&gt;学习总结&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="http://luhao.wiki/categories/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="随笔" scheme="http://luhao.wiki/categories/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>【cpp】Memory</title>
    <link href="http://luhao.wiki/posts/memory/"/>
    <id>http://luhao.wiki/posts/memory/</id>
    <published>2023-07-04T17:01:35.000Z</published>
    <updated>2023-07-22T13:03:25.859Z</updated>
    
    <content type="html"><![CDATA[<p>C++的内存分配与管理<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li>理论偏：<a href="/posts/virtual-memory/">【CSAPP】Virtual Memory</a></li><li>本篇结合 C/C++ 了解内存分配相关领域知识</li><li>ptmalloc，tcmalloc，jemalloc ...</li></ul></div><div class="markmap-container" style="height:300px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;malloc / free&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;new / delete&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;system-call&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;<a href=\&quot;#brk-sbrk\&quot;>brk / sbrk</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#mmap\&quot;>mmap</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;c-malloc&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#ptmalloc\&quot;>ptmalloc（glibc）</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;tcmalloc（google）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;jemalloc（facebok）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;mimalloc（microsoft）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;c++&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;std::allocator&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="malloc-free">malloc/free</h2><ul><li>阅读文档：<a href="https://en.cppreference.com/w/c/memory">cppreference: Dynamic memory management</a></li><li>使用的时候多查阅文档，注意 <code>malloc</code> 使用时要判断 <code>NULL</code> 避免内存分配失败</li></ul><pre><code class="language-c++">#include &lt;unistd.h&gt;void *malloc(size_t size);void *calloc( size_t num, size_t size );void *realloc( void *ptr, size_t new_size );</code></pre><ul><li>分配过程：↓</li><li>需要考虑字节对齐，注意被释放后的内存也可能重复利用，这也解释了为什么野指针的 <code>undefined behavior</code></li></ul><p><img src="/images/malloc-demo.png" alt=""></p><h2 id="new-delete">new/delete</h2><p><a href="/posts/virtual-memory/#u-class-black-mallco-free-u">malloc / free</a> 前面有介绍过。</p><p><strong>以 <code>A* a = new A</code>为例，通过 <a href="https://gcc.godbolt.org/">godbolt</a> 查看汇编代码，发现其有两段逻辑组成：</strong></p><ul><li>调用 <code>new operator</code></li><li>调用 <code>class's constructor</code></li></ul><pre><code class="language-asm">call    operator new(unsigned long)mov     rbx, raxmov     rdi, rbxcall    A::A() [complete object constructor]</code></pre><p><strong>相应的 <code>delete</code> 方法，也对应如下的两段逻辑：</strong></p><ul><li>调用 <code>class's destructor</code></li><li>调用 <code>delete operator</code></li></ul><p>下面重点展开对 <code>new / delete</code> 两个操作符的学习（推荐阅读 <a href="https://www.programiz.com/cpp-programming/operators">C++ Operators</a> 和 <a href="https://en.cppreference.com/w/cpp/language/operators">cppreference operator overloading</a>）</p><p><strong>先看 libc 的 <a href="https://codebrowser.dev/llvm/libcxx/src/new.cpp.html">源码实现</a>，可以看到是对 <code>malloc</code> 的一层封装。</strong><br>如果类自定义了 <code>new /delete</code>，则优先调用它们。</p><pre><code class="language-C++">void *operator new(std::size_t size) _THROW_BAD_ALLOC{    if (size == 0)        size = 1;    void* p;    while ((p = ::malloc(size)) == nullptr)    {        // If malloc fails and there is a new_handler,        // call it to try free up memory.        std::new_handler nh = std::get_new_handler();        if (nh)            nh();        else#ifndef _LIBCPP_HAS_NO_EXCEPTIONS            throw std::bad_alloc();#else            break;#endif    }    return p;}voidoperator delete(void* ptr) noexcept{    ::free(ptr);}</code></pre><h2 id="System-Call">System Call</h2><p>程序中的内存分配有三个层次，如下图。<br>最终调用的还是Linux/Windows中的操作系统API：如sbrk, mmap… 因此需要重点掌握这些系统调用。</p><p><img src="/images/memory-call.png" alt=""></p><h3 id="brk-sbrk">brk, sbrk</h3><blockquote><p><em>change data segment size</em></p></blockquote><p>参考阅读  <a href="https://www.cnblogs.com/sylar5/p/11508821.html">cnblog: brk 和 sbrk 区别</a></p><p>linux man 手册中描述两者的作用是改变 <code>data segment</code> 的结束地址。<br>通俗地理解就是，<code>brk</code>函数会重新设置 <code>heap</code> 的高位地址，而 <code>sbrk</code>函数会根据大小来调整 <code>heap</code> 的容量。</p><p>两个函数的定义如下：</p><pre><code class="language-C++"> #include &lt;unistd.h&gt;int brk(void *addr);void *sbrk(intptr_t increment);</code></pre><h3 id="mmap">mmap</h3><blockquote><p><em>map (or unmap) files or devices into memory</em></p></blockquote><pre><code class="language-C++">#include &lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags,            int fd, off_t offset);int munmap(void *addr, size_t length);</code></pre><h2 id="ptmalloc">ptmalloc</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++的内存分配与管理&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/"/>
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/C/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>日志：2023年7月</title>
    <link href="http://luhao.wiki/posts/2023/7/"/>
    <id>http://luhao.wiki/posts/2023/7/</id>
    <published>2023-06-30T16:23:22.000Z</published>
    <updated>2023-08-07T16:19:29.048Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0851a0368b387b9bfd1f7d1594c7eae2a82ee3ac45ebf15175c78bf0da59da97">b3dc07a81f6459d120ce338ccca550463faa708b9b4d89df9ab14ba4edd809f60b32d15b5672ce84c5d84744f7f475debb79baf718116b8398ebb7a36965f5712db04a990a04196bf7d89b9188d2f59608c72ed5aa29e6fc56a5ff1b29fef766d5ea38b7aab101c2c288cc8d47a1ddb98f58e3ebed46e51710844af238f638a595dcac39d4bda5ded8547aa673d0beeca805102f4562a781f12cdc07d2da448e4ebf47133795728ca1d580628672d374c763017902d054d929efa4c3aee95334f067071686413aed6fbc1c0d418e93aa3bcb387a92a042cfa05b807fe267b5ba62c20a2f048c31c3b7091c6bfd48e1bbdf52156047e2f8b07cc4a7df940b8fef50a435e591511689fcf8d2d5faafbabd0527fcb5da530c6230f1fa703e6716f23890796df860502732d5f6a1cea25acc2e1bc11a51504d36fdd945bce963514e161abf4cec44c03159e11f9038e237289e9d8281c702e61576f2f90f375a12a819e4286e7c31c3bb74514a6925ee85eca1529d6abdd7538e15c4bd1fc3fd1f3ebff6ac9483c9dfce5b7b0eccabc593db99c4822ca51a2378436fcf09fdad42d29ff50482e9d0eb1b58dadea5fa9f50b79855fd26c4b19f49d191e8c2aab60a2e1a436859f97a44935946f841150d27050f2903a09341a4a8cf9ad0138efa26d1c815137b28364ad5ed2b4a1ff9fe16eb21147a6a004b01f2403a1a0085ba3db57dfe4654b751e00925b9d369286309ba339d22f2dddb796ead59f80055f73298232520397531f0b0bf705b21554ea101a48ae5198f596e98687394f595cb88f6dee6cf78552aa85c806a0a8159ad13cbaeabe70aae83809f31eade9f489579c6a060c007c51f55e25f3efe4c96a995ca0f4021d2c4e4440c6e09b16160c085b5b23dc7b78be18c8976f0be7ed1e97c28be99e78fcd804bd5506b100a863f874f936bc9ed0b78aac30391272c90e7d1d316b6e5c2cc5f1eed1893662cb50797b1d4b808eeeb26daadad35aabeceb2fdfdd8f3be439a15a66581b665403960b81732cbb50ddf30180c7375d28c085245e3a2cadd3b2d476254386ac8b145a5aaff957ffed6c48dba81df88bb3382b402af47ea8680eb1fe397d3bb86d8b229a9748bfd6a62751b933916745ab9b5a6a9e773e52a4d4071bbcc2e57efa8556864abb615fc4e253fc4ebf85f1caf87972a49b45ee2517d46b10098ccfe32a315a4e0b47488a4724c74e25a09f2f4ee2967d96b393e885bb43f3a82d36843b27a51d9656f20d41770672b81c2e7b3da43e172e55ff0979c9bdf1025f6ddd49ad4af161eea013373b3cf15a20468117c1193013fe3bf6db061118a23a0050afdc5fb085393904249490314b1628e1dfe03f37072e7ba62e793d34bd62fd6f64c799eb289e2208cc202709291d15df54bdfb21f389b168c0f3e02e373d8c751be8e61ec2f1a067a1ba484704dc9c9811dea65853c08781728678cabd4b6cbd900710b0efc505729f7c46b7e460e170f2fa94e9074029e9f6f6ef812557fbb56bcbebfec0e7b9b6634f2a18879de02211e08fa0399cd8774dfdd1fd1955ec71252e0d53df0acd78629e25f744aa6f60252d65d659c040506ce1575b77a5873e09d6a3c637493a04e75580aaf4ffe018fb783edbc83e439794e861ffab9b4d2c9d9b3cb35d58ff7325563ebb045ef75509072d74494e140e0a50f0c02487562fb6287259f07251e539cda2b3895bdad3cdbd023b8779fc0493dc3fe460563cff17d403f99d77a8828c301fb4a673bce167d4937ef27c9f9dcff8e350bc7c04c6abab0d9ae0c4b50a1280ecff99136e4630850a0a283668f6f7a163dbbc5d2bad3bdf260c0c830bdee9e5544c667b5841c9e61d439950b737215db4115bf937dbd188d8abe942c27bdb222dabad08c7d5411d1d33f64b48a2cacfcc74976f93c48c7be58619b24e03f73e0ae71ddd8d9aa3cba8bd5241c901ccbb12047c71df2f1e0f1d8c32b6fbb77079595043e084d71302e670c2c93d5c3dbfac2bb55fd167be16ec2a74adbdffb67689b15bce66a86311136613f7c99ecebd9e46c8b2089e9ce1af7985c3dada61c7f6465192afea33e9693b3b4f750f1c734b959ab9c4e9ee1b884fe587cf7a85870296dad165b34248e76a1aab7a6e29c81561757aef5d293dc52f6f280705c880fb6b86c9e3cb78e6eafab6b717b5670108af7ae4f54ef294e37a35fa85c3f222fd86c258f527908cf424ed2b4e0157871288f709a37900b01a328960d19a4f82637d1571e9bb0d8c7cedc536a6288b33d3a7a4c1914fbd4946cce2209cb735a3e86f82d100d3f3e0ada4de54f1a8b1a4503faea8645b502aee40fb7e0f4a972c5ecd020d00b3ef50deaed2d91418684b7c0c9cee51dbc616861db3992c8be405dd83981022b68b5ddabe3930545b07acea0bfa328def7212adfbdfdb3e2a29b30d8ecae02b08cf0a1e37053c3533fba1d8c214a3a4bf6f6bf768028d5e39af030d42a561e908b6a8adb0870dc59164c6b41eebd6f7cd339047ab3115eb107904d0e869330b8b2ffaa8b07b2a8729871cb589505754bb5d5a8fafbd49c1b210f5591c68f71f166fef3a030eb2d7f3c7b889d398953fdfa85c5a522dae6a699be1eba275739811d6185901a96d74796fd8e2169dc2763bf66683a1564afc2662bf0da774c0f3ad3040b6c9a3b71495e7f7fb2af8baec4432394cfaebae134cecf5903339f4082a7f719532e441fe971cc4f63e23420710a78970362d3ca4f95aac85b62976bb256b2dafe1a81cd4a905973d12b7d9fe80b55dffb5ec11a7f091a10c088fe7b24ca48f3a1adbc64eb5b238420f121b1acc6c4c8cee8625e9b26bfec714553d92b501633b893ee9497d6299c1cd0e1732e3cb3c81775326a622ce31bac61ade3a8d4c188dc5964cbc5187ded1de93a5050726e1d9431f4253ee3d6f8c589d304e66d5b6c275a8b9de7a66c717d98fa5491026ef813fb52417c68a30893b792900520f4533dbcdc5e92b4864957167918ad9781db9181bd90e1f30c58750d5c631c1870d8afe445da4f9e65494985cb2f61ec69a82edb3cf1527d7c07824a62649aac69d7c4fbc5a2fe03e4372a52cef7200d7d012d8e0be071467579d24a817ac5d9bd24b12473ce9d92297384e44ac719eb9c104bf356052de42f123899d850b46a8f3a790dbdaaf2d05560890e3a3d880669538307b7525ca3361609c356bcbd8316d113af68b238582799278bf2b05ff931df04fd8edf741a5d6aa1b6dd5bbeb2532b43c6299130fbe1e60cecbeff951a11f5cc8e3c5ceda6b972a52e5b99ddc0844c20fa96773c6c31a8180e4e2042a9331b440305c6053ce0ff5cb945b42b603ca3c44557288e0760a9d1e367b0ecfe47e9cb0be7a4f3821d1f9bf8ce0084d442c19a144417cf2641027647b9af5dbdfc0d246ffbdbbb1ccd272702035da0120809a713188f544ee7177ef356dd0f7f90664af7994ca49f7fcd53508380b5c074cb829271df0d9f2dc9694d59b08d60eb036c2fb125bdda82a353881a860134c734afea74432376e1e0e8050cc312cb8fc7b614f9e4a2cf2084cffb694045f6a80c687ffe4a05b9f729027117f24e96bbfac5bb1fcb70380fbd849e7db7f35da3b294070868c15e327c7f9b973b3b125a7da178eaca670c38ecc36cfa1bf30e09c9716f4013648129f30e5ba577bd2bd5d6b782fca8820d51ecb8b58fd0099325a5b6dd8f5e92159905ada98825a90c6f2f1435a68644fa3f2e12ce85cc4f95e7d7fbd157a6c60f2923ac5325e0dc99dd56267772016b7e8dcdd31b837899aa02999811f617c8938edf1770d7a282347aa0675aff22c16ce5aac49bce8ce09da67f600cc620d094b5c9001b8dcbad4316bdd5a7c5e7342a370c6272d554ab6483bd2b5ff3b50f170a8184937a41de33da575d35daba03896316323534f1d616c0f745d03405130da3ff4edaee6bc65a05da28795c69b941b5da634d4628113b85201779d48cafe9a7cf05d401ec4e2d95abb7ad7ffe2b5d739ab653f381c942af01cc93101749094673d1da7959ed6a3a4c058dcf7df7aeac52d2e51fec89e3e2f6821ad97073631943568425072bf7ddb1d6626570730a6ef615e987ef70001fcfe22fc75377390369ff8746e9fa689968518d1951b9ed544af5ac5642715fff081cc3192572d5409b00d32d39fb224f78cb39477fb711443a415aa98547b8d3508ccfda42e41f5a786a82e6a56eb6ff5f4317d2413a4a1f8f0d59a078cca5b99e97b9c7e824cc9547e6c90ca2febb33edb407e230ab0fdabad15d869d617ef2c36c90dcb4b1a322972ec87ed4e7fcefc8644ad5821d8aab57a94adef417a6ae5a7da91f04c589c16d51b4fdcce19f4573e5821cbd50cdae4e13c23b22628c81c2743e1aec6d94bbc8af4c65082463c0767fe9ee4aee334de605126c3fe04cdeac70768cb5312aaa81d873b7ab8e10917bfa321f677dbc7f61bec01ec32469c78d1afe8e085b86437439ed615e6fe2641a05cb41f69e917d90c775a2f9e39d506a6a6f540ef0ae2d4f954cfb1070445407592967dbdc4a15b84ecf8d61f9c675b844c49d8221600aa09140692777def80bbcd4d56fd18701e60ed67c8c044ebbcfe8f2279b3b74e8ecbc51cecfe8594d0945df93d68b17d2ec78f48e9870fef5eea32f6b50563a828f630ee83aa507109cb20457b6b42d5ce5f3357f179b90a939e36fd32be5c8c4f3a76235e8d89df99d4ac755afd14b14d102c2fba8aedb6743bc942e2468069e437a6c593dc0a147cd375dc68934ba3fcaf725ce186f69fff739e8f8a6c89c82559a2f1115f0b93028d37baa54a482a97d6f426edf678229042dcf806d747514b8d86b690adeef4eb178dc9b345035a030bb834821c1c064b69306f57765a39e022c9abcf19c2da3533bcdd30b77a97ad3ca44fe8388ea54f1b1ed6d46be660ebd51715f605644c9375fc50733aa7dae481691241e6dd54cca1c47f468289a8f0838377849d9189a1ae8a8350c823c720fe40e7ffc1ca2e2411c772a3509b76b5f85596b1454d4e3422f8918fd4383c7020fc791f03fd850c37209ad301f0b0fb536d3e0a6cbee4d19b03f5a03bf92cf64778b76cc60ea6918094261d5f5a60e455f0cf7b84655677918b4cc722387be25d786865ec2a1b9f75c25eff52b534dcea4dc8b09a63394432c939b7ac38f3276bfc220803eb2f3c9460d7c6412fdc04c748602749b25addb1a4c9f6709d2a2935fa2f74e56bffecbeedbc645a7c9b77c13d79ca23ed866c46875ccf1918386c6d83b20ed86b7dcb7e1b040b753c73e2ad3921f05a399ad67ec7a9df630e1a2ae8ff74ea5e00dff6f2dfce3b1c8646d5f947181843a69b82df3f15cebd7168c87976bc598e1058636f4af23c280092a735820403590a6c065854653e6e12772037e8f221d8e48fb1a30f9e909c6b2e3e6ce4bdc808616d232ce88acf8f9a837d100f618a8e3fa0c7227ccda3cf88e02d66b7d2c430b1252f78267132c8927bdae7bc84953b5c271b64d8e81aebb202c79b6cc526dafdee92da4af6356fb54071c26ec25aa2086e59cb1183172e093b84612f938997c9d5d1036718792e5f291b2b36c2dc832524c7db54745aca1a829845a80ed631989339607776965518f89465a89a4342e4465717af858212d79a933775907de7aac428d5efb78bf354117f2ab54cfad82d0b5a744babc0dd2b87f1a8e4cbf96bcfb665c335588c1d22cdfaa3852bef3c91a13286764c0ba44c72cc37345731cb1e642bba556b2bfba771b99661f954d22c5e437752930eb11490647a2b26afb7a23f1a07316a51c8def4b57c70cea01c1a69fb482e7700e488459cc1293442f6b26e1ca933cd30322c6aca178f8e9f88b06a75358aaa87a2037aa51ec94a5ca7fc5373bb1694c59febdd78c1dd1b1daec60e29712fd393ffe4e8f659568c9a4e6caf8c70a59a259c157052323e083c47c465bbf333cd393d18cbb3467c6ee8ec6acd0feb53b3923005f563d5e703b3555a8e8f415411a8e67d6f49697cf7f9e49012d4c4b8311ca9f429c74cce655d0703b4020787633705f860c7c6d47956d377e770df3f316956c8859e526b40e8d5f61c5782153916efe1f4fc646cce2a7ce0dcaf6d32ed9410029ee0622da4ca5981ec49d88f3bdc8f86801871a6d76cbcfd9ab85c033ad0aca4925bd885e2ea6026a6ef9f211bd18833296ae0e6a982cce2d16b5452594b419695fdb7ff8fe633540e67ce9ebe369fe6d45324069a404f7af2c0c787e15b214cc3fc628f74432b012328dd93ecf150c7770875f55b5f1d5cf871be9ebe1db7875dc3a5080684672e3ebafbc3ab37fa1901eb986400cb96f3b3817667cd626a6c46616969a15c1c78b6124c678a1dba521e16cba513521d12398013c70f76a3c887a20212a85ca34d54e0d1e8c63cf1e0345d0d1d45d2096e08d722214a6cef7b7bfd4671e6b1416f6694e795bc19e7dc827d861588ecda82710f38d7f3306ae56562591e08b701a803cda99fca9408b3395fbba9407d149aa59aa1ea53d1d1618a67c4cd59fed13e23f9365c4bbad1f009712aceeae566425987db32e59f1cb80bc1861977dbdda87476a0d328ecf830d431fc33b23a09c8f86e3c3467bc91cc8eddd60bc3c0309a961b02532a462f7966460c923b8baa236091b116023c927c501ae78473aae12555c55b39f97741dc32cb2ac11cd6e7547da7f95a3a34bb97767a6a90dd5337c2ce9951f4a43dad32a8864a1b2e24e7a18447ee3a026f4b161030dcb8ef514a725f38a0609cff84a704a72f7f1f5a5474a4f4d85ef87813a11ba86655bb421988e5e788e59c92feaeb8697603a3d67a218acfa20f4e11d0c8ff23868da856fb2ea2a58f431e195ad5db2a86cc4e11a72e0da34a37627d30e40c911c8003736eddd6ca566eee05916f2acc10fc6d55440962f78094777e4023b81b4f8eea9e782c94f4aed27423ea62b4c5b21274f447a1f63aebb9f118d4bcaf77cb82365c4537ea6fa84262d9683151ec86e101f0995d7131543eada2ae0e2e18157ac7c82f2253ff44986ef3abb2483e00e5662284f92296dfc479d6c9e6f070c7689c0118f4c5f1dc1a48542f00eb5eae67f91bdcc675b38fb13251a05421412001d2da0f3f25d99a8759683ee1e0dfc651ffc262df1fbcfcea3ae8c3379ee79cca7d91ef196cc047c8179619ad6cc4791371ef92b377e63b66be402458adb9da94684953e864e4ef44dca8bf82e699395d5cb15175806961b82dbd73ff37a78b739a700f59e41383cd1364dec38474525c7c51a52cabb7983042836af3f2534bf684ad106bde36aad56</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;Oh, this is an invalid password. Check and try again, please.&quot; data-whm=&quot;OOP</summary>
      
    
    
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="vim" scheme="http://luhao.wiki/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Google评分卡💯及自评</title>
    <link href="http://luhao.wiki/posts/grade/"/>
    <id>http://luhao.wiki/posts/grade/</id>
    <published>2023-06-27T16:40:51.000Z</published>
    <updated>2023-08-16T17:08:18.021Z</updated>
    
    <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li>Google将技术能力划分为 0~11 的等级</li><li>自我评估技术，判断下一步需要作出的努力</li></ul></div><h2 id="↓-Self-Evaluation">↓ Self-Evaluation</h2><table><thead><tr><th style="text-align:left">↓ 基础要求</th><th style="text-align:center">grade</th></tr></thead><tbody><tr><td style="text-align:left">熟悉数据结构与算法</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">熟练使用 C++11</td><td style="text-align:center">3</td></tr><tr><td style="text-align:left">熟悉并掌握 C++高级特性 (14/17/20)</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟练使用 Python 等脚本语言</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">熟悉batch、Shell、Linux常见指令</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟悉MySQL等数据库的设计、优化</td><td style="text-align:center">0</td></tr><tr><td style="text-align:left">熟悉编译原理、编译优化</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟悉 vscode、sublime、vim 等IDE、Editor</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">熟悉 Jenkins、TeamCity 等 CI&amp;CD 平台</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">熟悉 ChatGPT、CodeMaker 等 AI工具</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟悉Linux内核，如进程管理、内存管理、文件系统等</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟悉网络协议和网络编程，熟悉websocket、HTTP、socket、TCP/IP等</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">↓ <strong>C/C++领域</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">内存管理、内存分配、ASan原理、内存错误及排查</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">模板、SFINAE、type traits、metaprogramming</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">并发、memory order、同步、互斥、boost::asio</td><td style="text-align:center">0</td></tr><tr><td style="text-align:left">编译优化、SIMD、ISPC、CPU性能分析</td><td style="text-align:center">0</td></tr><tr><td style="text-align:left">C++编码规范</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">↓ <strong>Python2/3领域</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Todo</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">↓ <strong>工具/pipline领域</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">Jenkins 日常工作使用，无阻碍</td><td style="text-align:center">3</td></tr><tr><td style="text-align:left">VSCode 日常开发使用、多个插件开发经验</td><td style="text-align:center">5</td></tr><tr><td style="text-align:left">Vim 熟练使用、vimrc配置</td><td style="text-align:center">4</td></tr><tr><td style="text-align:left">Git 基本的GUI、CMD操作</td><td style="text-align:center">2 ~ 3</td></tr><tr><td style="text-align:left">↓ <strong>加分项</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">具备内存优化经验、熟悉linux内存分配</td><td style="text-align:center">1</td></tr><tr><td style="text-align:left">熟悉GPU使用，或有底层基础库（CUDA，mkl、openblas等）优化经验</td><td style="text-align:center">0 ~ 1</td></tr><tr><td style="text-align:left">良好的系统设计能力，如 performance、reliability、availability 多维度考量程序</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">熟悉机器学习平台相关工具，比如k8s，kubeflow，mlflow，automl等</td><td style="text-align:center">0</td></tr><tr><td style="text-align:left">有视频解码和渲染开发经验者优先</td><td style="text-align:center">2</td></tr><tr><td style="text-align:left">有存储系统、分布式系统等底层开发经验</td><td style="text-align:center">0</td></tr></tbody></table><br>## ↓ Google-Standards<table><thead><tr><th style="text-align:center">等级</th><th style="text-align:left">标准</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:left">You are unfamiliar with the subject area</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">一窍不通</td></tr><tr><td style="text-align:center">1</td><td style="text-align:left">You can read/understand the most fundamental aspects of the subject area</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">理解基本概念</td></tr><tr><td style="text-align:center">2</td><td style="text-align:left">Ability to implement small changes,understand basic principles and able to figure out additional details with minimal help</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">能够实现一些小改动，在别人帮助下钻研更多细节</td></tr><tr><td style="text-align:center">3</td><td style="text-align:left">Basic proficiency in a subject area without relying on help</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">基本掌握和熟练使用</td></tr><tr><td style="text-align:center">4</td><td style="text-align:left">You are comfortable with the subject area and all routine work on it</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">足够精通，足够应对所有日常工作</td></tr><tr><td style="text-align:center">5</td><td style="text-align:left">An even lower degree of reliance on reference materials. Deeper skills in a field or specific technology in the subject area.</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">深耕某个细分领域</td></tr><tr><td style="text-align:center">6</td><td style="text-align:left">Ability to develop large programs and systems from scratch</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">独立开发大型系统</td></tr><tr><td style="text-align:center">7~10</td><td style="text-align:left">脚踏实地慢慢来吧…</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;导读
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;Google将技术能力划分为 0~11 的等级&lt;/li&gt;
&lt;li&gt;自我评估技术，判断下一步需要作出的努力&lt;/li&gt;
&lt;/ul&gt;
&lt;/d</summary>
      
    
    
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
    <category term="vim" scheme="http://luhao.wiki/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>【网络】HTTP协议进阶</title>
    <link href="http://luhao.wiki/posts/http/2/"/>
    <id>http://luhao.wiki/posts/http/2/</id>
    <published>2023-06-26T12:51:27.000Z</published>
    <updated>2023-07-01T17:08:49.171Z</updated>
    
    <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE">专栏：透视HTTP协议</a> 墙裂推荐 ⭐</li><li><a href="/posts/http-1/">HTTP协议入门</a></li></ul></div><div class="markmap-container" style="height:500px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;HTTP数据编码&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#MIME-type\&quot;>MIME-type</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;&amp;quot;Accept&amp;quot;&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;&amp;quot;Content-Type&amp;quot;&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;HTTP大文件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;数据压缩&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;chunked传输&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;HTTP连接&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;短连接&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;长连接&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;<a href=\&quot;#队首阻塞\&quot;>队首阻塞</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie\&quot;>Cookie</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie原理\&quot;>Cookie原理</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie生命周期\&quot;>Cookie生命周期</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie作用域\&quot;>Cookie作用域</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Cookie应用&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie应用：身份识别⭐\&quot;>身份识别</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;#Cookie应用：广告追踪\&quot;>广告追踪</a>&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP代理\&quot;>HTTP代理</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;<a href=\&quot;#代理字段\&quot;>代理字段</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;<a href=\&quot;#代理协议\&quot;>代理协议</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;<a href=\&quot;#负载均衡\&quot;>负载均衡</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;Cache&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;<a href=\&quot;#Cache：浏览器\&quot;>浏览器cache</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;<a href=\&quot;#Cache：服务器\&quot;>服务器cache</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;<a href=\&quot;#Chrome调试\&quot;>Chrome调试</a>&quot;}],&quot;p&quot;:{}}"></svg></div><h2 id="HTTP数据编码">HTTP数据编码</h2><p><font color="#FF1E10"><strong>todo</strong></font></p><h3 id="MIME-type">MIME-type</h3><p>使用svn更新的时候有一栏会标注 <code>Mime type</code>，可以观察到除了常见代码文件外，都是以 <code>application/octet-stream</code> 格式传输，它代表未知的二进制数据。</p><p><img src="/images/svn-mime-type.png" alt=""></p><h2 id="HTTP大文件">HTTP大文件</h2><p><font color="#FF1E10"><strong>todo</strong></font></p><h2 id="HTTP连接">HTTP连接</h2><p><a href="/posts/http-1/#TCP">前面说过</a>，HTTP协议 是运行在 TCP/IP协议 之上，因此每一次新的HTTP连接，都需要经过TCP协议的 <strong>“3次握手 &amp; 4次挥手”</strong>，这无形中降低了HTTP协议连接的代价。</p><p>因为 TCP位于传输层，HTTP位于应用层，所以可以用如下的类比来理解连接的代价：</p><ul><li>开关机：TCP连接</li><li>使用电脑办公：HTTP连接</li></ul><p>每次使用电脑办公，都需要打开电脑，在使用完毕后又需要关闭电脑。这就好比 <strong>HTTP 短连接</strong>。而更常规地做法是，保持电脑的始终开启，这样利于随时使用，这就好比 <strong>HTTP 长连接</strong>。</p><p><img src="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/assets/57b3d80234a1f1b8c538a376aa01d3b4.png" alt=""></p><h3 id="Connection字段">Connection字段</h3><p>当HTTP请求采取长连接时，在响应报文的 “Connection” 字段会标记为 <strong>keep-alive</strong>，此时服务器不会在短时间内断开连接，但是为了降低服务器的无效占用，Web-Server 往往会在一段时间内若没有任何数据收发，便会主动断开连接，断开后会收到 “Connection: close” 的字段。</p><h3 id="队首阻塞">队首阻塞</h3><p>因为 HTTP协议 采取 “一问一答” 的模式，即典型的 <strong>FIFO</strong> 结构，当队首的请求因为处理太慢而耽误时间，那么队列后面的所有请求也会相应地被阻塞，这就是 <a href="https://en.wikipedia.org/wiki/Head-of-line_blocking"><strong>Head-of-line blocking</strong></a>。</p><p>类比理解为：食堂排队打饭，每次刷卡是一次 Request，每次领到饭是一次 Response，每处理完一次成对的 Request-Response，队伍才能往前推进一步。只要前面打饭的慢了，后面所有人都会受影响。</p><p>解决方案是：并发连接，即增加打饭的窗口。这里不详细介绍。</p><h2 id="Cookie">Cookie</h2><p>前面说过 <strong>HTTP连接 是无状态的，即没有任何记忆</strong>。即使某个请求会让服务器出现500的错误，下次请求时服务器依然会 “热情招待”。这迫切得需要一种缓存的机制，Cookie应运而生。</p><blockquote><p>Cookie 是服务器委托浏览器存储的一些数据，让服务器有了“记忆能力”</p></blockquote><h3 id="Cookie原理">Cookie原理</h3><p>Response报文中，<strong>利用 <code>Set-Cookie</code>字段发送多个 “key=value” 形式的 cookie值</strong>，这些会由浏览器负责记录下来。当浏览器下次访问同样的地址时，Request报文会自动利用 <code>Cookie</code>字段将本地缓存的 cookie 发送给服务器，这样服务器就知道自己的身份了。</p><p>因为 Cookie 是与浏览器绑定的，如果你换个浏览器或者换台电脑，就会丢失之前的 Cookie记录，此时服务器也会重走一遍新的 <code>Set-Cookie</code> 流程。</p><h3 id="Cookie生命周期">Cookie生命周期</h3><p>Cookie拥有自己的生命周期，它通过 <code>Expires</code> 或 <code>Max-Age</code> 两个字段实现。当超过标记的有效期后，浏览器会自动在本地删除记录，不会再通过HTTP请求发送给服务器。</p><ul><li><code>Expires</code>：记录“过期时间”，如 <code>Fri, 07-Jun-23 20:00:00 GMT</code></li><li><code>Max-Age</code>：记录“保质期”，单秒是秒。将浏览器收到相应的时间加上 <code>Max-Age</code>，即得到 <code>Expires</code></li></ul><h3 id="Cookie作用域">Cookie作用域</h3><p>浏览器会存储大量的Cookies，因此需要标记其作用域，即发送给哪个服务器或者URL，常用字段是：（不清楚的推荐阅读 <a href="/posts/http-1/#URL">HTTP协议之URL</a>）</p><ul><li><code>Domain</code>：域名</li><li><code>Path</code>：路径</li></ul><h3 id="Cookie应用：身份识别⭐">Cookie应用：身份识别⭐</h3><p>登录taobao等电商网站时，浏览器会自动保存你的登录账户（或密码），就便是利用cookies实现的。它同时还会记录你的浏览记录和购物车。</p><p>大概格式为：<code>name=xxxxx....</code></p><h3 id="Cookie应用：广告追踪">Cookie应用：广告追踪</h3><p>当你浏览各种网站时，它们会根据你的访问喜好作行为分析，然后定向推荐一些图片广告给你，这就是利用cookies的原理。<br>这部分成为 “第三方Cookie”，属于搜集用户隐私的行为，浏览器经常会弹出确认框以请求权限。</p><h2 id="HTTP代理">HTTP代理</h2><p>传统的HTTP请求是 <code>Client-Server</code>，现在常常有“第三者插足”，即在中间会引入一个 <strong>代理服务器（Proxy Server）</strong>，它的角色是双面的：</p><ul><li>面对上游：充当客户端，发送请求</li><li>面对下游：充当服务端，响应请求</li></ul><div class="admonition note"><p class="admonition-title">类比：消费者（浏览器）—— 便利店（代理）—— 源服务器（批发市场）</p></div><div class="admonition note"><p class="admonition-title">定理：计算机领域的任何问题，都可以通过引入一个中间层来解决</p></div><p><img src="/images/proxy-server.png" alt=""></p><h3 id="代理字段">代理字段</h3><p><strong>代理服务器 通过字段 <code>Via</code> 标明代理的身份</strong>，在HTTP请求的链路中，每当报文经过一个代理节点，代理服务器就会将自身的信息追加到 <code>Via</code>字段的末尾。<br>另通过如下字段标明其他信息：</p><ul><li><code>X-Forwarded-For</code>：追加代理的域名</li><li><code>X-Real-IP</code>：客户端真实IP</li></ul><p><img src="/images/proxy-process.png" alt=""></p><h3 id="代理协议">代理协议</h3><p>针对代理的HTTP请求，<a href="https://www.haproxy.org/">HAProxy</a> 公司推出了专门的代理请求协议，The Proxy Protocol。<br>其基本格式为：开头必须是“PROXY”五个大写字母，然后是“TCP4”或者“TCP6”，表示客户端的 IP 地址类型，再后面是请求方地址、应答方地址、请求方端口号、应答方端口号，最后用一个回车换行（\r\n）结束。</p><pre><code>PROXY TCP4 1.15.115.4 110.42.228.178 32200 80\r\n</code></pre><h3 id="负载均衡">负载均衡</h3><p>当一个区域所有的消费者，都蜂拥而至一个批发市场购物，就会造成堵塞排场对的现象。<br>因此 “负载均衡” 的解决方案是，在每个居民集中地地区设置一个小商超，或者经销商，而自己只负责货物的批发和调配。消费者 择近择闲 选择小商超去购物即可。</p><p><strong>通过中间的代理服务器，将请求均匀合理地分散到多台源服务器</strong>，能够有效提高系统的响应速度和利用率，这就是 负载均衡 的基本原理。</p><p>而如何挑选转发的服务器，有如下的思路：</p><ul><li>哈希：如尾数单号的去A服，尾数双号的去B服</li><li>轮询：对于新请求，分配一个最空闲的Server去处理</li></ul><h2 id="Cache">Cache</h2><div class="admonition note"><p class="admonition-title">两句话讲清楚Cache</p><ul><li>浏览器Cache：消费者家里囤（上次买的）货</li><li>服务器Cache：小商超囤（上次卖的）货</li></ul></div><h3 id="Cache：浏览器">Cache：浏览器</h3><p>当浏览器频繁每秒请求同样的数据时，如果服务器不厌其烦的依次发送，会造成很大的性能和流量浪费。因此需要客户端（即浏览器）的缓存。</p><p><strong>一个带Cache的HTTP请求流程是：</strong></p><ul><li><p>浏览器检查cache，若有则直接读取，若无则发送新的HTTP请求；</p></li><li><p>服务器响应请求，并返回资源，同时标记资源的有限期；</p></li><li><p>浏览器接受请求，并缓存资源；</p></li></ul><p>而<strong>标记资源的有效期字段是 <code>max-age</code></strong>，即cache的生存时间（秒），过期则被浏览器自动销毁。<br>其他常见字段有：</p><ul><li><code>no_store</code>：不允许缓存，如一些高频的秒杀字段</li><li><code>no_cache</code>：使用缓存前，检查是否有最新版本</li><li><code>muster-revalidate</code>：不过期则直接使用缓存</li></ul><h3 id="Cache：服务器">Cache：服务器</h3><p><font color="#FF1E10"><strong>Todo</strong></font>，与HTTP协议关系不大，可以了解 Redis、Varnish 等缓存技术。</p><h2 id="Chrome调试">Chrome调试</h2><p>Chrome浏览器提供了丰富而强大的调试功能，按下 <code>F12</code> 或者右键点击“检查” 以进入调试页面。</p><img src="/images/chrome-http-debug.png" height="400">]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;导读
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%</summary>
      
    
    
    
    <category term="Network" scheme="http://luhao.wiki/categories/Network/"/>
    
    <category term="Network" scheme="http://luhao.wiki/categories/Network/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>Computer Networking</title>
    <link href="http://luhao.wiki/posts/network/"/>
    <id>http://luhao.wiki/posts/network/</id>
    <published>2023-06-22T12:18:00.000Z</published>
    <updated>2023-06-26T17:48:59.056Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络大纲，HTTP/TCP/UDP…<span id="more"></span></p><div class="markmap-container" style="height:425px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Network Model&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;TCP/IP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;OSI&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Protocol&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;HTTP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;/posts/http-1/\&quot;>HTTP协议入门</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;/posts/http-2/\&quot;>HTTP协议进阶</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;TCP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;UDP&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;KCP&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;Web Server&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;Apache&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Nginx&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;Performance&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;RPS：每秒处理数&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;TPR：平均响应时间&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;Concurrency：并发量&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;Tools&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;Telnet&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;<a href=\&quot;#/posts/2G7VBZ2/#curl\&quot;>curl</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;wireshark&quot;}]}],&quot;p&quot;:{}}"></svg></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机网络大纲，HTTP/TCP/UDP…&lt;/p&gt;</summary>
    
    
    
    <category term="Network" scheme="http://luhao.wiki/categories/Network/"/>
    
    <category term="Network" scheme="http://luhao.wiki/categories/Network/Network/"/>
    
    
  </entry>
  
  <entry>
    <title>【网络】HTTP协议入门</title>
    <link href="http://luhao.wiki/posts/http/1/"/>
    <id>http://luhao.wiki/posts/http/1/</id>
    <published>2023-06-21T16:15:09.000Z</published>
    <updated>2023-07-01T17:08:46.323Z</updated>
    
    <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE">专栏：透视HTTP协议</a> 墙裂推荐 ⭐</li></ul></div><div class="markmap-container" style="height:480px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;HTTP&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;<a href=\&quot;#Hypertext\&quot;>Hypertext</a>（html）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;text&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;media&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;hyperlink&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;<a href=\&quot;#Transfer\&quot;>Transfer</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;client&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Chrome, Edge&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;Telnet&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;server&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;<a href=\&quot;https://nginx.org/\&quot;>Nginx</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;<a href=\&quot;https://httpd.apache.org/\&quot;>Apache</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;CDN（内容分发）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;<a href=\&quot;https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\&quot;>负载均衡</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;加速访问&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;<a href=\&quot;#Protocol\&quot;>Protocol</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#TCP-IP\&quot;>TCP/IP</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;<a href=\&quot;#IP\&quot;>IP</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;<a href=\&quot;#TCP\&quot;>TCP</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;<a href=\&quot;#DNS\&quot;>DNS</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;<a href=\&quot;#域名解析\&quot;>域名解析</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;<a href=\&quot;#DNS缓存\&quot;>DNS缓存</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;<a href=\&quot;#URL\&quot;>URL</a>（网址）&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;<a href=\&quot;#URL\&quot;>示例⭐</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP抓包\&quot;>HTTP抓包</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;wireshark&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP报文\&quot;>HTTP报文⭐</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;start-line&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;headers&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;body&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP方法\&quot;>HTTP方法⭐</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;GET, HEAD&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;POST&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP状态码\&quot;>HTTP状态码</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;<a href=\&quot;#HTTP特点\&quot;>HTTP特点</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;.&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;.&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;可靠传输&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;明文传输&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:4,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;无状态&quot;}]}]}]}],&quot;p&quot;:{}}"></svg></div><h2 id="HTTP协议">HTTP协议</h2><p>HTTP 协议是 <a href="https://en.wikipedia.org/wiki/HTTP"><em><strong>HyperText Transfer Protocol</strong></em></a> 的缩写，它是一种用于超媒体信息传输的应用层协议，是互联网通信的基础。</p><p>如何通俗地理解 HTTP协议 呢？</p><div class="admonition todo"><p class="admonition-title">如何理解新概念?</p><ol><li>任何技术思想，在现实生活中都能找到映射</li><li>巧用 “类比” 的手段</li></ol></div><h3 id="Hypertext">Hypertext</h3><p>在互联网早期，传输的信息只有简单的字符文字，即 <code>Text</code>。随着信息爆炸式地增长，网络需要传输的信息被扩展为 图片、音频、视频等等，这些就是超文本。<br>超文本的核心是 <a href="https://en.wikipedia.org/wiki/Hyperlink">超链接 Hyperlink</a>，通过互相引用而形成复杂的网状信息结构。</p><h3 id="Transfer">Transfer</h3><p>HTTP 是一种 <code>Request-Response</code>协议，即将信息在 A、B 两个点之间双向传输，因此有两类参与方：</p><ul><li><code>client</code><br>http请求的发起方，通常指浏览器（如Chrome、Edge）</li><li><code>server</code><br>http请求的接收方，又称为 <code>Web Server</code>，如 <a href="https://nginx.org/">Nginx</a>、<a href="https://httpd.apache.org/">Apache</a> 都是常见的服务器框架</li><li><code>CDN</code><br>client和server之间通常不会直连，而是经过 <code>CDN</code>(<a href="https://en.wikipedia.org/wiki/Content_delivery_network">Content Delivery Network</a>) 这个中间商。它能够实现安全防护、负载均衡等常见功能。</li></ul><h3 id="Protocol">Protocol</h3><p>HTTP 是众多网络协议中的一个，先理解什么是协议?<br>以毕业生签署的“三方协议”为例，参与对象是多元的（自己、学校、企业），同时协议还会规定各方需履行的义务，以及该做什么和不该做什么。因此协议的核心要素是：</p><ul><li><p>多方参与<br>client、server、中转者…</p></li><li><p>通信规范<br>如规定 <code>Get</code>、<code>Post</code> 的请求报文格式，如请求的错误处理等等</p></li></ul><p>在 HTTP 的发展历程中，也经历过很多大版本的迭代，如 <code>HTTP/0.9</code>、<code>HTTP/1.0</code>、<code>HTTP/2</code>、<code>HTTP/3</code>等等。</p><h2 id="TCP-IP">TCP/IP</h2><p><a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">TCP/IP协议</a> 是整个互联网的标准通信协议，它实际上是一系列协议的统称，其中最核心的是 TCP 和 IP，这里篇幅有限只作简单介绍。</p><h3 id="IP">IP</h3><p><strong>IP协议（<a href="https://en.wikipedia.org/wiki/Internet_Protocol">Internet Protocol</a>）主要解决寻址和路由问题</strong>，它提出 <strong>IP地址</strong> 的概念来定位互联网上的每一台计算机。因此可以将其类比为电话号码，而整个运营商的拨号系统就是一个 IP协议。</p><p>IP协议又分为 IPv4 和 IPv6，大部分仍在使用前者，即IP地址是4个用冒号分割的数字，例如 <code>1.15.115.4</code>。之所以出现 IPv6，是因为v4分配的地址已经捉襟见肘，不够整个互联网的使用。</p><h3 id="TCP">TCP</h3><p><strong>TCP协议（<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission Control Protocol</a>）是一种 传输控制协议</strong>，它基于 IP协议 之上，提供可靠的、字节流形式的通信，也是HTTP协议得以实现的基础。</p><p>之所以了解TCP/IP协议，是因为HTTP运行在前者上，因此又称为 <code>HTTP over TCP/IP</code>。</p><h2 id="DNS">DNS</h2><p>在TCP/IP协议中，通常使用纯数字的 IP地址 来标记计算机，这非常不利于用于的使用和记忆。<br>因此 <strong>DNS（<a href="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System</a>）域名系统</strong> 应运而生，它使用具有实际含义的名称来替代IP地址（即英文+数字的组合，也可以是汉字），例如：<code>95.211.80.227</code>是IP地址，<code>nginx.org</code>是其域名，两者指向的是同一个web服务器。</p><h3 id="域名解析">域名解析</h3><p>以 <code>www.apple.com</code> 这个域名为例，当用户尝试访问该域名时，会经过至少3次的DNS域名解析服务器：</p><ul><li><em>Root DNS Server</em>：管理 <code>com</code>, <code>cn</code>, <code>net</code>等顶级域名的IP地址。</li><li><em>Top-level DNS Server</em>：管理 <code>apple.com</code> 的IP地址。</li><li><em>Authoritative DNS Server</em>：管理 <code>www.apple.com</code>的IP地址。</li></ul><h3 id="DNS缓存">DNS缓存</h3><p>目前全世界有 13组 <code>Root-DNS-Server</code> 提供顶级域名的解析服务，但因为全世界的网民都在请求，会造成系统的拥挤并降低访问速度，优化手段之一就是利用 <em>DNS缓存</em>。</p><p>当你已经访问过 <code>www.apple.com</code>，操作系统就会在某个文件（如下↓）<strong>缓存解析后的IP地址</strong>，这样下次访问时，就不再需要经过 DNF解析服务器了。</p><ul><li>linux: <code>/etc/hosts</code></li><li>windows: <code>C:\WINDOWS\system32\drivers\etc\hosts</code></li></ul><h2 id="URL">URL</h2><p>通过 TCP/IP协议 加上 DNS 的组合，我们实现了访问互联网中任意一台机器，但是每台机器上的资源仍然有很多，如何对他们加以区分呢？</p><p><strong>URL（<a href="https://en.wikipedia.org/wiki/URL">Uniform Resource Locator</a>）含义是 统一资源定位符，即俗称的网址</strong>，如下是其组成格式：</p><p><img src="/images/URI.svg" alt=""></p><ul><li><code>scheme</code>：指定http、https、ftp等协议<ul><li><code>file</code>：本地文件</li><li><code>ftp</code>：文件传输</li><li><code>ssh</code>：加密登录</li></ul></li><li><code>://</code>：约定俗成的分隔符</li><li><code>user:passwd@</code>：明文身份信息，已被弃用</li><li><code>host:port</code>：省略端口会用默认值，如 HTTP 80，HTTPS 443</li><li><code>path</code>：资源的在主机的路径，也可能是服务路径</li><li><code>?query</code>：查询参数</li><li><code>#fragment</code>：仅浏览器使用，用于锚点跳转</li></ul><h2 id="HTTP抓包">HTTP抓包</h2><p>“纸上得来终觉浅”，我们通过在windows下快速搭建一个最小化的HTTP模拟环境，借助抓包工具 wireshark 来对 HTTP 的细节一探究竟。</p><blockquote><ul><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/07%20%20%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%EF%BC%8C%E6%90%AD%E5%BB%BAHTTP%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.md">搭建http本地实验环境</a></li><li><a href="https://zhuanlan.zhihu.com/p/82498482">知乎: Wireshark抓包指南</a></li></ul></blockquote><p>在启动本地web服务器后，尝试在浏览器输入 <code>127.0.0.1</code> 访问该server，然后按下回车，wireshark抓包（限制<code>http/tcp port 80</code>）抓包的结果如下：</p><ul><li>前三个包：TCP协议的 “三次握手”</li><li>中间四个包：HTTP协议发送了一个 <code>GET /HTTP/1.1</code> 的请求报文，Server回复OK</li><li>后四个包：HTTP协议发送了请求 <code>/favicon.io</code> 的请求报文，Server回复404</li></ul><p>通过http抓包，基本清楚了http协议的工作流程，<strong>核心是 “Requst-Response”，即 “一问一答”的模式</strong>。</p><p><img src="/images/wireshark-http.png" alt=""></p><h2 id="HTTP报文">HTTP报文</h2><p>通过wireshark也可以清楚看到http请求发送的报文内容，其全部由 ASCII文本 组成，非常容易肉眼阅读。</p><p>HTTP协议的 requet报文 和 response报文 的组成机构基本相同，由三个部分组成，每个部分由一个空行 “CRLF（0x0D0A）” 隔开:</p><ul><li>请求报文</li></ul><div class="markmap-container" style="height:220px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Request-line&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;Method&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;URI&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;http-version&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;Request-header&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Key-Value&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;eg. Host: 127.0.0.1&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;eg. Connection: keep-alive&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;eg. User-Agent: xxxxxx&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;Request-body（空）&quot;}],&quot;p&quot;:{}}"></svg></div><ul><li>回复报文</li></ul><div class="markmap-container" style="height:180px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Response-line&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;http-version&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Status-code&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;200：成功&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;404：查找失败&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Reason（描述原因）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;Response-header（同上）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Response-body&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;eg. name=luhao&amp;amp;password=1234&quot;}]}],&quot;p&quot;:{}}"></svg></div><ul><li>报文示例<br><img src="/images/http-request.png" alt=""></li></ul><h2 id="HTTP状态码">HTTP状态码</h2><p>既然 HTTP协议 采用 “一问一答” 的模式，那么响应报文内应该包含请求的结果信息，即状态码（Status Code）。<br>目前 RFC标准 规定状态码是三位数，即取值范围是 000 到 999，其从设计之初也有具体的含义区分：</p><ul><li>1xx：提示信息</li><li>2xx：成功<ul><li>200 OK</li></ul></li><li>3xx：重定向</li><li>4xx：客户端请求报文错误<ul><li>400 Bad Request</li><li>403 Forbidden</li><li>404 Not Found</li><li>408 Request Timeout</li></ul></li><li>5xx：服务端内部错误<ul><li>500 Internal Server Error</li><li>502 Bad Gateway</li></ul></li></ul><h2 id="HTTP特点">HTTP特点</h2><p>作为本篇的收尾总结，HTTP协议可以概括为三大特点：</p><ul><li><p>可靠传输<br>注意，“可靠”只是确保 Request方 的必定传输，由于一些网络原因未必能确保 Response方 的成功接收。</p></li><li><p>明文传输<br>HTTP报文的所有信息都回暴露在 “光天化日之下”，HTTPS协议实现了加密版本的HTTP传输。</p></li><li><p>无状态<br>区分于 TCP协议 的状态，HTTPS协议 是没有状态的，即 “没有记忆能力”。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;导读
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%80%</summary>
      
    
    
    
    <category term="Network" scheme="http://luhao.wiki/categories/Network/"/>
    
    <category term="Network" scheme="http://luhao.wiki/categories/Network/Network/"/>
    
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【GAMES101】Shading</title>
    <link href="http://luhao.wiki/posts/shading/"/>
    <id>http://luhao.wiki/posts/shading/</id>
    <published>2023-06-13T15:42:19.000Z</published>
    <updated>2023-07-01T17:10:20.591Z</updated>
    
    <content type="html"><![CDATA[<p>Lambertian、Blinn-phong、shading-tech<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101 Shading</a></li><li><a href="https://www.cs.ucr.edu/~shinar/courses/cs130-spring-2012/schedule.html">CS130 Shading</a></li><li><a href="https://www.cs.toronto.edu/~jacobson/phong-demo/">WebGL demo</a></li></ul></div><div class="markmap-container" style="height:300px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;Factors&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2],&quot;f&quot;:true},&quot;v&quot;:&quot;光源&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[2,3],&quot;f&quot;:true},&quot;v&quot;:&quot;平行光&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4],&quot;f&quot;:true},&quot;v&quot;:&quot;点光&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[4,5],&quot;f&quot;:true},&quot;v&quot;:&quot;聚光灯&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6],&quot;f&quot;:true},&quot;v&quot;:&quot;相对位置&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7],&quot;f&quot;:true},&quot;v&quot;:&quot;距离衰减&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8],&quot;f&quot;:true},&quot;v&quot;:&quot;角度（Lambert’s cosine law）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[8,9],&quot;f&quot;:true},&quot;v&quot;:&quot;材质&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[9,10],&quot;f&quot;:true},&quot;v&quot;:&quot;Ambient&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11],&quot;f&quot;:true},&quot;v&quot;:&quot;Diffuse&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12],&quot;f&quot;:true},&quot;v&quot;:&quot;Specular&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;Shading-Reflection⭐&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[13,14],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#font-color-750000-Lambertian-Reflection-⭐-font\&quot;>Lambertian</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[14,15],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#font-color-750000-Blinn-Phong-Reflection-⭐-font\&quot;>Blinn-Phong</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Shading-Tech&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[16,17],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#1-Flat-Shading\&quot;>Flat</a>（poly）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[17,18],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#2-Gouraud-Shading\&quot;>Gouraund</a>（vertex）&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#3-Phong-Shading\&quot;>Phong</a>（pixel）&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;Shading-Normal&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[20,21],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#1-顶点法线\&quot;>Vertex-normal</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[21,22],&quot;f&quot;:true},&quot;v&quot;:&quot;<a href=\&quot;#2-像素法线\&quot;>Pixel-normal</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="Shading">Shading</h2><p><a href="https://en.wikipedia.org/wiki/Shading">Wikipedia: Shading</a><br>维基百科对于 shading 的定义非常清楚，即对3维场景中模型 <strong>着色</strong> 的过程，且着色的效果取决于如下几个因素：</p><h3 id="1-光源">1.光源</h3><p>推荐阅读：<a href="https://learnopengl.com/Lighting/Multiple-lights">LearnOpenGL</a>，<a href="https://www.cs.ucr.edu/~shinar/courses/cs130-spring-2012/content/Lecture12.pdf">CS130-Lecture12</a></p><ul><li><p>Ambient lighting<br>环境光照，即使在最黑暗的情况下，存在一些微弱的光亮使得物体呈现出一些颜色。</p></li><li><p>Directional lighting<br>平行光，也称作天光，在固定的光源方向上无任何衰减。</p></li><li><p>Point lighing<br>点光，向四周照射，随距离衰减。</p></li><li><p>Spotlighting<br>聚光灯，呈一个锥形范围照射，随距离衰减。</p></li></ul><h3 id="2-相对位置">2.相对位置</h3><ul><li><p>距离关系<br>光照强度一般随 <strong>距离的平方</strong> 衰减，$ ~ I / r^{2}$</p></li><li><p>角度关系<br>根据 <a href="https://en.wikipedia.org/wiki/Lambert%27s_cosine_law">Lambert’s cosine law</a>，$\vec {n} * \vec {l}$ （结合后面的 Lambertian Reflection 理解）</p></li></ul><h3 id="3-材质">3.材质</h3><ul><li><p>Roughness<br>粗糙度越高，镜面反射能力越强，典型代表如镜子。</p></li><li><p>Metallic<br>金属度越高，漫反射越弱。</p></li><li><p>Translucent<br>具有透光属性，如典型的 <a href="https://en.wikipedia.org/wiki/Subsurface_scattering">SSS</a>。</p></li></ul><h2 id="Local-Shading">Local Shading</h2><p>现实中的光照，需要考虑各种直接光、间接光的反射、吸收效果，想要在图形引擎中模拟它们非常不现实。因此一些大佬提出局部的着色算法，以模拟 <strong>一个独立点的shading计算</strong>，这里统称为 local-shading。<br>我们需要了解 <code>Lambertian Reflection</code> 和 <code>Blinn-Phong Reflection</code>。</p><h3 id="font-color-750000-Lambertian-Reflection-⭐-font"><font color="#750000">Lambertian Reflection ⭐</font></h3><p><strong>Lambertian模型</strong> 一般用来模拟 diffuse光，核心影响分别是：距离、角度。<br>距离基本的衰减关系，前面讲过了。角度根据 <a href="https://en.wikipedia.org/wiki/Lambert%27s_cosine_law">Lambert’s cosine law</a> 计算得一个光照强度的系数，其中 $max(0, n \cdot l)$ 表示任何大于90度的夹角，光照强度都为0。</p><p><img src="/images/lambert-shading.png" alt=""></p><hr><h3 id="font-color-750000-Blinn-Phong-Reflection-⭐-font"><font color="#750000">Blinn-Phong Reflection ⭐</font></h3><p><strong>Blinn-Phong模型</strong> 在前者的基础上引入了 <strong>Ambient 环境光</strong> 和 <strong>Specular高光</strong>，它是一个叫<code>Blinn</code>的教授拓展了<code>Phong</code>的光照模型，其计算方式分别为：</p><ul><li><strong>Specular</strong></li></ul><blockquote><p>$L_{s} = K_{s}(I/r^{2}) max(0, n \cdot h)^{p}$<br>引入一个 <strong>半程向量 $h (=\frac{v+l}{|v+l|})$</strong>，实际含义为入射角和观察角的二分之一夹角。此时衡量 $h$ 和 $n$ 的接近程度，即点乘 $n \cdot h$（<code>Phong</code>模型选取的是 $cos(\alpha)$，$\alpha$是夹角）， $n, h$ 越接近 则点乘值越大，则高光越强烈。<br><br>其中的 p 衡量 <strong>高光随夹角的衰减速度</strong>，p值越大，则呈现高光的范围越小（如下图）。</p><ul><li>p = 5 … 10：塑料</li><li>p = 100 … 200：金属<br><img src="/images/blinn-phong-demo-all.png" alt=""></li></ul></blockquote><ul><li><strong>Diffuse</strong></li></ul><blockquote><p>同 Lambertian模型</p></blockquote><ul><li><strong>Ambient</strong></li></ul><blockquote><p>$L_{a} = k_{a}I_{a}$<br>环境光假设任何点来自环境的 <strong>光照强度是一致的</strong>，即 $I_{a}$，它与实际光照方向无关。<br>笔者粗暴地理解为自发光、固有色。</p></blockquote><p><img src="/images/blinn-phong.png" alt=""><br><br></p><h2 id="Shading-Tech">Shading Tech</h2><p>推荐阅读：<a href="https://en.wikipedia.org/wiki/Shading">Wikipedia</a>，<a href="https://www.cs.ucr.edu/~shinar/courses/cs130-spring-2012/content/Lecture14.pdf">CS130-Lecture14</a></p><p>前面讨论光照模型的计算，但是忽略了一个重点：<strong>以什么对象（或粒度）进行Shading?</strong><br>基于前面的知识得到，任何 mesh 都是由顶点和三角形（或Poly）组成，因此自然想到如下几种方案：</p><ul><li>Tri（Poly）：基于三角面的 Flat Shading</li><li>Vertex：基于顶点的 Gouraud Shading</li><li>Pixel：基于像素的 Phong Shading</li></ul><p><img src="/images/shading-tech.png" alt=""></p><h3 id="1-Flat-Shading">1. Flat Shading</h3><p>对<strong>每个三角形（或Poly）</strong> 计算出一个法线，可以通过叉乘得到，并基于法线作光照计算。此时三角形内的Shading结果是一样的。可以理解为 <code>Low-Poly</code> 的渲染风格。</p><h3 id="2-Gouraud-Shading">2. Gouraud Shading</h3><p>对<strong>每个顶点</strong>作计算（假设顶点没有自己法线，可以根据周围几个三角面的法线求均值）。可以理解为 <code>Vertex-Shader</code>。</p><p><img src="/images/gouraud-shading.png" alt=""></p><h3 id="3-Phong-Shading">3. Phong Shading</h3><p>对<strong>每个像素</strong>插值出单独的法线，基于此作光照计算。因为是全像素的，所以性能开销高。可以理解为 <code>Pixel-Shader</code></p><h3 id="三种方案对比">三种方案对比</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Flat</th><th style="text-align:center">Gouraud</th><th style="text-align:center">Phong</th></tr></thead><tbody><tr><td style="text-align:center">光照粒度</td><td style="text-align:center">poly</td><td style="text-align:center">Vertex</td><td style="text-align:center">pixel</td></tr><tr><td style="text-align:center">表现</td><td style="text-align:center">劣</td><td style="text-align:center">中</td><td style="text-align:center">优</td></tr><tr><td style="text-align:center">性能需求</td><td style="text-align:center">低</td><td style="text-align:center">中</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">需要顶点法线</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><h2 id="Normal">Normal</h2><p>Shading的着色计算非常依赖 <strong>法线</strong>，下面介绍两种常见的法线计算方式：</p><h3 id="1-顶点法线">1. 顶点法线</h3><ul><li><p>模型自带，例如 <code>obj</code> 格式可以指定逐顶点的法线</p></li><li><p>计算顶点周围 <code>Poly</code> 的法线均值</p></li></ul><p><img src="/images/vertex-normal.png" alt=""></p><h3 id="2-像素法线">2. 像素法线</h3><ul><li>通过两个顶点的法线插值，记得归一化！</li></ul><p><img src="/images/pixel-vertex.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Lambertian、Blinn-phong、shading-tech&lt;/p&gt;</summary>
    
    
    
    <category term="Graphics" scheme="http://luhao.wiki/categories/Graphics/"/>
    
    <category term="Graphics" scheme="http://luhao.wiki/categories/Graphics/Graphics/"/>
    
    
    <category term="OpenGL" scheme="http://luhao.wiki/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【CSAPP】Virtual Memory</title>
    <link href="http://luhao.wiki/posts/virtual-memory/"/>
    <id>http://luhao.wiki/posts/virtual-memory/</id>
    <published>2023-06-13T12:33:56.000Z</published>
    <updated>2023-07-04T18:18:36.861Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟内存、cache、内存分配、内存泄漏…<span id="more"></span></p><div class="admonition note"><p class="admonition-title">导读</p><ul><li><a href="http://1.15.115.4/CSAPP-3rd.pdf">CSAPP 第9章：Virtual Memory</a>（已读完，通俗 &amp; 受益匪浅）</li><li><a href="/posts/3RBTN4W/">汇编（一）：计算机架构入门</a>（站内文章，硬件基础知识）</li><li><a href="https://fengmuzi2003.gitbook.io/csapp3e/dixzhang-xu-ni-nei-cun">CSAPP重点解读：虚拟内存</a></li><li><a href="https://people.freebsd.org/~lstewart/articles/cpumemory.pdf">What Every Programmer Should Know About Memory</a>（114页pdf）</li><li><a href="https://en.cppreference.com/w/c/memory">cppreference: Dynamic memory management</a></li><li><a href="https://www.usna.edu/Users/cs/roche/courses/s19ic221/lab05.html">IC221 Lab 05: Memory Leaks</a></li></ul></div><div class="markmap-container" style="height:450px">  <svg data="{&quot;t&quot;:&quot;root&quot;,&quot;d&quot;:0,&quot;v&quot;:&quot;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;What，Why&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;physics-memory 及弊端&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;virtual-memory&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;virtual page&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;<a href=\&quot;#PTE\&quot;>页表 PTE</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;Cache&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;<a href=\&quot;#page-hits-✔\&quot;>页命中</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;<a href=\&quot;#page-faults-❌\&quot;>缺页</a>&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;<a href=\&quot;#locality\&quot;>Locality</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;时间局部性&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;空间局部性&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;<a href=\&quot;#memory-allocator\&quot;>memory allocator</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;<a href=\&quot;#衡量标准\&quot;>衡量标准</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;1. 分配&amp;amp;释放速率&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;2. 内存利用率&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;Explicit allocator&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;<a href=\&quot;#u-class-black-mallco-free-u\&quot;>malloc &amp;amp; free</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;new &amp;amp; delete&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;Implicit allocator&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;<a href=\&quot;#垃圾回收\&quot;>垃圾回收</a>&quot;}]}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;<a href=\&quot;#memory-leaks\&quot;>memory leaks</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;<a href=\&quot;#Valgrind\&quot;>Valgrind</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;<a href=\&quot;#ASan\&quot;>ASan</a>&quot;}]},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;<a href=\&quot;#memory-bugs\&quot;>memory bugs</a>&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;<a href=\&quot;#引用坏指针❌\&quot;>引用坏指针</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;<a href=\&quot;#未初始化的堆内存❌\&quot;>未初始化的堆内存</a>&quot;},{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:2,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;<a href=\&quot;#缓冲区溢出❌\&quot;>缓冲区溢出</a>&quot;}]}],&quot;p&quot;:{}}"></svg></div><h2 id="virtual-memory">virtual memory</h2><p>物理内存有什么问题？1. 内存空间不够，2. 产生内存碎片，3. 没有内存保护。从这个角度看，<strong>虚拟内存是一个中间层，本质是到物理内存的一层映射关系</strong>。<br>并非所有系统都会使用虚拟内存，一些古老or简单的系统就会直接使用物理内存。</p><p>物理地址和虚拟地址的对比如下：</p><ul><li><p><strong>Physical-Address</strong>：物理地址，从0开始每个byte递增1<br>物理地址可以直观反应内存大小，且是连续的，例如 <code>0x0000 ~ 0xFFFF</code> 表示 <code>64KB</code> 的内存。</p></li><li><p><strong>Virtual-Address</strong>：虚拟地址，是一种到物理地址的映射（<a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a>）<br>使用虚拟地址，可以节省地址总线的位数，且利于cache实现。</p></li></ul><p><img src="/images/virtual-memory.png" alt=""></p><h2 id="cache">cache</h2><p><strong>存储器</strong> 是计算机用来存储数据的器件，即通常所说的磁盘。其根据读写特性又可以分为两类：</p><ul><li><p><strong>ROM（Read-Only-Memory）</strong><br>只读，一般是显卡、网卡上的默认系统，如<code>BIOS</code></p></li><li><p><strong>RAM（Random-Access-Memory）</strong><br>可读可写，显卡上的RAM又成为显存</p></li></ul><p>为了提高CPU读写数据的速度，现代计算机在 CPU和RAM之间又增加了 <strong>速度更快、内存更小、造价更高的</strong> <em><strong>L1, L2, L3 Cache</strong></em>，这部分称为 SRAM（Static）。<br>作为对比，DRAM（Dynamic） 一般用作虚拟内存的cache。<font color="#FF1E10"><strong>（???）</strong></font></p><p>至于为什么 SRAM 速度要比 DRAM 快很多？这需要从硬件制造上理解，参考阅读：<a href="https://rf.eefocus.com/article/id-336795">存储技术SRAM详解</a></p><h2 id="page">page</h2><p>计算机内存会被划分为固定大小的 <strong>页（page）</strong>，划分页是为了实现缓存的功能。</p><p>对于虚拟内存而言，任何一个 <strong>虚拟页（virtual page, VP）</strong> 中的内存只能处于如下三种状态：</p><ul><li>unallocated：未分配内存（即不在物理内存中）</li><li>cached：已缓存（但在物理内存中）</li><li>uncached：未缓存（但在物理内存中）</li></ul><h3 id="PTE">PTE</h3><p>为了描述 虚拟页 和 DRAM 之间的缓存关系，操作系统引入 <strong>页表 PTE（Page Table Entry）</strong> 的概念。通常情况下，它有一个有效位和一个n位地址 组成：</p><ul><li><strong>有效位</strong>：对应的虚拟页是否 cached</li><li><strong>地址位</strong>：若cached，则对应 DRAM 的物理地址</li><li>其他许可位：如可读、可写、可在内核运行等</li></ul><p>配合下图理解，一段虚拟内存被分为 8个虚拟页，对应着左侧的 8个PTE，其中的虚拟页1、2、4、7已经在物理内存中被缓存，同时在PTE中存储了对应地址。</p><p><img src="/images/virtual-page.png" alt=""></p><div class="admonition note"><p class="admonition-title">虚拟内存访问页的两种情形</p><ul><li>已缓存，即 page hits</li><li>未缓存，即 page faults</li></ul></div><h3 id="page-hits-✔">page hits ✔</h3><p>页命中，即虚拟页已经在DRAM中被缓存，读取时只需根据 PTE 找到对应的物理地址。</p><h3 id="page-faults-❌">page faults ❌</h3><p>页缺失，即虚拟页 <code>cache miss</code>，这是它在 PTE 中的有效位是0，即代表其在 DRAM 中未缓存。<br>此时内核会选择一个已经被缓存的 “无辜儿” 去替换成该页，这个无辜儿又称为 <strong>牺牲页（victim page）</strong>，同时进行如下两个操作：</p><ol><li>（物理内存中）用 查找页 替换 牺牲页</li><li>（页表PTE中）交换 查找页和牺牲页 的 cache有效位</li></ol><p>注意这里的 <a href="https://forum.huawei.com/enterprise/en/thread/667215004455288832?page=1">替换策略</a> 很重要，主要有如下两种（实际应用会更复杂）：</p><ul><li>write-through：直写，发生改变时更新cache和内存</li><li>write-back：回写，发生改变时只更新cache</li></ul><p>DRAM 为了性能考虑，采取的是 <code>write-back</code> 方案。</p><h2 id="locality">locality</h2><p>虚拟内存、分页之所以能达到非常好的cache优化，是因为程序的局部性原理 <a href="https://en.wikipedia.org/wiki/Locality_of_reference">Locality of reference</a></p><ul><li><p><strong>时间局部性</strong>：一个刚刚被访问的内存地址，在未来有更大概率被再次访问</p></li><li><p><strong>空间局部性</strong>：被访问的内存地址，其周围的内存更容易被访问</p></li></ul><h2 id="memory-allocator">memory allocator</h2><p>实际开发中，当需要申请一段内存时，其大小往往不是固定的（与runtime有关），此时有如下两种内存分配到方式：</p><ul><li><code>int arr[10000];</code> 静态定义偏 <code>hard-code</code>，浪费较多内存</li><li><code>int* arr;</code> <strong>需要时动态分配内存⭐，本章重点介绍</strong></li></ul><p>C++ 提供一种在 <strong>堆(heap)</strong> 上动态分配内存的方法，一个 <code>runtime</code> 程序的内存划分如下：<br><img src="/images/section.png" alt=""></p><p>C++ 的动态内存分配器有两种类型，区别在于<strong>如何释放内存</strong>：</p><ul><li><p><font color="#ef6d3b"><strong>Explicit allocator</strong></font><br>显示分配器，要求程序自己去释放掉申请的内存，C-Style的方法是 <code>malloc/free</code>，Cpp-Style的方法是 <code>new/delete</code>；<br>当程序没有正确或及时地释放内存，就会造成 <em><strong>Memory Leaks</strong></em>。</p></li><li><p><font color="#ef6d3b"><strong>Implicit allocator</strong></font><br>隐式分配器，它会自动检测未被释放的内存块，并主动去释放掉，它有一个通俗的名称叫 <strong>Garbage Collector（垃圾回收）</strong>；<br>诸如 Java、Python 等拥有自己的垃圾回收（这部分不作讨论）。</p></li></ul><h3 id="u-class-black-mallco-free-u"><u class="black">mallco &amp; free</u></h3><ul><li>阅读文档：<a href="https://en.cppreference.com/w/c/memory">cppreference: Dynamic memory management</a></li><li>使用的时候多查阅文档，注意 <code>malloc</code> 使用时要判断 <code>NULL</code> 避免内存分配失败</li></ul><pre><code class="language-c++">#include &lt;unistd.h&gt;void *malloc(size_t size);void *calloc( size_t num, size_t size );void *realloc( void *ptr, size_t new_size );</code></pre><ul><li>分配过程：↓</li><li>需要考虑字节对齐，注意被释放后的内存也可能重复利用，这也解释了为什么野指针的 <code>undefined behavior</code></li></ul><p><img src="/images/malloc-demo.png" alt=""></p><h3 id="衡量标准">衡量标准</h3><p>动态内存分配器的实现有很多种（<code>malloc</code>是非常普遍的一种），一个优秀的分配器应该兼顾如下两种性质：</p><ul><li><p><strong>分配&amp;释放的速率</strong><br>即每秒可以进行多少次的内存分配 和 释放操作，又称为吞吐率。</p></li><li><p><strong>内存利用率</strong><br>即内存的实际利用率，受牵制与内存中的小碎片。</p></li></ul><h2 id="垃圾回收">垃圾回收</h2><p>垃圾回收（Garbage Collection）是现代高级语言的常见特性，它最早可追溯于 1960s Lisp语言，如今也已经发展为 Java、Python 等语言的重要部分。</p><h3 id="What-is-Garbage">What is Garbage?</h3><p>正所谓知己知彼方能百战百胜，欲消灭“垃圾”，先搞清楚“垃圾”的定义。<br>阅读下段代码，其中的指针<code>p</code>在函数<code>garbage</code>内部没有被释放掉，因此函数调用返回后，这就是一段内存垃圾，也称为<strong>内存泄漏</strong>。</p><blockquote><p>因此垃圾回收，就是自动释放 泄漏的内存</p></blockquote><pre><code class="language-c++">void garbage(){    int *p = (int *)Malloc(15213);    return; /* Array p is garbage at this point */}</code></pre><ul><li>实际的垃圾做法比较复杂，这里简要提一下其实现原理。</li></ul><p>垃圾回收器 会维护一个内存块的有向图，其中 <code>Reachable</code>节点就是有指针指向的，可以被手动释放；而 <code>Unreachable</code>节点就是无内存泄漏的节点，垃圾回收就是去释放它们。</p><p><img src="/images/memory-garbage.png" alt=""></p><h2 id="memory-leaks">memory leaks</h2><p>关于内存泄漏的定义，<a href="#What-is-Garbage">上面有提到</a>。这里重点介绍两种检测内存泄漏的工具。推荐阅读这篇材料: <a href="https://www.usna.edu/Users/cs/roche/courses/s19ic221/lab05.html">IC221 Lab 05: Memory Leaks</a></p><h3 id="Valgrind">Valgrind</h3><ul><li><code>valgrind ./a.out</code>：跟踪内存泄漏</li><li><code>valgrind --leak-check=full ./a.out</code>：查看更详细的内存泄漏信息</li><li><code>LEAK SUMMARY</code>：该标签，就是潜在的泄漏部分</li></ul><pre><code class="language-c++">==2392771== HEAP SUMMARY:==2392771==     in use at exit: 0 bytes in 0 blocks==2392771==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated</code></pre><h3 id="ASan">ASan</h3><p><a href="https://github.com/google/sanitizers/wiki/AddressSanitizer"><strong>AddressSanitizer</strong></a> 已集成到 gcc、clang 等编译器，添加 <code>-fsanitize=address</code> 的编译选项 并运行即可。</p><ul><li><code>g++ -fsanitize=address -g main.cp</code></li></ul><pre><code class="language-c++">===================================================================2392472==ERROR: LeakSanitizer: detected memory leaksDirect leak of 5 byte(s) in 1 object(s) allocated from:</code></pre><h2 id="memory-bugs">memory bugs</h2><p>内存bug 相对于其他类型的bug，往往更难以定义和排查。这篇文章 <a href="/posts/2F2QH5R/#Bug%E4%BA%A7%E7%94%9F%E5%8E%9F%E7%90%86">调试理论与实践</a> 指出：<strong>程序代码错（Bug）到 可观测错（Failure）之间的跨度距离，决定一个bug排查的难易程度</strong>，而内存bug的跨度尤长。</p><blockquote><p>换言之，不论是时间还是空间上，内存的错误 往往距离错误源有较长一段距离。</p></blockquote><h3 id="引用坏指针❌">引用坏指针❌</h3><p>错误表现是 <code>segmentation fault</code>，错误原因有：</p><ul><li>访问非法内存地址，如读取 <code>0x0000001</code> 地址的值；</li><li>对 “只读内存” 进行写操作，如 <code>scanf("%d", val)</code></li></ul><div class="admonition warning"><p class="admonition-title">WARNING</p><ul><li><code>scanf("%d", val)</code> 会将 <code>val</code> 的值解释为一个地址</li><li>如果该地址只读，会出现 <code>segmentation fault</code></li><li>如果该地址可写，程序会覆盖这段内存，造成无法预测的后果...</li></ul></div><h3 id="未初始化的堆内存❌">未初始化的堆内存❌</h3><p>对于 <code>.bss</code> 的静态内存，加载器会将其初始化为0，但是堆内存的值是无法预测的。</p><p>如下 <code>y</code> 数组的值不一定都为0，请手动为其赋值。<br><code>int *y = (int *)malloc(5 * sizeof(int))</code></p><h3 id="缓冲区溢出-❌">缓冲区溢出 ❌</h3><p>这类bug使用中文有点别扭，实际是 <code>Stack (Buffer) Overflows</code>，即写内存时超出原本的大小限制。如下当输入超过 64 bits 就会出现 <code>segmentation fault</code>：</p><pre><code class="language-c++">char buf[64];scanf("%s", &amp;buf);</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;虚拟内存、cache、内存分配、内存泄漏…&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://luhao.wiki/categories/Linux/"/>
    
    <category term="Linux" scheme="http://luhao.wiki/categories/Linux/Linux/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>【CSAPP】CMU 15-213</title>
    <link href="http://luhao.wiki/posts/csapp/"/>
    <id>http://luhao.wiki/posts/csapp/</id>
    <published>2023-06-11T18:00:54.000Z</published>
    <updated>2023-06-27T17:30:11.703Z</updated>
    
    <content type="html"><![CDATA[<p>CS网课中的 “圣经”<span id="more"></span></p><style type="text/css">blockquote{    line-height: 30px;    padding: 4px 16px;}</style><blockquote><ul><li><a href="https://www.cs.cmu.edu/~213/">课程主页</a> | <a href="https://www.bilibili.com/video/BV1iW411d7hd/">B站视频（中字）</a> | <a href="https://www.cs.cmu.edu/~213/lectures/">课程ppt</a></li><li><a href="http://1.15.115.4/CSAPP-3rd.pdf">CSAPP pdf 英文版</a></li><li><a href="https://github.com/Maecenas/ICS-15213-CSAPP3e-CMU">Labs Github</a></li><li><a href="https://fengmuzi2003.gitbook.io/csapp3e/">CSAPP重点解读</a></li><li><a href="https://wdxtub.com/work/">读薄/读厚 CSAPP</a></li></ul></blockquote><h2 id="CSAPP">CSAPP</h2><p>CSAPP 是 《Computer Systems: A Programmer’s Perspective》 这本书的缩写，它作为CMU大学的ICS课教材，被誉为计算机系列课程的圣经，其内容涉及：计算机组成原理、操作系统、编译优化、网络和并发等。</p><p>“万丈高楼平地起，勿以浮沙筑高台”，学习计算机的底层原理，是在修炼内功、在夯实基础，这比修一个bug或者读几段代码更加实在。</p><h3 id="站内文章">站内文章</h3><ul><li><a href="/posts/24H1CZ3/">2. Information Storage</a></li><li><a href="/posts/1X3A6C1/">9. Virtual Memory</a></li></ul><h2 id="关于-labs">关于 labs</h2><p>首先 <code>CSAPP</code> 的整个学习过程：以 <code>labs</code> 为主，视频和ppt 为辅。在github上找到一份疑似官方一致的repo，自己fork了一份用于开发：<a href="https://github.com/593413198/ICS-15213-CSAPP3e-CMU">🔥<em><strong>Github Repo</strong></em></a></p><p>整个 labs 的设计非常精巧，还囊括了测试、评分的用例，后者是用 python2 脚本编写。以 lab-0 为例稍微介绍其整体的架构设计：</p><ul><li><code>RAEDME</code>：实验说明</li><li><code>Makefile</code>：通过 <code>make</code> 完成实验的编译、运行与测试</li><li><code>*.c, *.h</code>：lab源码 ⭐</li><li><code>qtest</code>：脚本驱动的测试框架，值得一读 ⭐</li></ul><p>其中 <code>console.c</code> 实现了一个精巧的可交互命令行，并集成一些用于 lab 的指令。<code>qtest</code> 集成了前者和一些测试用例，它将评判你的代码是否通过多少case、以及获得多少得分。</p><p><strong>通过实验，读懂实验框架代码，这两件事都很重要！</strong></p><h2 id="Lab0-c-programing">Lab0 - c programing</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;CS网课中的 “圣经”&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://luhao.wiki/categories/Linux/"/>
    
    <category term="Linux" scheme="http://luhao.wiki/categories/Linux/Linux/"/>
    
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【cpp】Constructors</title>
    <link href="http://luhao.wiki/posts/17P7469/"/>
    <id>http://luhao.wiki/posts/17P7469/</id>
    <published>2023-06-10T18:42:16.000Z</published>
    <updated>2023-07-04T17:03:58.353Z</updated>
    
    <content type="html"><![CDATA[<div class="admonition note"><p class="admonition-title">提要</p><ul><li><a href="https://hackingcpp.com/cpp/lang/destructors.html">hackingcpp: destructors</a></li><li>面向一些基础使用，因此所涉比较浅</li></ul></div><h2 id="基础">基础</h2><p><code>cpp</code> 有 3 种特殊的成员函数，本文所有的内容都围绕它们展开：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">what</th><th style="text-align:center">when</th></tr></thead><tbody><tr><td style="text-align:left"><code>T::T()</code></td><td style="text-align:center">默认<u class="green">构造</u>函数</td><td style="text-align:center"><code>T</code>创建时</td></tr><tr><td style="text-align:left"><code>T::~T()</code></td><td style="text-align:center">默认<u class="green">析构</u>函数</td><td style="text-align:center"><code>T</code>销毁时</td></tr><tr><td style="text-align:left"><code>T::T(param…)</code></td><td style="text-align:center">特殊<u class="green">构造</u>函数</td><td style="text-align:center"><code>T</code>带参数创建时</td></tr></tbody></table><p>即使用户不去声明 构造 和 析构 函数，编译器也会<strong>自行创建者两者</strong>。</p><p>构造函数的调用时机很容易理解，但<strong>析构函数的调用时机</strong>很特殊。</p><ul><li><p>显式地销毁对象</p></li><li><p>隐式地被销毁，如局部变量的作用域结束</p></li></ul><pre><code class="language-c++">if (...) {    T x;  // constructor}  // destructor</code></pre><h2 id="Constructor">Constructor</h2><p>构造函数根据构造的类型，又分为如下几类：</p><pre><code class="language-c++">class Test{public:    Test(int a);  // 构造函数    Test(const Test&amp;);  // 拷贝构造函数    Test&amp; operator=(const Test&amp;);  // 拷贝赋值operator    Test();   // 构造函数    ~Test();  // 析构函数}</code></pre><p>考虑如下两个初始化的用法，才能看出调用构造函数的区别：</p><ul><li><code>Test t1(88);</code>：普通构造函数</li><li><code>Test t1 = t2;</code>：拷贝构造函数</li><li><code>Test t1; t1 = t2;</code>：拷贝赋值operator</li></ul><div class="admonition warning"><p class="admonition-title">C++11 delete</p><ul><li>申明为 <code>Test(const Test&amp;) = delete;</code> 可以禁止用户使用拷贝构造函数</li><li>此时如果调用，会有编译报错：<u class="error"><code>error: use of deleted function ‘Test::Test(const Test&amp;)’</code></u></li></ul></div><h2 id="Destructor">Destructor</h2><p>析构函数的调用顺序是编译器严格限制的，即<strong>析构顺序与声明顺序相反</strong>。</p><p>对于如下的结构体 <code>Test</code>，当对象发生销毁时，执行析构的顺序依次是：</p><ul><li><code>Test -&gt; t3 -&gt; t2 -&gt; t1</code></li></ul><pre><code class="language-c++">class Test {    T1 t1;    T2 t2;    T3 t3;public:    Test();    ~Test();}</code></pre><h2 id="RAII">RAII</h2><blockquote><p><em>Resource Acquisition Is Initialization</em></p></blockquote><p>这条 <a href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii">stackoverflow</a> 认为<code>RAII</code>应该称作<code>Scope-Bound Resouce Managerment</code>，这样更容易理解，笔者深表赞同，因此下面也围绕这个理解展开。</p><p><strong>Resource</strong></p><p>首先理解什么是 <code>Resource</code>? 可以理解为任何需要被合理控制的c++对象</p><ul><li><em>file handles</em></li><li><em>thread</em></li><li><em>lock</em></li><li>…</li></ul><p>对于任何一个resouce，它的生命周期会经历 <u class="black"><strong>创建 -&gt; 使用 -&gt; 销毁</strong></u> 三个阶段。而销毁往往最容易被忽视，这会引起内存泄漏等问题。</p><p><strong>Scope-Bound</strong></p><p><code>Scope</code>是指一个resource的作用域，当其离开作用域时，应该自动调用其析构函数以使其销毁。</p><div class="admonition note"><p class="admonition-title">总结</p><ul><li><code>RAII</code> 是一种防止内存泄漏而进行自动析构的cpp特性</li></ul></div><h3 id="RAII应用">RAII应用</h3><p>一些 C Library 总是会成对出现一些功能性的函数，例如：</p><ul><li><code>gpulib_init</code>, <code>gpulib_finalize</code></li></ul><p>如果只调用了init函数，而忘记调用负责析构的后者，就会出现内存泄漏、资源hung-up等bug。<br>因此我们可以在cpp层通过 RAII 的理念将它们封装一层：</p><pre><code class="language-c++">#include &lt;gpulib.h&gt;class GPUContext {  int gpuid_;public:  explicit  GPUContext (int gpuid = 0): gpuid_{gpuid} {    gpulib_init(gpuid_);  }  ~GPUContext () {    gpulib_finalize(gpuid_);  }}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;admonition note&quot;&gt;&lt;p class=&quot;admonition-title&quot;&gt;提要
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hackingcpp.com/cpp/lang/destructors.html&quot;&gt;hackingc</summary>
      
    
    
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/"/>
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/C/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>2023下半年规划</title>
    <link href="http://luhao.wiki/posts/2023b/"/>
    <id>http://luhao.wiki/posts/2023b/</id>
    <published>2023-06-04T17:29:53.000Z</published>
    <updated>2023-08-16T17:04:11.273Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d3473e1f4890d5e9eb45c47feb05667bf3c833b3832a9007b5d5b6c1faea5621">b3dc07a81f6459d120ce338ccca5504603780459e0306826441972681af56d62ee5e99a6b2a15c89d5fbc320a13f63ed9ba268edabaf6c1c008413d66883445c58b4a2e699e4db9148ef23f3cdb870ec629634ee078e07787bd698a1a7017441544b629e2ca45641055b5256dddc3850ef7b32f2b68d3790a725ce8ee1848b4e29139d82dc7e412ad454c07aa205233a72745362d1b46e637326d420e4ac5e28b017b61b1e296a78ef19174eaf108459d882e5566ca8f8f60623de7fad8d11de55ac7a485bf7431c027be922ed67691382f46e870981bfa2d5f44c37647e9f884f2c949ff8f74e5fa4d637bdc965636ed0230500af093bd31a7b09acf2445adb8794690deae28484535dfdb43f905e86ba26b4573159e9b5ecb96ed3829629fc66f5cd9dd7246343cc41183bccf94ac15a62d1cdbf37380cac522e2d5d377a19c3e8d6ed1822424bc017329448f1c8adcf142b7caada11d87e5439cf3bece0f10d5ed2a3c12d936e44cac29d668f90addc6b225dbb15f90676d8e9482786e7c16988627d4396666cfec1962e24df0b06041ddfdcbeef3871ac953c6069b3bbc30965b3c86333b814c934887a596d9f1c850f96950fca6cac75638adf45420b02aece8370b695f968867993f35f474d6d3350443f69b67227cc572e8275fd928e0db708844c9164b3ac272eb6ee5525aec55eaba807aade2812a344a3b18a140a06f265f8ff4552e655e58cbf71729a738ce2b625c865c1f2d96ab306c29a47a85150ff833aa72eeb506bbebb58a14587f30b9162ff8c719c0100dfff7d8799074e9169fe89408724d6bfeb4b785fe99281eba0e152cb531201c5e2a93a93b7e9a1964ff44627b98f462cc24a37405aaac7c672ce32db0f0ff5200680f115a6d732e20ef1c200b633873737b1f7bc55387cbf298de8eb399796fa5a2a6bbba975a6ea0726ea4ba7d007b5fc3f6564eb44e0f73b181b67af8cf7789bfab11fa5e73364897d22096d2a7a63e713ce43751daa86f5ef363d9da1bbbfec4a7750b92cb80a3d5a8d65ed62aaf2ce940e4ab4061a33ac704538d7971f3b5f121c50c7c60d7d16b54bfbda8e77db4922165e6027af4f2cc756b5338bc079d09be3dd538cafb98f01726bd78333f0ad555cb27948781268f10a51debc2db9d2d46cc81fbe157e0a9649508d1d77dc43c218b0859c07788786ae885b4344558467826a80ff289634e430191ad3bf66237642cd97774672200753e853688fb057aefda431b5604c81c8aef7fc340231e5702cd69ea9687d8e3c9d716f6d687576534a21afbe1f8f06266eeee2aaae3abce9b1240f2c44b616b1f84231bd6a69a2e8bf1c2fdad57edda8344adbf3694490d99396f0f18d41d94319b3e4f8fb926cd3122bb3a59fca9fe04c321689bf48058bf7070da842c4cf79989c5581c0a341a7098b037d388d144697b6466ff9c0373bbd26022ded2f404c7294006d3ca085122e5e188b4cff484495e84d2272150bb15e090382a19512819a5d8a231a55e692c9d5f717f0e11e1f6d72c7e9c2960e21f1a9462d391d40827ec601608464e6f34c96d642087b63dbecbe5be536cd6715bf4fdc27ae0a7d7dfd053c57626ff18d54725e754a83cc95008132a7877833eb6b36f05797c066c13883fe6e9c72296ff91970b79a3c40f7c877d309d10876c9d578e53a923653ea56ee0f58a107cf5c6f1695397879703fd41ec9a32b3d75d2268e18b40c48af5f8dbe63433f4e4d79f431fcb8a7e45bce5fc56229d38d13ff4f69afcd888d4d4a05192c4b06f5049b647f65669b29a6825979f07d1ccac51cf6fc2e2e60a9b08bda21a068a094319fab135f33904e769adfebf535cfd14d97d02e6f816880f5c97058b0b19599f7824eccdcd65b680f645ee5778f0bb773ed91a9f7c027c0a1659663f1b4ae02c92ecbbf2a5be0df6b5b5c3ddbca4cb3b187b40adf90aa2748ef5097da69c8ca38f5628c6be9370ca63e5aeef4469a554d02e9551b280a20967f577a1c7cabfb548b8048d77181f11510b6fd064dc814f10a1010d564c540c3f0aaaf21e2f7af89c8f3e19411efef527b74b19c6be7e5e67df18a58c13a296373cc007f85088f0dc01db18d6a8787cfef33aa61a702c7a2c82ec15e0fb60a8d59735c05134ab63c2630bacf95233a1231c3b2f9236f752101fcc7c836f4a930d823dba55efe9aa6945f6795c4b0b4a8665313c0066bec928b4b11804aa25962beca36f97cfa9c542a7453e9235111cdf2b05ba36beecec8b85db3598b84f0455bd2013b35b3de1bcf33fd88efc181066389163ad3425e587b45dabdb05de461bc0b058d2cd68a09b895d8e2dba1576b8406608f10282c02e35dde1fc36c86351d335093ca29a8594cd2a4fff0c71472870f09321924997e1640f4be4d45823083bfe33383d7cf074bf73354f238d1fe74f96cb5fc0fdf276d2317973945b15645fd0b7553b99538defaea41925a04790d055939a8abe0fbf2e350acab956962faa74a71dc2e790c0103d37961524858ef1945d40e0c3ca254640b45b1400ffab5526a1abf0307ffe41476955986200bdcbd85eb74d9e4b5d166353aae8fa42d2419f3582e46370e3b01b1ee75e57584cb5629d8546d59a9c89df7a3db1c508a56f6ef213c9b359f3cbe34d8538dfba4f2b5b755c1d9443038f2ae1e4865eff43550e8d705f612b5f43e54a2329e1b748531ee9882914d2c92e18063d5240272a367cd0217e14e997913c875f2f4d8d1bbd4142d33c998c7e21e6f515c9edd0905e41abfee1054f4f0fffd23b8644592b8d28d7fe4d8d8386ad8db911f7670a1fe862760d909d595d4c9db7b2c9721d6ca64a2d1f4b0a91b7ff959e89d99256033cb971c6714092568d27ff51e5a0165e8e82dec2f8a601b98b14e86fde36585555aa49c3038228d05849c53dbd13ce512f973735241970e9a490e2970743c1c96946a566f7e7d90f123876426df1c59225549ca025d9d52236e0f964655578a8ce0bce211144c69161bdb8b407c0a1986f82d58bf58b32aaa173cfdcb6e033c9bd7c415c6be2fe796d402a708d62f7428112482baa55d5a0f163216448bff6568a7368b789ed94e649d03d18c30271023bec0bdefea04179bde56af9f0098f3b37641c026451f640c1128f4c6279642a8297aa2f95dd082c825a33ebcd8e22622f6b29462e94f378cf5d1e35f8d21639d024ba1bad4eaf48cf557a73a8737cc9f9b7771da5a16a22e7ea1e7f9ba257ed69106a2c368b38c1d3d6d2c9663e37cd51c141671821ff833f048995f39d63916d97f09be3c1ff5425de7fabd7bdc7bc05c4335184743c372219b5411b076ffc6a6d3ccbc30edb116cf71af0f70e1b491ccc653d0abbb9ccac5e09f48a50eede41a98f0a5373b29aa9f859efdefe6f096e0acd0d86c621b38a39d1f2d63e88f0e0c123255dbcd61f2aa3a6df50680380d3e1ad43d6c4bb2ec36c6853c8f489cc0839eb333b21e0592b66be81589d7fab122dd5a013463e7f87605092ab895a27af4f28de052e27eeefc5dce97e9cbeb211b0d46c1cb81fe927a5deb649edc71290d84ec1a7068742a00b13ebb5f27bd0f169570277c17b86ec75e2c72703fe37e7ce5708d688b16fe9b38f281c967cecb4218c73edb53ee1d90cf7d759d79d2813ac6ff7c1be48478259a88c37695e4e507f1b8f227a8087acbd6c552381e294f8ea4fdc92594a3b0b77ca9c3303aaa80ddba33e5d21f5b5f3ef6aa2133eea52661aced93d28565714ce48c68fd8c3c4b7954dc36d55716e88245574f0dd48c07deb601eff7916ab456e0ccfe9949e075c5efc9715377ae2b5c570843b0a131d0f8b7153dac182004f85685b1bc49d848da9dad908efa47e02d9d84936e94503d59c4287068b8286daaa59bd41bd89d1c970e36e8b0323dd5ccc17b5dc890a2253e5b71966d509cea4d1080c882c79286f6564a5cf343d2f28a5d7074d2aec74698765b68c33c670b54cf460ef2c22f9d95450fd35fd22c472db5961032e0d07ea4d360f2de35a188fb2aceb8ec0fc7d395513581b112036b758193e12f77c8e8b08f3e2aec967e059b98cd341f958bd2c7ab31ca6af5de1d837ba0e544a13a56ef5148d44e5158cc66e8fd04eaa644655889cb6cdf78072c8d3f31d5d4b59fb8ec2f4f02baaf827e48ad8adc8c15a92ec255d2eb912b8f2c3de5cb92166ed297f3c8d942c6529f631ae07cb678f92b6ec1d0e223ab6d5c60c5a6eac3f432faed0e3d8b858e9ac2d45338ca93b65e3fb81dc0dee61c64a209dc9d6c00fae5fc446f374b48281fa20cc3c03306ff9d4f73d51afe76ad29ce0a025be6714fd2a82b562aa25e1b3877665d196ec7412e00f186ba778c775bb509f1126f39f0687bfb48d9899eb76615d4b2e9bbd9329f16c4cbaae105516d3b35032e6281721b18657a198406915736a1117955316500dd17edb2645e0ed32e46e9823aef75d0f6436c1e590f18080923202521b34679c2976add9a497fead5803ce283b30f31cb164e271614aef329b96dee09ea1cdc2a48636b089475453bf571e739ee5bd7ea69e2047d954ed266984bd50a2db23cc043da5d9c4fb4ca873a4fd8b6bbe6f18e6ca04014b694c581135bba41aa8ccc42f2780506354692133e37a75c69f80f901be879ac3d3c502ac113c702bce5c9153aad0b139cb8aaa5f1b5bbbc79dd91db811dd96ef5640eb89c66a0fa34767750a9bd470452788dec3ee0940c59409a3298feb7832d5f38adecbc84dd3b6717c7e835230b98a23e90b2ce85ae29fa8624eb4812233c3a1d46c70f9ee25d9ce72d370107d750ba6b0d0980c0275116ee29f2b8fabad16d3e021e7b316eac</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;hbe hbe-container&quot; id=&quot;hexo-blog-encrypt&quot; data-wpm=&quot;Oh, this is an invalid password. Check and try again, please.&quot; data-whm=&quot;OOP</summary>
      
    
    
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    <category term="个人日志" scheme="http://luhao.wiki/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>【vscode】如何配置断点调试</title>
    <link href="http://luhao.wiki/posts/1RVNF84/"/>
    <id>http://luhao.wiki/posts/1RVNF84/</id>
    <published>2023-06-03T16:50:52.000Z</published>
    <updated>2023-06-18T13:12:53.656Z</updated>
    
    <content type="html"><![CDATA[<p>包含<code>python、cpp、ts/js</code>等调试<span id="more"></span></p><div class="admonition note"><p class="admonition-title">概要</p><ul><li><a href="https://code.visualstudio.com/docs/editor/debugging">vscode debug 官方文档</a></li><li>附一张日常开发调试用的 vscode调试面板 截图<img src="/images/vscode-debug.png" alt=""></li></ul></div><h2 id="环境配置">环境配置</h2><p>vscode 虽然是一款轻量级编辑器（相比于Visual Studio、pycharm），但只要搭配正确的插件使用，依然可以轻松拥有 <code>IDE</code> 的断点debug功能。</p><h3 id="launch-json">launch.json</h3><p>vscode 的调试配置都写在 <code>launch.json</code> 文件中，它的位置是在 <code>.vscode</code> 目录下。如下是一个最简单的 python debug 配置：</p><pre><code class="language-xml">{    "version": "0.2.0",    "configurations": [        {            "type": "python",            "request": "launch",            "name": "Python: debug",        }    ]}</code></pre><p>常见字段的含义和配置方法如下：</p><table><thead><tr><th style="text-align:left">字段</th><th style="text-align:left">作用</th><th style="text-align:center">必选</th></tr></thead><tbody><tr><td style="text-align:left">type</td><td style="text-align:left">调试语言，需要安装对应的<code>debug extension</code></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left">request</td><td style="text-align:left">支持 <code>launch</code> 和 <code>attach</code> 两种模式</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left">name</td><td style="text-align:left">调试选项中展示的名称</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left">program</td><td style="text-align:left">调试的目标文件，如 <code>main.py</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">args</td><td style="text-align:left">参数，格式为 <code>["1", "2"]</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">env</td><td style="text-align:left">环境变量</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">cwd</td><td style="text-align:left">设置工作目录</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">port</td><td style="text-align:left">attach模式指定端口</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">console</td><td style="text-align:left">使用哪种终端: <br><code>internalConsole</code>, <code>integratedTerminal</code>, <code>externalTerminal</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">preLaunchTask</td><td style="text-align:left">debug之前运行指定Task</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">postDebugTask</td><td style="text-align:left">debug之后运行指定Task</td><td style="text-align:center"></td></tr></tbody></table><p>一些常用的环境变量：</p><ul><li><code>${file}</code>：表示正在打开的文件</li><li><code>${workspaceFolder}</code>：表示 <code>workspace</code> 的根目录</li></ul><h2 id="python">python</h2><p>python一般选择调试当前文件，要注意工作目录是否正确。</p><pre><code>{    "name": "Python: 调试当前文件",    "type": "python",    "request": "launch",    "program": "${file}",}</code></pre><div class="admonition warning"><p class="admonition-title">python2调试</p><ul><li>新版的 <code>python extension</code> 往往不支持 python2 断点调试，需要回退到<code>2021</code>年左右的版本</li></ul></div><h2 id="cpp">cpp</h2><p><a href="https://code.visualstudio.com/docs/cpp/cpp-debug">官方文档: Debug C++ in VSCode</a></p><p>C/C++ 的断点调试略微复杂，需要分为两个步骤：</p><ul><li>使用 <code>gcc/g++</code> 将源码编译为 可执行文件（默认为<code>a.out</code>）</li><li>使用 <code>gdb</code> 调试 可执行文件</li></ul><h3 id="1-编译">1. 编译</h3><p>首先借助 vscode tasks 将cpp源码编译为可执行文件，配置如下：<br>详细可以阅读 <a href="https://code.visualstudio.com/docs/editor/tasks">官方文档：VSCode Tasks</a></p><pre><code class="language-xml">{    "tasks": [        {            "type": "cppbuild",            "label": "C/C++: gcc build",            "command": "/usr/bin/g++",            "args": [                "-g",                "${file}", // 编译的cpp文件                "-o",                "${workspaceFolder}/a.out" // 生成的可执行文件            ],            "options": {                "cwd": "${workspaceFolder}"            },            "problemMatcher": [                "$gcc"            ],        }    ],}</code></pre><p>配置 <code>tasks.json</code> 完毕后，可以通过 <code>ctrl+p</code> 输入 <code>Run Task</code> 并选中 <code>C/C++: gcc build</code>，可以将当前cpp源码编译为指定的 <code>a.out</code> 可执行文件。<br>后面的调试需要用到这个task。</p><h3 id="2-调试">2. 调试</h3><p>接下来配置 <code>launch.json</code> 以实现对上一步生成的 <code>a.out</code> 调试，配置如下：</p><pre><code class="language-xml">{    "name": "gcc/g++ debug",    "type": "cppdbg",    "request": "launch",    "program": "${workspaceFolder}/a.out", // 需要调试的二进制文件    "args": [],    "stopAtEntry": false,    "cwd": "${workspaceFolder}",    "environment": [],    "externalConsole": false,    "MIMode": "gdb",    "setupCommands": [        {            "description": "Enable pretty-printing for gdb",            "text": "-enable-pretty-printing",            "ignoreFailures": true        }    ],    "preLaunchTask": "C/C++: gcc build",    "miDebuggerPath": "/usr/bin/gdb"}</code></pre><p>其中的 <code>preLaunchTask</code> 会在按下 <code>f5</code> 调试按钮后，先行运行指定的Task，即编译指定的cpp源码文件，然后调用 linux下的 <code>/usr/bin/gdb</code> 对可执行文件进行调试。</p><h2 id="Node-js">Node.js</h2><p>vscode 对于 <code>js/ts</code> 的开发生态支持度非常高（毕竟vscode插件都是基于<code>typescript</code>所开发的）</p><pre><code class="language-xml">{    "type": "node",    "request": "launch",    "name": "JS/TS debug",    "skipFiles": [        "&lt;node_internals&gt;/**"    ],    "program": "${file}"}</code></pre><h2 id="others">others</h2><div class="admonition warning"><p class="admonition-title">其他语言用到时再补充</p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;包含&lt;code&gt;python、cpp、ts/js&lt;/code&gt;等调试&lt;/p&gt;</summary>
    
    
    
    <category term="VSCode" scheme="http://luhao.wiki/categories/VSCode/"/>
    
    <category term="VSCode" scheme="http://luhao.wiki/categories/VSCode/VSCode/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="Python" scheme="http://luhao.wiki/tags/Python/"/>
    
    <category term="linux" scheme="http://luhao.wiki/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【cpp】pointers</title>
    <link href="http://luhao.wiki/posts/pointer/"/>
    <id>http://luhao.wiki/posts/pointer/</id>
    <published>2023-06-03T14:58:55.000Z</published>
    <updated>2023-07-01T17:10:50.499Z</updated>
    
    <content type="html"><![CDATA[<p>cpp指针、地址、引用相关<span id="more"></span></p><div class="admonition note"><p class="admonition-title">概要</p><ul><li>指针是C++学习中绕不过去的难题，需要对计算机内存有深入的理解。</li><li><a href="https://hackingcpp.com/cpp/lang/pointers.html">hacking C++ Pointers</a></li><li><a href="http://alumni.cs.ucr.edu/~pdiloren/C++_Pointers/">Learning C++ Pointers for REAL Dummies</a></li><li><font color="#FF1E10"><strong>todo: unique_ptr, shared_ptr ...</strong></font></li></ul></div><h2 id="When">When</h2><p>任何一门技术（或者概念），都是服务于具体的需求，或者在特定的需求场景下，才会诞生。<br>C++的指针也不例外，它的出现是为了满足如下三个常见的场景：</p><ul><li><p><strong>持有（任意的）对象</strong><br>在避免 copy 的情况下持有对象，这是 cpp 最重要的语言特性之一，通过指针可以实现对象的引用。</p></li><li><p><strong>访问动态内存</strong><br>这块暂时没理解，todo…</p></li><li><p><strong>创建某些动态的数据结构</strong><br>如 vector，链表，树等结构。</p></li></ul><h2 id="What">What</h2><blockquote><p>Pointer to Object of type <code>T</code>，which stores a memory address.</p></blockquote><p>指针<strong>永远指向一个具体的对象</strong>（任意类型<code>T</code>），也可以是空对象（<code>nullptr</code>）。<br>指针的<strong>本质是一个内存地址</strong>，这个地址在 x64 的机器上占 64 Bits，即 <code>usigned int64</code>。<br>指针的生命周期，和它所指向对象的生命周期，两者是相互独立的。</p><div class="admonition todo"><p class="admonition-title">TODO: 通常说的 “指针” 是指c++默认指针，不包括如下（有空补充）</p><ul><li><code>std::unique_pointer</code></li><li><code>std::shared_pointer</code></li><li><code>std::weak_pointer</code></li></ul></div><h2 id="Operators">Operators</h2><p>C++有三个操作符与指针相关，分别是 <code>&amp;</code>、<code>*</code>、<code>-&gt;</code>，需要区分其不同的使用场景和含义。</p><h3 id="Address"><code>&amp;</code>: Address</h3><p><code>&amp;</code> 的含义是<strong>取地址</strong>，<code>&amp;a</code> 会<strong>返回对象a的地址</strong>。</p><p><img src="/images/cpp-address.png" alt=""></p><h3 id="Dereference"><code>*</code>: Dereference</h3><p><code>*</code> 的含义是<strong>解引用</strong>，该操作符后面会跟随一个地址，<code>*p</code>会<strong>返回地址p上的值</strong>。</p><p><img src="/images/cpp-pointer.png" alt=""></p><h3 id="Member-Access"><code>-&gt;</code>: Member Access</h3><p><code>-&gt;</code> 的作用是<strong>访问类成员</strong>，准确说是访问一段地址上的某个成员属性，经常会和 <code>.</code> 使用混淆。</p><ul><li>对于指针类型，使用 <code>-&gt;</code></li><li>对于具体的对象，使用 <code>.</code></li></ul><p><img src="/images/cpp-access.png" alt=""></p><h3 id="和-的区别"><code>&amp;</code> 和 <code>*</code> 的区别</h3><p>作为不同的操作数有不同用法，区别如下：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>*</code></th><th style="text-align:center"><code>&amp;</code></th></tr></thead><tbody><tr><td style="text-align:center">声明符</td><td style="text-align:center">定义指针: <code>int *p = nullptr</code></td><td style="text-align:center">定义引用: <code>int &amp;a = b</code></td></tr><tr><td style="text-align:center">一元操作符</td><td style="text-align:center">解引用: <code>char a = *p</code></td><td style="text-align:center">取地址: <code>auto p = &amp;a</code></td></tr><tr><td style="text-align:center">二元操作符</td><td style="text-align:center">乘法运算: <code>a * b</code></td><td style="text-align:center">与运算: <code>a &amp; b</code></td></tr></tbody></table><div class="admonition warning"><p class="admonition-title">不要在单行申明多个指针</p><ul><li><u class="error"><code>int *a, b</code></u>：容易产生歧义，建议多行申明</li></ul></div><h3 id="pointer-to-pointer-⭐"><code>**</code>: pointer to pointer ⭐</h3><pre><code class="language-c++">int   v = 5;int*  p = &amp;v;  // 指向intint** pp = &amp;p  // 指向int*</code></pre><h2 id="nullptr-C-11">nullptr (C++11)</h2><blockquote><p>nullptr is a special pointer value</p></blockquote><p><code>NULL</code> 完全等同于0，<code>nullptr</code> 本质是一个空指针对象，注意两者的区别！<br>作为规范，<code>nullptr</code> 通常代表 <strong>无法访问的变量</strong>（value not available）</p><div class="admonition note"><p class="admonition-title">nullptr 编码规范</p><ul><li>指针初始化时，赋值为nullptr：<code>int *p = nullptr</code></li><li>解引用时，检查该指针是否为nullptr：<code>if (p != nullptr) { *p = 8; }</code></li></ul></div><h2 id="const-pointer">const pointer</h2><blockquote><p>Read-only and preventing pointer redirection.</p></blockquote><p><code>const</code> 搭配指针会产生奇妙的化学反应，一共有如下四种情形：<br>牢记口诀：<strong><code>const</code> 左边的永远是不可变的。</strong></p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">指向的对象 可修改?</th><th style="text-align:center">指针自身 可修改?</th></tr></thead><tbody><tr><td style="text-align:left"><code>int *</code></td><td style="text-align:center">✔</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left"><code>int const *</code></td><td style="text-align:center">❌</td><td style="text-align:center">✔</td></tr><tr><td style="text-align:left"><code>int * const</code></td><td style="text-align:center">✔</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:left"><code>int const * const</code></td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr></tbody></table><p>下面看一段代码示例：</p><pre><code class="language-c++">int i = 5;int j = 8;int const* cp = &amp;i;*cp = 8;   //  ❌ COMPILER ERROR: pointed-to value is constcp = &amp;j;   //  ✔int *const pc = &amp;i;*pc = 8;   //  ✔pc = &amp;j;   //  ❌ COMPILER ERROR: pointer itself is constint const*const cpc = &amp;i;*cpc = 8;  //  ❌ COMPILER ERROR: pointed-to value is constcpc = &amp;j;  //  ❌ COMPILER ERROR: pointer itself is const</code></pre><h2 id="this-pointer">this pointer</h2><p><code>this</code> 仅在类内部使用，<strong>本质是一个指针</strong>。</p><ul><li><p><code>this</code> 返回类对象的地址</p></li><li><p><code>*this</code> 访问类自身</p></li><li><p><code>this-&gt;</code> 用来访问内部的成员</p></li></ul><h2 id="Memory">Memory</h2><p>接下来从 <strong>内存分配</strong> 的视角，理解指针在计算机内的存储，以及指针运算符做了什么。</p><ul><li><p>根据内存对齐，<code>char</code> 和 <code>short</code> 在内存中都占据 4 bytes</p></li><li><p>指针的本质，就是第一个byte的16位地址（因此 <code>sizeof(p) = 2</code>）</p></li></ul><p><img src="/images/pointer-memory.png" alt=""></p><ul><li><p>下图演示指针的<code>++</code>，会根据指向对象的内存大小而进行偏移</p></li><li><p><code>pointer += 2</code> 或者 <code>pointer --</code> 也是同样道理</p></li><li><p><code>pointer[3]</code> 等价于 <code>pointer += 3</code> 后的取值</p></li></ul><p><img src="/images/pointer-memory-add.png" alt=""></p><h2 id="⚠️-Warning">⚠️ Warning</h2><p>指针使用经常会出现如下几种错误：</p><h3 id="1-dangling-pointer">1. dangling pointer</h3><blockquote><p><em><strong>dangling</strong></em>： pointer points to an invalid/inaccessible memory address</p></blockquote><p>永远确保 <strong>指针指向的对象是合理的</strong>，否则出现 悬空指针（迷途指针）。</p><ul><li>error 1：访问 未初始化的对象</li></ul><pre><code class="language-c++">int *p; // p not initialized!*p = 7; // ❌</code></pre><ul><li>error 2：访问 nullptr</li></ul><pre><code class="language-c++">int *p = nullptr;*p = 7; // ❌</code></pre><ul><li>error 3：指向 无法访问的内存<br><code>p = 0x0000001</code>，这是运行程序无法访问的内存段，运行时会报错。</li></ul><h3 id="2-pointer-argument-passing">2. pointer argument passing</h3><p>当函数的参数定义为指针时，注意传入的参数，不能是一个非法的指针。</p><pre><code class="language-c++">void swap_values (int* a, int* b) {  int t = *a;  *a = *b;  *b = t;}int x = 3, y = 4;swap_values(&amp;x, &amp;y)        // ✔swap_values(&amp;x, 0);        // ❌ UNDEFINED BEHAVIORswap_values(&amp;x, nullptr);  // ❌ UNDEFINED BEHAVIOR</code></pre><h3 id="3-hard-code">3. hard code</h3><p>通过合理的编码，区分 <code>*</code> 的频繁使用，尤其是乘法和指针混合使用的场景。</p><p><code>*p = *p * *p + (2 * *p + 1);   // SO MANY STARS!</code></p><h2 id="指针习题">指针习题</h2><p>当你以为入门了cpp指针，尝试解答下面的题目，常看常新：</p><ul><li>已知如下的地址和取值，问如下输出</li></ul><pre><code class="language-c++">cout &lt;&lt; v;cout &lt;&lt; p;cout &lt;&lt; pp;cout &lt;&lt; &amp;v;cout &lt;&lt; &amp;p;cout &lt;&lt; &amp;pp;cout &lt;&lt; *v;cout &lt;&lt; *p;cout &lt;&lt; **pp;</code></pre><p><img src="/images/pointer-question.png" alt=""></p><h3 id="解析如下："><strong>解析如下：</strong></h3><ul><li><p><code>cout &lt;&lt; v</code>：5</p></li><li><p><code>cout &lt;&lt; p</code>：0x44</p></li><li><p><code>cout &lt;&lt; pp</code>：0x48</p></li><li><p><code>cout &lt;&lt; &amp;v</code>：0x40 (=p)</p></li><li><p><code>cout &lt;&lt; &amp;p</code>：0x44 (=pp)</p></li><li><p><code>cout &lt;&lt; &amp;pp</code>：0x48</p></li><li><p><code>cout &lt;&lt; *p</code>：5</p></li><li><p><code>cout &lt;&lt; *pp</code>：0x40 (=p)</p></li><li><p><code>cout &lt;&lt; **pp</code>：5</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;cpp指针、地址、引用相关&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/"/>
    
    <category term="C++" scheme="http://luhao.wiki/categories/C/C/"/>
    
    
    <category term="C++" scheme="http://luhao.wiki/tags/C/"/>
    
    <category term="Compiler" scheme="http://luhao.wiki/tags/Compiler/"/>
    
  </entry>
  
</feed>
